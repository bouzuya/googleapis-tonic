// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Awsv4Signature {
    #[prost(string, optional, tag = "468922628")]
    pub access_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "292975158")]
    pub access_key_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "80261277")]
    pub access_key_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "265305645")]
    pub origin_region: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbandonInstancesInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "320929016")]
    pub instance_group_managers_abandon_instances_request_resource: ::core::option::Option<
        InstanceGroupManagersAbandonInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbandonInstancesRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "488499491")]
    pub region_instance_group_managers_abandon_instances_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersAbandonInstancesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorConfig {
    #[prost(int32, optional, tag = "504879675")]
    pub accelerator_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "138031246")]
    pub accelerator_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorType {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "263814482")]
    pub maximum_cards_per_instance: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorTypeAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AcceleratorTypesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<AcceleratorType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcceleratorTypesScopedList {
    #[prost(message, repeated, tag = "520872357")]
    pub accelerator_types: ::prost::alloc::vec::Vec<AcceleratorType>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Accelerators {
    #[prost(int32, optional, tag = "479079316")]
    pub guest_accelerator_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "293064725")]
    pub guest_accelerator_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessConfig {
    #[prost(string, optional, tag = "532703707")]
    pub external_ipv6: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "425672143")]
    pub external_ipv6_prefix_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "117634556")]
    pub nat_i_p: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "517397843")]
    pub network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "316599167")]
    pub public_ptr_domain_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "523870229")]
    pub set_public_ptr: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AccessConfig`.
pub mod access_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkTier {
        UndefinedNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkTier::UndefinedNetworkTier => "UNDEFINED_NETWORK_TIER",
                NetworkTier::FixedStandard => "FIXED_STANDARD",
                NetworkTier::Premium => "PREMIUM",
                NetworkTier::Standard => "STANDARD",
                NetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_TIER" => Some(Self::UndefinedNetworkTier),
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        DirectIpv6 = 4397213,
        OneToOneNat = 84090205,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::DirectIpv6 => "DIRECT_IPV6",
                Type::OneToOneNat => "ONE_TO_ONE_NAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "DIRECT_IPV6" => Some(Self::DirectIpv6),
                "ONE_TO_ONE_NAT" => Some(Self::OneToOneNat),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddAccessConfigInstanceRequest {
    #[prost(message, optional, tag = "387825552")]
    pub access_config_resource: ::core::option::Option<AccessConfig>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "365387880")]
    pub network_interface: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddAssociationFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259546170")]
    pub firewall_policy_association_resource: ::core::option::Option<
        FirewallPolicyAssociation,
    >,
    #[prost(bool, optional, tag = "209541240")]
    pub replace_existing_association: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddAssociationNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259546170")]
    pub firewall_policy_association_resource: ::core::option::Option<
        FirewallPolicyAssociation,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "209541240")]
    pub replace_existing_association: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddAssociationRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259546170")]
    pub firewall_policy_association_resource: ::core::option::Option<
        FirewallPolicyAssociation,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "209541240")]
    pub replace_existing_association: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddHealthCheckTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "269573412")]
    pub target_pools_add_health_check_request_resource: ::core::option::Option<
        TargetPoolsAddHealthCheckRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddInstanceTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "428796404")]
    pub target_pools_add_instance_request_resource: ::core::option::Option<
        TargetPoolsAddInstanceRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddInstancesInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "453713246")]
    pub instance_groups_add_instances_request_resource: ::core::option::Option<
        InstanceGroupsAddInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddNodesNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "131263288")]
    pub node_groups_add_nodes_request_resource: ::core::option::Option<
        NodeGroupsAddNodesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPeeringNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "388810421")]
    pub networks_add_peering_request_resource: ::core::option::Option<
        NetworksAddPeeringRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddResourcePoliciesDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "496483363")]
    pub disks_add_resource_policies_request_resource: ::core::option::Option<
        DisksAddResourcePoliciesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddResourcePoliciesInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "489351963")]
    pub instances_add_resource_policies_request_resource: ::core::option::Option<
        InstancesAddResourcePoliciesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddResourcePoliciesRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "284196750")]
    pub region_disks_add_resource_policies_request_resource: ::core::option::Option<
        RegionDisksAddResourcePoliciesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRuleFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRuleNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(int32, optional, tag = "329635359")]
    pub max_priority: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "267190513")]
    pub min_priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRuleRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(int32, optional, tag = "329635359")]
    pub max_priority: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "267190513")]
    pub min_priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRuleRegionSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "402693443")]
    pub security_policy_rule_resource: ::core::option::Option<SecurityPolicyRule>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddRuleSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "402693443")]
    pub security_policy_rule_resource: ::core::option::Option<SecurityPolicyRule>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddSignedUrlKeyBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "457625985")]
    pub signed_url_key_resource: ::core::option::Option<SignedUrlKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddSignedUrlKeyBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "457625985")]
    pub signed_url_key_resource: ::core::option::Option<SignedUrlKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Address {
    #[prost(string, optional, tag = "462920692")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "264307877")]
    pub address_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "294959552")]
    pub ip_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "97501004")]
    pub ipv6_endpoint_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "517397843")]
    pub network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "453565747")]
    pub prefix_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "316407070")]
    pub purpose: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "111578632")]
    pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Address`.
pub mod address {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AddressType {
        UndefinedAddressType = 0,
        External = 35607499,
        Internal = 279295677,
        UnspecifiedType = 53933922,
    }
    impl AddressType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AddressType::UndefinedAddressType => "UNDEFINED_ADDRESS_TYPE",
                AddressType::External => "EXTERNAL",
                AddressType::Internal => "INTERNAL",
                AddressType::UnspecifiedType => "UNSPECIFIED_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADDRESS_TYPE" => Some(Self::UndefinedAddressType),
                "EXTERNAL" => Some(Self::External),
                "INTERNAL" => Some(Self::Internal),
                "UNSPECIFIED_TYPE" => Some(Self::UnspecifiedType),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IpVersion {
        UndefinedIpVersion = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
        UnspecifiedVersion = 21850000,
    }
    impl IpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpVersion::UndefinedIpVersion => "UNDEFINED_IP_VERSION",
                IpVersion::Ipv4 => "IPV4",
                IpVersion::Ipv6 => "IPV6",
                IpVersion::UnspecifiedVersion => "UNSPECIFIED_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IP_VERSION" => Some(Self::UndefinedIpVersion),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                "UNSPECIFIED_VERSION" => Some(Self::UnspecifiedVersion),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Ipv6EndpointType {
        UndefinedIpv6EndpointType = 0,
        Netlb = 74173363,
        Vm = 2743,
    }
    impl Ipv6EndpointType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Ipv6EndpointType::UndefinedIpv6EndpointType => {
                    "UNDEFINED_IPV6_ENDPOINT_TYPE"
                }
                Ipv6EndpointType::Netlb => "NETLB",
                Ipv6EndpointType::Vm => "VM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IPV6_ENDPOINT_TYPE" => Some(Self::UndefinedIpv6EndpointType),
                "NETLB" => Some(Self::Netlb),
                "VM" => Some(Self::Vm),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkTier {
        UndefinedNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkTier::UndefinedNetworkTier => "UNDEFINED_NETWORK_TIER",
                NetworkTier::FixedStandard => "FIXED_STANDARD",
                NetworkTier::Premium => "PREMIUM",
                NetworkTier::Standard => "STANDARD",
                NetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_TIER" => Some(Self::UndefinedNetworkTier),
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Purpose {
        UndefinedPurpose = 0,
        DnsResolver = 476114556,
        GceEndpoint = 230515243,
        IpsecInterconnect = 340437251,
        NatAuto = 163666477,
        PrivateServiceConnect = 48134724,
        Serverless = 270492508,
        SharedLoadbalancerVip = 294447572,
        VpcPeering = 400800170,
    }
    impl Purpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Purpose::UndefinedPurpose => "UNDEFINED_PURPOSE",
                Purpose::DnsResolver => "DNS_RESOLVER",
                Purpose::GceEndpoint => "GCE_ENDPOINT",
                Purpose::IpsecInterconnect => "IPSEC_INTERCONNECT",
                Purpose::NatAuto => "NAT_AUTO",
                Purpose::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
                Purpose::Serverless => "SERVERLESS",
                Purpose::SharedLoadbalancerVip => "SHARED_LOADBALANCER_VIP",
                Purpose::VpcPeering => "VPC_PEERING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PURPOSE" => Some(Self::UndefinedPurpose),
                "DNS_RESOLVER" => Some(Self::DnsResolver),
                "GCE_ENDPOINT" => Some(Self::GceEndpoint),
                "IPSEC_INTERCONNECT" => Some(Self::IpsecInterconnect),
                "NAT_AUTO" => Some(Self::NatAuto),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                "SERVERLESS" => Some(Self::Serverless),
                "SHARED_LOADBALANCER_VIP" => Some(Self::SharedLoadbalancerVip),
                "VPC_PEERING" => Some(Self::VpcPeering),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        InUse = 17393485,
        Reserved = 432241448,
        Reserving = 514587225,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::InUse => "IN_USE",
                Status::Reserved => "RESERVED",
                Status::Reserving => "RESERVING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "IN_USE" => Some(Self::InUse),
                "RESERVED" => Some(Self::Reserved),
                "RESERVING" => Some(Self::Reserving),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AddressesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Address>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddressesScopedList {
    #[prost(message, repeated, tag = "337673122")]
    pub addresses: ::prost::alloc::vec::Vec<Address>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvancedMachineFeatures {
    #[prost(bool, optional, tag = "16639365")]
    pub enable_nested_virtualization: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "334485668")]
    pub enable_uefi_networking: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "352611671")]
    pub threads_per_core: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "193198684")]
    pub visible_core_count: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListAcceleratorTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListAddressesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListAutoscalersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListBackendServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListDiskTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListDisksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListForwardingRulesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListGlobalOperationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListHealthChecksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInstanceGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInstanceTemplatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInstancesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInstantSnapshotsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListInterconnectAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListMachineTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNetworkAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNetworkEdgeSecurityServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNodeGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNodeTemplatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListNodeTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListPacketMirroringsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListPublicDelegatedPrefixesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListRegionCommitmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListReservationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListResourcePoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListRoutersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListSecurityPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListServiceAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListSslCertificatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListSslPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListStoragePoolTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListStoragePoolsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListSubnetworksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetHttpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetHttpsProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetInstancesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetPoolsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetTcpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListTargetVpnGatewaysRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListUrlMapsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListVpnGatewaysRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggregatedListVpnTunnelsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "391327988")]
    pub include_all_scopes: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(int64, optional, tag = "316757497")]
    pub service_project_number: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AliasIpRange {
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "387995966")]
    pub subnetwork_range_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationAggregateReservation {
    #[prost(message, repeated, tag = "409009107")]
    pub in_use_resources: ::prost::alloc::vec::Vec<
        AllocationAggregateReservationReservedResourceInfo,
    >,
    #[prost(message, repeated, tag = "213217742")]
    pub reserved_resources: ::prost::alloc::vec::Vec<
        AllocationAggregateReservationReservedResourceInfo,
    >,
    #[prost(string, optional, tag = "125017580")]
    pub vm_family: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "273432322")]
    pub workload_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AllocationAggregateReservation`.
pub mod allocation_aggregate_reservation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VmFamily {
        UndefinedVmFamily = 0,
        CloudTpuLiteDeviceCt5l = 108020067,
        CloudTpuLitePodSliceCt5lp = 18705267,
        CloudTpuPodSliceCt4p = 517384407,
    }
    impl VmFamily {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VmFamily::UndefinedVmFamily => "UNDEFINED_VM_FAMILY",
                VmFamily::CloudTpuLiteDeviceCt5l => {
                    "VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L"
                }
                VmFamily::CloudTpuLitePodSliceCt5lp => {
                    "VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP"
                }
                VmFamily::CloudTpuPodSliceCt4p => "VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_VM_FAMILY" => Some(Self::UndefinedVmFamily),
                "VM_FAMILY_CLOUD_TPU_LITE_DEVICE_CT5L" => {
                    Some(Self::CloudTpuLiteDeviceCt5l)
                }
                "VM_FAMILY_CLOUD_TPU_LITE_POD_SLICE_CT5LP" => {
                    Some(Self::CloudTpuLitePodSliceCt5lp)
                }
                "VM_FAMILY_CLOUD_TPU_POD_SLICE_CT4P" => Some(Self::CloudTpuPodSliceCt4p),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WorkloadType {
        UndefinedWorkloadType = 0,
        Batch = 62971674,
        Serving = 17781740,
        Unspecified = 526786327,
    }
    impl WorkloadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WorkloadType::UndefinedWorkloadType => "UNDEFINED_WORKLOAD_TYPE",
                WorkloadType::Batch => "BATCH",
                WorkloadType::Serving => "SERVING",
                WorkloadType::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_WORKLOAD_TYPE" => Some(Self::UndefinedWorkloadType),
                "BATCH" => Some(Self::Batch),
                "SERVING" => Some(Self::Serving),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationAggregateReservationReservedResourceInfo {
    #[prost(message, optional, tag = "424338027")]
    pub accelerator: ::core::option::Option<
        AllocationAggregateReservationReservedResourceInfoAccelerator,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationAggregateReservationReservedResourceInfoAccelerator {
    #[prost(int32, optional, tag = "504879675")]
    pub accelerator_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "138031246")]
    pub accelerator_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationResourceStatus {
    #[prost(message, optional, tag = "196231151")]
    pub specific_sku_allocation: ::core::option::Option<
        AllocationResourceStatusSpecificSkuAllocation,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationResourceStatusSpecificSkuAllocation {
    #[prost(string, optional, tag = "111196154")]
    pub source_instance_template_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationSpecificSkuAllocationAllocatedInstancePropertiesReservedDisk {
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "502623545")]
    pub interface: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AllocationSpecificSKUAllocationAllocatedInstancePropertiesReservedDisk`.
pub mod allocation_specific_sku_allocation_allocated_instance_properties_reserved_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Interface {
        UndefinedInterface = 0,
        Nvme = 2408800,
        Scsi = 2539686,
    }
    impl Interface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Interface::UndefinedInterface => "UNDEFINED_INTERFACE",
                Interface::Nvme => "NVME",
                Interface::Scsi => "SCSI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INTERFACE" => Some(Self::UndefinedInterface),
                "NVME" => Some(Self::Nvme),
                "SCSI" => Some(Self::Scsi),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationSpecificSkuAllocationReservedInstanceProperties {
    #[prost(message, repeated, tag = "463595119")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(message, repeated, tag = "229951299")]
    pub local_ssds: ::prost::alloc::vec::Vec<
        AllocationSpecificSkuAllocationAllocatedInstancePropertiesReservedDisk,
    >,
    #[prost(string, optional, tag = "350519505")]
    pub location_hint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "227711026")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "242912759")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllocationSpecificSkuReservation {
    #[prost(int64, optional, tag = "281197645")]
    pub assured_count: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "94851343")]
    pub count: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "493458877")]
    pub in_use_count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "215355165")]
    pub instance_properties: ::core::option::Option<
        AllocationSpecificSkuAllocationReservedInstanceProperties,
    >,
    #[prost(string, optional, tag = "332423616")]
    pub source_instance_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Allowed {
    #[prost(string, optional, tag = "488094525")]
    pub i_p_protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "106854418")]
    pub ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnouncePublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "101874590")]
    pub public_advertised_prefix: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnouncePublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyUpdatesToInstancesInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259242835")]
    pub instance_group_managers_apply_updates_request_resource: ::core::option::Option<
        InstanceGroupManagersApplyUpdatesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "76248318")]
    pub region_instance_group_managers_apply_updates_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersApplyUpdatesRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachDiskInstanceRequest {
    #[prost(message, optional, tag = "90605845")]
    pub attached_disk_resource: ::core::option::Option<AttachedDisk>,
    #[prost(bool, optional, tag = "142758425")]
    pub force_attach: ::core::option::Option<bool>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest {
    #[prost(message, optional, tag = "30691563")]
    pub global_network_endpoint_groups_attach_endpoints_request_resource: ::core::option::Option<
        GlobalNetworkEndpointGroupsAttachEndpointsRequest,
    >,
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachNetworkEndpointsNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "531079")]
    pub network_endpoint_groups_attach_endpoints_request_resource: ::core::option::Option<
        NetworkEndpointGroupsAttachEndpointsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachNetworkEndpointsRegionNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "334986492")]
    pub region_network_endpoint_groups_attach_endpoints_request_resource: ::core::option::Option<
        RegionNetworkEndpointGroupsAttachEndpointsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDisk {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3029746")]
    pub boot: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "67541716")]
    pub device_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "271660677")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "142758425")]
    pub force_attach: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "79294545")]
    pub guest_os_features: ::prost::alloc::vec::Vec<GuestOsFeature>,
    #[prost(int32, optional, tag = "100346066")]
    pub index: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "17697045")]
    pub initialize_params: ::core::option::Option<AttachedDiskInitializeParams>,
    #[prost(string, optional, tag = "502623545")]
    pub interface: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "411587801")]
    pub saved_state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "192356867")]
    pub shielded_instance_initial_state: ::core::option::Option<InitialStateConfig>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AttachedDisk`.
pub mod attached_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Interface {
        UndefinedInterface = 0,
        Nvme = 2408800,
        Scsi = 2539686,
    }
    impl Interface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Interface::UndefinedInterface => "UNDEFINED_INTERFACE",
                Interface::Nvme => "NVME",
                Interface::Scsi => "SCSI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INTERFACE" => Some(Self::UndefinedInterface),
                "NVME" => Some(Self::Nvme),
                "SCSI" => Some(Self::Scsi),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        ReadOnly = 91950261,
        ReadWrite = 173607894,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::ReadOnly => "READ_ONLY",
                Mode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SavedState {
        UndefinedSavedState = 0,
        DiskSavedStateUnspecified = 391290831,
        Preserved = 254159736,
    }
    impl SavedState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SavedState::UndefinedSavedState => "UNDEFINED_SAVED_STATE",
                SavedState::DiskSavedStateUnspecified => "DISK_SAVED_STATE_UNSPECIFIED",
                SavedState::Preserved => "PRESERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SAVED_STATE" => Some(Self::UndefinedSavedState),
                "DISK_SAVED_STATE_UNSPECIFIED" => Some(Self::DiskSavedStateUnspecified),
                "PRESERVED" => Some(Self::Preserved),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Persistent = 460683927,
        Scratch = 496778970,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Persistent => "PERSISTENT",
                Type::Scratch => "SCRATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "PERSISTENT" => Some(Self::Persistent),
                "SCRATCH" => Some(Self::Scratch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttachedDiskInitializeParams {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "92807149")]
    pub disk_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "93009052")]
    pub disk_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "102135228")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "202451980")]
    pub on_update_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "186769108")]
    pub provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "526524181")]
    pub provisioned_throughput: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "48438272")]
    pub replica_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "377671164")]
    pub resource_manager_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50443319")]
    pub source_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "381503659")]
    pub source_image_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "126061928")]
    pub source_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "303679322")]
    pub source_snapshot_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "360473440")]
    pub storage_pool: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AttachedDiskInitializeParams`.
pub mod attached_disk_initialize_params {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnUpdateAction {
        UndefinedOnUpdateAction = 0,
        RecreateDisk = 494767853,
        RecreateDiskIfSourceChanged = 398099712,
        UseExistingDisk = 232682233,
    }
    impl OnUpdateAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnUpdateAction::UndefinedOnUpdateAction => "UNDEFINED_ON_UPDATE_ACTION",
                OnUpdateAction::RecreateDisk => "RECREATE_DISK",
                OnUpdateAction::RecreateDiskIfSourceChanged => {
                    "RECREATE_DISK_IF_SOURCE_CHANGED"
                }
                OnUpdateAction::UseExistingDisk => "USE_EXISTING_DISK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ON_UPDATE_ACTION" => Some(Self::UndefinedOnUpdateAction),
                "RECREATE_DISK" => Some(Self::RecreateDisk),
                "RECREATE_DISK_IF_SOURCE_CHANGED" => {
                    Some(Self::RecreateDiskIfSourceChanged)
                }
                "USE_EXISTING_DISK" => Some(Self::UseExistingDisk),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditConfig {
    #[prost(message, repeated, tag = "488420626")]
    pub audit_log_configs: ::prost::alloc::vec::Vec<AuditLogConfig>,
    #[prost(string, repeated, tag = "232615576")]
    pub exempted_members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuditLogConfig {
    #[prost(string, repeated, tag = "232615576")]
    pub exempted_members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "70141850")]
    pub ignore_child_exemptions: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "403115861")]
    pub log_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AuditLogConfig`.
pub mod audit_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogType {
        UndefinedLogType = 0,
        AdminRead = 128951462,
        DataRead = 305224971,
        DataWrite = 340181738,
        Unspecified = 154527053,
    }
    impl LogType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LogType::UndefinedLogType => "UNDEFINED_LOG_TYPE",
                LogType::AdminRead => "ADMIN_READ",
                LogType::DataRead => "DATA_READ",
                LogType::DataWrite => "DATA_WRITE",
                LogType::Unspecified => "LOG_TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOG_TYPE" => Some(Self::UndefinedLogType),
                "ADMIN_READ" => Some(Self::AdminRead),
                "DATA_READ" => Some(Self::DataRead),
                "DATA_WRITE" => Some(Self::DataWrite),
                "LOG_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthorizationLoggingOptions {
    #[prost(string, optional, tag = "525978538")]
    pub permission_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AuthorizationLoggingOptions`.
pub mod authorization_logging_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PermissionType {
        UndefinedPermissionType = 0,
        AdminRead = 128951462,
        AdminWrite = 244412079,
        DataRead = 305224971,
        DataWrite = 340181738,
        Unspecified = 440313346,
    }
    impl PermissionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PermissionType::UndefinedPermissionType => "UNDEFINED_PERMISSION_TYPE",
                PermissionType::AdminRead => "ADMIN_READ",
                PermissionType::AdminWrite => "ADMIN_WRITE",
                PermissionType::DataRead => "DATA_READ",
                PermissionType::DataWrite => "DATA_WRITE",
                PermissionType::Unspecified => "PERMISSION_TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PERMISSION_TYPE" => Some(Self::UndefinedPermissionType),
                "ADMIN_READ" => Some(Self::AdminRead),
                "ADMIN_WRITE" => Some(Self::AdminWrite),
                "DATA_READ" => Some(Self::DataRead),
                "DATA_WRITE" => Some(Self::DataWrite),
                "PERMISSION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Autoscaler {
    #[prost(message, optional, tag = "221950041")]
    pub autoscaling_policy: ::core::option::Option<AutoscalingPolicy>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "257915749")]
    pub recommended_size: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "465950178")]
    pub scaling_schedule_status: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ScalingScheduleStatus,
    >,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "363353845")]
    pub status_details: ::prost::alloc::vec::Vec<AutoscalerStatusDetails>,
    #[prost(string, optional, tag = "192835985")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Autoscaler`.
pub mod autoscaler {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Active = 314733318,
        Deleting = 528602024,
        Error = 66247144,
        Pending = 35394935,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Active => "ACTIVE",
                Status::Deleting => "DELETING",
                Status::Error => "ERROR",
                Status::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACTIVE" => Some(Self::Active),
                "DELETING" => Some(Self::Deleting),
                "ERROR" => Some(Self::Error),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalerAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AutoscalersScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalerList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Autoscaler>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalerStatusDetails {
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AutoscalerStatusDetails`.
pub mod autoscaler_status_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        AllInstancesUnhealthy = 404965477,
        BackendServiceDoesNotExist = 191417626,
        CappedAtMaxNumReplicas = 518617,
        CustomMetricDataPointsTooSparse = 328964659,
        CustomMetricInvalid = 204430550,
        MinEqualsMax = 2821361,
        MissingCustomMetricDataPoints = 94885086,
        MissingLoadBalancingDataPoints = 509858898,
        ModeOff = 164169907,
        ModeOnlyScaleOut = 3840994,
        ModeOnlyUp = 100969842,
        MoreThanOneBackendService = 151922141,
        NotEnoughQuotaAvailable = 403101631,
        RegionResourceStockout = 528622846,
        ScalingTargetDoesNotExist = 122636699,
        ScheduledInstancesGreaterThanAutoscalerMax = 29275586,
        ScheduledInstancesLessThanAutoscalerMin = 398287669,
        Unknown = 433141802,
        UnsupportedMaxRateLoadBalancingConfiguration = 330845009,
        ZoneResourceStockout = 210200502,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::AllInstancesUnhealthy => "ALL_INSTANCES_UNHEALTHY",
                Type::BackendServiceDoesNotExist => "BACKEND_SERVICE_DOES_NOT_EXIST",
                Type::CappedAtMaxNumReplicas => "CAPPED_AT_MAX_NUM_REPLICAS",
                Type::CustomMetricDataPointsTooSparse => {
                    "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE"
                }
                Type::CustomMetricInvalid => "CUSTOM_METRIC_INVALID",
                Type::MinEqualsMax => "MIN_EQUALS_MAX",
                Type::MissingCustomMetricDataPoints => {
                    "MISSING_CUSTOM_METRIC_DATA_POINTS"
                }
                Type::MissingLoadBalancingDataPoints => {
                    "MISSING_LOAD_BALANCING_DATA_POINTS"
                }
                Type::ModeOff => "MODE_OFF",
                Type::ModeOnlyScaleOut => "MODE_ONLY_SCALE_OUT",
                Type::ModeOnlyUp => "MODE_ONLY_UP",
                Type::MoreThanOneBackendService => "MORE_THAN_ONE_BACKEND_SERVICE",
                Type::NotEnoughQuotaAvailable => "NOT_ENOUGH_QUOTA_AVAILABLE",
                Type::RegionResourceStockout => "REGION_RESOURCE_STOCKOUT",
                Type::ScalingTargetDoesNotExist => "SCALING_TARGET_DOES_NOT_EXIST",
                Type::ScheduledInstancesGreaterThanAutoscalerMax => {
                    "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX"
                }
                Type::ScheduledInstancesLessThanAutoscalerMin => {
                    "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN"
                }
                Type::Unknown => "UNKNOWN",
                Type::UnsupportedMaxRateLoadBalancingConfiguration => {
                    "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION"
                }
                Type::ZoneResourceStockout => "ZONE_RESOURCE_STOCKOUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "ALL_INSTANCES_UNHEALTHY" => Some(Self::AllInstancesUnhealthy),
                "BACKEND_SERVICE_DOES_NOT_EXIST" => {
                    Some(Self::BackendServiceDoesNotExist)
                }
                "CAPPED_AT_MAX_NUM_REPLICAS" => Some(Self::CappedAtMaxNumReplicas),
                "CUSTOM_METRIC_DATA_POINTS_TOO_SPARSE" => {
                    Some(Self::CustomMetricDataPointsTooSparse)
                }
                "CUSTOM_METRIC_INVALID" => Some(Self::CustomMetricInvalid),
                "MIN_EQUALS_MAX" => Some(Self::MinEqualsMax),
                "MISSING_CUSTOM_METRIC_DATA_POINTS" => {
                    Some(Self::MissingCustomMetricDataPoints)
                }
                "MISSING_LOAD_BALANCING_DATA_POINTS" => {
                    Some(Self::MissingLoadBalancingDataPoints)
                }
                "MODE_OFF" => Some(Self::ModeOff),
                "MODE_ONLY_SCALE_OUT" => Some(Self::ModeOnlyScaleOut),
                "MODE_ONLY_UP" => Some(Self::ModeOnlyUp),
                "MORE_THAN_ONE_BACKEND_SERVICE" => Some(Self::MoreThanOneBackendService),
                "NOT_ENOUGH_QUOTA_AVAILABLE" => Some(Self::NotEnoughQuotaAvailable),
                "REGION_RESOURCE_STOCKOUT" => Some(Self::RegionResourceStockout),
                "SCALING_TARGET_DOES_NOT_EXIST" => Some(Self::ScalingTargetDoesNotExist),
                "SCHEDULED_INSTANCES_GREATER_THAN_AUTOSCALER_MAX" => {
                    Some(Self::ScheduledInstancesGreaterThanAutoscalerMax)
                }
                "SCHEDULED_INSTANCES_LESS_THAN_AUTOSCALER_MIN" => {
                    Some(Self::ScheduledInstancesLessThanAutoscalerMin)
                }
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED_MAX_RATE_LOAD_BALANCING_CONFIGURATION" => {
                    Some(Self::UnsupportedMaxRateLoadBalancingConfiguration)
                }
                "ZONE_RESOURCE_STOCKOUT" => Some(Self::ZoneResourceStockout),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalersScopedList {
    #[prost(message, repeated, tag = "465771644")]
    pub autoscalers: ::prost::alloc::vec::Vec<Autoscaler>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicy {
    #[prost(int32, optional, tag = "107692954")]
    pub cool_down_period_sec: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "381211147")]
    pub cpu_utilization: ::core::option::Option<AutoscalingPolicyCpuUtilization>,
    #[prost(message, repeated, tag = "131972850")]
    pub custom_metric_utilizations: ::prost::alloc::vec::Vec<
        AutoscalingPolicyCustomMetricUtilization,
    >,
    #[prost(message, optional, tag = "429746403")]
    pub load_balancing_utilization: ::core::option::Option<
        AutoscalingPolicyLoadBalancingUtilization,
    >,
    #[prost(int32, optional, tag = "62327375")]
    pub max_num_replicas: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "535329825")]
    pub min_num_replicas: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "527670872")]
    pub scale_in_control: ::core::option::Option<AutoscalingPolicyScaleInControl>,
    #[prost(map = "string, message", tag = "355416580")]
    pub scaling_schedules: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AutoscalingPolicyScalingSchedule,
    >,
}
/// Nested message and enum types in `AutoscalingPolicy`.
pub mod autoscaling_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        Off = 78159,
        On = 2527,
        OnlyScaleOut = 152713670,
        OnlyUp = 478095374,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::Off => "OFF",
                Mode::On => "ON",
                Mode::OnlyScaleOut => "ONLY_SCALE_OUT",
                Mode::OnlyUp => "ONLY_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "ONLY_SCALE_OUT" => Some(Self::OnlyScaleOut),
                "ONLY_UP" => Some(Self::OnlyUp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicyCpuUtilization {
    #[prost(string, optional, tag = "390220737")]
    pub predictive_method: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "215905870")]
    pub utilization_target: ::core::option::Option<f64>,
}
/// Nested message and enum types in `AutoscalingPolicyCpuUtilization`.
pub mod autoscaling_policy_cpu_utilization {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PredictiveMethod {
        UndefinedPredictiveMethod = 0,
        None = 2402104,
        OptimizeAvailability = 11629437,
    }
    impl PredictiveMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PredictiveMethod::UndefinedPredictiveMethod => {
                    "UNDEFINED_PREDICTIVE_METHOD"
                }
                PredictiveMethod::None => "NONE",
                PredictiveMethod::OptimizeAvailability => "OPTIMIZE_AVAILABILITY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PREDICTIVE_METHOD" => Some(Self::UndefinedPredictiveMethod),
                "NONE" => Some(Self::None),
                "OPTIMIZE_AVAILABILITY" => Some(Self::OptimizeAvailability),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicyCustomMetricUtilization {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "533067184")]
    pub metric: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "504768064")]
    pub single_instance_assignment: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "215905870")]
    pub utilization_target: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "340169355")]
    pub utilization_target_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `AutoscalingPolicyCustomMetricUtilization`.
pub mod autoscaling_policy_custom_metric_utilization {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UtilizationTargetType {
        UndefinedUtilizationTargetType = 0,
        DeltaPerMinute = 87432861,
        DeltaPerSecond = 255180029,
        Gauge = 67590361,
    }
    impl UtilizationTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UtilizationTargetType::UndefinedUtilizationTargetType => {
                    "UNDEFINED_UTILIZATION_TARGET_TYPE"
                }
                UtilizationTargetType::DeltaPerMinute => "DELTA_PER_MINUTE",
                UtilizationTargetType::DeltaPerSecond => "DELTA_PER_SECOND",
                UtilizationTargetType::Gauge => "GAUGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_UTILIZATION_TARGET_TYPE" => {
                    Some(Self::UndefinedUtilizationTargetType)
                }
                "DELTA_PER_MINUTE" => Some(Self::DeltaPerMinute),
                "DELTA_PER_SECOND" => Some(Self::DeltaPerSecond),
                "GAUGE" => Some(Self::Gauge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicyLoadBalancingUtilization {
    #[prost(double, optional, tag = "215905870")]
    pub utilization_target: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicyScaleInControl {
    #[prost(message, optional, tag = "180710123")]
    pub max_scaled_in_replicas: ::core::option::Option<FixedOrPercent>,
    #[prost(int32, optional, tag = "36405300")]
    pub time_window_sec: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AutoscalingPolicyScalingSchedule {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "270940796")]
    pub disabled: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "212356902")]
    pub duration_sec: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "365514414")]
    pub min_required_replicas: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "375820951")]
    pub schedule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "36848094")]
    pub time_zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Backend {
    #[prost(string, optional, tag = "430286217")]
    pub balancing_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "315958157")]
    pub capacity_scaler: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "138892530")]
    pub failover: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "98629247")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "110652154")]
    pub max_connections: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "216904604")]
    pub max_connections_per_endpoint: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "104671900")]
    pub max_connections_per_instance: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "408035035")]
    pub max_rate: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "129832283")]
    pub max_rate_per_endpoint: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "17599579")]
    pub max_rate_per_instance: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "148192199")]
    pub max_utilization: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "150781147")]
    pub preference: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Backend`.
pub mod backend {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BalancingMode {
        UndefinedBalancingMode = 0,
        Connection = 246311646,
        Rate = 2508000,
        Utilization = 157008386,
    }
    impl BalancingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BalancingMode::UndefinedBalancingMode => "UNDEFINED_BALANCING_MODE",
                BalancingMode::Connection => "CONNECTION",
                BalancingMode::Rate => "RATE",
                BalancingMode::Utilization => "UTILIZATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BALANCING_MODE" => Some(Self::UndefinedBalancingMode),
                "CONNECTION" => Some(Self::Connection),
                "RATE" => Some(Self::Rate),
                "UTILIZATION" => Some(Self::Utilization),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Preference {
        UndefinedPreference = 0,
        Default = 115302945,
        Unspecified = 496219571,
        Preferred = 418847841,
    }
    impl Preference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Preference::UndefinedPreference => "UNDEFINED_PREFERENCE",
                Preference::Default => "DEFAULT",
                Preference::Unspecified => "PREFERENCE_UNSPECIFIED",
                Preference::Preferred => "PREFERRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PREFERENCE" => Some(Self::UndefinedPreference),
                "DEFAULT" => Some(Self::Default),
                "PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                "PREFERRED" => Some(Self::Preferred),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendBucket {
    #[prost(string, optional, tag = "283610048")]
    pub bucket_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "213976452")]
    pub cdn_policy: ::core::option::Option<BackendBucketCdnPolicy>,
    #[prost(string, optional, tag = "95520988")]
    pub compression_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "387539094")]
    pub custom_response_headers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41036943")]
    pub edge_security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "282942321")]
    pub enable_cdn: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BackendBucket`.
pub mod backend_bucket {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompressionMode {
        UndefinedCompressionMode = 0,
        Automatic = 165298699,
        Disabled = 516696700,
    }
    impl CompressionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompressionMode::UndefinedCompressionMode => "UNDEFINED_COMPRESSION_MODE",
                CompressionMode::Automatic => "AUTOMATIC",
                CompressionMode::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_COMPRESSION_MODE" => Some(Self::UndefinedCompressionMode),
                "AUTOMATIC" => Some(Self::Automatic),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendBucketCdnPolicy {
    #[prost(message, repeated, tag = "486203082")]
    pub bypass_cache_on_request_headers: ::prost::alloc::vec::Vec<
        BackendBucketCdnPolicyBypassCacheOnRequestHeader,
    >,
    #[prost(message, optional, tag = "159263727")]
    pub cache_key_policy: ::core::option::Option<BackendBucketCdnPolicyCacheKeyPolicy>,
    #[prost(string, optional, tag = "28877888")]
    pub cache_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "29034360")]
    pub client_ttl: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "100253422")]
    pub default_ttl: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "307578001")]
    pub max_ttl: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "336110005")]
    pub negative_caching: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "155359996")]
    pub negative_caching_policy: ::prost::alloc::vec::Vec<
        BackendBucketCdnPolicyNegativeCachingPolicy,
    >,
    #[prost(bool, optional, tag = "532808276")]
    pub request_coalescing: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "236682203")]
    pub serve_while_stale: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "269374534")]
    pub signed_url_cache_max_age_sec: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "371848885")]
    pub signed_url_key_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BackendBucketCdnPolicy`.
pub mod backend_bucket_cdn_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CacheMode {
        UndefinedCacheMode = 0,
        CacheAllStatic = 355027945,
        ForceCacheAll = 486026928,
        InvalidCacheMode = 381295560,
        UseOriginHeaders = 55380261,
    }
    impl CacheMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CacheMode::UndefinedCacheMode => "UNDEFINED_CACHE_MODE",
                CacheMode::CacheAllStatic => "CACHE_ALL_STATIC",
                CacheMode::ForceCacheAll => "FORCE_CACHE_ALL",
                CacheMode::InvalidCacheMode => "INVALID_CACHE_MODE",
                CacheMode::UseOriginHeaders => "USE_ORIGIN_HEADERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CACHE_MODE" => Some(Self::UndefinedCacheMode),
                "CACHE_ALL_STATIC" => Some(Self::CacheAllStatic),
                "FORCE_CACHE_ALL" => Some(Self::ForceCacheAll),
                "INVALID_CACHE_MODE" => Some(Self::InvalidCacheMode),
                "USE_ORIGIN_HEADERS" => Some(Self::UseOriginHeaders),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendBucketCdnPolicyBypassCacheOnRequestHeader {
    #[prost(string, optional, tag = "110223613")]
    pub header_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendBucketCdnPolicyCacheKeyPolicy {
    #[prost(string, repeated, tag = "2489606")]
    pub include_http_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "52456496")]
    pub query_string_whitelist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackendBucketCdnPolicyNegativeCachingPolicy {
    #[prost(int32, optional, tag = "3059181")]
    pub code: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "115180")]
    pub ttl: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendBucketList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<BackendBucket>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendService {
    #[prost(int32, optional, tag = "369996954")]
    pub affinity_cookie_ttl_sec: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "510839903")]
    pub backends: ::prost::alloc::vec::Vec<Backend>,
    #[prost(message, optional, tag = "213976452")]
    pub cdn_policy: ::core::option::Option<BackendServiceCdnPolicy>,
    #[prost(message, optional, tag = "421340061")]
    pub circuit_breakers: ::core::option::Option<CircuitBreakers>,
    #[prost(string, optional, tag = "95520988")]
    pub compression_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "461096747")]
    pub connection_draining: ::core::option::Option<ConnectionDraining>,
    #[prost(message, optional, tag = "143994969")]
    pub connection_tracking_policy: ::core::option::Option<
        BackendServiceConnectionTrackingPolicy,
    >,
    #[prost(message, optional, tag = "905883")]
    pub consistent_hash: ::core::option::Option<ConsistentHashLoadBalancerSettings>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "27977992")]
    pub custom_request_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "387539094")]
    pub custom_response_headers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41036943")]
    pub edge_security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "250733499")]
    pub enable_c_d_n: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "105658655")]
    pub failover_policy: ::core::option::Option<BackendServiceFailoverPolicy>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "104024")]
    pub iap: ::core::option::Option<BackendServiceIap>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "363890244")]
    pub load_balancing_scheme: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "140982557")]
    pub locality_lb_policies: ::prost::alloc::vec::Vec<
        BackendServiceLocalityLoadBalancingPolicyConfig,
    >,
    #[prost(string, optional, tag = "131431487")]
    pub locality_lb_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "351299741")]
    pub log_config: ::core::option::Option<BackendServiceLogConfig>,
    #[prost(message, optional, tag = "61428376")]
    pub max_stream_duration: ::core::option::Option<Duration>,
    #[prost(map = "string, string", tag = "8514340")]
    pub metadatas: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "354625086")]
    pub outlier_detection: ::core::option::Option<OutlierDetection>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "84577944")]
    pub protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "478649922")]
    pub security_settings: ::core::option::Option<SecuritySettings>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "133581016")]
    pub service_bindings: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "94848785")]
    pub service_lb_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "463888561")]
    pub session_affinity: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "450283536")]
    pub subsetting: ::core::option::Option<Subsetting>,
    #[prost(int32, optional, tag = "79994995")]
    pub timeout_sec: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "389320729")]
    pub used_by: ::prost::alloc::vec::Vec<BackendServiceUsedBy>,
}
/// Nested message and enum types in `BackendService`.
pub mod backend_service {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CompressionMode {
        UndefinedCompressionMode = 0,
        Automatic = 165298699,
        Disabled = 516696700,
    }
    impl CompressionMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CompressionMode::UndefinedCompressionMode => "UNDEFINED_COMPRESSION_MODE",
                CompressionMode::Automatic => "AUTOMATIC",
                CompressionMode::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_COMPRESSION_MODE" => Some(Self::UndefinedCompressionMode),
                "AUTOMATIC" => Some(Self::Automatic),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancingScheme {
        UndefinedLoadBalancingScheme = 0,
        External = 35607499,
        ExternalManaged = 512006923,
        Internal = 279295677,
        InternalManaged = 37350397,
        InternalSelfManaged = 236211150,
        InvalidLoadBalancingScheme = 275352060,
    }
    impl LoadBalancingScheme {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LoadBalancingScheme::UndefinedLoadBalancingScheme => {
                    "UNDEFINED_LOAD_BALANCING_SCHEME"
                }
                LoadBalancingScheme::External => "EXTERNAL",
                LoadBalancingScheme::ExternalManaged => "EXTERNAL_MANAGED",
                LoadBalancingScheme::Internal => "INTERNAL",
                LoadBalancingScheme::InternalManaged => "INTERNAL_MANAGED",
                LoadBalancingScheme::InternalSelfManaged => "INTERNAL_SELF_MANAGED",
                LoadBalancingScheme::InvalidLoadBalancingScheme => {
                    "INVALID_LOAD_BALANCING_SCHEME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOAD_BALANCING_SCHEME" => {
                    Some(Self::UndefinedLoadBalancingScheme)
                }
                "EXTERNAL" => Some(Self::External),
                "EXTERNAL_MANAGED" => Some(Self::ExternalManaged),
                "INTERNAL" => Some(Self::Internal),
                "INTERNAL_MANAGED" => Some(Self::InternalManaged),
                "INTERNAL_SELF_MANAGED" => Some(Self::InternalSelfManaged),
                "INVALID_LOAD_BALANCING_SCHEME" => Some(Self::InvalidLoadBalancingScheme),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalityLbPolicy {
        UndefinedLocalityLbPolicy = 0,
        InvalidLbPolicy = 323318707,
        LeastRequest = 46604921,
        Maglev = 119180266,
        OriginalDestination = 166297216,
        Random = 262527171,
        RingHash = 432795069,
        RoundRobin = 153895801,
        WeightedMaglev = 254930962,
    }
    impl LocalityLbPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalityLbPolicy::UndefinedLocalityLbPolicy => {
                    "UNDEFINED_LOCALITY_LB_POLICY"
                }
                LocalityLbPolicy::InvalidLbPolicy => "INVALID_LB_POLICY",
                LocalityLbPolicy::LeastRequest => "LEAST_REQUEST",
                LocalityLbPolicy::Maglev => "MAGLEV",
                LocalityLbPolicy::OriginalDestination => "ORIGINAL_DESTINATION",
                LocalityLbPolicy::Random => "RANDOM",
                LocalityLbPolicy::RingHash => "RING_HASH",
                LocalityLbPolicy::RoundRobin => "ROUND_ROBIN",
                LocalityLbPolicy::WeightedMaglev => "WEIGHTED_MAGLEV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOCALITY_LB_POLICY" => Some(Self::UndefinedLocalityLbPolicy),
                "INVALID_LB_POLICY" => Some(Self::InvalidLbPolicy),
                "LEAST_REQUEST" => Some(Self::LeastRequest),
                "MAGLEV" => Some(Self::Maglev),
                "ORIGINAL_DESTINATION" => Some(Self::OriginalDestination),
                "RANDOM" => Some(Self::Random),
                "RING_HASH" => Some(Self::RingHash),
                "ROUND_ROBIN" => Some(Self::RoundRobin),
                "WEIGHTED_MAGLEV" => Some(Self::WeightedMaglev),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Protocol {
        UndefinedProtocol = 0,
        Grpc = 2196510,
        Http = 2228360,
        Http2 = 69079210,
        Https = 69079243,
        Ssl = 82412,
        Tcp = 82881,
        Udp = 83873,
        Unspecified = 526786327,
    }
    impl Protocol {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Protocol::UndefinedProtocol => "UNDEFINED_PROTOCOL",
                Protocol::Grpc => "GRPC",
                Protocol::Http => "HTTP",
                Protocol::Http2 => "HTTP2",
                Protocol::Https => "HTTPS",
                Protocol::Ssl => "SSL",
                Protocol::Tcp => "TCP",
                Protocol::Udp => "UDP",
                Protocol::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROTOCOL" => Some(Self::UndefinedProtocol),
                "GRPC" => Some(Self::Grpc),
                "HTTP" => Some(Self::Http),
                "HTTP2" => Some(Self::Http2),
                "HTTPS" => Some(Self::Https),
                "SSL" => Some(Self::Ssl),
                "TCP" => Some(Self::Tcp),
                "UDP" => Some(Self::Udp),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionAffinity {
        UndefinedSessionAffinity = 0,
        ClientIp = 345665051,
        ClientIpNoDestination = 106122516,
        ClientIpPortProto = 221722926,
        ClientIpProto = 25322148,
        GeneratedCookie = 370321204,
        HeaderField = 200737960,
        HttpCookie = 494981627,
        None = 2402104,
    }
    impl SessionAffinity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SessionAffinity::UndefinedSessionAffinity => "UNDEFINED_SESSION_AFFINITY",
                SessionAffinity::ClientIp => "CLIENT_IP",
                SessionAffinity::ClientIpNoDestination => "CLIENT_IP_NO_DESTINATION",
                SessionAffinity::ClientIpPortProto => "CLIENT_IP_PORT_PROTO",
                SessionAffinity::ClientIpProto => "CLIENT_IP_PROTO",
                SessionAffinity::GeneratedCookie => "GENERATED_COOKIE",
                SessionAffinity::HeaderField => "HEADER_FIELD",
                SessionAffinity::HttpCookie => "HTTP_COOKIE",
                SessionAffinity::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SESSION_AFFINITY" => Some(Self::UndefinedSessionAffinity),
                "CLIENT_IP" => Some(Self::ClientIp),
                "CLIENT_IP_NO_DESTINATION" => Some(Self::ClientIpNoDestination),
                "CLIENT_IP_PORT_PROTO" => Some(Self::ClientIpPortProto),
                "CLIENT_IP_PROTO" => Some(Self::ClientIpProto),
                "GENERATED_COOKIE" => Some(Self::GeneratedCookie),
                "HEADER_FIELD" => Some(Self::HeaderField),
                "HTTP_COOKIE" => Some(Self::HttpCookie),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        BackendServicesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceCdnPolicy {
    #[prost(message, repeated, tag = "486203082")]
    pub bypass_cache_on_request_headers: ::prost::alloc::vec::Vec<
        BackendServiceCdnPolicyBypassCacheOnRequestHeader,
    >,
    #[prost(message, optional, tag = "159263727")]
    pub cache_key_policy: ::core::option::Option<CacheKeyPolicy>,
    #[prost(string, optional, tag = "28877888")]
    pub cache_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "29034360")]
    pub client_ttl: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "100253422")]
    pub default_ttl: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "307578001")]
    pub max_ttl: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "336110005")]
    pub negative_caching: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "155359996")]
    pub negative_caching_policy: ::prost::alloc::vec::Vec<
        BackendServiceCdnPolicyNegativeCachingPolicy,
    >,
    #[prost(bool, optional, tag = "532808276")]
    pub request_coalescing: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "236682203")]
    pub serve_while_stale: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "269374534")]
    pub signed_url_cache_max_age_sec: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "371848885")]
    pub signed_url_key_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BackendServiceCdnPolicy`.
pub mod backend_service_cdn_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CacheMode {
        UndefinedCacheMode = 0,
        CacheAllStatic = 355027945,
        ForceCacheAll = 486026928,
        InvalidCacheMode = 381295560,
        UseOriginHeaders = 55380261,
    }
    impl CacheMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CacheMode::UndefinedCacheMode => "UNDEFINED_CACHE_MODE",
                CacheMode::CacheAllStatic => "CACHE_ALL_STATIC",
                CacheMode::ForceCacheAll => "FORCE_CACHE_ALL",
                CacheMode::InvalidCacheMode => "INVALID_CACHE_MODE",
                CacheMode::UseOriginHeaders => "USE_ORIGIN_HEADERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CACHE_MODE" => Some(Self::UndefinedCacheMode),
                "CACHE_ALL_STATIC" => Some(Self::CacheAllStatic),
                "FORCE_CACHE_ALL" => Some(Self::ForceCacheAll),
                "INVALID_CACHE_MODE" => Some(Self::InvalidCacheMode),
                "USE_ORIGIN_HEADERS" => Some(Self::UseOriginHeaders),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceCdnPolicyBypassCacheOnRequestHeader {
    #[prost(string, optional, tag = "110223613")]
    pub header_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackendServiceCdnPolicyNegativeCachingPolicy {
    #[prost(int32, optional, tag = "3059181")]
    pub code: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "115180")]
    pub ttl: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceConnectionTrackingPolicy {
    #[prost(string, optional, tag = "152439033")]
    pub connection_persistence_on_unhealthy_backends: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "24539924")]
    pub enable_strong_affinity: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "24977544")]
    pub idle_timeout_sec: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "127757867")]
    pub tracking_mode: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BackendServiceConnectionTrackingPolicy`.
pub mod backend_service_connection_tracking_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectionPersistenceOnUnhealthyBackends {
        UndefinedConnectionPersistenceOnUnhealthyBackends = 0,
        AlwaysPersist = 38400900,
        DefaultForProtocol = 145265356,
        NeverPersist = 138646241,
    }
    impl ConnectionPersistenceOnUnhealthyBackends {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectionPersistenceOnUnhealthyBackends::UndefinedConnectionPersistenceOnUnhealthyBackends => {
                    "UNDEFINED_CONNECTION_PERSISTENCE_ON_UNHEALTHY_BACKENDS"
                }
                ConnectionPersistenceOnUnhealthyBackends::AlwaysPersist => {
                    "ALWAYS_PERSIST"
                }
                ConnectionPersistenceOnUnhealthyBackends::DefaultForProtocol => {
                    "DEFAULT_FOR_PROTOCOL"
                }
                ConnectionPersistenceOnUnhealthyBackends::NeverPersist => "NEVER_PERSIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONNECTION_PERSISTENCE_ON_UNHEALTHY_BACKENDS" => {
                    Some(Self::UndefinedConnectionPersistenceOnUnhealthyBackends)
                }
                "ALWAYS_PERSIST" => Some(Self::AlwaysPersist),
                "DEFAULT_FOR_PROTOCOL" => Some(Self::DefaultForProtocol),
                "NEVER_PERSIST" => Some(Self::NeverPersist),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrackingMode {
        UndefinedTrackingMode = 0,
        InvalidTrackingMode = 49234371,
        PerConnection = 85162848,
        PerSession = 182099252,
    }
    impl TrackingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrackingMode::UndefinedTrackingMode => "UNDEFINED_TRACKING_MODE",
                TrackingMode::InvalidTrackingMode => "INVALID_TRACKING_MODE",
                TrackingMode::PerConnection => "PER_CONNECTION",
                TrackingMode::PerSession => "PER_SESSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TRACKING_MODE" => Some(Self::UndefinedTrackingMode),
                "INVALID_TRACKING_MODE" => Some(Self::InvalidTrackingMode),
                "PER_CONNECTION" => Some(Self::PerConnection),
                "PER_SESSION" => Some(Self::PerSession),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BackendServiceFailoverPolicy {
    #[prost(bool, optional, tag = "182150753")]
    pub disable_connection_drain_on_failover: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "112289428")]
    pub drop_traffic_if_unhealthy: ::core::option::Option<bool>,
    #[prost(float, optional, tag = "212667006")]
    pub failover_ratio: ::core::option::Option<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceGroupHealth {
    #[prost(map = "string, string", tag = "112032548")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "380545845")]
    pub health_status: ::prost::alloc::vec::Vec<HealthStatus>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceIap {
    #[prost(bool, optional, tag = "1018689")]
    pub enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "314017611")]
    pub oauth2_client_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50999520")]
    pub oauth2_client_secret: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "112903782")]
    pub oauth2_client_secret_sha256: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<BackendService>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceListUsable {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<BackendService>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceLocalityLoadBalancingPolicyConfig {
    #[prost(message, optional, tag = "4818368")]
    pub custom_policy: ::core::option::Option<
        BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy,
    >,
    #[prost(message, optional, tag = "91071794")]
    pub policy: ::core::option::Option<
        BackendServiceLocalityLoadBalancingPolicyConfigPolicy,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceLocalityLoadBalancingPolicyConfigCustomPolicy {
    #[prost(string, optional, tag = "3076010")]
    pub data: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceLocalityLoadBalancingPolicyConfigPolicy {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `BackendServiceLocalityLoadBalancingPolicyConfigPolicy`.
pub mod backend_service_locality_load_balancing_policy_config_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Name {
        UndefinedName = 0,
        InvalidLbPolicy = 323318707,
        LeastRequest = 46604921,
        Maglev = 119180266,
        OriginalDestination = 166297216,
        Random = 262527171,
        RingHash = 432795069,
        RoundRobin = 153895801,
        WeightedMaglev = 254930962,
    }
    impl Name {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Name::UndefinedName => "UNDEFINED_NAME",
                Name::InvalidLbPolicy => "INVALID_LB_POLICY",
                Name::LeastRequest => "LEAST_REQUEST",
                Name::Maglev => "MAGLEV",
                Name::OriginalDestination => "ORIGINAL_DESTINATION",
                Name::Random => "RANDOM",
                Name::RingHash => "RING_HASH",
                Name::RoundRobin => "ROUND_ROBIN",
                Name::WeightedMaglev => "WEIGHTED_MAGLEV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NAME" => Some(Self::UndefinedName),
                "INVALID_LB_POLICY" => Some(Self::InvalidLbPolicy),
                "LEAST_REQUEST" => Some(Self::LeastRequest),
                "MAGLEV" => Some(Self::Maglev),
                "ORIGINAL_DESTINATION" => Some(Self::OriginalDestination),
                "RANDOM" => Some(Self::Random),
                "RING_HASH" => Some(Self::RingHash),
                "ROUND_ROBIN" => Some(Self::RoundRobin),
                "WEIGHTED_MAGLEV" => Some(Self::WeightedMaglev),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceLogConfig {
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "528589944")]
    pub optional_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "128697122")]
    pub optional_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "153193045")]
    pub sample_rate: ::core::option::Option<f32>,
}
/// Nested message and enum types in `BackendServiceLogConfig`.
pub mod backend_service_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionalMode {
        UndefinedOptionalMode = 0,
        Custom = 388595569,
        ExcludeAllOptional = 168636099,
        IncludeAllOptional = 535606965,
    }
    impl OptionalMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptionalMode::UndefinedOptionalMode => "UNDEFINED_OPTIONAL_MODE",
                OptionalMode::Custom => "CUSTOM",
                OptionalMode::ExcludeAllOptional => "EXCLUDE_ALL_OPTIONAL",
                OptionalMode::IncludeAllOptional => "INCLUDE_ALL_OPTIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OPTIONAL_MODE" => Some(Self::UndefinedOptionalMode),
                "CUSTOM" => Some(Self::Custom),
                "EXCLUDE_ALL_OPTIONAL" => Some(Self::ExcludeAllOptional),
                "INCLUDE_ALL_OPTIONAL" => Some(Self::IncludeAllOptional),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceReference {
    #[prost(string, optional, tag = "306946058")]
    pub backend_service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServiceUsedBy {
    #[prost(string, optional, tag = "148586315")]
    pub reference: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BackendServicesScopedList {
    #[prost(message, repeated, tag = "388522409")]
    pub backend_services: ::prost::alloc::vec::Vec<BackendService>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BfdPacket {
    #[prost(bool, optional, tag = "105974260")]
    pub authentication_present: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "62363573")]
    pub control_plane_independent: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "275180107")]
    pub demand: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "62708647")]
    pub diagnostic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "97436022")]
    pub r#final: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "504249062")]
    pub length: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "97286868")]
    pub min_echo_rx_interval_ms: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "463399028")]
    pub min_rx_interval_ms: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "526023602")]
    pub min_tx_interval_ms: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "191331777")]
    pub multiplier: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "191421431")]
    pub multipoint: ::core::option::Option<bool>,
    #[prost(uint32, optional, tag = "76663113")]
    pub my_discriminator: ::core::option::Option<u32>,
    #[prost(bool, optional, tag = "3446719")]
    pub poll: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "351608024")]
    pub version: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "515634064")]
    pub your_discriminator: ::core::option::Option<u32>,
}
/// Nested message and enum types in `BfdPacket`.
pub mod bfd_packet {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Diagnostic {
        UndefinedDiagnostic = 0,
        AdministrativelyDown = 121685798,
        ConcatenatedPathDown = 26186892,
        ControlDetectionTimeExpired = 135478383,
        Unspecified = 58720895,
        EchoFunctionFailed = 220687466,
        ForwardingPlaneReset = 19715882,
        NeighborSignaledSessionDown = 374226742,
        NoDiagnostic = 222503141,
        PathDown = 290605180,
        ReverseConcatenatedPathDown = 479337129,
    }
    impl Diagnostic {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Diagnostic::UndefinedDiagnostic => "UNDEFINED_DIAGNOSTIC",
                Diagnostic::AdministrativelyDown => "ADMINISTRATIVELY_DOWN",
                Diagnostic::ConcatenatedPathDown => "CONCATENATED_PATH_DOWN",
                Diagnostic::ControlDetectionTimeExpired => {
                    "CONTROL_DETECTION_TIME_EXPIRED"
                }
                Diagnostic::Unspecified => "DIAGNOSTIC_UNSPECIFIED",
                Diagnostic::EchoFunctionFailed => "ECHO_FUNCTION_FAILED",
                Diagnostic::ForwardingPlaneReset => "FORWARDING_PLANE_RESET",
                Diagnostic::NeighborSignaledSessionDown => {
                    "NEIGHBOR_SIGNALED_SESSION_DOWN"
                }
                Diagnostic::NoDiagnostic => "NO_DIAGNOSTIC",
                Diagnostic::PathDown => "PATH_DOWN",
                Diagnostic::ReverseConcatenatedPathDown => {
                    "REVERSE_CONCATENATED_PATH_DOWN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DIAGNOSTIC" => Some(Self::UndefinedDiagnostic),
                "ADMINISTRATIVELY_DOWN" => Some(Self::AdministrativelyDown),
                "CONCATENATED_PATH_DOWN" => Some(Self::ConcatenatedPathDown),
                "CONTROL_DETECTION_TIME_EXPIRED" => {
                    Some(Self::ControlDetectionTimeExpired)
                }
                "DIAGNOSTIC_UNSPECIFIED" => Some(Self::Unspecified),
                "ECHO_FUNCTION_FAILED" => Some(Self::EchoFunctionFailed),
                "FORWARDING_PLANE_RESET" => Some(Self::ForwardingPlaneReset),
                "NEIGHBOR_SIGNALED_SESSION_DOWN" => {
                    Some(Self::NeighborSignaledSessionDown)
                }
                "NO_DIAGNOSTIC" => Some(Self::NoDiagnostic),
                "PATH_DOWN" => Some(Self::PathDown),
                "REVERSE_CONCATENATED_PATH_DOWN" => {
                    Some(Self::ReverseConcatenatedPathDown)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        AdminDown = 128544690,
        Down = 2104482,
        Init = 2252048,
        Unspecified = 470755401,
        Up = 2715,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::AdminDown => "ADMIN_DOWN",
                State::Down => "DOWN",
                State::Init => "INIT",
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ADMIN_DOWN" => Some(Self::AdminDown),
                "DOWN" => Some(Self::Down),
                "INIT" => Some(Self::Init),
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BfdStatus {
    #[prost(string, optional, tag = "218156954")]
    pub bfd_session_initialization_mode: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(int64, optional, tag = "457195569")]
    pub config_update_timestamp_micros: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "132573561")]
    pub control_packet_counts: ::core::option::Option<BfdStatusPacketCounts>,
    #[prost(message, repeated, tag = "500806649")]
    pub control_packet_intervals: ::prost::alloc::vec::Vec<PacketIntervals>,
    #[prost(string, optional, tag = "463737083")]
    pub local_diagnostic: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "149195453")]
    pub local_state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "21768340")]
    pub negotiated_local_control_tx_interval_ms: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "505069729")]
    pub rx_packet: ::core::option::Option<BfdPacket>,
    #[prost(message, optional, tag = "111386275")]
    pub tx_packet: ::core::option::Option<BfdPacket>,
    #[prost(int64, optional, tag = "125398365")]
    pub uptime_ms: ::core::option::Option<i64>,
}
/// Nested message and enum types in `BfdStatus`.
pub mod bfd_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BfdSessionInitializationMode {
        UndefinedBfdSessionInitializationMode = 0,
        Active = 314733318,
        Disabled = 516696700,
        Passive = 462813959,
    }
    impl BfdSessionInitializationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BfdSessionInitializationMode::UndefinedBfdSessionInitializationMode => {
                    "UNDEFINED_BFD_SESSION_INITIALIZATION_MODE"
                }
                BfdSessionInitializationMode::Active => "ACTIVE",
                BfdSessionInitializationMode::Disabled => "DISABLED",
                BfdSessionInitializationMode::Passive => "PASSIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BFD_SESSION_INITIALIZATION_MODE" => {
                    Some(Self::UndefinedBfdSessionInitializationMode)
                }
                "ACTIVE" => Some(Self::Active),
                "DISABLED" => Some(Self::Disabled),
                "PASSIVE" => Some(Self::Passive),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalDiagnostic {
        UndefinedLocalDiagnostic = 0,
        AdministrativelyDown = 121685798,
        ConcatenatedPathDown = 26186892,
        ControlDetectionTimeExpired = 135478383,
        DiagnosticUnspecified = 58720895,
        EchoFunctionFailed = 220687466,
        ForwardingPlaneReset = 19715882,
        NeighborSignaledSessionDown = 374226742,
        NoDiagnostic = 222503141,
        PathDown = 290605180,
        ReverseConcatenatedPathDown = 479337129,
    }
    impl LocalDiagnostic {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalDiagnostic::UndefinedLocalDiagnostic => "UNDEFINED_LOCAL_DIAGNOSTIC",
                LocalDiagnostic::AdministrativelyDown => "ADMINISTRATIVELY_DOWN",
                LocalDiagnostic::ConcatenatedPathDown => "CONCATENATED_PATH_DOWN",
                LocalDiagnostic::ControlDetectionTimeExpired => {
                    "CONTROL_DETECTION_TIME_EXPIRED"
                }
                LocalDiagnostic::DiagnosticUnspecified => "DIAGNOSTIC_UNSPECIFIED",
                LocalDiagnostic::EchoFunctionFailed => "ECHO_FUNCTION_FAILED",
                LocalDiagnostic::ForwardingPlaneReset => "FORWARDING_PLANE_RESET",
                LocalDiagnostic::NeighborSignaledSessionDown => {
                    "NEIGHBOR_SIGNALED_SESSION_DOWN"
                }
                LocalDiagnostic::NoDiagnostic => "NO_DIAGNOSTIC",
                LocalDiagnostic::PathDown => "PATH_DOWN",
                LocalDiagnostic::ReverseConcatenatedPathDown => {
                    "REVERSE_CONCATENATED_PATH_DOWN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOCAL_DIAGNOSTIC" => Some(Self::UndefinedLocalDiagnostic),
                "ADMINISTRATIVELY_DOWN" => Some(Self::AdministrativelyDown),
                "CONCATENATED_PATH_DOWN" => Some(Self::ConcatenatedPathDown),
                "CONTROL_DETECTION_TIME_EXPIRED" => {
                    Some(Self::ControlDetectionTimeExpired)
                }
                "DIAGNOSTIC_UNSPECIFIED" => Some(Self::DiagnosticUnspecified),
                "ECHO_FUNCTION_FAILED" => Some(Self::EchoFunctionFailed),
                "FORWARDING_PLANE_RESET" => Some(Self::ForwardingPlaneReset),
                "NEIGHBOR_SIGNALED_SESSION_DOWN" => {
                    Some(Self::NeighborSignaledSessionDown)
                }
                "NO_DIAGNOSTIC" => Some(Self::NoDiagnostic),
                "PATH_DOWN" => Some(Self::PathDown),
                "REVERSE_CONCATENATED_PATH_DOWN" => {
                    Some(Self::ReverseConcatenatedPathDown)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalState {
        UndefinedLocalState = 0,
        AdminDown = 128544690,
        Down = 2104482,
        Init = 2252048,
        StateUnspecified = 470755401,
        Up = 2715,
    }
    impl LocalState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalState::UndefinedLocalState => "UNDEFINED_LOCAL_STATE",
                LocalState::AdminDown => "ADMIN_DOWN",
                LocalState::Down => "DOWN",
                LocalState::Init => "INIT",
                LocalState::StateUnspecified => "STATE_UNSPECIFIED",
                LocalState::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOCAL_STATE" => Some(Self::UndefinedLocalState),
                "ADMIN_DOWN" => Some(Self::AdminDown),
                "DOWN" => Some(Self::Down),
                "INIT" => Some(Self::Init),
                "STATE_UNSPECIFIED" => Some(Self::StateUnspecified),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BfdStatusPacketCounts {
    #[prost(uint32, optional, tag = "39375263")]
    pub num_rx: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "281007902")]
    pub num_rx_rejected: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "455361850")]
    pub num_rx_successful: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "39375325")]
    pub num_tx: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Binding {
    #[prost(string, optional, tag = "441088277")]
    pub binding_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "212430107")]
    pub condition: ::core::option::Option<Expr>,
    #[prost(string, repeated, tag = "412010777")]
    pub members: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3506294")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertDiskRequest {
    #[prost(message, optional, tag = "289799382")]
    pub bulk_insert_disk_resource_resource: ::core::option::Option<
        BulkInsertDiskResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertDiskResource {
    #[prost(string, optional, tag = "19616093")]
    pub source_consistency_group_policy: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertInstanceRequest {
    #[prost(message, optional, tag = "41427278")]
    pub bulk_insert_instance_resource_resource: ::core::option::Option<
        BulkInsertInstanceResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertInstanceResource {
    #[prost(int64, optional, tag = "94851343")]
    pub count: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "215355165")]
    pub instance_properties: ::core::option::Option<InstanceProperties>,
    #[prost(message, optional, tag = "465689852")]
    pub location_policy: ::core::option::Option<LocationPolicy>,
    #[prost(int64, optional, tag = "523228386")]
    pub min_count: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "413815260")]
    pub name_pattern: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "108502267")]
    pub per_instance_properties: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        BulkInsertInstanceResourcePerInstanceProperties,
    >,
    #[prost(string, optional, tag = "332423616")]
    pub source_instance_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertInstanceResourcePerInstanceProperties {
    #[prost(string, optional, tag = "237067315")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertOperationStatus {
    #[prost(int32, optional, tag = "396924158")]
    pub created_vm_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "271756013")]
    pub deleted_vm_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "58384104")]
    pub failed_to_create_vm_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "532975733")]
    pub target_vm_count: ::core::option::Option<i32>,
}
/// Nested message and enum types in `BulkInsertOperationStatus`.
pub mod bulk_insert_operation_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Done = 2104194,
        RollingBack = 259411649,
        Unspecified = 42133066,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Done => "DONE",
                Status::RollingBack => "ROLLING_BACK",
                Status::Unspecified => "STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DONE" => Some(Self::Done),
                "ROLLING_BACK" => Some(Self::RollingBack),
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertRegionDiskRequest {
    #[prost(message, optional, tag = "289799382")]
    pub bulk_insert_disk_resource_resource: ::core::option::Option<
        BulkInsertDiskResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BulkInsertRegionInstanceRequest {
    #[prost(message, optional, tag = "41427278")]
    pub bulk_insert_instance_resource_resource: ::core::option::Option<
        BulkInsertInstanceResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheInvalidationRule {
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3433509")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CacheKeyPolicy {
    #[prost(bool, optional, tag = "486867679")]
    pub include_host: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "2489606")]
    pub include_http_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "87316530")]
    pub include_named_cookies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "303507535")]
    pub include_protocol: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "474036639")]
    pub include_query_string: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "354964742")]
    pub query_string_blacklist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "52456496")]
    pub query_string_whitelist: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelInstanceGroupManagerResizeRequestRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "216941060")]
    pub resize_request: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CircuitBreakers {
    #[prost(int32, optional, tag = "110652154")]
    pub max_connections: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "375558887")]
    pub max_pending_requests: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "28097599")]
    pub max_requests: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "361630528")]
    pub max_requests_per_connection: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "55546219")]
    pub max_retries: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneRulesFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25013549")]
    pub source_firewall_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneRulesNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25013549")]
    pub source_firewall_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloneRulesRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "25013549")]
    pub source_firewall_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Commitment {
    #[prost(bool, optional, tag = "495520765")]
    pub auto_renew: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "50511102")]
    pub category: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "468096690")]
    pub end_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "493028443")]
    pub existing_reservations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "437955148")]
    pub license_resource: ::core::option::Option<LicenseResourceCommitment>,
    #[prost(string, repeated, tag = "188093761")]
    pub merge_source_commitments: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3443497")]
    pub plan: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "399717927")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
    #[prost(message, repeated, tag = "164412965")]
    pub resources: ::prost::alloc::vec::Vec<ResourceCommitment>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "402611156")]
    pub split_source_commitment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "83645817")]
    pub start_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "297428154")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Commitment`.
pub mod commitment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Category {
        UndefinedCategory = 0,
        Unspecified = 509189462,
        License = 347869217,
        Machine = 469553191,
    }
    impl Category {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Category::UndefinedCategory => "UNDEFINED_CATEGORY",
                Category::Unspecified => "CATEGORY_UNSPECIFIED",
                Category::License => "LICENSE",
                Category::Machine => "MACHINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CATEGORY" => Some(Self::UndefinedCategory),
                "CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
                "LICENSE" => Some(Self::License),
                "MACHINE" => Some(Self::Machine),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Plan {
        UndefinedPlan = 0,
        Invalid = 530283991,
        ThirtySixMonth = 266295942,
        TwelveMonth = 173083962,
    }
    impl Plan {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Plan::UndefinedPlan => "UNDEFINED_PLAN",
                Plan::Invalid => "INVALID",
                Plan::ThirtySixMonth => "THIRTY_SIX_MONTH",
                Plan::TwelveMonth => "TWELVE_MONTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PLAN" => Some(Self::UndefinedPlan),
                "INVALID" => Some(Self::Invalid),
                "THIRTY_SIX_MONTH" => Some(Self::ThirtySixMonth),
                "TWELVE_MONTH" => Some(Self::TwelveMonth),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Active = 314733318,
        Cancelled = 41957681,
        Creating = 455564985,
        Expired = 482489093,
        NotYetActive = 20607337,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Active => "ACTIVE",
                Status::Cancelled => "CANCELLED",
                Status::Creating => "CREATING",
                Status::Expired => "EXPIRED",
                Status::NotYetActive => "NOT_YET_ACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACTIVE" => Some(Self::Active),
                "CANCELLED" => Some(Self::Cancelled),
                "CREATING" => Some(Self::Creating),
                "EXPIRED" => Some(Self::Expired),
                "NOT_YET_ACTIVE" => Some(Self::NotYetActive),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        AcceleratorOptimized = 280848403,
        AcceleratorOptimizedA3 = 158574526,
        AcceleratorOptimizedA3Mega = 156517459,
        ComputeOptimized = 158349023,
        ComputeOptimizedC2d = 383246453,
        ComputeOptimizedC3 = 428004784,
        ComputeOptimizedC3d = 383246484,
        ComputeOptimizedH3 = 428004939,
        GeneralPurpose = 299793543,
        GeneralPurposeE2 = 301911877,
        GeneralPurposeN2 = 301912156,
        GeneralPurposeN2d = 232471400,
        GeneralPurposeN4 = 301912158,
        GeneralPurposeT2d = 232477166,
        GraphicsOptimized = 68500563,
        MemoryOptimized = 281753417,
        MemoryOptimizedM3 = 276301372,
        StorageOptimizedZ3 = 316796085,
        Unspecified = 437714322,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::AcceleratorOptimized => "ACCELERATOR_OPTIMIZED",
                Type::AcceleratorOptimizedA3 => "ACCELERATOR_OPTIMIZED_A3",
                Type::AcceleratorOptimizedA3Mega => "ACCELERATOR_OPTIMIZED_A3_MEGA",
                Type::ComputeOptimized => "COMPUTE_OPTIMIZED",
                Type::ComputeOptimizedC2d => "COMPUTE_OPTIMIZED_C2D",
                Type::ComputeOptimizedC3 => "COMPUTE_OPTIMIZED_C3",
                Type::ComputeOptimizedC3d => "COMPUTE_OPTIMIZED_C3D",
                Type::ComputeOptimizedH3 => "COMPUTE_OPTIMIZED_H3",
                Type::GeneralPurpose => "GENERAL_PURPOSE",
                Type::GeneralPurposeE2 => "GENERAL_PURPOSE_E2",
                Type::GeneralPurposeN2 => "GENERAL_PURPOSE_N2",
                Type::GeneralPurposeN2d => "GENERAL_PURPOSE_N2D",
                Type::GeneralPurposeN4 => "GENERAL_PURPOSE_N4",
                Type::GeneralPurposeT2d => "GENERAL_PURPOSE_T2D",
                Type::GraphicsOptimized => "GRAPHICS_OPTIMIZED",
                Type::MemoryOptimized => "MEMORY_OPTIMIZED",
                Type::MemoryOptimizedM3 => "MEMORY_OPTIMIZED_M3",
                Type::StorageOptimizedZ3 => "STORAGE_OPTIMIZED_Z3",
                Type::Unspecified => "TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "ACCELERATOR_OPTIMIZED" => Some(Self::AcceleratorOptimized),
                "ACCELERATOR_OPTIMIZED_A3" => Some(Self::AcceleratorOptimizedA3),
                "ACCELERATOR_OPTIMIZED_A3_MEGA" => Some(Self::AcceleratorOptimizedA3Mega),
                "COMPUTE_OPTIMIZED" => Some(Self::ComputeOptimized),
                "COMPUTE_OPTIMIZED_C2D" => Some(Self::ComputeOptimizedC2d),
                "COMPUTE_OPTIMIZED_C3" => Some(Self::ComputeOptimizedC3),
                "COMPUTE_OPTIMIZED_C3D" => Some(Self::ComputeOptimizedC3d),
                "COMPUTE_OPTIMIZED_H3" => Some(Self::ComputeOptimizedH3),
                "GENERAL_PURPOSE" => Some(Self::GeneralPurpose),
                "GENERAL_PURPOSE_E2" => Some(Self::GeneralPurposeE2),
                "GENERAL_PURPOSE_N2" => Some(Self::GeneralPurposeN2),
                "GENERAL_PURPOSE_N2D" => Some(Self::GeneralPurposeN2d),
                "GENERAL_PURPOSE_N4" => Some(Self::GeneralPurposeN4),
                "GENERAL_PURPOSE_T2D" => Some(Self::GeneralPurposeT2d),
                "GRAPHICS_OPTIMIZED" => Some(Self::GraphicsOptimized),
                "MEMORY_OPTIMIZED" => Some(Self::MemoryOptimized),
                "MEMORY_OPTIMIZED_M3" => Some(Self::MemoryOptimizedM3),
                "STORAGE_OPTIMIZED_Z3" => Some(Self::StorageOptimizedZ3),
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitmentAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        CommitmentsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitmentList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Commitment>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CommitmentsScopedList {
    #[prost(message, repeated, tag = "450664446")]
    pub commitments: ::prost::alloc::vec::Vec<Commitment>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Condition {
    #[prost(string, optional, tag = "104021")]
    pub iam: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3553")]
    pub op: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "114272")]
    pub svc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "114381")]
    pub sys: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "249928994")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Condition`.
pub mod condition {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Iam {
        UndefinedIam = 0,
        Approver = 357258949,
        Attribution = 232465503,
        Authority = 504108835,
        CredentialsType = 348222141,
        CredsAssertion = 332343272,
        JustificationType = 206147719,
        SecurityRealm = 526269616,
    }
    impl Iam {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Iam::UndefinedIam => "UNDEFINED_IAM",
                Iam::Approver => "APPROVER",
                Iam::Attribution => "ATTRIBUTION",
                Iam::Authority => "AUTHORITY",
                Iam::CredentialsType => "CREDENTIALS_TYPE",
                Iam::CredsAssertion => "CREDS_ASSERTION",
                Iam::JustificationType => "JUSTIFICATION_TYPE",
                Iam::SecurityRealm => "SECURITY_REALM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IAM" => Some(Self::UndefinedIam),
                "APPROVER" => Some(Self::Approver),
                "ATTRIBUTION" => Some(Self::Attribution),
                "AUTHORITY" => Some(Self::Authority),
                "CREDENTIALS_TYPE" => Some(Self::CredentialsType),
                "CREDS_ASSERTION" => Some(Self::CredsAssertion),
                "JUSTIFICATION_TYPE" => Some(Self::JustificationType),
                "SECURITY_REALM" => Some(Self::SecurityRealm),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Op {
        UndefinedOp = 0,
        Discharged = 266338274,
        Equals = 442201023,
        In = 2341,
        NotEquals = 19718859,
        NotIn = 161144369,
        NoOp = 74481951,
    }
    impl Op {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Op::UndefinedOp => "UNDEFINED_OP",
                Op::Discharged => "DISCHARGED",
                Op::Equals => "EQUALS",
                Op::In => "IN",
                Op::NotEquals => "NOT_EQUALS",
                Op::NotIn => "NOT_IN",
                Op::NoOp => "NO_OP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OP" => Some(Self::UndefinedOp),
                "DISCHARGED" => Some(Self::Discharged),
                "EQUALS" => Some(Self::Equals),
                "IN" => Some(Self::In),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "NOT_IN" => Some(Self::NotIn),
                "NO_OP" => Some(Self::NoOp),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Sys {
        UndefinedSys = 0,
        Ip = 2343,
        Name = 2388619,
        Region = 266017524,
        Service = 17781397,
    }
    impl Sys {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Sys::UndefinedSys => "UNDEFINED_SYS",
                Sys::Ip => "IP",
                Sys::Name => "NAME",
                Sys::Region => "REGION",
                Sys::Service => "SERVICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SYS" => Some(Self::UndefinedSys),
                "IP" => Some(Self::Ip),
                "NAME" => Some(Self::Name),
                "REGION" => Some(Self::Region),
                "SERVICE" => Some(Self::Service),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConfidentialInstanceConfig {
    #[prost(bool, optional, tag = "102135228")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConnectionDraining {
    #[prost(int32, optional, tag = "225127070")]
    pub draining_timeout_sec: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsistentHashLoadBalancerSettings {
    #[prost(message, optional, tag = "6673915")]
    pub http_cookie: ::core::option::Option<
        ConsistentHashLoadBalancerSettingsHttpCookie,
    >,
    #[prost(string, optional, tag = "234798022")]
    pub http_header_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "234380735")]
    pub minimum_ring_size: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsistentHashLoadBalancerSettingsHttpCookie {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3433509")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "115180")]
    pub ttl: ::core::option::Option<Duration>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorsPolicy {
    #[prost(bool, optional, tag = "481263366")]
    pub allow_credentials: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "45179024")]
    pub allow_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "205405372")]
    pub allow_methods: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "215385810")]
    pub allow_origin_regexes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "194914071")]
    pub allow_origins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "270940796")]
    pub disabled: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "247604747")]
    pub expose_headers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "307559332")]
    pub max_age: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstancesInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "24558867")]
    pub instance_group_managers_create_instances_request_resource: ::core::option::Option<
        InstanceGroupManagersCreateInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateInstancesRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "359014280")]
    pub region_instance_group_managers_create_instances_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersCreateInstancesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnapshotDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "385550813")]
    pub guest_flush: ::core::option::Option<bool>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "481319977")]
    pub snapshot_resource: ::core::option::Option<Snapshot>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSnapshotRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "481319977")]
    pub snapshot_resource: ::core::option::Option<Snapshot>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerEncryptionKey {
    #[prost(string, optional, tag = "484373913")]
    pub kms_key_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "209986261")]
    pub kms_key_service_account: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "449196488")]
    pub raw_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "335487397")]
    pub rsa_encrypted_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "170112551")]
    pub sha256: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomerEncryptionKeyProtectedDisk {
    #[prost(message, optional, tag = "271660677")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Data {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessConfigInstanceRequest {
    #[prost(string, tag = "72856189")]
    pub access_config: ::prost::alloc::string::String,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "365387880")]
    pub network_interface: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAutoscalerRequest {
    #[prost(string, tag = "517258967")]
    pub autoscaler: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExternalVpnGatewayRequest {
    #[prost(string, tag = "109898629")]
    pub external_vpn_gateway: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirewallRequest {
    #[prost(string, tag = "511016192")]
    pub firewall: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteGlobalOperationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalOrganizationOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "459714768")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteGlobalOrganizationOperationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGlobalPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteImageRequest {
    #[prost(string, tag = "100313435")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceGroupManagerResizeRequestRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "216941060")]
    pub resize_request: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstanceTemplateRequest {
    #[prost(string, tag = "309248228")]
    pub instance_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstancesInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "166421252")]
    pub instance_group_managers_delete_instances_request_resource: ::core::option::Option<
        InstanceGroupManagersDeleteInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstancesRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "500876665")]
    pub region_instance_group_managers_delete_instances_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersDeleteInstancesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInstantSnapshotRequest {
    #[prost(string, tag = "391638626")]
    pub instant_snapshot: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInterconnectAttachmentRequest {
    #[prost(string, tag = "308135284")]
    pub interconnect_attachment: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteInterconnectRequest {
    #[prost(string, tag = "224601230")]
    pub interconnect: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteLicenseRequest {
    #[prost(string, tag = "166757441")]
    pub license: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMachineImageRequest {
    #[prost(string, tag = "69189475")]
    pub machine_image: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkAttachmentRequest {
    #[prost(string, tag = "224644052")]
    pub network_attachment: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkEdgeSecurityServiceRequest {
    #[prost(string, tag = "157011879")]
    pub network_edge_security_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodeTemplateRequest {
    #[prost(string, tag = "323154455")]
    pub node_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteNodesNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "183298962")]
    pub node_groups_delete_nodes_request_resource: ::core::option::Option<
        NodeGroupsDeleteNodesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePacketMirroringRequest {
    #[prost(string, tag = "22305996")]
    pub packet_mirroring: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePerInstanceConfigsInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "362427680")]
    pub instance_group_managers_delete_per_instance_configs_req_resource: ::core::option::Option<
        InstanceGroupManagersDeletePerInstanceConfigsReq,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePerInstanceConfigsRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "740741")]
    pub region_instance_group_manager_delete_instance_config_req_resource: ::core::option::Option<
        RegionInstanceGroupManagerDeleteInstanceConfigReq,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "101874590")]
    pub public_advertised_prefix: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionAutoscalerRequest {
    #[prost(string, tag = "517258967")]
    pub autoscaler: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionHealthCheckServiceRequest {
    #[prost(string, tag = "408374747")]
    pub health_check_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionInstanceTemplateRequest {
    #[prost(string, tag = "309248228")]
    pub instance_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionInstantSnapshotRequest {
    #[prost(string, tag = "391638626")]
    pub instant_snapshot: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionNotificationEndpointRequest {
    #[prost(string, tag = "376807017")]
    pub notification_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteRegionOperationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "46443492")]
    pub ssl_certificate: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "47530956")]
    pub reservation: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "159240835")]
    pub resource_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRouteRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "108704329")]
    pub route: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "338957549")]
    pub service_attachment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSignedUrlKeyBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "500938859")]
    pub key_name: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSignedUrlKeyBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "500938859")]
    pub key_name: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "284874180")]
    pub snapshot: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "46443492")]
    pub ssl_certificate: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "360473440")]
    pub storage_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "307827694")]
    pub subnetwork: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetGrpcProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "5020283")]
    pub target_grpc_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "289769347")]
    pub target_instance: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTargetVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "532512843")]
    pub target_vpn_gateway: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "406684153")]
    pub vpn_gateway: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVpnTunnelRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "143821331")]
    pub vpn_tunnel: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteZoneOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteZoneOperationResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Denied {
    #[prost(string, optional, tag = "488094525")]
    pub i_p_protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "106854418")]
    pub ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecateImageRequest {
    #[prost(message, optional, tag = "333006064")]
    pub deprecation_status_resource: ::core::option::Option<DeprecationStatus>,
    #[prost(string, tag = "100313435")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeprecationStatus {
    #[prost(string, optional, tag = "476721177")]
    pub deleted: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "357647769")]
    pub obsolete: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "430919186")]
    pub replacement: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DeprecationStatus`.
pub mod deprecation_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Deleted = 120962041,
        Deprecated = 463360435,
        Obsolete = 66532761,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Deleted => "DELETED",
                State::Deprecated => "DEPRECATED",
                State::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "DELETED" => Some(Self::Deleted),
                "DEPRECATED" => Some(Self::Deprecated),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachDiskInstanceRequest {
    #[prost(string, tag = "67541716")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest {
    #[prost(message, optional, tag = "8898269")]
    pub global_network_endpoint_groups_detach_endpoints_request_resource: ::core::option::Option<
        GlobalNetworkEndpointGroupsDetachEndpointsRequest,
    >,
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachNetworkEndpointsNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "515608697")]
    pub network_endpoint_groups_detach_endpoints_request_resource: ::core::option::Option<
        NetworkEndpointGroupsDetachEndpointsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DetachNetworkEndpointsRegionNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "313193198")]
    pub region_network_endpoint_groups_detach_endpoints_request_resource: ::core::option::Option<
        RegionNetworkEndpointGroupsDetachEndpointsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableXpnHostProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisableXpnResourceProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "209136170")]
    pub projects_disable_xpn_resource_request_resource: ::core::option::Option<
        ProjectsDisableXpnResourceRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Disk {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "180517533")]
    pub async_primary_disk: ::core::option::Option<DiskAsyncReplication>,
    #[prost(map = "string, message", tag = "322925608")]
    pub async_secondary_disks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DiskAsyncReplicationList,
    >,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "271660677")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(bool, optional, tag = "102135228")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "79294545")]
    pub guest_os_features: ::prost::alloc::vec::Vec<GuestOsFeature>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "42159653")]
    pub last_attach_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "56471027")]
    pub last_detach_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, repeated, tag = "45482664")]
    pub license_codes: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "350519505")]
    pub location_hint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "361137822")]
    pub options: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "78313862")]
    pub params: ::core::option::Option<DiskParams>,
    #[prost(int64, optional, tag = "420007943")]
    pub physical_block_size_bytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "186769108")]
    pub provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "526524181")]
    pub provisioned_throughput: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "48438272")]
    pub replica_zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<DiskResourceStatus>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "494929369")]
    pub size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "19616093")]
    pub source_consistency_group_policy: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "267568957")]
    pub source_consistency_group_policy_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "454190809")]
    pub source_disk_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50443319")]
    pub source_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "381503659")]
    pub source_image_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "55328291")]
    pub source_image_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "219202054")]
    pub source_instant_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "287582708")]
    pub source_instant_snapshot_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "126061928")]
    pub source_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "303679322")]
    pub source_snapshot_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "98962258")]
    pub source_snapshot_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "233052711")]
    pub source_storage_object: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "360473440")]
    pub storage_pool: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "111578632")]
    pub users: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Disk`.
pub mod disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
        Restoring = 404263851,
        Unavailable = 413756464,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Ready => "READY",
                Status::Restoring => "RESTORING",
                Status::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                "RESTORING" => Some(Self::Restoring),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DisksScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskAsyncReplication {
    #[prost(string, optional, tag = "1991097")]
    pub consistency_group_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "261065057")]
    pub consistency_group_policy_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3083677")]
    pub disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "60990205")]
    pub disk_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskAsyncReplicationList {
    #[prost(message, optional, tag = "231794067")]
    pub async_replication_disk: ::core::option::Option<DiskAsyncReplication>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskInstantiationConfig {
    #[prost(bool, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "184123149")]
    pub custom_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "67541716")]
    pub device_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "393383903")]
    pub instantiate_from: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DiskInstantiationConfig`.
pub mod disk_instantiation_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstantiateFrom {
        UndefinedInstantiateFrom = 0,
        AttachReadOnly = 513775419,
        Blank = 63281460,
        CustomImage = 196311789,
        Default = 115302945,
        DoNotInclude = 104218952,
        SourceImage = 62631959,
        SourceImageFamily = 76850316,
    }
    impl InstantiateFrom {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstantiateFrom::UndefinedInstantiateFrom => "UNDEFINED_INSTANTIATE_FROM",
                InstantiateFrom::AttachReadOnly => "ATTACH_READ_ONLY",
                InstantiateFrom::Blank => "BLANK",
                InstantiateFrom::CustomImage => "CUSTOM_IMAGE",
                InstantiateFrom::Default => "DEFAULT",
                InstantiateFrom::DoNotInclude => "DO_NOT_INCLUDE",
                InstantiateFrom::SourceImage => "SOURCE_IMAGE",
                InstantiateFrom::SourceImageFamily => "SOURCE_IMAGE_FAMILY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANTIATE_FROM" => Some(Self::UndefinedInstantiateFrom),
                "ATTACH_READ_ONLY" => Some(Self::AttachReadOnly),
                "BLANK" => Some(Self::Blank),
                "CUSTOM_IMAGE" => Some(Self::CustomImage),
                "DEFAULT" => Some(Self::Default),
                "DO_NOT_INCLUDE" => Some(Self::DoNotInclude),
                "SOURCE_IMAGE" => Some(Self::SourceImage),
                "SOURCE_IMAGE_FAMILY" => Some(Self::SourceImageFamily),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Disk>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskMoveRequest {
    #[prost(string, optional, tag = "131854653")]
    pub destination_zone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "62433163")]
    pub target_disk: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskParams {
    #[prost(map = "string, string", tag = "377671164")]
    pub resource_manager_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskResourceStatus {
    #[prost(message, optional, tag = "180517533")]
    pub async_primary_disk: ::core::option::Option<
        DiskResourceStatusAsyncReplicationStatus,
    >,
    #[prost(map = "string, message", tag = "322925608")]
    pub async_secondary_disks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DiskResourceStatusAsyncReplicationStatus,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskResourceStatusAsyncReplicationStatus {
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DiskResourceStatusAsyncReplicationStatus`.
pub mod disk_resource_status_async_replication_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Created = 135924424,
        Starting = 488820800,
        Unspecified = 470755401,
        Stopped = 444276141,
        Stopping = 350791796,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Created => "CREATED",
                State::Starting => "STARTING",
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Stopped => "STOPPED",
                State::Stopping => "STOPPING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "CREATED" => Some(Self::Created),
                "STARTING" => Some(Self::Starting),
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "STOPPED" => Some(Self::Stopped),
                "STOPPING" => Some(Self::Stopping),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskType {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "270619253")]
    pub default_disk_size_gb: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "493962464")]
    pub valid_disk_size: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskTypeAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        DiskTypesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<DiskType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskTypesScopedList {
    #[prost(message, repeated, tag = "198926167")]
    pub disk_types: ::prost::alloc::vec::Vec<DiskType>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksAddResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksRemoveResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisksResizeRequest {
    #[prost(int64, optional, tag = "494929369")]
    pub size_gb: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksScopedList {
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<Disk>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksStartAsyncReplicationRequest {
    #[prost(string, optional, tag = "131645867")]
    pub async_secondary_disk: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisksStopGroupAsyncReplicationResource {
    #[prost(string, optional, tag = "159240835")]
    pub resource_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayDevice {
    #[prost(bool, optional, tag = "14266886")]
    pub enable_display: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributionPolicy {
    #[prost(string, optional, tag = "338621299")]
    pub target_shape: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "116085319")]
    pub zones: ::prost::alloc::vec::Vec<DistributionPolicyZoneConfiguration>,
}
/// Nested message and enum types in `DistributionPolicy`.
pub mod distribution_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetShape {
        UndefinedTargetShape = 0,
        Any = 64972,
        AnySingleZone = 61100880,
        Balanced = 468409608,
        Even = 2140442,
    }
    impl TargetShape {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetShape::UndefinedTargetShape => "UNDEFINED_TARGET_SHAPE",
                TargetShape::Any => "ANY",
                TargetShape::AnySingleZone => "ANY_SINGLE_ZONE",
                TargetShape::Balanced => "BALANCED",
                TargetShape::Even => "EVEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TARGET_SHAPE" => Some(Self::UndefinedTargetShape),
                "ANY" => Some(Self::Any),
                "ANY_SINGLE_ZONE" => Some(Self::AnySingleZone),
                "BALANCED" => Some(Self::Balanced),
                "EVEN" => Some(Self::Even),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DistributionPolicyZoneConfiguration {
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Duration {
    #[prost(int32, optional, tag = "104586303")]
    pub nanos: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "359484031")]
    pub seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableXpnHostProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnableXpnResourceProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "421980207")]
    pub projects_enable_xpn_resource_request_resource: ::core::option::Option<
        ProjectsEnableXpnResourceRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Error {
    #[prost(message, repeated, tag = "315977579")]
    pub errors: ::prost::alloc::vec::Vec<Errors>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    #[prost(message, optional, tag = "25251973")]
    pub error_info: ::core::option::Option<ErrorInfo>,
    #[prost(message, optional, tag = "3198785")]
    pub help: ::core::option::Option<Help>,
    #[prost(message, optional, tag = "404537155")]
    pub localized_message: ::core::option::Option<LocalizedMessage>,
    #[prost(message, optional, tag = "93923861")]
    pub quota_info: ::core::option::Option<QuotaExceededInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorInfo {
    #[prost(string, optional, tag = "284415172")]
    pub domain: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "8514340")]
    pub metadatas: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "138777156")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Errors {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "274653963")]
    pub error_details: ::prost::alloc::vec::Vec<ErrorDetails>,
    #[prost(string, optional, tag = "290430901")]
    pub location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangedPeeringRoute {
    #[prost(string, optional, tag = "381327712")]
    pub dest_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "114502404")]
    pub imported: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "122577014")]
    pub next_hop_region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ExchangedPeeringRoute`.
pub mod exchanged_peering_route {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        DynamicPeeringRoute = 469794858,
        StaticPeeringRoute = 473407545,
        SubnetPeeringRoute = 465782504,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::DynamicPeeringRoute => "DYNAMIC_PEERING_ROUTE",
                Type::StaticPeeringRoute => "STATIC_PEERING_ROUTE",
                Type::SubnetPeeringRoute => "SUBNET_PEERING_ROUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "DYNAMIC_PEERING_ROUTE" => Some(Self::DynamicPeeringRoute),
                "STATIC_PEERING_ROUTE" => Some(Self::StaticPeeringRoute),
                "SUBNET_PEERING_ROUTE" => Some(Self::SubnetPeeringRoute),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExchangedPeeringRoutesList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<ExchangedPeeringRoute>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandIpCidrRangeSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "307827694")]
    pub subnetwork: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "477014110")]
    pub subnetworks_expand_ip_cidr_range_request_resource: ::core::option::Option<
        SubnetworksExpandIpCidrRangeRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Expr {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "352031384")]
    pub expression: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "290430901")]
    pub location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "110371416")]
    pub title: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalVpnGateway {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "12073562")]
    pub interfaces: ::prost::alloc::vec::Vec<ExternalVpnGatewayInterface>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "271443740")]
    pub redundancy_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ExternalVpnGateway`.
pub mod external_vpn_gateway {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RedundancyType {
        UndefinedRedundancyType = 0,
        FourIpsRedundancy = 520087913,
        SingleIpInternallyRedundant = 133914873,
        TwoIpsRedundancy = 367049635,
    }
    impl RedundancyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RedundancyType::UndefinedRedundancyType => "UNDEFINED_REDUNDANCY_TYPE",
                RedundancyType::FourIpsRedundancy => "FOUR_IPS_REDUNDANCY",
                RedundancyType::SingleIpInternallyRedundant => {
                    "SINGLE_IP_INTERNALLY_REDUNDANT"
                }
                RedundancyType::TwoIpsRedundancy => "TWO_IPS_REDUNDANCY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_REDUNDANCY_TYPE" => Some(Self::UndefinedRedundancyType),
                "FOUR_IPS_REDUNDANCY" => Some(Self::FourIpsRedundancy),
                "SINGLE_IP_INTERNALLY_REDUNDANT" => {
                    Some(Self::SingleIpInternallyRedundant)
                }
                "TWO_IPS_REDUNDANCY" => Some(Self::TwoIpsRedundancy),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalVpnGatewayInterface {
    #[prost(uint32, optional, tag = "3355")]
    pub id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "341563804")]
    pub ipv6_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalVpnGatewayList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<ExternalVpnGateway>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileContentBuffer {
    #[prost(string, optional, tag = "414659705")]
    pub content: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "294346781")]
    pub file_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FileContentBuffer`.
pub mod file_content_buffer {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FileType {
        UndefinedFileType = 0,
        Bin = 65767,
        Undefined = 137851184,
        X509 = 2674086,
    }
    impl FileType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FileType::UndefinedFileType => "UNDEFINED_FILE_TYPE",
                FileType::Bin => "BIN",
                FileType::Undefined => "UNDEFINED",
                FileType::X509 => "X509",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_FILE_TYPE" => Some(Self::UndefinedFileType),
                "BIN" => Some(Self::Bin),
                "UNDEFINED" => Some(Self::Undefined),
                "X509" => Some(Self::X509),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Firewall {
    #[prost(message, repeated, tag = "162398632")]
    pub allowed: ::prost::alloc::vec::Vec<Allowed>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "275217307")]
    pub denied: ::prost::alloc::vec::Vec<Denied>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "305699879")]
    pub destination_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111150975")]
    pub direction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "270940796")]
    pub disabled: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "351299741")]
    pub log_config: ::core::option::Option<FirewallLogConfig>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "200097658")]
    pub source_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "105100756")]
    pub source_service_accounts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "452222397")]
    pub source_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "457639710")]
    pub target_service_accounts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "62901767")]
    pub target_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Firewall`.
pub mod firewall {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        UndefinedDirection = 0,
        Egress = 432880501,
        Ingress = 516931221,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::UndefinedDirection => "UNDEFINED_DIRECTION",
                Direction::Egress => "EGRESS",
                Direction::Ingress => "INGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DIRECTION" => Some(Self::UndefinedDirection),
                "EGRESS" => Some(Self::Egress),
                "INGRESS" => Some(Self::Ingress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Firewall>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallLogConfig {
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FirewallLogConfig`.
pub mod firewall_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Metadata {
        UndefinedMetadata = 0,
        ExcludeAllMetadata = 334519954,
        IncludeAllMetadata = 164619908,
    }
    impl Metadata {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Metadata::UndefinedMetadata => "UNDEFINED_METADATA",
                Metadata::ExcludeAllMetadata => "EXCLUDE_ALL_METADATA",
                Metadata::IncludeAllMetadata => "INCLUDE_ALL_METADATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_METADATA" => Some(Self::UndefinedMetadata),
                "EXCLUDE_ALL_METADATA" => Some(Self::ExcludeAllMetadata),
                "INCLUDE_ALL_METADATA" => Some(Self::IncludeAllMetadata),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPoliciesListAssociationsResponse {
    #[prost(message, repeated, tag = "508736530")]
    pub associations: ::prost::alloc::vec::Vec<FirewallPolicyAssociation>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicy {
    #[prost(message, repeated, tag = "508736530")]
    pub associations: ::prost::alloc::vec::Vec<FirewallPolicyAssociation>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4473832")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "78317738")]
    pub parent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "388342037")]
    pub rule_tuple_count: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<FirewallPolicyRule>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "492051566")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyAssociation {
    #[prost(string, optional, tag = "175773741")]
    pub attachment_target: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4473832")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "357211849")]
    pub firewall_policy_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "492051566")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<FirewallPolicy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyRule {
    #[prost(string, optional, tag = "187661878")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111150975")]
    pub direction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "270940796")]
    pub disabled: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "295396515")]
    pub enable_logging: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "103668165")]
    pub r#match: ::core::option::Option<FirewallPolicyRuleMatcher>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "55286254")]
    pub rule_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "388342037")]
    pub rule_tuple_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "207411626")]
    pub security_profile_group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "528230647")]
    pub target_resources: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "468132403")]
    pub target_secure_tags: ::prost::alloc::vec::Vec<FirewallPolicyRuleSecureTag>,
    #[prost(string, repeated, tag = "457639710")]
    pub target_service_accounts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(bool, optional, tag = "43425488")]
    pub tls_inspect: ::core::option::Option<bool>,
}
/// Nested message and enum types in `FirewallPolicyRule`.
pub mod firewall_policy_rule {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        UndefinedDirection = 0,
        Egress = 432880501,
        Ingress = 516931221,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::UndefinedDirection => "UNDEFINED_DIRECTION",
                Direction::Egress => "EGRESS",
                Direction::Ingress => "INGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DIRECTION" => Some(Self::UndefinedDirection),
                "EGRESS" => Some(Self::Egress),
                "INGRESS" => Some(Self::Ingress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyRuleMatcher {
    #[prost(string, repeated, tag = "468760508")]
    pub dest_address_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "370712737")]
    pub dest_fqdns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "337357713")]
    pub dest_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "199120280")]
    pub dest_region_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "119896492")]
    pub dest_threat_intelligences: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "373534261")]
    pub layer4_configs: ::prost::alloc::vec::Vec<FirewallPolicyRuleMatcherLayer4Config>,
    #[prost(string, repeated, tag = "436423738")]
    pub src_address_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "435906147")]
    pub src_fqdns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "432128083")]
    pub src_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "99086742")]
    pub src_region_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "508791302")]
    pub src_secure_tags: ::prost::alloc::vec::Vec<FirewallPolicyRuleSecureTag>,
    #[prost(string, repeated, tag = "323631018")]
    pub src_threat_intelligences: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyRuleMatcherLayer4Config {
    #[prost(string, optional, tag = "475958960")]
    pub ip_protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "106854418")]
    pub ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallPolicyRuleSecureTag {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `FirewallPolicyRuleSecureTag`.
pub mod firewall_policy_rule_secure_tag {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Effective = 244201863,
        Ineffective = 304458242,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Effective => "EFFECTIVE",
                State::Ineffective => "INEFFECTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "EFFECTIVE" => Some(Self::Effective),
                "INEFFECTIVE" => Some(Self::Ineffective),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FixedOrPercent {
    #[prost(int32, optional, tag = "472082878")]
    pub calculated: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "97445748")]
    pub fixed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "394814533")]
    pub percent: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRule {
    #[prost(string, optional, tag = "42976943")]
    pub i_p_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "488094525")]
    pub i_p_protocol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "445175796")]
    pub all_ports: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "499409674")]
    pub allow_global_access: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "263471819")]
    pub allow_psc_global_access: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "306946058")]
    pub backend_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "524873104")]
    pub base_forwarding_rule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "176818358")]
    pub ip_collection: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "294959552")]
    pub ip_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "119255164")]
    pub is_mirroring_collector: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "363890244")]
    pub load_balancing_scheme: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "464725739")]
    pub metadata_filters: ::prost::alloc::vec::Vec<MetadataFilter>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "517397843")]
    pub network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "64546991")]
    pub no_automate_dns_zone: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "217518079")]
    pub port_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "106854418")]
    pub ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "292082397")]
    pub psc_connection_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "184149172")]
    pub psc_connection_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "223549694")]
    pub service_directory_registrations: ::prost::alloc::vec::Vec<
        ForwardingRuleServiceDirectoryRegistration,
    >,
    #[prost(string, optional, tag = "417008874")]
    pub service_label: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "359880149")]
    pub service_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "111563210")]
    pub source_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "192835985")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ForwardingRule`.
pub mod forwarding_rule {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IpProtocolEnum {
        UndefinedIPProtocolEnum = 0,
        Ah = 2087,
        Esp = 68962,
        Icmp = 2241597,
        L3Default = 48151369,
        Sctp = 2539724,
        Tcp = 82881,
        Udp = 83873,
    }
    impl IpProtocolEnum {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpProtocolEnum::UndefinedIPProtocolEnum => "UNDEFINED_I_P_PROTOCOL_ENUM",
                IpProtocolEnum::Ah => "AH",
                IpProtocolEnum::Esp => "ESP",
                IpProtocolEnum::Icmp => "ICMP",
                IpProtocolEnum::L3Default => "L3_DEFAULT",
                IpProtocolEnum::Sctp => "SCTP",
                IpProtocolEnum::Tcp => "TCP",
                IpProtocolEnum::Udp => "UDP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_I_P_PROTOCOL_ENUM" => Some(Self::UndefinedIPProtocolEnum),
                "AH" => Some(Self::Ah),
                "ESP" => Some(Self::Esp),
                "ICMP" => Some(Self::Icmp),
                "L3_DEFAULT" => Some(Self::L3Default),
                "SCTP" => Some(Self::Sctp),
                "TCP" => Some(Self::Tcp),
                "UDP" => Some(Self::Udp),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IpVersion {
        UndefinedIpVersion = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
        UnspecifiedVersion = 21850000,
    }
    impl IpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpVersion::UndefinedIpVersion => "UNDEFINED_IP_VERSION",
                IpVersion::Ipv4 => "IPV4",
                IpVersion::Ipv6 => "IPV6",
                IpVersion::UnspecifiedVersion => "UNSPECIFIED_VERSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IP_VERSION" => Some(Self::UndefinedIpVersion),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                "UNSPECIFIED_VERSION" => Some(Self::UnspecifiedVersion),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancingScheme {
        UndefinedLoadBalancingScheme = 0,
        External = 35607499,
        ExternalManaged = 512006923,
        Internal = 279295677,
        InternalManaged = 37350397,
        InternalSelfManaged = 236211150,
        Invalid = 530283991,
    }
    impl LoadBalancingScheme {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LoadBalancingScheme::UndefinedLoadBalancingScheme => {
                    "UNDEFINED_LOAD_BALANCING_SCHEME"
                }
                LoadBalancingScheme::External => "EXTERNAL",
                LoadBalancingScheme::ExternalManaged => "EXTERNAL_MANAGED",
                LoadBalancingScheme::Internal => "INTERNAL",
                LoadBalancingScheme::InternalManaged => "INTERNAL_MANAGED",
                LoadBalancingScheme::InternalSelfManaged => "INTERNAL_SELF_MANAGED",
                LoadBalancingScheme::Invalid => "INVALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOAD_BALANCING_SCHEME" => {
                    Some(Self::UndefinedLoadBalancingScheme)
                }
                "EXTERNAL" => Some(Self::External),
                "EXTERNAL_MANAGED" => Some(Self::ExternalManaged),
                "INTERNAL" => Some(Self::Internal),
                "INTERNAL_MANAGED" => Some(Self::InternalManaged),
                "INTERNAL_SELF_MANAGED" => Some(Self::InternalSelfManaged),
                "INVALID" => Some(Self::Invalid),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkTier {
        UndefinedNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkTier::UndefinedNetworkTier => "UNDEFINED_NETWORK_TIER",
                NetworkTier::FixedStandard => "FIXED_STANDARD",
                NetworkTier::Premium => "PREMIUM",
                NetworkTier::Standard => "STANDARD",
                NetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_TIER" => Some(Self::UndefinedNetworkTier),
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PscConnectionStatus {
        UndefinedPscConnectionStatus = 0,
        Accepted = 246714279,
        Closed = 380163436,
        NeedsAttention = 344491452,
        Pending = 35394935,
        Rejected = 174130302,
        StatusUnspecified = 42133066,
    }
    impl PscConnectionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PscConnectionStatus::UndefinedPscConnectionStatus => {
                    "UNDEFINED_PSC_CONNECTION_STATUS"
                }
                PscConnectionStatus::Accepted => "ACCEPTED",
                PscConnectionStatus::Closed => "CLOSED",
                PscConnectionStatus::NeedsAttention => "NEEDS_ATTENTION",
                PscConnectionStatus::Pending => "PENDING",
                PscConnectionStatus::Rejected => "REJECTED",
                PscConnectionStatus::StatusUnspecified => "STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PSC_CONNECTION_STATUS" => {
                    Some(Self::UndefinedPscConnectionStatus)
                }
                "ACCEPTED" => Some(Self::Accepted),
                "CLOSED" => Some(Self::Closed),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "PENDING" => Some(Self::Pending),
                "REJECTED" => Some(Self::Rejected),
                "STATUS_UNSPECIFIED" => Some(Self::StatusUnspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRuleAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ForwardingRulesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRuleList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<ForwardingRule>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRuleReference {
    #[prost(string, optional, tag = "269964030")]
    pub forwarding_rule: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRuleServiceDirectoryRegistration {
    #[prost(string, optional, tag = "178476379")]
    pub namespace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "74030416")]
    pub service_directory_region: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRulesScopedList {
    #[prost(message, repeated, tag = "315821365")]
    pub forwarding_rules: ::prost::alloc::vec::Vec<ForwardingRule>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GrpcHealthCheck {
    #[prost(string, optional, tag = "136533078")]
    pub grpc_service_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GRPCHealthCheck`.
pub mod grpc_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAcceleratorTypeRequest {
    #[prost(string, tag = "138031246")]
    pub accelerator_type: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssociationFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssociationNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAssociationRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAutoscalerRequest {
    #[prost(string, tag = "517258967")]
    pub autoscaler: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDiagnosticsInterconnectRequest {
    #[prost(string, tag = "224601230")]
    pub interconnect: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDiskTypeRequest {
    #[prost(string, tag = "93009052")]
    pub disk_type: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveFirewallsInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "365387880")]
    pub network_interface: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveFirewallsNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExternalVpnGatewayRequest {
    #[prost(string, tag = "109898629")]
    pub external_vpn_gateway: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFirewallRequest {
    #[prost(string, tag = "511016192")]
    pub firewall: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetFromFamilyImageRequest {
    #[prost(string, tag = "328751972")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalOrganizationOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "459714768")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGuestAttributesInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "368591164")]
    pub query_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "164364828")]
    pub variable_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "112951123")]
    pub resource_group_reference_resource: ::core::option::Option<
        ResourceGroupReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "112951123")]
    pub resource_group_reference_resource: ::core::option::Option<
        ResourceGroupReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetHealthTargetPoolRequest {
    #[prost(message, optional, tag = "292926060")]
    pub instance_reference_resource: ::core::option::Option<InstanceReference>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyBackendBucketRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyBackendServiceRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyDiskRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyFirewallPolicyRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyImageRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyInstanceRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyInstanceTemplateRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyInstantSnapshotRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyLicenseRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyMachineImageRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyNetworkAttachmentRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyNetworkFirewallPolicyRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyNodeGroupRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyNodeTemplateRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyRegionBackendServiceRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyRegionDiskRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyRegionInstantSnapshotRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyRegionNetworkFirewallPolicyRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyReservationRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyResourcePolicyRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyServiceAttachmentRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicySnapshotRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicyStoragePoolRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetIamPolicySubnetworkRequest {
    #[prost(int32, optional, tag = "499220029")]
    pub options_requested_policy_version: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageFamilyViewRequest {
    #[prost(string, tag = "328751972")]
    pub family: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetImageRequest {
    #[prost(string, tag = "100313435")]
    pub image: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceGroupManagerResizeRequestRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "216941060")]
    pub resize_request: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceSettingRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstanceTemplateRequest {
    #[prost(string, tag = "309248228")]
    pub instance_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInstantSnapshotRequest {
    #[prost(string, tag = "391638626")]
    pub instant_snapshot: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInterconnectAttachmentRequest {
    #[prost(string, tag = "308135284")]
    pub interconnect_attachment: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInterconnectLocationRequest {
    #[prost(string, tag = "492235846")]
    pub interconnect_location: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInterconnectRemoteLocationRequest {
    #[prost(string, tag = "290153949")]
    pub interconnect_remote_location: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInterconnectRequest {
    #[prost(string, tag = "224601230")]
    pub interconnect: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLicenseCodeRequest {
    #[prost(string, tag = "1467179")]
    pub license_code: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetLicenseRequest {
    #[prost(string, tag = "166757441")]
    pub license: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMachineImageRequest {
    #[prost(string, tag = "69189475")]
    pub machine_image: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMachineTypeRequest {
    #[prost(string, tag = "227711026")]
    pub machine_type: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMacsecConfigInterconnectRequest {
    #[prost(string, tag = "224601230")]
    pub interconnect: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNatIpInfoRouterRequest {
    #[prost(string, optional, tag = "425596649")]
    pub nat_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNatMappingInfoRoutersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "425596649")]
    pub nat_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkAttachmentRequest {
    #[prost(string, tag = "224644052")]
    pub network_attachment: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkEdgeSecurityServiceRequest {
    #[prost(string, tag = "157011879")]
    pub network_edge_security_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeTemplateRequest {
    #[prost(string, tag = "323154455")]
    pub node_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetNodeTypeRequest {
    #[prost(string, tag = "465832791")]
    pub node_type: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPacketMirroringRequest {
    #[prost(string, tag = "22305996")]
    pub packet_mirroring: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "101874590")]
    pub public_advertised_prefix: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionAutoscalerRequest {
    #[prost(string, tag = "517258967")]
    pub autoscaler: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionCommitmentRequest {
    #[prost(string, tag = "482134805")]
    pub commitment: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionDiskTypeRequest {
    #[prost(string, tag = "93009052")]
    pub disk_type: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionHealthCheckServiceRequest {
    #[prost(string, tag = "408374747")]
    pub health_check_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionInstanceTemplateRequest {
    #[prost(string, tag = "309248228")]
    pub instance_template: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionInstantSnapshotRequest {
    #[prost(string, tag = "391638626")]
    pub instant_snapshot: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionNetworkEndpointGroupRequest {
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionNotificationEndpointRequest {
    #[prost(string, tag = "376807017")]
    pub notification_endpoint: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "46443492")]
    pub ssl_certificate: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "47530956")]
    pub reservation: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "159240835")]
    pub resource_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRouteRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "108704329")]
    pub route: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRouterStatusRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleRegionSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScreenshotInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSerialPortOutputInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "109757538")]
    pub start: ::core::option::Option<i64>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "338957549")]
    pub service_attachment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetShieldedInstanceIdentityInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "284874180")]
    pub snapshot: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSnapshotSettingRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "46443492")]
    pub ssl_certificate: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStatusVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "406684153")]
    pub vpn_gateway: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "360473440")]
    pub storage_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStoragePoolTypeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "285999289")]
    pub storage_pool_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "307827694")]
    pub subnetwork: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetGrpcProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "5020283")]
    pub target_grpc_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "289769347")]
    pub target_instance: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTargetVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "532512843")]
    pub target_vpn_gateway: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "406684153")]
    pub vpn_gateway: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVpnTunnelRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "143821331")]
    pub vpn_tunnel: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetXpnHostProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetXpnResourcesProjectsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetZoneRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalAddressesMoveRequest {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "371693763")]
    pub destination_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalNetworkEndpointGroupsAttachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalNetworkEndpointGroupsDetachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalOrganizationSetPolicyRequest {
    #[prost(message, repeated, tag = "403251854")]
    pub bindings: ::prost::alloc::vec::Vec<Binding>,
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "91071794")]
    pub policy: ::core::option::Option<Policy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSetLabelsRequest {
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSetPolicyRequest {
    #[prost(message, repeated, tag = "403251854")]
    pub bindings: ::prost::alloc::vec::Vec<Binding>,
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "91071794")]
    pub policy: ::core::option::Option<Policy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestAttributes {
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "368591164")]
    pub query_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "157570874")]
    pub query_value: ::core::option::Option<GuestAttributesValue>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "164364828")]
    pub variable_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "124582382")]
    pub variable_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestAttributesEntry {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178476379")]
    pub namespace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestAttributesValue {
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<GuestAttributesEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestOsFeature {
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `GuestOsFeature`.
pub mod guest_os_feature {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        FeatureTypeUnspecified = 531767259,
        Gvnic = 68209305,
        Idpf = 2242641,
        MultiIpSubnet = 151776719,
        SecureBoot = 376811194,
        SevCapable = 87083793,
        SevLiveMigratable = 392039820,
        SevLiveMigratableV2 = 168551983,
        SevSnpCapable = 426919,
        UefiCompatible = 195865408,
        VirtioScsiMultiqueue = 201597069,
        Windows = 456863331,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::FeatureTypeUnspecified => "FEATURE_TYPE_UNSPECIFIED",
                Type::Gvnic => "GVNIC",
                Type::Idpf => "IDPF",
                Type::MultiIpSubnet => "MULTI_IP_SUBNET",
                Type::SecureBoot => "SECURE_BOOT",
                Type::SevCapable => "SEV_CAPABLE",
                Type::SevLiveMigratable => "SEV_LIVE_MIGRATABLE",
                Type::SevLiveMigratableV2 => "SEV_LIVE_MIGRATABLE_V2",
                Type::SevSnpCapable => "SEV_SNP_CAPABLE",
                Type::UefiCompatible => "UEFI_COMPATIBLE",
                Type::VirtioScsiMultiqueue => "VIRTIO_SCSI_MULTIQUEUE",
                Type::Windows => "WINDOWS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "FEATURE_TYPE_UNSPECIFIED" => Some(Self::FeatureTypeUnspecified),
                "GVNIC" => Some(Self::Gvnic),
                "IDPF" => Some(Self::Idpf),
                "MULTI_IP_SUBNET" => Some(Self::MultiIpSubnet),
                "SECURE_BOOT" => Some(Self::SecureBoot),
                "SEV_CAPABLE" => Some(Self::SevCapable),
                "SEV_LIVE_MIGRATABLE" => Some(Self::SevLiveMigratable),
                "SEV_LIVE_MIGRATABLE_V2" => Some(Self::SevLiveMigratableV2),
                "SEV_SNP_CAPABLE" => Some(Self::SevSnpCapable),
                "UEFI_COMPATIBLE" => Some(Self::UefiCompatible),
                "VIRTIO_SCSI_MULTIQUEUE" => Some(Self::VirtioScsiMultiqueue),
                "WINDOWS" => Some(Self::Windows),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Http2HealthCheck {
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "229403605")]
    pub request_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "196547649")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HTTP2HealthCheck`.
pub mod http2_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHealthCheck {
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "229403605")]
    pub request_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "196547649")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HTTPHealthCheck`.
pub mod http_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpsHealthCheck {
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "229403605")]
    pub request_path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "196547649")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HTTPSHealthCheck`.
pub mod https_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheck {
    #[prost(int32, optional, tag = "345561006")]
    pub check_interval_sec: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "85529574")]
    pub grpc_health_check: ::core::option::Option<GrpcHealthCheck>,
    #[prost(int32, optional, tag = "403212361")]
    pub healthy_threshold: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "11360986")]
    pub http2_health_check: ::core::option::Option<Http2HealthCheck>,
    #[prost(message, optional, tag = "412586940")]
    pub http_health_check: ::core::option::Option<HttpHealthCheck>,
    #[prost(message, optional, tag = "436046905")]
    pub https_health_check: ::core::option::Option<HttpsHealthCheck>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "351299741")]
    pub log_config: ::core::option::Option<HealthCheckLogConfig>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "280032440")]
    pub ssl_health_check: ::core::option::Option<SslHealthCheck>,
    #[prost(message, optional, tag = "469980419")]
    pub tcp_health_check: ::core::option::Option<TcpHealthCheck>,
    #[prost(int32, optional, tag = "79994995")]
    pub timeout_sec: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "227958480")]
    pub unhealthy_threshold: ::core::option::Option<i32>,
}
/// Nested message and enum types in `HealthCheck`.
pub mod health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Grpc = 2196510,
        Http = 2228360,
        Http2 = 69079210,
        Https = 69079243,
        Invalid = 530283991,
        Ssl = 82412,
        Tcp = 82881,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Grpc => "GRPC",
                Type::Http => "HTTP",
                Type::Http2 => "HTTP2",
                Type::Https => "HTTPS",
                Type::Invalid => "INVALID",
                Type::Ssl => "SSL",
                Type::Tcp => "TCP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "GRPC" => Some(Self::Grpc),
                "HTTP" => Some(Self::Http),
                "HTTP2" => Some(Self::Http2),
                "HTTPS" => Some(Self::Https),
                "INVALID" => Some(Self::Invalid),
                "SSL" => Some(Self::Ssl),
                "TCP" => Some(Self::Tcp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<HealthCheck>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HealthCheckLogConfig {
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckReference {
    #[prost(string, optional, tag = "308876645")]
    pub health_check: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckService {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "253163129")]
    pub health_status_aggregation_policy: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "29346733")]
    pub network_endpoint_groups: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "406728490")]
    pub notification_endpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HealthCheckService`.
pub mod health_check_service {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthStatusAggregationPolicy {
        UndefinedHealthStatusAggregationPolicy = 0,
        And = 64951,
        NoAggregation = 426445124,
    }
    impl HealthStatusAggregationPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthStatusAggregationPolicy::UndefinedHealthStatusAggregationPolicy => {
                    "UNDEFINED_HEALTH_STATUS_AGGREGATION_POLICY"
                }
                HealthStatusAggregationPolicy::And => "AND",
                HealthStatusAggregationPolicy::NoAggregation => "NO_AGGREGATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_HEALTH_STATUS_AGGREGATION_POLICY" => {
                    Some(Self::UndefinedHealthStatusAggregationPolicy)
                }
                "AND" => Some(Self::And),
                "NO_AGGREGATION" => Some(Self::NoAggregation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckServiceReference {
    #[prost(string, optional, tag = "408374747")]
    pub health_check_service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthCheckServicesList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<HealthCheckService>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthChecksAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        HealthChecksScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthChecksScopedList {
    #[prost(message, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<HealthCheck>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthStatus {
    #[prost(map = "string, string", tag = "112032548")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "269964030")]
    pub forwarding_rule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "172250632")]
    pub forwarding_rule_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "324007150")]
    pub health_state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "282149496")]
    pub weight: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "522501505")]
    pub weight_error: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HealthStatus`.
pub mod health_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthState {
        UndefinedHealthState = 0,
        Healthy = 439801213,
        Unhealthy = 462118084,
    }
    impl HealthState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthState::UndefinedHealthState => "UNDEFINED_HEALTH_STATE",
                HealthState::Healthy => "HEALTHY",
                HealthState::Unhealthy => "UNHEALTHY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_HEALTH_STATE" => Some(Self::UndefinedHealthState),
                "HEALTHY" => Some(Self::Healthy),
                "UNHEALTHY" => Some(Self::Unhealthy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WeightError {
        UndefinedWeightError = 0,
        InvalidWeight = 383698400,
        MissingWeight = 384027537,
        UnavailableWeight = 439464295,
        WeightNone = 502428831,
    }
    impl WeightError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WeightError::UndefinedWeightError => "UNDEFINED_WEIGHT_ERROR",
                WeightError::InvalidWeight => "INVALID_WEIGHT",
                WeightError::MissingWeight => "MISSING_WEIGHT",
                WeightError::UnavailableWeight => "UNAVAILABLE_WEIGHT",
                WeightError::WeightNone => "WEIGHT_NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_WEIGHT_ERROR" => Some(Self::UndefinedWeightError),
                "INVALID_WEIGHT" => Some(Self::InvalidWeight),
                "MISSING_WEIGHT" => Some(Self::MissingWeight),
                "UNAVAILABLE_WEIGHT" => Some(Self::UnavailableWeight),
                "WEIGHT_NONE" => Some(Self::WeightNone),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HealthStatusForNetworkEndpoint {
    #[prost(message, optional, tag = "306946058")]
    pub backend_service: ::core::option::Option<BackendServiceReference>,
    #[prost(message, optional, tag = "269964030")]
    pub forwarding_rule: ::core::option::Option<ForwardingRuleReference>,
    #[prost(message, optional, tag = "308876645")]
    pub health_check: ::core::option::Option<HealthCheckReference>,
    #[prost(message, optional, tag = "408374747")]
    pub health_check_service: ::core::option::Option<HealthCheckServiceReference>,
    #[prost(string, optional, tag = "324007150")]
    pub health_state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `HealthStatusForNetworkEndpoint`.
pub mod health_status_for_network_endpoint {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthState {
        UndefinedHealthState = 0,
        Draining = 480455402,
        Healthy = 439801213,
        Unhealthy = 462118084,
        Unknown = 433141802,
    }
    impl HealthState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthState::UndefinedHealthState => "UNDEFINED_HEALTH_STATE",
                HealthState::Draining => "DRAINING",
                HealthState::Healthy => "HEALTHY",
                HealthState::Unhealthy => "UNHEALTHY",
                HealthState::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_HEALTH_STATE" => Some(Self::UndefinedHealthState),
                "DRAINING" => Some(Self::Draining),
                "HEALTHY" => Some(Self::Healthy),
                "UNHEALTHY" => Some(Self::Unhealthy),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Help {
    #[prost(message, repeated, tag = "102977465")]
    pub links: ::prost::alloc::vec::Vec<HelpLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HelpLink {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116079")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HostRule {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "99467211")]
    pub hosts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "337813272")]
    pub path_matcher: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpFaultAbort {
    #[prost(uint32, optional, tag = "468949897")]
    pub http_status: ::core::option::Option<u32>,
    #[prost(double, optional, tag = "151909018")]
    pub percentage: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpFaultDelay {
    #[prost(message, optional, tag = "317037816")]
    pub fixed_delay: ::core::option::Option<Duration>,
    #[prost(double, optional, tag = "151909018")]
    pub percentage: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HttpFaultInjection {
    #[prost(message, optional, tag = "92611376")]
    pub abort: ::core::option::Option<HttpFaultAbort>,
    #[prost(message, optional, tag = "95467907")]
    pub delay: ::core::option::Option<HttpFaultDelay>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHeaderAction {
    #[prost(message, repeated, tag = "72111974")]
    pub request_headers_to_add: ::prost::alloc::vec::Vec<HttpHeaderOption>,
    #[prost(string, repeated, tag = "218425247")]
    pub request_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "32136052")]
    pub response_headers_to_add: ::prost::alloc::vec::Vec<HttpHeaderOption>,
    #[prost(string, repeated, tag = "75415761")]
    pub response_headers_to_remove: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHeaderMatch {
    #[prost(string, optional, tag = "457641093")]
    pub exact_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "110223613")]
    pub header_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "501130268")]
    pub invert_match: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "257898968")]
    pub prefix_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "67435841")]
    pub present_match: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "97244227")]
    pub range_match: ::core::option::Option<Int64RangeMatch>,
    #[prost(string, optional, tag = "107387853")]
    pub regex_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "426488663")]
    pub suffix_match: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpHeaderOption {
    #[prost(string, optional, tag = "110223613")]
    pub header_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "203094335")]
    pub header_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "20755124")]
    pub replace: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpQueryParameterMatch {
    #[prost(string, optional, tag = "457641093")]
    pub exact_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "67435841")]
    pub present_match: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "107387853")]
    pub regex_match: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRedirectAction {
    #[prost(string, optional, tag = "107417747")]
    pub host_redirect: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "170260656")]
    pub https_redirect: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "272342710")]
    pub path_redirect: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "446184169")]
    pub prefix_redirect: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "436710408")]
    pub redirect_response_code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "52284641")]
    pub strip_query: ::core::option::Option<bool>,
}
/// Nested message and enum types in `HttpRedirectAction`.
pub mod http_redirect_action {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RedirectResponseCode {
        UndefinedRedirectResponseCode = 0,
        Found = 67084130,
        MovedPermanentlyDefault = 386698449,
        PermanentRedirect = 382006381,
        SeeOther = 445380580,
        TemporaryRedirect = 489550378,
    }
    impl RedirectResponseCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RedirectResponseCode::UndefinedRedirectResponseCode => {
                    "UNDEFINED_REDIRECT_RESPONSE_CODE"
                }
                RedirectResponseCode::Found => "FOUND",
                RedirectResponseCode::MovedPermanentlyDefault => {
                    "MOVED_PERMANENTLY_DEFAULT"
                }
                RedirectResponseCode::PermanentRedirect => "PERMANENT_REDIRECT",
                RedirectResponseCode::SeeOther => "SEE_OTHER",
                RedirectResponseCode::TemporaryRedirect => "TEMPORARY_REDIRECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_REDIRECT_RESPONSE_CODE" => {
                    Some(Self::UndefinedRedirectResponseCode)
                }
                "FOUND" => Some(Self::Found),
                "MOVED_PERMANENTLY_DEFAULT" => Some(Self::MovedPermanentlyDefault),
                "PERMANENT_REDIRECT" => Some(Self::PermanentRedirect),
                "SEE_OTHER" => Some(Self::SeeOther),
                "TEMPORARY_REDIRECT" => Some(Self::TemporaryRedirect),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRetryPolicy {
    #[prost(uint32, optional, tag = "251680141")]
    pub num_retries: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "280041147")]
    pub per_try_timeout: ::core::option::Option<Duration>,
    #[prost(string, repeated, tag = "28815535")]
    pub retry_conditions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRouteAction {
    #[prost(message, optional, tag = "398943748")]
    pub cors_policy: ::core::option::Option<CorsPolicy>,
    #[prost(message, optional, tag = "412781079")]
    pub fault_injection_policy: ::core::option::Option<HttpFaultInjection>,
    #[prost(message, optional, tag = "61428376")]
    pub max_stream_duration: ::core::option::Option<Duration>,
    #[prost(message, optional, tag = "220196866")]
    pub request_mirror_policy: ::core::option::Option<RequestMirrorPolicy>,
    #[prost(message, optional, tag = "56799913")]
    pub retry_policy: ::core::option::Option<HttpRetryPolicy>,
    #[prost(message, optional, tag = "296701281")]
    pub timeout: ::core::option::Option<Duration>,
    #[prost(message, optional, tag = "273333948")]
    pub url_rewrite: ::core::option::Option<UrlRewrite>,
    #[prost(message, repeated, tag = "337028049")]
    pub weighted_backend_services: ::prost::alloc::vec::Vec<WeightedBackendService>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRouteRule {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328077352")]
    pub header_action: ::core::option::Option<HttpHeaderAction>,
    #[prost(message, repeated, tag = "376200701")]
    pub match_rules: ::prost::alloc::vec::Vec<HttpRouteRuleMatch>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "424563948")]
    pub route_action: ::core::option::Option<HttpRouteAction>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "405147820")]
    pub url_redirect: ::core::option::Option<HttpRedirectAction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HttpRouteRuleMatch {
    #[prost(string, optional, tag = "214598875")]
    pub full_path_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "361903489")]
    pub header_matches: ::prost::alloc::vec::Vec<HttpHeaderMatch>,
    #[prost(bool, optional, tag = "464324989")]
    pub ignore_case: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "464725739")]
    pub metadata_filters: ::prost::alloc::vec::Vec<MetadataFilter>,
    #[prost(string, optional, tag = "292348186")]
    pub path_template_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "257898968")]
    pub prefix_match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "286231270")]
    pub query_parameter_matches: ::prost::alloc::vec::Vec<HttpQueryParameterMatch>,
    #[prost(string, optional, tag = "107387853")]
    pub regex_match: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Image {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "381093450")]
    pub archive_size_bytes: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "102135228")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "328751972")]
    pub family: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "79294545")]
    pub guest_os_features: ::prost::alloc::vec::Vec<GuestOsFeature>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "379512583")]
    pub image_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int64, repeated, tag = "45482664")]
    pub license_codes: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "503113556")]
    pub raw_disk: ::core::option::Option<RawDisk>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "192356867")]
    pub shielded_instance_initial_state: ::core::option::Option<InitialStateConfig>,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "531501153")]
    pub source_disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "454190809")]
    pub source_disk_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50443319")]
    pub source_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "381503659")]
    pub source_image_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "55328291")]
    pub source_image_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "126061928")]
    pub source_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "303679322")]
    pub source_snapshot_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "98962258")]
    pub source_snapshot_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "452245726")]
    pub source_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "328005274")]
    pub storage_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Image`.
pub mod image {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceType {
        UndefinedSourceType = 0,
        Raw = 80904,
    }
    impl SourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceType::UndefinedSourceType => "UNDEFINED_SOURCE_TYPE",
                SourceType::Raw => "RAW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SOURCE_TYPE" => Some(Self::UndefinedSourceType),
                "RAW" => Some(Self::Raw),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Deleting = 528602024,
        Failed = 455706685,
        Pending = 35394935,
        Ready = 77848963,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Pending => "PENDING",
                Status::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageFamilyView {
    #[prost(message, optional, tag = "100313435")]
    pub image: ::core::option::Option<Image>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImageList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Image>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InitialStateConfig {
    #[prost(message, repeated, tag = "99253")]
    pub dbs: ::prost::alloc::vec::Vec<FileContentBuffer>,
    #[prost(message, repeated, tag = "3077113")]
    pub dbxs: ::prost::alloc::vec::Vec<FileContentBuffer>,
    #[prost(message, repeated, tag = "3288130")]
    pub keks: ::prost::alloc::vec::Vec<FileContentBuffer>,
    #[prost(message, optional, tag = "3579")]
    pub pk: ::core::option::Option<FileContentBuffer>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertAddressRequest {
    #[prost(message, optional, tag = "483888121")]
    pub address_resource: ::core::option::Option<Address>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertAutoscalerRequest {
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertBackendBucketRequest {
    #[prost(message, optional, tag = "380757784")]
    pub backend_bucket_resource: ::core::option::Option<BackendBucket>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertBackendServiceRequest {
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertDiskRequest {
    #[prost(message, optional, tag = "25880688")]
    pub disk_resource: ::core::option::Option<Disk>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50443319")]
    pub source_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertExternalVpnGatewayRequest {
    #[prost(message, optional, tag = "486813576")]
    pub external_vpn_gateway_resource: ::core::option::Option<ExternalVpnGateway>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertFirewallPolicyRequest {
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, tag = "459714768")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertFirewallRequest {
    #[prost(message, optional, tag = "41425005")]
    pub firewall_resource: ::core::option::Option<Firewall>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertForwardingRuleRequest {
    #[prost(message, optional, tag = "301211695")]
    pub forwarding_rule_resource: ::core::option::Option<ForwardingRule>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertGlobalAddressRequest {
    #[prost(message, optional, tag = "483888121")]
    pub address_resource: ::core::option::Option<Address>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertGlobalForwardingRuleRequest {
    #[prost(message, optional, tag = "301211695")]
    pub forwarding_rule_resource: ::core::option::Option<ForwardingRule>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertGlobalNetworkEndpointGroupRequest {
    #[prost(message, optional, tag = "525788839")]
    pub network_endpoint_group_resource: ::core::option::Option<NetworkEndpointGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertGlobalPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "47594501")]
    pub public_delegated_prefix_resource: ::core::option::Option<PublicDelegatedPrefix>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertHealthCheckRequest {
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertImageRequest {
    #[prost(bool, optional, tag = "197723344")]
    pub force_create: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "371171954")]
    pub image_resource: ::core::option::Option<Image>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstanceGroupManagerRequest {
    #[prost(message, optional, tag = "261063946")]
    pub instance_group_manager_resource: ::core::option::Option<InstanceGroupManager>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstanceGroupManagerResizeRequestRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "468541293")]
    pub instance_group_manager_resize_request_resource: ::core::option::Option<
        InstanceGroupManagerResizeRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstanceGroupRequest {
    #[prost(message, optional, tag = "286612152")]
    pub instance_group_resource: ::core::option::Option<InstanceGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstanceRequest {
    #[prost(message, optional, tag = "215988344")]
    pub instance_resource: ::core::option::Option<Instance>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "332423616")]
    pub source_instance_template: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21769791")]
    pub source_machine_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstanceTemplateRequest {
    #[prost(message, optional, tag = "10679561")]
    pub instance_template_resource: ::core::option::Option<InstanceTemplate>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInstantSnapshotRequest {
    #[prost(message, optional, tag = "383915339")]
    pub instant_snapshot_resource: ::core::option::Option<InstantSnapshot>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInterconnectAttachmentRequest {
    #[prost(message, optional, tag = "212341369")]
    pub interconnect_attachment_resource: ::core::option::Option<InterconnectAttachment>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertInterconnectRequest {
    #[prost(message, optional, tag = "397611167")]
    pub interconnect_resource: ::core::option::Option<Interconnect>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertLicenseRequest {
    #[prost(message, optional, tag = "437955148")]
    pub license_resource: ::core::option::Option<License>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertMachineImageRequest {
    #[prost(message, optional, tag = "60740970")]
    pub machine_image_resource: ::core::option::Option<MachineImage>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "396315705")]
    pub source_instance: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNetworkAttachmentRequest {
    #[prost(message, optional, tag = "210974745")]
    pub network_attachment_resource: ::core::option::Option<NetworkAttachment>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNetworkEdgeSecurityServiceRequest {
    #[prost(message, optional, tag = "477548966")]
    pub network_edge_security_service_resource: ::core::option::Option<
        NetworkEdgeSecurityService,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNetworkEndpointGroupRequest {
    #[prost(message, optional, tag = "525788839")]
    pub network_endpoint_group_resource: ::core::option::Option<NetworkEndpointGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNetworkFirewallPolicyRequest {
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNetworkRequest {
    #[prost(message, optional, tag = "122105599")]
    pub network_resource: ::core::option::Option<Network>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNodeGroupRequest {
    #[prost(int32, tag = "71951469")]
    pub initial_node_count: i32,
    #[prost(message, optional, tag = "505321899")]
    pub node_group_resource: ::core::option::Option<NodeGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertNodeTemplateRequest {
    #[prost(message, optional, tag = "127364406")]
    pub node_template_resource: ::core::option::Option<NodeTemplate>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertPacketMirroringRequest {
    #[prost(message, optional, tag = "493501985")]
    pub packet_mirroring_resource: ::core::option::Option<PacketMirroring>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertPublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "233614223")]
    pub public_advertised_prefix_resource: ::core::option::Option<
        PublicAdvertisedPrefix,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "47594501")]
    pub public_delegated_prefix_resource: ::core::option::Option<PublicDelegatedPrefix>,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionAutoscalerRequest {
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionBackendServiceRequest {
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionCommitmentRequest {
    #[prost(message, optional, tag = "244240888")]
    pub commitment_resource: ::core::option::Option<Commitment>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionDiskRequest {
    #[prost(message, optional, tag = "25880688")]
    pub disk_resource: ::core::option::Option<Disk>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "50443319")]
    pub source_image: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionHealthCheckRequest {
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionHealthCheckServiceRequest {
    #[prost(message, optional, tag = "477367794")]
    pub health_check_service_resource: ::core::option::Option<HealthCheckService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionInstanceGroupManagerRequest {
    #[prost(message, optional, tag = "261063946")]
    pub instance_group_manager_resource: ::core::option::Option<InstanceGroupManager>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionInstanceTemplateRequest {
    #[prost(message, optional, tag = "10679561")]
    pub instance_template_resource: ::core::option::Option<InstanceTemplate>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionInstantSnapshotRequest {
    #[prost(message, optional, tag = "383915339")]
    pub instant_snapshot_resource: ::core::option::Option<InstantSnapshot>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionNetworkEndpointGroupRequest {
    #[prost(message, optional, tag = "525788839")]
    pub network_endpoint_group_resource: ::core::option::Option<NetworkEndpointGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionNetworkFirewallPolicyRequest {
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionNotificationEndpointRequest {
    #[prost(message, optional, tag = "338459940")]
    pub notification_endpoint_resource: ::core::option::Option<NotificationEndpoint>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "216159612")]
    pub security_policy_resource: ::core::option::Option<SecurityPolicy>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "180709897")]
    pub ssl_certificate_resource: ::core::option::Option<SslCertificate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "274891848")]
    pub ssl_policy_resource: ::core::option::Option<SslPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "24696744")]
    pub target_http_proxy_resource: ::core::option::Option<TargetHttpProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "433657473")]
    pub target_https_proxy_resource: ::core::option::Option<TargetHttpsProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "145913931")]
    pub target_tcp_proxy_resource: ::core::option::Option<TargetTcpProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "285030177")]
    pub reservation_resource: ::core::option::Option<Reservation>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "76826186")]
    pub resource_policy_resource: ::core::option::Option<ResourcePolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRouteRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "225428804")]
    pub route_resource: ::core::option::Option<Route>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "155222084")]
    pub router_resource: ::core::option::Option<Router>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "216159612")]
    pub security_policy_resource: ::core::option::Option<SecurityPolicy>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "472980256")]
    pub service_attachment_resource: ::core::option::Option<ServiceAttachment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "481319977")]
    pub snapshot_resource: ::core::option::Option<Snapshot>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertSslCertificateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "180709897")]
    pub ssl_certificate_resource: ::core::option::Option<SslCertificate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "274891848")]
    pub ssl_policy_resource: ::core::option::Option<SslPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "157179405")]
    pub storage_pool_resource: ::core::option::Option<StoragePool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "42233151")]
    pub subnetwork_resource: ::core::option::Option<Subnetwork>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetGrpcProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328922450")]
    pub target_grpc_proxy_resource: ::core::option::Option<TargetGrpcProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "24696744")]
    pub target_http_proxy_resource: ::core::option::Option<TargetHttpProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "433657473")]
    pub target_https_proxy_resource: ::core::option::Option<TargetHttpsProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "430453066")]
    pub target_instance_resource: ::core::option::Option<TargetInstance>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "101281443")]
    pub target_pool_resource: ::core::option::Option<TargetPool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "142016192")]
    pub target_ssl_proxy_resource: ::core::option::Option<TargetSslProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "145913931")]
    pub target_tcp_proxy_resource: ::core::option::Option<TargetTcpProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertTargetVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "498050")]
    pub target_vpn_gateway_resource: ::core::option::Option<TargetVpnGateway>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "182688660")]
    pub vpn_gateway_resource: ::core::option::Option<VpnGateway>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InsertVpnTunnelRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "86839482")]
    pub vpn_tunnel_resource: ::core::option::Option<VpnTunnel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Instance {
    #[prost(message, optional, tag = "409646002")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    #[prost(bool, optional, tag = "467731324")]
    pub can_ip_forward: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "490637685")]
    pub confidential_instance_config: ::core::option::Option<ConfidentialInstanceConfig>,
    #[prost(string, optional, tag = "410285354")]
    pub cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "458014698")]
    pub deletion_protection: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<AttachedDisk>,
    #[prost(message, optional, tag = "258933875")]
    pub display_device: ::core::option::Option<DisplayDevice>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "463595119")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(string, optional, tag = "237067315")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "64741517")]
    pub instance_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "235941474")]
    pub key_revocation_action_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "443830736")]
    pub last_start_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "412823010")]
    pub last_stop_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "356275337")]
    pub last_suspended_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "227711026")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, optional, tag = "242912759")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "52735243")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    #[prost(message, optional, tag = "398330850")]
    pub network_performance_config: ::core::option::Option<NetworkPerformanceConfig>,
    #[prost(message, optional, tag = "78313862")]
    pub params: ::core::option::Option<InstanceParams>,
    #[prost(string, optional, tag = "48277006")]
    pub private_ipv6_google_access: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "157850683")]
    pub reservation_affinity: ::core::option::Option<ReservationAffinity>,
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<ResourceStatus>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "386688404")]
    pub scheduling: ::core::option::Option<Scheduling>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "277537328")]
    pub service_accounts: ::prost::alloc::vec::Vec<ServiceAccount>,
    #[prost(message, optional, tag = "12862901")]
    pub shielded_instance_config: ::core::option::Option<ShieldedInstanceConfig>,
    #[prost(message, optional, tag = "163696919")]
    pub shielded_instance_integrity_policy: ::core::option::Option<
        ShieldedInstanceIntegrityPolicy,
    >,
    #[prost(string, optional, tag = "21769791")]
    pub source_machine_image: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "192839075")]
    pub source_machine_image_encryption_key: ::core::option::Option<
        CustomerEncryptionKey,
    >,
    #[prost(bool, optional, tag = "123693144")]
    pub start_restricted: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "297428154")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3552281")]
    pub tags: ::core::option::Option<Tags>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Instance`.
pub mod instance {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyRevocationActionType {
        UndefinedKeyRevocationActionType = 0,
        Unspecified = 467110106,
        None = 2402104,
        Stop = 2555906,
    }
    impl KeyRevocationActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeyRevocationActionType::UndefinedKeyRevocationActionType => {
                    "UNDEFINED_KEY_REVOCATION_ACTION_TYPE"
                }
                KeyRevocationActionType::Unspecified => {
                    "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED"
                }
                KeyRevocationActionType::None => "NONE",
                KeyRevocationActionType::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_KEY_REVOCATION_ACTION_TYPE" => {
                    Some(Self::UndefinedKeyRevocationActionType)
                }
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrivateIpv6GoogleAccess {
        UndefinedPrivateIpv6GoogleAccess = 0,
        EnableBidirectionalAccessToGoogle = 427975994,
        EnableOutboundVmAccessToGoogle = 288210263,
        InheritFromSubnetwork = 530256959,
    }
    impl PrivateIpv6GoogleAccess {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PrivateIpv6GoogleAccess::UndefinedPrivateIpv6GoogleAccess => {
                    "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS"
                }
                PrivateIpv6GoogleAccess::EnableBidirectionalAccessToGoogle => {
                    "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
                }
                PrivateIpv6GoogleAccess::EnableOutboundVmAccessToGoogle => {
                    "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
                }
                PrivateIpv6GoogleAccess::InheritFromSubnetwork => {
                    "INHERIT_FROM_SUBNETWORK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS" => {
                    Some(Self::UndefinedPrivateIpv6GoogleAccess)
                }
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableBidirectionalAccessToGoogle)
                }
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableOutboundVmAccessToGoogle)
                }
                "INHERIT_FROM_SUBNETWORK" => Some(Self::InheritFromSubnetwork),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Deprovisioning = 428935662,
        Provisioning = 290896621,
        Repairing = 413483285,
        Running = 121282975,
        Staging = 431072283,
        Stopped = 444276141,
        Stopping = 350791796,
        Suspended = 51223995,
        Suspending = 514206246,
        Terminated = 250018339,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Deprovisioning => "DEPROVISIONING",
                Status::Provisioning => "PROVISIONING",
                Status::Repairing => "REPAIRING",
                Status::Running => "RUNNING",
                Status::Staging => "STAGING",
                Status::Stopped => "STOPPED",
                Status::Stopping => "STOPPING",
                Status::Suspended => "SUSPENDED",
                Status::Suspending => "SUSPENDING",
                Status::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DEPROVISIONING" => Some(Self::Deprovisioning),
                "PROVISIONING" => Some(Self::Provisioning),
                "REPAIRING" => Some(Self::Repairing),
                "RUNNING" => Some(Self::Running),
                "STAGING" => Some(Self::Staging),
                "STOPPED" => Some(Self::Stopped),
                "STOPPING" => Some(Self::Stopping),
                "SUSPENDED" => Some(Self::Suspended),
                "SUSPENDING" => Some(Self::Suspending),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstancesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceConsumptionData {
    #[prost(message, optional, tag = "146354898")]
    pub consumption_info: ::core::option::Option<InstanceConsumptionInfo>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstanceConsumptionInfo {
    #[prost(int32, optional, tag = "393356754")]
    pub guest_cpus: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "329237578")]
    pub local_ssd_gb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "116001171")]
    pub memory_mb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "317231675")]
    pub min_node_cpus: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroup {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "427598732")]
    pub named_ports: ::prost::alloc::vec::Vec<NamedPort>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3530753")]
    pub size: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstanceGroupsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceGroup>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManager {
    #[prost(message, optional, tag = "112596737")]
    pub all_instances_config: ::core::option::Option<
        InstanceGroupManagerAllInstancesConfig,
    >,
    #[prost(message, repeated, tag = "456799109")]
    pub auto_healing_policies: ::prost::alloc::vec::Vec<
        InstanceGroupManagerAutoHealingPolicy,
    >,
    #[prost(string, optional, tag = "389106439")]
    pub base_instance_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "164045879")]
    pub current_actions: ::core::option::Option<InstanceGroupManagerActionsSummary>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "534558541")]
    pub distribution_policy: ::core::option::Option<DistributionPolicy>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "81095253")]
    pub instance_group: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "447961617")]
    pub instance_lifecycle_policy: ::core::option::Option<
        InstanceGroupManagerInstanceLifecyclePolicy,
    >,
    #[prost(string, optional, tag = "309248228")]
    pub instance_template: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "296047156")]
    pub list_managed_instances_results: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "427598732")]
    pub named_ports: ::prost::alloc::vec::Vec<NamedPort>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "47538565")]
    pub stateful_policy: ::core::option::Option<StatefulPolicy>,
    #[prost(message, optional, tag = "181260274")]
    pub status: ::core::option::Option<InstanceGroupManagerStatus>,
    #[prost(string, repeated, tag = "336072617")]
    pub target_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "62880239")]
    pub target_size: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "175809896")]
    pub update_policy: ::core::option::Option<InstanceGroupManagerUpdatePolicy>,
    #[prost(message, repeated, tag = "162430619")]
    pub versions: ::prost::alloc::vec::Vec<InstanceGroupManagerVersion>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceGroupManager`.
pub mod instance_group_manager {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListManagedInstancesResults {
        UndefinedListManagedInstancesResults = 0,
        Pageless = 32183464,
        Paginated = 40190637,
    }
    impl ListManagedInstancesResults {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListManagedInstancesResults::UndefinedListManagedInstancesResults => {
                    "UNDEFINED_LIST_MANAGED_INSTANCES_RESULTS"
                }
                ListManagedInstancesResults::Pageless => "PAGELESS",
                ListManagedInstancesResults::Paginated => "PAGINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LIST_MANAGED_INSTANCES_RESULTS" => {
                    Some(Self::UndefinedListManagedInstancesResults)
                }
                "PAGELESS" => Some(Self::Pageless),
                "PAGINATED" => Some(Self::Paginated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerActionsSummary {
    #[prost(int32, optional, tag = "440023373")]
    pub abandoning: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "209809081")]
    pub creating: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "369916745")]
    pub creating_without_retries: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "282846120")]
    pub deleting: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3387192")]
    pub none: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "339057132")]
    pub recreating: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "215044903")]
    pub refreshing: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "372312947")]
    pub restarting: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "201100714")]
    pub resuming: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "243064896")]
    pub starting: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "105035892")]
    pub stopping: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "29113894")]
    pub suspending: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "451612873")]
    pub verifying: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstanceGroupManagersScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerAllInstancesConfig {
    #[prost(message, optional, tag = "147688755")]
    pub properties: ::core::option::Option<InstancePropertiesPatch>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerAutoHealingPolicy {
    #[prost(string, optional, tag = "308876645")]
    pub health_check: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "263207002")]
    pub initial_delay_sec: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerInstanceLifecyclePolicy {
    #[prost(string, optional, tag = "61383253")]
    pub default_action_on_failure: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "356302027")]
    pub force_update_on_repair: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceGroupManagerInstanceLifecyclePolicy`.
pub mod instance_group_manager_instance_lifecycle_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DefaultActionOnFailure {
        UndefinedDefaultActionOnFailure = 0,
        DoNothing = 451307513,
        Repair = 266277773,
    }
    impl DefaultActionOnFailure {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DefaultActionOnFailure::UndefinedDefaultActionOnFailure => {
                    "UNDEFINED_DEFAULT_ACTION_ON_FAILURE"
                }
                DefaultActionOnFailure::DoNothing => "DO_NOTHING",
                DefaultActionOnFailure::Repair => "REPAIR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DEFAULT_ACTION_ON_FAILURE" => {
                    Some(Self::UndefinedDefaultActionOnFailure)
                }
                "DO_NOTHING" => Some(Self::DoNothing),
                "REPAIR" => Some(Self::Repair),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForceUpdateOnRepair {
        UndefinedForceUpdateOnRepair = 0,
        No = 2497,
        Yes = 87751,
    }
    impl ForceUpdateOnRepair {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ForceUpdateOnRepair::UndefinedForceUpdateOnRepair => {
                    "UNDEFINED_FORCE_UPDATE_ON_REPAIR"
                }
                ForceUpdateOnRepair::No => "NO",
                ForceUpdateOnRepair::Yes => "YES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_FORCE_UPDATE_ON_REPAIR" => {
                    Some(Self::UndefinedForceUpdateOnRepair)
                }
                "NO" => Some(Self::No),
                "YES" => Some(Self::Yes),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceGroupManager>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerResizeRequest {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "232146425")]
    pub requested_run_duration: ::core::option::Option<Duration>,
    #[prost(int32, optional, tag = "533735362")]
    pub resize_by: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "181260274")]
    pub status: ::core::option::Option<InstanceGroupManagerResizeRequestStatus>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceGroupManagerResizeRequest`.
pub mod instance_group_manager_resize_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Accepted = 246714279,
        Cancelled = 41957681,
        Creating = 455564985,
        Failed = 455706685,
        Unspecified = 470755401,
        Succeeded = 511103553,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Accepted => "ACCEPTED",
                State::Cancelled => "CANCELLED",
                State::Creating => "CREATING",
                State::Failed => "FAILED",
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACCEPTED" => Some(Self::Accepted),
                "CANCELLED" => Some(Self::Cancelled),
                "CREATING" => Some(Self::Creating),
                "FAILED" => Some(Self::Failed),
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerResizeRequestStatus {
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<Error>,
    #[prost(message, optional, tag = "434771492")]
    pub last_attempt: ::core::option::Option<
        InstanceGroupManagerResizeRequestStatusLastAttempt,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerResizeRequestStatusLastAttempt {
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<Error>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerResizeRequestsListResponse {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceGroupManagerResizeRequest>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerStatus {
    #[prost(message, optional, tag = "112596737")]
    pub all_instances_config: ::core::option::Option<
        InstanceGroupManagerStatusAllInstancesConfig,
    >,
    #[prost(string, optional, tag = "517258967")]
    pub autoscaler: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "108410864")]
    pub is_stable: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "244462412")]
    pub stateful: ::core::option::Option<InstanceGroupManagerStatusStateful>,
    #[prost(message, optional, tag = "289386200")]
    pub version_target: ::core::option::Option<InstanceGroupManagerStatusVersionTarget>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerStatusAllInstancesConfig {
    #[prost(string, optional, tag = "38355937")]
    pub current_revision: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "141961639")]
    pub effective: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerStatusStateful {
    #[prost(bool, optional, tag = "110474224")]
    pub has_stateful_config: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "526265001")]
    pub per_instance_configs: ::core::option::Option<
        InstanceGroupManagerStatusStatefulPerInstanceConfigs,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerStatusStatefulPerInstanceConfigs {
    #[prost(bool, optional, tag = "516540553")]
    pub all_effective: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerStatusVersionTarget {
    #[prost(bool, optional, tag = "433209149")]
    pub is_reached: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerUpdatePolicy {
    #[prost(string, optional, tag = "292630424")]
    pub instance_redistribution_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "302572691")]
    pub max_surge: ::core::option::Option<FixedOrPercent>,
    #[prost(message, optional, tag = "404940277")]
    pub max_unavailable: ::core::option::Option<FixedOrPercent>,
    #[prost(string, optional, tag = "270567060")]
    pub minimal_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "66103053")]
    pub most_disruptive_allowed_action: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "505931694")]
    pub replacement_method: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceGroupManagerUpdatePolicy`.
pub mod instance_group_manager_update_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceRedistributionType {
        UndefinedInstanceRedistributionType = 0,
    }
    impl InstanceRedistributionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceRedistributionType::UndefinedInstanceRedistributionType => {
                    "UNDEFINED_INSTANCE_REDISTRIBUTION_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANCE_REDISTRIBUTION_TYPE" => {
                    Some(Self::UndefinedInstanceRedistributionType)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinimalAction {
        UndefinedMinimalAction = 0,
    }
    impl MinimalAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinimalAction::UndefinedMinimalAction => "UNDEFINED_MINIMAL_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MINIMAL_ACTION" => Some(Self::UndefinedMinimalAction),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MostDisruptiveAllowedAction {
        UndefinedMostDisruptiveAllowedAction = 0,
    }
    impl MostDisruptiveAllowedAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MostDisruptiveAllowedAction::UndefinedMostDisruptiveAllowedAction => {
                    "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION" => {
                    Some(Self::UndefinedMostDisruptiveAllowedAction)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReplacementMethod {
        UndefinedReplacementMethod = 0,
        Recreate = 522644719,
        Substitute = 280924314,
    }
    impl ReplacementMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReplacementMethod::UndefinedReplacementMethod => {
                    "UNDEFINED_REPLACEMENT_METHOD"
                }
                ReplacementMethod::Recreate => "RECREATE",
                ReplacementMethod::Substitute => "SUBSTITUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_REPLACEMENT_METHOD" => Some(Self::UndefinedReplacementMethod),
                "RECREATE" => Some(Self::Recreate),
                "SUBSTITUTE" => Some(Self::Substitute),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Opportunistic = 429530089,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Opportunistic => "OPPORTUNISTIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "OPPORTUNISTIC" => Some(Self::Opportunistic),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagerVersion {
    #[prost(string, optional, tag = "309248228")]
    pub instance_template: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "62880239")]
    pub target_size: ::core::option::Option<FixedOrPercent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersAbandonInstancesRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersApplyUpdatesRequest {
    #[prost(bool, optional, tag = "403676512")]
    pub all_instances: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "270567060")]
    pub minimal_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "66103053")]
    pub most_disruptive_allowed_action: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `InstanceGroupManagersApplyUpdatesRequest`.
pub mod instance_group_managers_apply_updates_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinimalAction {
        UndefinedMinimalAction = 0,
    }
    impl MinimalAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinimalAction::UndefinedMinimalAction => "UNDEFINED_MINIMAL_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MINIMAL_ACTION" => Some(Self::UndefinedMinimalAction),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MostDisruptiveAllowedAction {
        UndefinedMostDisruptiveAllowedAction = 0,
    }
    impl MostDisruptiveAllowedAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MostDisruptiveAllowedAction::UndefinedMostDisruptiveAllowedAction => {
                    "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION" => {
                    Some(Self::UndefinedMostDisruptiveAllowedAction)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersCreateInstancesRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersDeleteInstancesRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "40631073")]
    pub skip_instances_on_validation_error: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersDeletePerInstanceConfigsReq {
    #[prost(string, repeated, tag = "104585032")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersListErrorsResponse {
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceManagedByIgmError>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersListManagedInstancesResponse {
    #[prost(message, repeated, tag = "336219614")]
    pub managed_instances: ::prost::alloc::vec::Vec<ManagedInstance>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersListPerInstanceConfigsResp {
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<PerInstanceConfig>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersPatchPerInstanceConfigsReq {
    #[prost(message, repeated, tag = "526265001")]
    pub per_instance_configs: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersRecreateInstancesRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersScopedList {
    #[prost(message, repeated, tag = "214072592")]
    pub instance_group_managers: ::prost::alloc::vec::Vec<InstanceGroupManager>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersSetInstanceTemplateRequest {
    #[prost(string, optional, tag = "309248228")]
    pub instance_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersSetTargetPoolsRequest {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "336072617")]
    pub target_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupManagersUpdatePerInstanceConfigsReq {
    #[prost(message, repeated, tag = "526265001")]
    pub per_instance_configs: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsAddInstancesRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<InstanceReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsListInstances {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceWithNamedPorts>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsListInstancesRequest {
    #[prost(string, optional, tag = "92223591")]
    pub instance_state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceGroupsListInstancesRequest`.
pub mod instance_groups_list_instances_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceState {
        UndefinedInstanceState = 0,
        All = 64897,
        Running = 121282975,
    }
    impl InstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceState::UndefinedInstanceState => "UNDEFINED_INSTANCE_STATE",
                InstanceState::All => "ALL",
                InstanceState::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANCE_STATE" => Some(Self::UndefinedInstanceState),
                "ALL" => Some(Self::All),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsRemoveInstancesRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<InstanceReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsScopedList {
    #[prost(message, repeated, tag = "366469310")]
    pub instance_groups: ::prost::alloc::vec::Vec<InstanceGroup>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceGroupsSetNamedPortsRequest {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "427598732")]
    pub named_ports: ::prost::alloc::vec::Vec<NamedPort>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Instance>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceListReferrers {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Reference>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceManagedByIgmError {
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<InstanceManagedByIgmErrorManagedInstanceError>,
    #[prost(message, optional, tag = "292224547")]
    pub instance_action_details: ::core::option::Option<
        InstanceManagedByIgmErrorInstanceActionDetails,
    >,
    #[prost(string, optional, tag = "55126294")]
    pub timestamp: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceManagedByIgmErrorInstanceActionDetails {
    #[prost(string, optional, tag = "187661878")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "351608024")]
    pub version: ::core::option::Option<ManagedInstanceVersion>,
}
/// Nested message and enum types in `InstanceManagedByIgmErrorInstanceActionDetails`.
pub mod instance_managed_by_igm_error_instance_action_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        UndefinedAction = 0,
        Abandoning = 388244813,
        Creating = 455564985,
        CreatingWithoutRetries = 428843785,
        Deleting = 528602024,
        None = 2402104,
        Recreating = 287278572,
        Refreshing = 163266343,
        Restarting = 320534387,
        Resuming = 446856618,
        Starting = 488820800,
        Stopping = 350791796,
        Suspending = 514206246,
        Verifying = 16982185,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::UndefinedAction => "UNDEFINED_ACTION",
                Action::Abandoning => "ABANDONING",
                Action::Creating => "CREATING",
                Action::CreatingWithoutRetries => "CREATING_WITHOUT_RETRIES",
                Action::Deleting => "DELETING",
                Action::None => "NONE",
                Action::Recreating => "RECREATING",
                Action::Refreshing => "REFRESHING",
                Action::Restarting => "RESTARTING",
                Action::Resuming => "RESUMING",
                Action::Starting => "STARTING",
                Action::Stopping => "STOPPING",
                Action::Suspending => "SUSPENDING",
                Action::Verifying => "VERIFYING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ACTION" => Some(Self::UndefinedAction),
                "ABANDONING" => Some(Self::Abandoning),
                "CREATING" => Some(Self::Creating),
                "CREATING_WITHOUT_RETRIES" => Some(Self::CreatingWithoutRetries),
                "DELETING" => Some(Self::Deleting),
                "NONE" => Some(Self::None),
                "RECREATING" => Some(Self::Recreating),
                "REFRESHING" => Some(Self::Refreshing),
                "RESTARTING" => Some(Self::Restarting),
                "RESUMING" => Some(Self::Resuming),
                "STARTING" => Some(Self::Starting),
                "STOPPING" => Some(Self::Stopping),
                "SUSPENDING" => Some(Self::Suspending),
                "VERIFYING" => Some(Self::Verifying),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceManagedByIgmErrorManagedInstanceError {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceMoveRequest {
    #[prost(string, optional, tag = "131854653")]
    pub destination_zone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "289769347")]
    pub target_instance: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceParams {
    #[prost(map = "string, string", tag = "377671164")]
    pub resource_manager_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceProperties {
    #[prost(message, optional, tag = "409646002")]
    pub advanced_machine_features: ::core::option::Option<AdvancedMachineFeatures>,
    #[prost(bool, optional, tag = "467731324")]
    pub can_ip_forward: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "490637685")]
    pub confidential_instance_config: ::core::option::Option<ConfidentialInstanceConfig>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<AttachedDisk>,
    #[prost(message, repeated, tag = "463595119")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(string, optional, tag = "235941474")]
    pub key_revocation_action_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "227711026")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, optional, tag = "242912759")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "52735243")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    #[prost(message, optional, tag = "398330850")]
    pub network_performance_config: ::core::option::Option<NetworkPerformanceConfig>,
    #[prost(string, optional, tag = "48277006")]
    pub private_ipv6_google_access: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "157850683")]
    pub reservation_affinity: ::core::option::Option<ReservationAffinity>,
    #[prost(map = "string, string", tag = "377671164")]
    pub resource_manager_tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "386688404")]
    pub scheduling: ::core::option::Option<Scheduling>,
    #[prost(message, repeated, tag = "277537328")]
    pub service_accounts: ::prost::alloc::vec::Vec<ServiceAccount>,
    #[prost(message, optional, tag = "12862901")]
    pub shielded_instance_config: ::core::option::Option<ShieldedInstanceConfig>,
    #[prost(message, optional, tag = "3552281")]
    pub tags: ::core::option::Option<Tags>,
}
/// Nested message and enum types in `InstanceProperties`.
pub mod instance_properties {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyRevocationActionType {
        UndefinedKeyRevocationActionType = 0,
        Unspecified = 467110106,
        None = 2402104,
        Stop = 2555906,
    }
    impl KeyRevocationActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeyRevocationActionType::UndefinedKeyRevocationActionType => {
                    "UNDEFINED_KEY_REVOCATION_ACTION_TYPE"
                }
                KeyRevocationActionType::Unspecified => {
                    "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED"
                }
                KeyRevocationActionType::None => "NONE",
                KeyRevocationActionType::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_KEY_REVOCATION_ACTION_TYPE" => {
                    Some(Self::UndefinedKeyRevocationActionType)
                }
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrivateIpv6GoogleAccess {
        UndefinedPrivateIpv6GoogleAccess = 0,
        EnableBidirectionalAccessToGoogle = 427975994,
        EnableOutboundVmAccessToGoogle = 288210263,
        InheritFromSubnetwork = 530256959,
    }
    impl PrivateIpv6GoogleAccess {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PrivateIpv6GoogleAccess::UndefinedPrivateIpv6GoogleAccess => {
                    "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS"
                }
                PrivateIpv6GoogleAccess::EnableBidirectionalAccessToGoogle => {
                    "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
                }
                PrivateIpv6GoogleAccess::EnableOutboundVmAccessToGoogle => {
                    "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
                }
                PrivateIpv6GoogleAccess::InheritFromSubnetwork => {
                    "INHERIT_FROM_SUBNETWORK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS" => {
                    Some(Self::UndefinedPrivateIpv6GoogleAccess)
                }
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableBidirectionalAccessToGoogle)
                }
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableOutboundVmAccessToGoogle)
                }
                "INHERIT_FROM_SUBNETWORK" => Some(Self::InheritFromSubnetwork),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancePropertiesPatch {
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "86866735")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceReference {
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceSettings {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<InstanceSettingsMetadata>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceSettingsMetadata {
    #[prost(map = "string, string", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceTemplate {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "147688755")]
    pub properties: ::core::option::Option<InstanceProperties>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "396315705")]
    pub source_instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "135342156")]
    pub source_instance_params: ::core::option::Option<SourceInstanceParams>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceTemplateAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstanceTemplatesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceTemplateList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceTemplate>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceTemplatesScopedList {
    #[prost(message, repeated, tag = "459889679")]
    pub instance_templates: ::prost::alloc::vec::Vec<InstanceTemplate>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceWithNamedPorts {
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "427598732")]
    pub named_ports: ::prost::alloc::vec::Vec<NamedPort>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstanceWithNamedPorts`.
pub mod instance_with_named_ports {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Deprovisioning = 428935662,
        Provisioning = 290896621,
        Repairing = 413483285,
        Running = 121282975,
        Staging = 431072283,
        Stopped = 444276141,
        Stopping = 350791796,
        Suspended = 51223995,
        Suspending = 514206246,
        Terminated = 250018339,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Deprovisioning => "DEPROVISIONING",
                Status::Provisioning => "PROVISIONING",
                Status::Repairing => "REPAIRING",
                Status::Running => "RUNNING",
                Status::Staging => "STAGING",
                Status::Stopped => "STOPPED",
                Status::Stopping => "STOPPING",
                Status::Suspended => "SUSPENDED",
                Status::Suspending => "SUSPENDING",
                Status::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DEPROVISIONING" => Some(Self::Deprovisioning),
                "PROVISIONING" => Some(Self::Provisioning),
                "REPAIRING" => Some(Self::Repairing),
                "RUNNING" => Some(Self::Running),
                "STAGING" => Some(Self::Staging),
                "STOPPED" => Some(Self::Stopped),
                "STOPPING" => Some(Self::Stopping),
                "SUSPENDED" => Some(Self::Suspended),
                "SUSPENDING" => Some(Self::Suspending),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesAddResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesBulkInsertOperationMetadata {
    #[prost(map = "string, message", tag = "167851162")]
    pub per_location_status: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        BulkInsertOperationStatus,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesGetEffectiveFirewallsResponse {
    #[prost(message, repeated, tag = "410985794")]
    pub firewall_policys: ::prost::alloc::vec::Vec<
        InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy,
    >,
    #[prost(message, repeated, tag = "272245619")]
    pub firewalls: ::prost::alloc::vec::Vec<Firewall>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    #[prost(string, optional, tag = "4473832")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<FirewallPolicyRule>,
    #[prost(string, optional, tag = "492051566")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy`.
pub mod instances_get_effective_firewalls_response_effective_firewall_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Hierarchy = 69902869,
        Network = 413984270,
        NetworkRegional = 190804272,
        Unspecified = 526786327,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Hierarchy => "HIERARCHY",
                Type::Network => "NETWORK",
                Type::NetworkRegional => "NETWORK_REGIONAL",
                Type::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "HIERARCHY" => Some(Self::Hierarchy),
                "NETWORK" => Some(Self::Network),
                "NETWORK_REGIONAL" => Some(Self::NetworkRegional),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesRemoveResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesScopedList {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<Instance>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetLabelsRequest {
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetMachineResourcesRequest {
    #[prost(message, repeated, tag = "463595119")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetMachineTypeRequest {
    #[prost(string, optional, tag = "227711026")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetMinCpuPlatformRequest {
    #[prost(string, optional, tag = "242912759")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetNameRequest {
    #[prost(string, optional, tag = "394983825")]
    pub current_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetSecurityPolicyRequest {
    #[prost(string, repeated, tag = "52735243")]
    pub network_interfaces: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesSetServiceAccountRequest {
    #[prost(string, optional, tag = "96619420")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "165973151")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstancesStartWithEncryptionKeyRequest {
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<CustomerEncryptionKeyProtectedDisk>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantSnapshot {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<InstantSnapshotResourceStatus>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "454190809")]
    pub source_disk_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InstantSnapshot`.
pub mod instant_snapshot {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
        Unavailable = 413756464,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Ready => "READY",
                Status::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantSnapshotAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InstantSnapshotsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantSnapshotList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstantSnapshot>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InstantSnapshotResourceStatus {
    #[prost(int64, optional, tag = "387548913")]
    pub storage_size_bytes: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantSnapshotsScopedList {
    #[prost(message, repeated, tag = "329637457")]
    pub instant_snapshots: ::prost::alloc::vec::Vec<InstantSnapshot>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Int64RangeMatch {
    #[prost(int64, optional, tag = "322439897")]
    pub range_end: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "103333600")]
    pub range_start: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interconnect {
    #[prost(bool, optional, tag = "445675089")]
    pub admin_enabled: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "496344307")]
    pub available_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "164839855")]
    pub circuit_infos: ::prost::alloc::vec::Vec<InterconnectCircuitInfo>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3665484")]
    pub customer_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "264484123")]
    pub expected_outages: ::prost::alloc::vec::Vec<InterconnectOutageNotification>,
    #[prost(string, optional, tag = "443105954")]
    pub google_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "534944469")]
    pub google_reference_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, repeated, tag = "425388415")]
    pub interconnect_attachments: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "515165259")]
    pub interconnect_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "523207775")]
    pub link_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "290430901")]
    pub location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "528867490")]
    pub macsec: ::core::option::Option<InterconnectMacsec>,
    #[prost(bool, optional, tag = "194203812")]
    pub macsec_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "14072832")]
    pub noc_contact_email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "201070847")]
    pub operational_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "207735769")]
    pub peer_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "410888565")]
    pub provisioned_link_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "324388750")]
    pub remote_location: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "461240814")]
    pub requested_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "45051387")]
    pub requested_link_count: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Interconnect`.
pub mod interconnect {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AvailableFeatures {
        UndefinedAvailableFeatures = 0,
    }
    impl AvailableFeatures {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AvailableFeatures::UndefinedAvailableFeatures => {
                    "UNDEFINED_AVAILABLE_FEATURES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AVAILABLE_FEATURES" => Some(Self::UndefinedAvailableFeatures),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InterconnectType {
        UndefinedInterconnectType = 0,
        Dedicated = 258411983,
        ItPrivate = 335677007,
        Partner = 461924520,
    }
    impl InterconnectType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InterconnectType::UndefinedInterconnectType => {
                    "UNDEFINED_INTERCONNECT_TYPE"
                }
                InterconnectType::Dedicated => "DEDICATED",
                InterconnectType::ItPrivate => "IT_PRIVATE",
                InterconnectType::Partner => "PARTNER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INTERCONNECT_TYPE" => Some(Self::UndefinedInterconnectType),
                "DEDICATED" => Some(Self::Dedicated),
                "IT_PRIVATE" => Some(Self::ItPrivate),
                "PARTNER" => Some(Self::Partner),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LinkType {
        UndefinedLinkType = 0,
        Ethernet100gLr = 337672551,
        Ethernet10gLr = 236739749,
    }
    impl LinkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LinkType::UndefinedLinkType => "UNDEFINED_LINK_TYPE",
                LinkType::Ethernet100gLr => "LINK_TYPE_ETHERNET_100G_LR",
                LinkType::Ethernet10gLr => "LINK_TYPE_ETHERNET_10G_LR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LINK_TYPE" => Some(Self::UndefinedLinkType),
                "LINK_TYPE_ETHERNET_100G_LR" => Some(Self::Ethernet100gLr),
                "LINK_TYPE_ETHERNET_10G_LR" => Some(Self::Ethernet10gLr),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationalStatus {
        UndefinedOperationalStatus = 0,
        OsActive = 55721409,
        OsUnprovisioned = 239771840,
    }
    impl OperationalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationalStatus::UndefinedOperationalStatus => {
                    "UNDEFINED_OPERATIONAL_STATUS"
                }
                OperationalStatus::OsActive => "OS_ACTIVE",
                OperationalStatus::OsUnprovisioned => "OS_UNPROVISIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OPERATIONAL_STATUS" => Some(Self::UndefinedOperationalStatus),
                "OS_ACTIVE" => Some(Self::OsActive),
                "OS_UNPROVISIONED" => Some(Self::OsUnprovisioned),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestedFeatures {
        UndefinedRequestedFeatures = 0,
    }
    impl RequestedFeatures {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RequestedFeatures::UndefinedRequestedFeatures => {
                    "UNDEFINED_REQUESTED_FEATURES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_REQUESTED_FEATURES" => Some(Self::UndefinedRequestedFeatures),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Unprovisioned = 517333979,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Unprovisioned => "UNPROVISIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "UNPROVISIONED" => Some(Self::Unprovisioned),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachment {
    #[prost(bool, optional, tag = "445675089")]
    pub admin_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "181715121")]
    pub bandwidth: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "70682522")]
    pub candidate_ipv6_subnets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "237842938")]
    pub candidate_subnets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "287392776")]
    pub cloud_router_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "451922376")]
    pub cloud_router_ipv6_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "521282701")]
    pub cloud_router_ipv6_interface_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "179681389")]
    pub configuration_constraints: ::core::option::Option<
        InterconnectAttachmentConfigurationConstraints,
    >,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "332475761")]
    pub customer_router_ip_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "290127089")]
    pub customer_router_ipv6_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "380994308")]
    pub customer_router_ipv6_interface_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(int32, optional, tag = "34920075")]
    pub dataplane_version: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "71289510")]
    pub edge_availability_domain: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "97980291")]
    pub encryption: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "534944469")]
    pub google_reference_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "224601230")]
    pub interconnect: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "407648565")]
    pub ipsec_internal_addresses: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int32, optional, tag = "108462")]
    pub mtu: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "201070847")]
    pub operational_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "439695464")]
    pub pairing_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "438166149")]
    pub partner_asn: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "65908934")]
    pub partner_metadata: ::core::option::Option<InterconnectAttachmentPartnerMetadata>,
    #[prost(message, optional, tag = "237270531")]
    pub private_interconnect_info: ::core::option::Option<
        InterconnectAttachmentPrivateInfo,
    >,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "391954364")]
    pub remote_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "148608841")]
    pub router: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "279831048")]
    pub subnet_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "119927836")]
    pub vlan_tag8021q: ::core::option::Option<i32>,
}
/// Nested message and enum types in `InterconnectAttachment`.
pub mod interconnect_attachment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Bandwidth {
        UndefinedBandwidth = 0,
        Bps100m = 49547958,
        Bps10g = 278693006,
        Bps1g = 355358448,
        Bps200m = 49577749,
        Bps20g = 278693967,
        Bps2g = 355358479,
        Bps300m = 49607540,
        Bps400m = 49637331,
        Bps500m = 49667122,
        Bps50g = 278696850,
        Bps50m = 278696856,
        Bps5g = 355358572,
    }
    impl Bandwidth {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Bandwidth::UndefinedBandwidth => "UNDEFINED_BANDWIDTH",
                Bandwidth::Bps100m => "BPS_100M",
                Bandwidth::Bps10g => "BPS_10G",
                Bandwidth::Bps1g => "BPS_1G",
                Bandwidth::Bps200m => "BPS_200M",
                Bandwidth::Bps20g => "BPS_20G",
                Bandwidth::Bps2g => "BPS_2G",
                Bandwidth::Bps300m => "BPS_300M",
                Bandwidth::Bps400m => "BPS_400M",
                Bandwidth::Bps500m => "BPS_500M",
                Bandwidth::Bps50g => "BPS_50G",
                Bandwidth::Bps50m => "BPS_50M",
                Bandwidth::Bps5g => "BPS_5G",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BANDWIDTH" => Some(Self::UndefinedBandwidth),
                "BPS_100M" => Some(Self::Bps100m),
                "BPS_10G" => Some(Self::Bps10g),
                "BPS_1G" => Some(Self::Bps1g),
                "BPS_200M" => Some(Self::Bps200m),
                "BPS_20G" => Some(Self::Bps20g),
                "BPS_2G" => Some(Self::Bps2g),
                "BPS_300M" => Some(Self::Bps300m),
                "BPS_400M" => Some(Self::Bps400m),
                "BPS_500M" => Some(Self::Bps500m),
                "BPS_50G" => Some(Self::Bps50g),
                "BPS_50M" => Some(Self::Bps50m),
                "BPS_5G" => Some(Self::Bps5g),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EdgeAvailabilityDomain {
        UndefinedEdgeAvailabilityDomain = 0,
        AvailabilityDomain1 = 349552090,
        AvailabilityDomain2 = 349552091,
        AvailabilityDomainAny = 375256373,
    }
    impl EdgeAvailabilityDomain {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EdgeAvailabilityDomain::UndefinedEdgeAvailabilityDomain => {
                    "UNDEFINED_EDGE_AVAILABILITY_DOMAIN"
                }
                EdgeAvailabilityDomain::AvailabilityDomain1 => "AVAILABILITY_DOMAIN_1",
                EdgeAvailabilityDomain::AvailabilityDomain2 => "AVAILABILITY_DOMAIN_2",
                EdgeAvailabilityDomain::AvailabilityDomainAny => {
                    "AVAILABILITY_DOMAIN_ANY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_EDGE_AVAILABILITY_DOMAIN" => {
                    Some(Self::UndefinedEdgeAvailabilityDomain)
                }
                "AVAILABILITY_DOMAIN_1" => Some(Self::AvailabilityDomain1),
                "AVAILABILITY_DOMAIN_2" => Some(Self::AvailabilityDomain2),
                "AVAILABILITY_DOMAIN_ANY" => Some(Self::AvailabilityDomainAny),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Encryption {
        UndefinedEncryption = 0,
        Ipsec = 69882282,
        None = 2402104,
    }
    impl Encryption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Encryption::UndefinedEncryption => "UNDEFINED_ENCRYPTION",
                Encryption::Ipsec => "IPSEC",
                Encryption::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENCRYPTION" => Some(Self::UndefinedEncryption),
                "IPSEC" => Some(Self::Ipsec),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationalStatus {
        UndefinedOperationalStatus = 0,
        OsActive = 55721409,
        OsUnprovisioned = 239771840,
    }
    impl OperationalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationalStatus::UndefinedOperationalStatus => {
                    "UNDEFINED_OPERATIONAL_STATUS"
                }
                OperationalStatus::OsActive => "OS_ACTIVE",
                OperationalStatus::OsUnprovisioned => "OS_UNPROVISIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OPERATIONAL_STATUS" => Some(Self::UndefinedOperationalStatus),
                "OS_ACTIVE" => Some(Self::OsActive),
                "OS_UNPROVISIONED" => Some(Self::OsUnprovisioned),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Defunct = 115891759,
        PartnerRequestReceived = 513587304,
        PendingCustomer = 167494054,
        PendingPartner = 387890656,
        Unspecified = 470755401,
        Unprovisioned = 517333979,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Defunct => "DEFUNCT",
                State::PartnerRequestReceived => "PARTNER_REQUEST_RECEIVED",
                State::PendingCustomer => "PENDING_CUSTOMER",
                State::PendingPartner => "PENDING_PARTNER",
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Unprovisioned => "UNPROVISIONED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "DEFUNCT" => Some(Self::Defunct),
                "PARTNER_REQUEST_RECEIVED" => Some(Self::PartnerRequestReceived),
                "PENDING_CUSTOMER" => Some(Self::PendingCustomer),
                "PENDING_PARTNER" => Some(Self::PendingPartner),
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNPROVISIONED" => Some(Self::Unprovisioned),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Dedicated = 258411983,
        Partner = 461924520,
        PartnerProvider = 483261352,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Dedicated => "DEDICATED",
                Type::Partner => "PARTNER",
                Type::PartnerProvider => "PARTNER_PROVIDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "DEDICATED" => Some(Self::Dedicated),
                "PARTNER" => Some(Self::Partner),
                "PARTNER_PROVIDER" => Some(Self::PartnerProvider),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        InterconnectAttachmentsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentConfigurationConstraints {
    #[prost(string, optional, tag = "373093386")]
    pub bgp_md5: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "475946370")]
    pub bgp_peer_asn_ranges: ::prost::alloc::vec::Vec<
        InterconnectAttachmentConfigurationConstraintsBgpPeerAsnRange,
    >,
}
/// Nested message and enum types in `InterconnectAttachmentConfigurationConstraints`.
pub mod interconnect_attachment_configuration_constraints {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BgpMd5 {
        UndefinedBgpMd5 = 0,
        Md5Optional = 532156673,
        Md5Required = 218034496,
        Md5Unsupported = 86962388,
    }
    impl BgpMd5 {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BgpMd5::UndefinedBgpMd5 => "UNDEFINED_BGP_MD5",
                BgpMd5::Md5Optional => "MD5_OPTIONAL",
                BgpMd5::Md5Required => "MD5_REQUIRED",
                BgpMd5::Md5Unsupported => "MD5_UNSUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BGP_MD5" => Some(Self::UndefinedBgpMd5),
                "MD5_OPTIONAL" => Some(Self::Md5Optional),
                "MD5_REQUIRED" => Some(Self::Md5Required),
                "MD5_UNSUPPORTED" => Some(Self::Md5Unsupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentConfigurationConstraintsBgpPeerAsnRange {
    #[prost(uint32, optional, tag = "107876")]
    pub max: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "108114")]
    pub min: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InterconnectAttachment>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentPartnerMetadata {
    #[prost(string, optional, tag = "514963356")]
    pub interconnect_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "161747874")]
    pub partner_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "269182748")]
    pub portal_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentPrivateInfo {
    #[prost(uint32, optional, tag = "271820992")]
    pub tag8021q: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectAttachmentsScopedList {
    #[prost(message, repeated, tag = "425388415")]
    pub interconnect_attachments: ::prost::alloc::vec::Vec<InterconnectAttachment>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectCircuitInfo {
    #[prost(string, optional, tag = "28771859")]
    pub customer_demarc_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "262014711")]
    pub google_circuit_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "448196270")]
    pub google_demarc_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnostics {
    #[prost(message, repeated, tag = "414591761")]
    pub arp_caches: ::prost::alloc::vec::Vec<InterconnectDiagnosticsArpEntry>,
    #[prost(string, optional, tag = "434939028")]
    pub bundle_aggregation_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "106433500")]
    pub bundle_operational_status: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "102977465")]
    pub links: ::prost::alloc::vec::Vec<InterconnectDiagnosticsLinkStatus>,
    #[prost(string, optional, tag = "332540164")]
    pub mac_address: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InterconnectDiagnostics`.
pub mod interconnect_diagnostics {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BundleAggregationType {
        UndefinedBundleAggregationType = 0,
        Lacp = 27758925,
        Static = 50678873,
    }
    impl BundleAggregationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BundleAggregationType::UndefinedBundleAggregationType => {
                    "UNDEFINED_BUNDLE_AGGREGATION_TYPE"
                }
                BundleAggregationType::Lacp => "BUNDLE_AGGREGATION_TYPE_LACP",
                BundleAggregationType::Static => "BUNDLE_AGGREGATION_TYPE_STATIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BUNDLE_AGGREGATION_TYPE" => {
                    Some(Self::UndefinedBundleAggregationType)
                }
                "BUNDLE_AGGREGATION_TYPE_LACP" => Some(Self::Lacp),
                "BUNDLE_AGGREGATION_TYPE_STATIC" => Some(Self::Static),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BundleOperationalStatus {
        UndefinedBundleOperationalStatus = 0,
        Down = 453842693,
        Up = 161366462,
    }
    impl BundleOperationalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BundleOperationalStatus::UndefinedBundleOperationalStatus => {
                    "UNDEFINED_BUNDLE_OPERATIONAL_STATUS"
                }
                BundleOperationalStatus::Down => "BUNDLE_OPERATIONAL_STATUS_DOWN",
                BundleOperationalStatus::Up => "BUNDLE_OPERATIONAL_STATUS_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BUNDLE_OPERATIONAL_STATUS" => {
                    Some(Self::UndefinedBundleOperationalStatus)
                }
                "BUNDLE_OPERATIONAL_STATUS_DOWN" => Some(Self::Down),
                "BUNDLE_OPERATIONAL_STATUS_UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnosticsArpEntry {
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "332540164")]
    pub mac_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnosticsLinkLacpStatus {
    #[prost(string, optional, tag = "91210405")]
    pub google_system_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "343821342")]
    pub neighbor_system_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InterconnectDiagnosticsLinkLACPStatus`.
pub mod interconnect_diagnostics_link_lacp_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Detached = 216562546,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Detached => "DETACHED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "DETACHED" => Some(Self::Detached),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnosticsLinkOpticalPower {
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "111972721")]
    pub value: ::core::option::Option<f32>,
}
/// Nested message and enum types in `InterconnectDiagnosticsLinkOpticalPower`.
pub mod interconnect_diagnostics_link_optical_power {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        HighAlarm = 305363284,
        HighWarning = 220984799,
        LowAlarm = 316659046,
        LowWarning = 338793841,
        Ok = 2524,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::HighAlarm => "HIGH_ALARM",
                State::HighWarning => "HIGH_WARNING",
                State::LowAlarm => "LOW_ALARM",
                State::LowWarning => "LOW_WARNING",
                State::Ok => "OK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "HIGH_ALARM" => Some(Self::HighAlarm),
                "HIGH_WARNING" => Some(Self::HighWarning),
                "LOW_ALARM" => Some(Self::LowAlarm),
                "LOW_WARNING" => Some(Self::LowWarning),
                "OK" => Some(Self::Ok),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnosticsLinkStatus {
    #[prost(message, repeated, tag = "414591761")]
    pub arp_caches: ::prost::alloc::vec::Vec<InterconnectDiagnosticsArpEntry>,
    #[prost(string, optional, tag = "225180977")]
    pub circuit_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51084")]
    pub google_demarc: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "361210415")]
    pub lacp_status: ::core::option::Option<InterconnectDiagnosticsLinkLacpStatus>,
    #[prost(message, optional, tag = "528867490")]
    pub macsec: ::core::option::Option<InterconnectDiagnosticsMacsecStatus>,
    #[prost(string, optional, tag = "201070847")]
    pub operational_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "244717279")]
    pub receiving_optical_power: ::core::option::Option<
        InterconnectDiagnosticsLinkOpticalPower,
    >,
    #[prost(message, optional, tag = "459431197")]
    pub transmitting_optical_power: ::core::option::Option<
        InterconnectDiagnosticsLinkOpticalPower,
    >,
}
/// Nested message and enum types in `InterconnectDiagnosticsLinkStatus`.
pub mod interconnect_diagnostics_link_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationalStatus {
        UndefinedOperationalStatus = 0,
        LinkOperationalStatusDown = 281653885,
        LinkOperationalStatusUp = 305879862,
    }
    impl OperationalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationalStatus::UndefinedOperationalStatus => {
                    "UNDEFINED_OPERATIONAL_STATUS"
                }
                OperationalStatus::LinkOperationalStatusDown => {
                    "LINK_OPERATIONAL_STATUS_DOWN"
                }
                OperationalStatus::LinkOperationalStatusUp => {
                    "LINK_OPERATIONAL_STATUS_UP"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OPERATIONAL_STATUS" => Some(Self::UndefinedOperationalStatus),
                "LINK_OPERATIONAL_STATUS_DOWN" => Some(Self::LinkOperationalStatusDown),
                "LINK_OPERATIONAL_STATUS_UP" => Some(Self::LinkOperationalStatusUp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectDiagnosticsMacsecStatus {
    #[prost(string, optional, tag = "98566")]
    pub ckn: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "129704914")]
    pub operational: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Interconnect>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectLocation {
    #[prost(string, optional, tag = "462920692")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "158459920")]
    pub availability_zone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "496344307")]
    pub available_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "509504298")]
    pub available_link_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3053931")]
    pub city: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "133442996")]
    pub continent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "533303309")]
    pub facility_provider: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "87269125")]
    pub facility_provider_facility_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "536567094")]
    pub peeringdb_facility_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "312194170")]
    pub region_infos: ::prost::alloc::vec::Vec<InterconnectLocationRegionInfo>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "83983214")]
    pub supports_pzs: ::core::option::Option<bool>,
}
/// Nested message and enum types in `InterconnectLocation`.
pub mod interconnect_location {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AvailableFeatures {
        UndefinedAvailableFeatures = 0,
        IfMacsec = 396279300,
    }
    impl AvailableFeatures {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AvailableFeatures::UndefinedAvailableFeatures => {
                    "UNDEFINED_AVAILABLE_FEATURES"
                }
                AvailableFeatures::IfMacsec => "IF_MACSEC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AVAILABLE_FEATURES" => Some(Self::UndefinedAvailableFeatures),
                "IF_MACSEC" => Some(Self::IfMacsec),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AvailableLinkTypes {
        UndefinedAvailableLinkTypes = 0,
        LinkTypeEthernet100gLr = 337672551,
        LinkTypeEthernet10gLr = 236739749,
    }
    impl AvailableLinkTypes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AvailableLinkTypes::UndefinedAvailableLinkTypes => {
                    "UNDEFINED_AVAILABLE_LINK_TYPES"
                }
                AvailableLinkTypes::LinkTypeEthernet100gLr => {
                    "LINK_TYPE_ETHERNET_100G_LR"
                }
                AvailableLinkTypes::LinkTypeEthernet10gLr => "LINK_TYPE_ETHERNET_10G_LR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AVAILABLE_LINK_TYPES" => {
                    Some(Self::UndefinedAvailableLinkTypes)
                }
                "LINK_TYPE_ETHERNET_100G_LR" => Some(Self::LinkTypeEthernet100gLr),
                "LINK_TYPE_ETHERNET_10G_LR" => Some(Self::LinkTypeEthernet10gLr),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Continent {
        UndefinedContinent = 0,
        Africa = 317443706,
        AsiaPac = 119782269,
        CAfrica = 71993846,
        CAsiaPac = 465668089,
        CEurope = 200369438,
        CNorthAmerica = 275697048,
        CSouthAmerica = 397149792,
        Europe = 445819298,
        NorthAmerica = 448015508,
        SouthAmerica = 32597340,
    }
    impl Continent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Continent::UndefinedContinent => "UNDEFINED_CONTINENT",
                Continent::Africa => "AFRICA",
                Continent::AsiaPac => "ASIA_PAC",
                Continent::CAfrica => "C_AFRICA",
                Continent::CAsiaPac => "C_ASIA_PAC",
                Continent::CEurope => "C_EUROPE",
                Continent::CNorthAmerica => "C_NORTH_AMERICA",
                Continent::CSouthAmerica => "C_SOUTH_AMERICA",
                Continent::Europe => "EUROPE",
                Continent::NorthAmerica => "NORTH_AMERICA",
                Continent::SouthAmerica => "SOUTH_AMERICA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONTINENT" => Some(Self::UndefinedContinent),
                "AFRICA" => Some(Self::Africa),
                "ASIA_PAC" => Some(Self::AsiaPac),
                "C_AFRICA" => Some(Self::CAfrica),
                "C_ASIA_PAC" => Some(Self::CAsiaPac),
                "C_EUROPE" => Some(Self::CEurope),
                "C_NORTH_AMERICA" => Some(Self::CNorthAmerica),
                "C_SOUTH_AMERICA" => Some(Self::CSouthAmerica),
                "EUROPE" => Some(Self::Europe),
                "NORTH_AMERICA" => Some(Self::NorthAmerica),
                "SOUTH_AMERICA" => Some(Self::SouthAmerica),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Available = 442079913,
        Closed = 380163436,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Available => "AVAILABLE",
                Status::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "AVAILABLE" => Some(Self::Available),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectLocationList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InterconnectLocation>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectLocationRegionInfo {
    #[prost(int64, optional, tag = "422543866")]
    pub expected_rtt_ms: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "101517893")]
    pub location_presence: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InterconnectLocationRegionInfo`.
pub mod interconnect_location_region_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationPresence {
        UndefinedLocationPresence = 0,
        Global = 494663587,
        LocalRegion = 403535464,
        LpGlobal = 429584062,
        LpLocalRegion = 488598851,
    }
    impl LocationPresence {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationPresence::UndefinedLocationPresence => {
                    "UNDEFINED_LOCATION_PRESENCE"
                }
                LocationPresence::Global => "GLOBAL",
                LocationPresence::LocalRegion => "LOCAL_REGION",
                LocationPresence::LpGlobal => "LP_GLOBAL",
                LocationPresence::LpLocalRegion => "LP_LOCAL_REGION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOCATION_PRESENCE" => Some(Self::UndefinedLocationPresence),
                "GLOBAL" => Some(Self::Global),
                "LOCAL_REGION" => Some(Self::LocalRegion),
                "LP_GLOBAL" => Some(Self::LpGlobal),
                "LP_LOCAL_REGION" => Some(Self::LpLocalRegion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectMacsec {
    #[prost(bool, optional, tag = "532597451")]
    pub fail_open: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "420308466")]
    pub pre_shared_keys: ::prost::alloc::vec::Vec<InterconnectMacsecPreSharedKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectMacsecConfig {
    #[prost(message, repeated, tag = "420308466")]
    pub pre_shared_keys: ::prost::alloc::vec::Vec<InterconnectMacsecConfigPreSharedKey>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectMacsecConfigPreSharedKey {
    #[prost(string, optional, tag = "98253")]
    pub cak: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "98566")]
    pub ckn: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectMacsecPreSharedKey {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectOutageNotification {
    #[prost(string, repeated, tag = "177717013")]
    pub affected_circuits: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "114938801")]
    pub end_time: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "369639136")]
    pub issue_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InterconnectOutageNotification`.
pub mod interconnect_outage_notification {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IssueType {
        UndefinedIssueType = 0,
        ItOutage = 175779973,
        ItPartialOutage = 92103971,
        Outage = 195285745,
        PartialOutage = 147053455,
    }
    impl IssueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IssueType::UndefinedIssueType => "UNDEFINED_ISSUE_TYPE",
                IssueType::ItOutage => "IT_OUTAGE",
                IssueType::ItPartialOutage => "IT_PARTIAL_OUTAGE",
                IssueType::Outage => "OUTAGE",
                IssueType::PartialOutage => "PARTIAL_OUTAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ISSUE_TYPE" => Some(Self::UndefinedIssueType),
                "IT_OUTAGE" => Some(Self::ItOutage),
                "IT_PARTIAL_OUTAGE" => Some(Self::ItPartialOutage),
                "OUTAGE" => Some(Self::Outage),
                "PARTIAL_OUTAGE" => Some(Self::PartialOutage),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Source {
        UndefinedSource = 0,
        Google = 497439289,
        NsrcGoogle = 510574562,
    }
    impl Source {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Source::UndefinedSource => "UNDEFINED_SOURCE",
                Source::Google => "GOOGLE",
                Source::NsrcGoogle => "NSRC_GOOGLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SOURCE" => Some(Self::UndefinedSource),
                "GOOGLE" => Some(Self::Google),
                "NSRC_GOOGLE" => Some(Self::NsrcGoogle),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Cancelled = 41957681,
        Completed = 309921323,
        NsActive = 252563136,
        NsCanceled = 506579411,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Cancelled => "CANCELLED",
                State::Completed => "COMPLETED",
                State::NsActive => "NS_ACTIVE",
                State::NsCanceled => "NS_CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "CANCELLED" => Some(Self::Cancelled),
                "COMPLETED" => Some(Self::Completed),
                "NS_ACTIVE" => Some(Self::NsActive),
                "NS_CANCELED" => Some(Self::NsCanceled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectRemoteLocation {
    #[prost(string, optional, tag = "462920692")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "326825041")]
    pub attachment_configuration_constraints: ::core::option::Option<
        InterconnectAttachmentConfigurationConstraints,
    >,
    #[prost(string, optional, tag = "3053931")]
    pub city: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3909174")]
    pub constraints: ::core::option::Option<InterconnectRemoteLocationConstraints>,
    #[prost(string, optional, tag = "133442996")]
    pub continent: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "533303309")]
    pub facility_provider: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "87269125")]
    pub facility_provider_facility_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3313826")]
    pub lacp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "245219253")]
    pub max_lag_size100_gbps: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "294007573")]
    pub max_lag_size10_gbps: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "536567094")]
    pub peeringdb_facility_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "442063278")]
    pub permitted_connections: ::prost::alloc::vec::Vec<
        InterconnectRemoteLocationPermittedConnections,
    >,
    #[prost(string, optional, tag = "391954364")]
    pub remote_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `InterconnectRemoteLocation`.
pub mod interconnect_remote_location {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Continent {
        UndefinedContinent = 0,
        Africa = 317443706,
        AsiaPac = 119782269,
        Europe = 445819298,
        NorthAmerica = 448015508,
        SouthAmerica = 32597340,
    }
    impl Continent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Continent::UndefinedContinent => "UNDEFINED_CONTINENT",
                Continent::Africa => "AFRICA",
                Continent::AsiaPac => "ASIA_PAC",
                Continent::Europe => "EUROPE",
                Continent::NorthAmerica => "NORTH_AMERICA",
                Continent::SouthAmerica => "SOUTH_AMERICA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONTINENT" => Some(Self::UndefinedContinent),
                "AFRICA" => Some(Self::Africa),
                "ASIA_PAC" => Some(Self::AsiaPac),
                "EUROPE" => Some(Self::Europe),
                "NORTH_AMERICA" => Some(Self::NorthAmerica),
                "SOUTH_AMERICA" => Some(Self::SouthAmerica),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Lacp {
        UndefinedLacp = 0,
        Supported = 339576113,
        Unsupported = 203930104,
    }
    impl Lacp {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Lacp::UndefinedLacp => "UNDEFINED_LACP",
                Lacp::Supported => "LACP_SUPPORTED",
                Lacp::Unsupported => "LACP_UNSUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LACP" => Some(Self::UndefinedLacp),
                "LACP_SUPPORTED" => Some(Self::Supported),
                "LACP_UNSUPPORTED" => Some(Self::Unsupported),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Available = 442079913,
        Closed = 380163436,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Available => "AVAILABLE",
                Status::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "AVAILABLE" => Some(Self::Available),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectRemoteLocationConstraints {
    #[prost(string, optional, tag = "495917351")]
    pub port_pair_remote_location: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "478214506")]
    pub port_pair_vlan: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "184473670")]
    pub subnet_length_range: ::core::option::Option<
        InterconnectRemoteLocationConstraintsSubnetLengthRange,
    >,
}
/// Nested message and enum types in `InterconnectRemoteLocationConstraints`.
pub mod interconnect_remote_location_constraints {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortPairRemoteLocation {
        UndefinedPortPairRemoteLocation = 0,
        PortPairMatchingRemoteLocation = 207291859,
        PortPairUnconstrainedRemoteLocation = 60609829,
    }
    impl PortPairRemoteLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortPairRemoteLocation::UndefinedPortPairRemoteLocation => {
                    "UNDEFINED_PORT_PAIR_REMOTE_LOCATION"
                }
                PortPairRemoteLocation::PortPairMatchingRemoteLocation => {
                    "PORT_PAIR_MATCHING_REMOTE_LOCATION"
                }
                PortPairRemoteLocation::PortPairUnconstrainedRemoteLocation => {
                    "PORT_PAIR_UNCONSTRAINED_REMOTE_LOCATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_PAIR_REMOTE_LOCATION" => {
                    Some(Self::UndefinedPortPairRemoteLocation)
                }
                "PORT_PAIR_MATCHING_REMOTE_LOCATION" => {
                    Some(Self::PortPairMatchingRemoteLocation)
                }
                "PORT_PAIR_UNCONSTRAINED_REMOTE_LOCATION" => {
                    Some(Self::PortPairUnconstrainedRemoteLocation)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortPairVlan {
        UndefinedPortPairVlan = 0,
        PortPairMatchingVlan = 250295358,
        PortPairUnconstrainedVlan = 175227948,
    }
    impl PortPairVlan {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortPairVlan::UndefinedPortPairVlan => "UNDEFINED_PORT_PAIR_VLAN",
                PortPairVlan::PortPairMatchingVlan => "PORT_PAIR_MATCHING_VLAN",
                PortPairVlan::PortPairUnconstrainedVlan => "PORT_PAIR_UNCONSTRAINED_VLAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_PAIR_VLAN" => Some(Self::UndefinedPortPairVlan),
                "PORT_PAIR_MATCHING_VLAN" => Some(Self::PortPairMatchingVlan),
                "PORT_PAIR_UNCONSTRAINED_VLAN" => Some(Self::PortPairUnconstrainedVlan),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InterconnectRemoteLocationConstraintsSubnetLengthRange {
    #[prost(int32, optional, tag = "107876")]
    pub max: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "108114")]
    pub min: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectRemoteLocationList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InterconnectRemoteLocation>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectRemoteLocationPermittedConnections {
    #[prost(string, optional, tag = "492235846")]
    pub interconnect_location: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectsGetDiagnosticsResponse {
    #[prost(message, optional, tag = "139315229")]
    pub result: ::core::option::Option<InterconnectDiagnostics>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterconnectsGetMacsecConfigResponse {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "139315229")]
    pub result: ::core::option::Option<InterconnectMacsecConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidateCacheUrlMapRequest {
    #[prost(message, optional, tag = "312795565")]
    pub cache_invalidation_rule_resource: ::core::option::Option<CacheInvalidationRule>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Items {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct License {
    #[prost(bool, optional, tag = "372412622")]
    pub charges_use_fee: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "1467179")]
    pub license_code: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "214292769")]
    pub resource_requirements: ::core::option::Option<LicenseResourceRequirements>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4349893")]
    pub transferable: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicenseCode {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "43550930")]
    pub license_alias: ::prost::alloc::vec::Vec<LicenseCodeLicenseAlias>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "4349893")]
    pub transferable: ::core::option::Option<bool>,
}
/// Nested message and enum types in `LicenseCode`.
pub mod license_code {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Disabled = 516696700,
        Enabled = 182130465,
        Restricted = 261551195,
        Unspecified = 470755401,
        Terminated = 250018339,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Disabled => "DISABLED",
                State::Enabled => "ENABLED",
                State::Restricted => "RESTRICTED",
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "DISABLED" => Some(Self::Disabled),
                "ENABLED" => Some(Self::Enabled),
                "RESTRICTED" => Some(Self::Restricted),
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicenseCodeLicenseAlias {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicenseResourceCommitment {
    #[prost(int64, optional, tag = "196759640")]
    pub amount: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "32482324")]
    pub cores_per_license: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "166757441")]
    pub license: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LicenseResourceRequirements {
    #[prost(int32, optional, tag = "477964836")]
    pub min_guest_cpu_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "504785894")]
    pub min_memory_mb: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LicensesListResponse {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<License>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAcceleratorTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAddressesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssociationsFirewallPolicyRequest {
    #[prost(string, optional, tag = "467318524")]
    pub target_resource: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAutoscalersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAvailableFeaturesRegionSslPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAvailableFeaturesSslPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendBucketsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBackendServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDiskTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisksStoragePoolsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "360473440")]
    pub storage_pool: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListErrorsInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListErrorsRegionInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExternalVpnGatewaysRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "459714768")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirewallsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListForwardingRulesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalAddressesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalForwardingRulesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalOperationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalOrganizationOperationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "459714768")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGlobalPublicDelegatedPrefixesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListHealthChecksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListImagesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceGroupManagerResizeRequestsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstanceTemplatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesInstanceGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "476255263")]
    pub instance_groups_list_instances_request_resource: ::core::option::Option<
        InstanceGroupsListInstancesRequest,
    >,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRegionInstanceGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "48239828")]
    pub region_instance_groups_list_instances_request_resource: ::core::option::Option<
        RegionInstanceGroupsListInstancesRequest,
    >,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstancesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInstantSnapshotsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterconnectAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterconnectLocationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterconnectRemoteLocationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterconnectsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLicensesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachineImagesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMachineTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagedInstancesInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListManagedInstancesRegionInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkEndpointsNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "59493390")]
    pub network_endpoint_groups_list_endpoints_request_resource: ::core::option::Option<
        NetworkEndpointGroupsListEndpointsRequest,
    >,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkEndpointsRegionNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "433907078")]
    pub network_endpoint_group: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworkFirewallPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNetworksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeTemplatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodeTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListNodesNodeGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPacketMirroringsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPeeringRoutesNetworksRequest {
    #[prost(string, optional, tag = "111150975")]
    pub direction: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "249571370")]
    pub peering_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
/// Nested message and enum types in `ListPeeringRoutesNetworksRequest`.
pub mod list_peering_routes_networks_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        UndefinedDirection = 0,
        Incoming = 338552870,
        Outgoing = 307438444,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::UndefinedDirection => "UNDEFINED_DIRECTION",
                Direction::Incoming => "INCOMING",
                Direction::Outgoing => "OUTGOING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DIRECTION" => Some(Self::UndefinedDirection),
                "INCOMING" => Some(Self::Incoming),
                "OUTGOING" => Some(Self::Outgoing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPerInstanceConfigsInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPerInstanceConfigsRegionInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPreconfiguredExpressionSetsSecurityPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicAdvertisedPrefixesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPublicDelegatedPrefixesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReferrersInstancesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionAutoscalersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionBackendServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionCommitmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionDiskTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionDisksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionHealthCheckServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionHealthChecksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionInstanceGroupManagersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionInstanceGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionInstanceTemplatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionInstantSnapshotsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionNetworkEndpointGroupsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionNetworkFirewallPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionNotificationEndpointsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionOperationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionSecurityPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionSslCertificatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionSslPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionTargetHttpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionTargetHttpsProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionTargetTcpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionUrlMapsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionZonesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRegionsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListReservationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListResourcePoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutersRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSecurityPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListServiceAttachmentsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSnapshotsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSslCertificatesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSslPoliciesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStoragePoolTypesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListStoragePoolsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubnetworksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetGrpcProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetHttpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetHttpsProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetInstancesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetPoolsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetSslProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetTcpProxiesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTargetVpnGatewaysRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUrlMapsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsableBackendServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsableRegionBackendServicesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUsableSubnetworksRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpnGatewaysRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpnTunnelsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListXpnHostsProjectsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "238266391")]
    pub projects_list_xpn_hosts_request_resource: ::core::option::Option<
        ProjectsListXpnHostsRequest,
    >,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZoneOperationsRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListZonesRequest {
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "54715419")]
    pub max_results: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "160562920")]
    pub order_by: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "19994697")]
    pub page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(bool, optional, tag = "517198390")]
    pub return_partial_success: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalDisk {
    #[prost(int32, optional, tag = "182933485")]
    pub disk_count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "93009052")]
    pub disk_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocalizedMessage {
    #[prost(string, optional, tag = "513150554")]
    pub locale: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationPolicy {
    #[prost(map = "string, message", tag = "413423454")]
    pub locations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        LocationPolicyLocation,
    >,
    #[prost(string, optional, tag = "338621299")]
    pub target_shape: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `LocationPolicy`.
pub mod location_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetShape {
        UndefinedTargetShape = 0,
        Any = 64972,
        AnySingleZone = 61100880,
        Balanced = 468409608,
    }
    impl TargetShape {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetShape::UndefinedTargetShape => "UNDEFINED_TARGET_SHAPE",
                TargetShape::Any => "ANY",
                TargetShape::AnySingleZone => "ANY_SINGLE_ZONE",
                TargetShape::Balanced => "BALANCED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TARGET_SHAPE" => Some(Self::UndefinedTargetShape),
                "ANY" => Some(Self::Any),
                "ANY_SINGLE_ZONE" => Some(Self::AnySingleZone),
                "BALANCED" => Some(Self::Balanced),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LocationPolicyLocation {
    #[prost(message, optional, tag = "3909174")]
    pub constraints: ::core::option::Option<LocationPolicyLocationConstraints>,
    #[prost(string, optional, tag = "150781147")]
    pub preference: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `LocationPolicyLocation`.
pub mod location_policy_location {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Preference {
        UndefinedPreference = 0,
        Allow = 62368553,
        Deny = 2094604,
        Unspecified = 496219571,
    }
    impl Preference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Preference::UndefinedPreference => "UNDEFINED_PREFERENCE",
                Preference::Allow => "ALLOW",
                Preference::Deny => "DENY",
                Preference::Unspecified => "PREFERENCE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PREFERENCE" => Some(Self::UndefinedPreference),
                "ALLOW" => Some(Self::Allow),
                "DENY" => Some(Self::Deny),
                "PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationPolicyLocationConstraints {
    #[prost(int32, optional, tag = "287620724")]
    pub max_count: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogConfig {
    #[prost(message, optional, tag = "412852561")]
    pub cloud_audit: ::core::option::Option<LogConfigCloudAuditOptions>,
    #[prost(message, optional, tag = "420959740")]
    pub counter: ::core::option::Option<LogConfigCounterOptions>,
    #[prost(message, optional, tag = "286633881")]
    pub data_access: ::core::option::Option<LogConfigDataAccessOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogConfigCloudAuditOptions {
    #[prost(message, optional, tag = "217861624")]
    pub authorization_logging_options: ::core::option::Option<
        AuthorizationLoggingOptions,
    >,
    #[prost(string, optional, tag = "402913958")]
    pub log_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `LogConfigCloudAuditOptions`.
pub mod log_config_cloud_audit_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogName {
        UndefinedLogName = 0,
        AdminActivity = 427503135,
        DataAccess = 238070681,
        UnspecifiedLogName = 410515182,
    }
    impl LogName {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LogName::UndefinedLogName => "UNDEFINED_LOG_NAME",
                LogName::AdminActivity => "ADMIN_ACTIVITY",
                LogName::DataAccess => "DATA_ACCESS",
                LogName::UnspecifiedLogName => "UNSPECIFIED_LOG_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOG_NAME" => Some(Self::UndefinedLogName),
                "ADMIN_ACTIVITY" => Some(Self::AdminActivity),
                "DATA_ACCESS" => Some(Self::DataAccess),
                "UNSPECIFIED_LOG_NAME" => Some(Self::UnspecifiedLogName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogConfigCounterOptions {
    #[prost(message, repeated, tag = "249651015")]
    pub custom_fields: ::prost::alloc::vec::Vec<LogConfigCounterOptionsCustomField>,
    #[prost(string, optional, tag = "97427706")]
    pub field: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "533067184")]
    pub metric: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogConfigCounterOptionsCustomField {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogConfigDataAccessOptions {
    #[prost(string, optional, tag = "402897342")]
    pub log_mode: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `LogConfigDataAccessOptions`.
pub mod log_config_data_access_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogMode {
        UndefinedLogMode = 0,
        LogFailClosed = 360469778,
        Unspecified = 88160822,
    }
    impl LogMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LogMode::UndefinedLogMode => "UNDEFINED_LOG_MODE",
                LogMode::LogFailClosed => "LOG_FAIL_CLOSED",
                LogMode::Unspecified => "LOG_MODE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOG_MODE" => Some(Self::UndefinedLogMode),
                "LOG_FAIL_CLOSED" => Some(Self::LogFailClosed),
                "LOG_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineImage {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "385550813")]
    pub guest_flush: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "215355165")]
    pub instance_properties: ::core::option::Option<InstanceProperties>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "528089087")]
    pub machine_image_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "397424318")]
    pub saved_disks: ::prost::alloc::vec::Vec<SavedDisk>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "370408498")]
    pub source_disk_encryption_keys: ::prost::alloc::vec::Vec<SourceDiskEncryptionKey>,
    #[prost(string, optional, tag = "396315705")]
    pub source_instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "475195641")]
    pub source_instance_properties: ::core::option::Option<SourceInstanceProperties>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "328005274")]
    pub storage_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "81855468")]
    pub total_storage_bytes: ::core::option::Option<i64>,
}
/// Nested message and enum types in `MachineImage`.
pub mod machine_image {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Invalid = 530283991,
        Ready = 77848963,
        Uploading = 267603489,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
                Status::Uploading => "UPLOADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                "UPLOADING" => Some(Self::Uploading),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineImageList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<MachineImage>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineType {
    #[prost(message, repeated, tag = "269577064")]
    pub accelerators: ::prost::alloc::vec::Vec<Accelerators>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "393356754")]
    pub guest_cpus: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "75331864")]
    pub image_space_gb: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "521399555")]
    pub is_shared_cpu: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "496220941")]
    pub maximum_persistent_disks: ::core::option::Option<i32>,
    #[prost(int64, optional, tag = "154274471")]
    pub maximum_persistent_disks_size_gb: ::core::option::Option<i64>,
    #[prost(int32, optional, tag = "116001171")]
    pub memory_mb: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "480778481")]
    pub scratch_disks: ::prost::alloc::vec::Vec<ScratchDisks>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineTypeAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        MachineTypesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<MachineType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MachineTypesScopedList {
    #[prost(message, repeated, tag = "79720065")]
    pub machine_types: ::prost::alloc::vec::Vec<MachineType>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagedInstance {
    #[prost(string, optional, tag = "178475964")]
    pub current_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "382667078")]
    pub instance_health: ::prost::alloc::vec::Vec<ManagedInstanceInstanceHealth>,
    #[prost(string, optional, tag = "174577372")]
    pub instance_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "434771492")]
    pub last_attempt: ::core::option::Option<ManagedInstanceLastAttempt>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "98661858")]
    pub preserved_state_from_config: ::core::option::Option<PreservedState>,
    #[prost(message, optional, tag = "470783954")]
    pub preserved_state_from_policy: ::core::option::Option<PreservedState>,
    #[prost(message, optional, tag = "351608024")]
    pub version: ::core::option::Option<ManagedInstanceVersion>,
}
/// Nested message and enum types in `ManagedInstance`.
pub mod managed_instance {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrentAction {
        UndefinedCurrentAction = 0,
        Abandoning = 388244813,
        Creating = 455564985,
        CreatingWithoutRetries = 428843785,
        Deleting = 528602024,
        None = 2402104,
        Recreating = 287278572,
        Refreshing = 163266343,
        Restarting = 320534387,
        Resuming = 446856618,
        Starting = 488820800,
        Verifying = 16982185,
    }
    impl CurrentAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CurrentAction::UndefinedCurrentAction => "UNDEFINED_CURRENT_ACTION",
                CurrentAction::Abandoning => "ABANDONING",
                CurrentAction::Creating => "CREATING",
                CurrentAction::CreatingWithoutRetries => "CREATING_WITHOUT_RETRIES",
                CurrentAction::Deleting => "DELETING",
                CurrentAction::None => "NONE",
                CurrentAction::Recreating => "RECREATING",
                CurrentAction::Refreshing => "REFRESHING",
                CurrentAction::Restarting => "RESTARTING",
                CurrentAction::Resuming => "RESUMING",
                CurrentAction::Starting => "STARTING",
                CurrentAction::Verifying => "VERIFYING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CURRENT_ACTION" => Some(Self::UndefinedCurrentAction),
                "ABANDONING" => Some(Self::Abandoning),
                "CREATING" => Some(Self::Creating),
                "CREATING_WITHOUT_RETRIES" => Some(Self::CreatingWithoutRetries),
                "DELETING" => Some(Self::Deleting),
                "NONE" => Some(Self::None),
                "RECREATING" => Some(Self::Recreating),
                "REFRESHING" => Some(Self::Refreshing),
                "RESTARTING" => Some(Self::Restarting),
                "RESUMING" => Some(Self::Resuming),
                "STARTING" => Some(Self::Starting),
                "VERIFYING" => Some(Self::Verifying),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceStatus {
        UndefinedInstanceStatus = 0,
        Deprovisioning = 428935662,
        Provisioning = 290896621,
        Repairing = 413483285,
        Running = 121282975,
        Staging = 431072283,
        Stopped = 444276141,
        Stopping = 350791796,
        Suspended = 51223995,
        Suspending = 514206246,
        Terminated = 250018339,
    }
    impl InstanceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceStatus::UndefinedInstanceStatus => "UNDEFINED_INSTANCE_STATUS",
                InstanceStatus::Deprovisioning => "DEPROVISIONING",
                InstanceStatus::Provisioning => "PROVISIONING",
                InstanceStatus::Repairing => "REPAIRING",
                InstanceStatus::Running => "RUNNING",
                InstanceStatus::Staging => "STAGING",
                InstanceStatus::Stopped => "STOPPED",
                InstanceStatus::Stopping => "STOPPING",
                InstanceStatus::Suspended => "SUSPENDED",
                InstanceStatus::Suspending => "SUSPENDING",
                InstanceStatus::Terminated => "TERMINATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANCE_STATUS" => Some(Self::UndefinedInstanceStatus),
                "DEPROVISIONING" => Some(Self::Deprovisioning),
                "PROVISIONING" => Some(Self::Provisioning),
                "REPAIRING" => Some(Self::Repairing),
                "RUNNING" => Some(Self::Running),
                "STAGING" => Some(Self::Staging),
                "STOPPED" => Some(Self::Stopped),
                "STOPPING" => Some(Self::Stopping),
                "SUSPENDED" => Some(Self::Suspended),
                "SUSPENDING" => Some(Self::Suspending),
                "TERMINATED" => Some(Self::Terminated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagedInstanceInstanceHealth {
    #[prost(string, optional, tag = "510470173")]
    pub detailed_health_state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "308876645")]
    pub health_check: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ManagedInstanceInstanceHealth`.
pub mod managed_instance_instance_health {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DetailedHealthState {
        UndefinedDetailedHealthState = 0,
        Draining = 480455402,
        Healthy = 439801213,
        Timeout = 477813057,
        Unhealthy = 462118084,
        Unknown = 433141802,
    }
    impl DetailedHealthState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DetailedHealthState::UndefinedDetailedHealthState => {
                    "UNDEFINED_DETAILED_HEALTH_STATE"
                }
                DetailedHealthState::Draining => "DRAINING",
                DetailedHealthState::Healthy => "HEALTHY",
                DetailedHealthState::Timeout => "TIMEOUT",
                DetailedHealthState::Unhealthy => "UNHEALTHY",
                DetailedHealthState::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DETAILED_HEALTH_STATE" => {
                    Some(Self::UndefinedDetailedHealthState)
                }
                "DRAINING" => Some(Self::Draining),
                "HEALTHY" => Some(Self::Healthy),
                "TIMEOUT" => Some(Self::Timeout),
                "UNHEALTHY" => Some(Self::Unhealthy),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagedInstanceLastAttempt {
    #[prost(message, optional, tag = "315977579")]
    pub errors: ::core::option::Option<Errors>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagedInstanceVersion {
    #[prost(string, optional, tag = "309248228")]
    pub instance_template: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Items>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataFilter {
    #[prost(message, repeated, tag = "307903142")]
    pub filter_labels: ::prost::alloc::vec::Vec<MetadataFilterLabelMatch>,
    #[prost(string, optional, tag = "239970368")]
    pub filter_match_criteria: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `MetadataFilter`.
pub mod metadata_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FilterMatchCriteria {
        UndefinedFilterMatchCriteria = 0,
        MatchAll = 180663271,
        MatchAny = 180663346,
        NotSet = 163646646,
    }
    impl FilterMatchCriteria {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FilterMatchCriteria::UndefinedFilterMatchCriteria => {
                    "UNDEFINED_FILTER_MATCH_CRITERIA"
                }
                FilterMatchCriteria::MatchAll => "MATCH_ALL",
                FilterMatchCriteria::MatchAny => "MATCH_ANY",
                FilterMatchCriteria::NotSet => "NOT_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_FILTER_MATCH_CRITERIA" => {
                    Some(Self::UndefinedFilterMatchCriteria)
                }
                "MATCH_ALL" => Some(Self::MatchAll),
                "MATCH_ANY" => Some(Self::MatchAny),
                "NOT_SET" => Some(Self::NotSet),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataFilterLabelMatch {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "409081924")]
    pub region_addresses_move_request_resource: ::core::option::Option<
        RegionAddressesMoveRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveDiskProjectRequest {
    #[prost(message, optional, tag = "313008458")]
    pub disk_move_request_resource: ::core::option::Option<DiskMoveRequest>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, tag = "459714768")]
    pub parent_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveGlobalAddressRequest {
    #[prost(string, tag = "462920692")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "302807283")]
    pub global_addresses_move_request_resource: ::core::option::Option<
        GlobalAddressesMoveRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MoveInstanceProjectRequest {
    #[prost(message, optional, tag = "311664194")]
    pub instance_move_request_resource: ::core::option::Option<InstanceMoveRequest>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NamedPort {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NatIpInfo {
    #[prost(message, repeated, tag = "241401884")]
    pub nat_ip_info_mappings: ::prost::alloc::vec::Vec<NatIpInfoNatIpInfoMapping>,
    #[prost(string, optional, tag = "425596649")]
    pub nat_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NatIpInfoNatIpInfoMapping {
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21113093")]
    pub nat_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111574433")]
    pub usage: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NatIpInfoNatIpInfoMapping`.
pub mod nat_ip_info_nat_ip_info_mapping {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        Auto = 2020783,
        Manual = 119397318,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::Auto => "AUTO",
                Mode::Manual => "MANUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "AUTO" => Some(Self::Auto),
                "MANUAL" => Some(Self::Manual),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Usage {
        UndefinedUsage = 0,
        InUse = 17393485,
        Unused = 360643030,
    }
    impl Usage {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Usage::UndefinedUsage => "UNDEFINED_USAGE",
                Usage::InUse => "IN_USE",
                Usage::Unused => "UNUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_USAGE" => Some(Self::UndefinedUsage),
                "IN_USE" => Some(Self::InUse),
                "UNUSED" => Some(Self::Unused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NatIpInfoResponse {
    #[prost(message, repeated, tag = "139315229")]
    pub result: ::prost::alloc::vec::Vec<NatIpInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Network {
    #[prost(string, optional, tag = "59234358")]
    pub i_pv4_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "256156690")]
    pub auto_create_subnetworks: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "423757720")]
    pub enable_ula_internal_ipv6: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "498173265")]
    pub firewall_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178678877")]
    pub gateway_i_pv4: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "277456807")]
    pub internal_ipv6_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "108462")]
    pub mtu: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "6504784")]
    pub network_firewall_policy_enforcement_order: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "69883187")]
    pub peerings: ::prost::alloc::vec::Vec<NetworkPeering>,
    #[prost(message, optional, tag = "523556059")]
    pub routing_config: ::core::option::Option<NetworkRoutingConfig>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "415853125")]
    pub subnetworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Network`.
pub mod network {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkFirewallPolicyEnforcementOrder {
        UndefinedNetworkFirewallPolicyEnforcementOrder = 0,
        AfterClassicFirewall = 154582608,
        BeforeClassicFirewall = 338458349,
    }
    impl NetworkFirewallPolicyEnforcementOrder {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkFirewallPolicyEnforcementOrder::UndefinedNetworkFirewallPolicyEnforcementOrder => {
                    "UNDEFINED_NETWORK_FIREWALL_POLICY_ENFORCEMENT_ORDER"
                }
                NetworkFirewallPolicyEnforcementOrder::AfterClassicFirewall => {
                    "AFTER_CLASSIC_FIREWALL"
                }
                NetworkFirewallPolicyEnforcementOrder::BeforeClassicFirewall => {
                    "BEFORE_CLASSIC_FIREWALL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_FIREWALL_POLICY_ENFORCEMENT_ORDER" => {
                    Some(Self::UndefinedNetworkFirewallPolicyEnforcementOrder)
                }
                "AFTER_CLASSIC_FIREWALL" => Some(Self::AfterClassicFirewall),
                "BEFORE_CLASSIC_FIREWALL" => Some(Self::BeforeClassicFirewall),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAttachment {
    #[prost(message, repeated, tag = "326078813")]
    pub connection_endpoints: ::prost::alloc::vec::Vec<
        NetworkAttachmentConnectedEndpoint,
    >,
    #[prost(string, optional, tag = "285818076")]
    pub connection_preference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "202804523")]
    pub producer_accept_lists: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "4112002")]
    pub producer_reject_lists: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "415853125")]
    pub subnetworks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkAttachment`.
pub mod network_attachment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectionPreference {
        UndefinedConnectionPreference = 0,
        AcceptAutomatic = 75250580,
        AcceptManual = 373061341,
        Invalid = 530283991,
    }
    impl ConnectionPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectionPreference::UndefinedConnectionPreference => {
                    "UNDEFINED_CONNECTION_PREFERENCE"
                }
                ConnectionPreference::AcceptAutomatic => "ACCEPT_AUTOMATIC",
                ConnectionPreference::AcceptManual => "ACCEPT_MANUAL",
                ConnectionPreference::Invalid => "INVALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONNECTION_PREFERENCE" => {
                    Some(Self::UndefinedConnectionPreference)
                }
                "ACCEPT_AUTOMATIC" => Some(Self::AcceptAutomatic),
                "ACCEPT_MANUAL" => Some(Self::AcceptManual),
                "INVALID" => Some(Self::Invalid),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAttachmentAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NetworkAttachmentsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAttachmentConnectedEndpoint {
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "341563804")]
    pub ipv6_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "349783336")]
    pub project_id_or_num: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "117184788")]
    pub secondary_ip_cidr_ranges: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "383249827")]
    pub subnetwork_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkAttachmentConnectedEndpoint`.
pub mod network_attachment_connected_endpoint {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Accepted = 246714279,
        Closed = 380163436,
        NeedsAttention = 344491452,
        Pending = 35394935,
        Rejected = 174130302,
        Unspecified = 42133066,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Accepted => "ACCEPTED",
                Status::Closed => "CLOSED",
                Status::NeedsAttention => "NEEDS_ATTENTION",
                Status::Pending => "PENDING",
                Status::Rejected => "REJECTED",
                Status::Unspecified => "STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACCEPTED" => Some(Self::Accepted),
                "CLOSED" => Some(Self::Closed),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "PENDING" => Some(Self::Pending),
                "REJECTED" => Some(Self::Rejected),
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAttachmentList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NetworkAttachment>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkAttachmentsScopedList {
    #[prost(message, repeated, tag = "521514783")]
    pub network_attachments: ::prost::alloc::vec::Vec<NetworkAttachment>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEdgeSecurityService {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEdgeSecurityServiceAggregatedList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NetworkEdgeSecurityServicesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEdgeSecurityServicesScopedList {
    #[prost(message, repeated, tag = "35530156")]
    pub network_edge_security_services: ::prost::alloc::vec::Vec<
        NetworkEdgeSecurityService,
    >,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpoint {
    #[prost(map = "string, string", tag = "112032548")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3150485")]
    pub fqdn: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroup {
    #[prost(map = "string, string", tag = "112032548")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "340788768")]
    pub app_engine: ::core::option::Option<NetworkEndpointGroupAppEngine>,
    #[prost(message, optional, tag = "519893666")]
    pub cloud_function: ::core::option::Option<NetworkEndpointGroupCloudFunction>,
    #[prost(message, optional, tag = "111060353")]
    pub cloud_run: ::core::option::Option<NetworkEndpointGroupCloudRun>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "423377855")]
    pub default_port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "118301523")]
    pub network_endpoint_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "71937481")]
    pub psc_data: ::core::option::Option<NetworkEndpointGroupPscData>,
    #[prost(string, optional, tag = "269132134")]
    pub psc_target_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3530753")]
    pub size: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkEndpointGroup`.
pub mod network_endpoint_group {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkEndpointType {
        UndefinedNetworkEndpointType = 0,
        GceVmIp = 401880793,
        GceVmIpPort = 501838375,
        InternetFqdnPort = 404154477,
        InternetIpPort = 477719963,
        NonGcpPrivateIpPort = 336447968,
        PrivateServiceConnect = 48134724,
        Serverless = 270492508,
    }
    impl NetworkEndpointType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkEndpointType::UndefinedNetworkEndpointType => {
                    "UNDEFINED_NETWORK_ENDPOINT_TYPE"
                }
                NetworkEndpointType::GceVmIp => "GCE_VM_IP",
                NetworkEndpointType::GceVmIpPort => "GCE_VM_IP_PORT",
                NetworkEndpointType::InternetFqdnPort => "INTERNET_FQDN_PORT",
                NetworkEndpointType::InternetIpPort => "INTERNET_IP_PORT",
                NetworkEndpointType::NonGcpPrivateIpPort => "NON_GCP_PRIVATE_IP_PORT",
                NetworkEndpointType::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
                NetworkEndpointType::Serverless => "SERVERLESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_ENDPOINT_TYPE" => {
                    Some(Self::UndefinedNetworkEndpointType)
                }
                "GCE_VM_IP" => Some(Self::GceVmIp),
                "GCE_VM_IP_PORT" => Some(Self::GceVmIpPort),
                "INTERNET_FQDN_PORT" => Some(Self::InternetFqdnPort),
                "INTERNET_IP_PORT" => Some(Self::InternetIpPort),
                "NON_GCP_PRIVATE_IP_PORT" => Some(Self::NonGcpPrivateIpPort),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                "SERVERLESS" => Some(Self::Serverless),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NetworkEndpointGroupsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupAppEngine {
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "103352252")]
    pub url_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "351608024")]
    pub version: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupCloudFunction {
    #[prost(string, optional, tag = "307196888")]
    pub function: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "103352252")]
    pub url_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupCloudRun {
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "114586")]
    pub tag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "103352252")]
    pub url_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NetworkEndpointGroup>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupPscData {
    #[prost(string, optional, tag = "452646572")]
    pub consumer_psc_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "292082397")]
    pub psc_connection_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "184149172")]
    pub psc_connection_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkEndpointGroupPscData`.
pub mod network_endpoint_group_psc_data {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PscConnectionStatus {
        UndefinedPscConnectionStatus = 0,
        Accepted = 246714279,
        Closed = 380163436,
        NeedsAttention = 344491452,
        Pending = 35394935,
        Rejected = 174130302,
        StatusUnspecified = 42133066,
    }
    impl PscConnectionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PscConnectionStatus::UndefinedPscConnectionStatus => {
                    "UNDEFINED_PSC_CONNECTION_STATUS"
                }
                PscConnectionStatus::Accepted => "ACCEPTED",
                PscConnectionStatus::Closed => "CLOSED",
                PscConnectionStatus::NeedsAttention => "NEEDS_ATTENTION",
                PscConnectionStatus::Pending => "PENDING",
                PscConnectionStatus::Rejected => "REJECTED",
                PscConnectionStatus::StatusUnspecified => "STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PSC_CONNECTION_STATUS" => {
                    Some(Self::UndefinedPscConnectionStatus)
                }
                "ACCEPTED" => Some(Self::Accepted),
                "CLOSED" => Some(Self::Closed),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "PENDING" => Some(Self::Pending),
                "REJECTED" => Some(Self::Rejected),
                "STATUS_UNSPECIFIED" => Some(Self::StatusUnspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupsAttachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupsDetachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupsListEndpointsRequest {
    #[prost(string, optional, tag = "380545845")]
    pub health_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkEndpointGroupsListEndpointsRequest`.
pub mod network_endpoint_groups_list_endpoints_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthStatus {
        UndefinedHealthStatus = 0,
        Show = 2544381,
        Skip = 2547071,
    }
    impl HealthStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthStatus::UndefinedHealthStatus => "UNDEFINED_HEALTH_STATUS",
                HealthStatus::Show => "SHOW",
                HealthStatus::Skip => "SKIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_HEALTH_STATUS" => Some(Self::UndefinedHealthStatus),
                "SHOW" => Some(Self::Show),
                "SKIP" => Some(Self::Skip),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupsListNetworkEndpoints {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NetworkEndpointWithHealthStatus>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointGroupsScopedList {
    #[prost(message, repeated, tag = "29346733")]
    pub network_endpoint_groups: ::prost::alloc::vec::Vec<NetworkEndpointGroup>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkEndpointWithHealthStatus {
    #[prost(message, repeated, tag = "258689431")]
    pub healths: ::prost::alloc::vec::Vec<HealthStatusForNetworkEndpoint>,
    #[prost(message, optional, tag = "56789126")]
    pub network_endpoint: ::core::option::Option<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInterface {
    #[prost(message, repeated, tag = "111058326")]
    pub access_configs: ::prost::alloc::vec::Vec<AccessConfig>,
    #[prost(message, repeated, tag = "165085631")]
    pub alias_ip_ranges: ::prost::alloc::vec::Vec<AliasIpRange>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "203833757")]
    pub internal_ipv6_prefix_length: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "483472110")]
    pub ipv6_access_configs: ::prost::alloc::vec::Vec<AccessConfig>,
    #[prost(string, optional, tag = "504658653")]
    pub ipv6_access_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "341563804")]
    pub ipv6_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "224644052")]
    pub network_attachment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "207181961")]
    pub network_i_p: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "59810577")]
    pub nic_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "503708769")]
    pub queue_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkInterface`.
pub mod network_interface {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Ipv6AccessType {
        UndefinedIpv6AccessType = 0,
        External = 35607499,
        Internal = 279295677,
        UnspecifiedIpv6AccessType = 313080613,
    }
    impl Ipv6AccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Ipv6AccessType::UndefinedIpv6AccessType => "UNDEFINED_IPV6_ACCESS_TYPE",
                Ipv6AccessType::External => "EXTERNAL",
                Ipv6AccessType::Internal => "INTERNAL",
                Ipv6AccessType::UnspecifiedIpv6AccessType => {
                    "UNSPECIFIED_IPV6_ACCESS_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IPV6_ACCESS_TYPE" => Some(Self::UndefinedIpv6AccessType),
                "EXTERNAL" => Some(Self::External),
                "INTERNAL" => Some(Self::Internal),
                "UNSPECIFIED_IPV6_ACCESS_TYPE" => Some(Self::UnspecifiedIpv6AccessType),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NicType {
        UndefinedNicType = 0,
        Gvnic = 68209305,
        UnspecifiedNicType = 67411801,
        VirtioNet = 452123481,
    }
    impl NicType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NicType::UndefinedNicType => "UNDEFINED_NIC_TYPE",
                NicType::Gvnic => "GVNIC",
                NicType::UnspecifiedNicType => "UNSPECIFIED_NIC_TYPE",
                NicType::VirtioNet => "VIRTIO_NET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NIC_TYPE" => Some(Self::UndefinedNicType),
                "GVNIC" => Some(Self::Gvnic),
                "UNSPECIFIED_NIC_TYPE" => Some(Self::UnspecifiedNicType),
                "VIRTIO_NET" => Some(Self::VirtioNet),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
        UnspecifiedStackType = 298084569,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
                StackType::UnspecifiedStackType => "UNSPECIFIED_STACK_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                "UNSPECIFIED_STACK_TYPE" => Some(Self::UnspecifiedStackType),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Network>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPeering {
    #[prost(bool, optional, tag = "57454941")]
    pub auto_create_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "26322256")]
    pub exchange_subnet_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "60281485")]
    pub export_custom_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "97940834")]
    pub export_subnet_routes_with_public_ip: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "197982398")]
    pub import_custom_routes: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "14419729")]
    pub import_subnet_routes_with_public_ip: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "69584721")]
    pub peer_mtu: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "95566996")]
    pub state_details: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkPeering`.
pub mod network_peering {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Inactive = 270421099,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPerformanceConfig {
    #[prost(string, optional, tag = "130109439")]
    pub total_egress_bandwidth_tier: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `NetworkPerformanceConfig`.
pub mod network_performance_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TotalEgressBandwidthTier {
        UndefinedTotalEgressBandwidthTier = 0,
        Default = 115302945,
        Tier1 = 326919444,
    }
    impl TotalEgressBandwidthTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TotalEgressBandwidthTier::UndefinedTotalEgressBandwidthTier => {
                    "UNDEFINED_TOTAL_EGRESS_BANDWIDTH_TIER"
                }
                TotalEgressBandwidthTier::Default => "DEFAULT",
                TotalEgressBandwidthTier::Tier1 => "TIER_1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TOTAL_EGRESS_BANDWIDTH_TIER" => {
                    Some(Self::UndefinedTotalEgressBandwidthTier)
                }
                "DEFAULT" => Some(Self::Default),
                "TIER_1" => Some(Self::Tier1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkRoutingConfig {
    #[prost(string, optional, tag = "475143548")]
    pub routing_mode: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworkRoutingConfig`.
pub mod network_routing_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RoutingMode {
        UndefinedRoutingMode = 0,
        Global = 494663587,
        Regional = 92288543,
    }
    impl RoutingMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RoutingMode::UndefinedRoutingMode => "UNDEFINED_ROUTING_MODE",
                RoutingMode::Global => "GLOBAL",
                RoutingMode::Regional => "REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROUTING_MODE" => Some(Self::UndefinedRoutingMode),
                "GLOBAL" => Some(Self::Global),
                "REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworksAddPeeringRequest {
    #[prost(bool, optional, tag = "57454941")]
    pub auto_create_routes: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328926767")]
    pub network_peering: ::core::option::Option<NetworkPeering>,
    #[prost(string, optional, tag = "500625489")]
    pub peer_network: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworksGetEffectiveFirewallsResponse {
    #[prost(message, repeated, tag = "410985794")]
    pub firewall_policys: ::prost::alloc::vec::Vec<
        NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy,
    >,
    #[prost(message, repeated, tag = "272245619")]
    pub firewalls: ::prost::alloc::vec::Vec<Firewall>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    #[prost(string, optional, tag = "4473832")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<FirewallPolicyRule>,
    #[prost(string, optional, tag = "492051566")]
    pub short_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NetworksGetEffectiveFirewallsResponseEffectiveFirewallPolicy`.
pub mod networks_get_effective_firewalls_response_effective_firewall_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Hierarchy = 69902869,
        Network = 413984270,
        Unspecified = 526786327,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Hierarchy => "HIERARCHY",
                Type::Network => "NETWORK",
                Type::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "HIERARCHY" => Some(Self::Hierarchy),
                "NETWORK" => Some(Self::Network),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworksRemovePeeringRequest {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworksUpdatePeeringRequest {
    #[prost(message, optional, tag = "328926767")]
    pub network_peering: ::core::option::Option<NetworkPeering>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroup {
    #[prost(message, optional, tag = "221950041")]
    pub autoscaling_policy: ::core::option::Option<NodeGroupAutoscalingPolicy>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "350519505")]
    pub location_hint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "403368049")]
    pub maintenance_interval: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "528327646")]
    pub maintenance_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "186374812")]
    pub maintenance_window: ::core::option::Option<NodeGroupMaintenanceWindow>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "323154455")]
    pub node_template: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "266668163")]
    pub share_settings: ::core::option::Option<ShareSettings>,
    #[prost(int32, optional, tag = "3530753")]
    pub size: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NodeGroup`.
pub mod node_group {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceInterval {
        UndefinedMaintenanceInterval = 0,
        AsNeeded = 500724834,
        Recurrent = 194244550,
    }
    impl MaintenanceInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MaintenanceInterval::UndefinedMaintenanceInterval => {
                    "UNDEFINED_MAINTENANCE_INTERVAL"
                }
                MaintenanceInterval::AsNeeded => "AS_NEEDED",
                MaintenanceInterval::Recurrent => "RECURRENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MAINTENANCE_INTERVAL" => {
                    Some(Self::UndefinedMaintenanceInterval)
                }
                "AS_NEEDED" => Some(Self::AsNeeded),
                "RECURRENT" => Some(Self::Recurrent),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenancePolicy {
        UndefinedMaintenancePolicy = 0,
        Default = 115302945,
        Unspecified = 72964182,
        MigrateWithinNodeGroup = 153483394,
        RestartInPlace = 228647325,
    }
    impl MaintenancePolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MaintenancePolicy::UndefinedMaintenancePolicy => {
                    "UNDEFINED_MAINTENANCE_POLICY"
                }
                MaintenancePolicy::Default => "DEFAULT",
                MaintenancePolicy::Unspecified => "MAINTENANCE_POLICY_UNSPECIFIED",
                MaintenancePolicy::MigrateWithinNodeGroup => "MIGRATE_WITHIN_NODE_GROUP",
                MaintenancePolicy::RestartInPlace => "RESTART_IN_PLACE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MAINTENANCE_POLICY" => Some(Self::UndefinedMaintenancePolicy),
                "DEFAULT" => Some(Self::Default),
                "MAINTENANCE_POLICY_UNSPECIFIED" => Some(Self::Unspecified),
                "MIGRATE_WITHIN_NODE_GROUP" => Some(Self::MigrateWithinNodeGroup),
                "RESTART_IN_PLACE" => Some(Self::RestartInPlace),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Invalid = 530283991,
        Ready = 77848963,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NodeGroupsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupAutoscalingPolicy {
    #[prost(int32, optional, tag = "297762838")]
    pub max_nodes: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "533370500")]
    pub min_nodes: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NodeGroupAutoscalingPolicy`.
pub mod node_group_autoscaling_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        Unspecified = 371348091,
        Off = 78159,
        On = 2527,
        OnlyScaleOut = 152713670,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::Unspecified => "MODE_UNSPECIFIED",
                Mode::Off => "OFF",
                Mode::On => "ON",
                Mode::OnlyScaleOut => "ONLY_SCALE_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "OFF" => Some(Self::Off),
                "ON" => Some(Self::On),
                "ONLY_SCALE_OUT" => Some(Self::OnlyScaleOut),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NodeGroup>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupMaintenanceWindow {
    #[prost(message, optional, tag = "525291840")]
    pub maintenance_duration: ::core::option::Option<Duration>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupNode {
    #[prost(message, repeated, tag = "269577064")]
    pub accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(message, optional, tag = "334527118")]
    pub consumed_resources: ::core::option::Option<InstanceConsumptionInfo>,
    #[prost(string, optional, tag = "247727959")]
    pub cpu_overcommit_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<LocalDisk>,
    #[prost(message, repeated, tag = "84715576")]
    pub instance_consumption_data: ::prost::alloc::vec::Vec<InstanceConsumptionData>,
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "465832791")]
    pub node_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "208179593")]
    pub server_binding: ::core::option::Option<ServerBinding>,
    #[prost(string, optional, tag = "339433367")]
    pub server_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "97406698")]
    pub total_resources: ::core::option::Option<InstanceConsumptionInfo>,
    #[prost(message, optional, tag = "227348592")]
    pub upcoming_maintenance: ::core::option::Option<UpcomingMaintenance>,
}
/// Nested message and enum types in `NodeGroupNode`.
pub mod node_group_node {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CpuOvercommitType {
        UndefinedCpuOvercommitType = 0,
        Unspecified = 520665615,
        Enabled = 182130465,
        None = 2402104,
    }
    impl CpuOvercommitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CpuOvercommitType::UndefinedCpuOvercommitType => {
                    "UNDEFINED_CPU_OVERCOMMIT_TYPE"
                }
                CpuOvercommitType::Unspecified => "CPU_OVERCOMMIT_TYPE_UNSPECIFIED",
                CpuOvercommitType::Enabled => "ENABLED",
                CpuOvercommitType::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CPU_OVERCOMMIT_TYPE" => Some(Self::UndefinedCpuOvercommitType),
                "CPU_OVERCOMMIT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Invalid = 530283991,
        Ready = 77848963,
        Repairing = 413483285,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
                Status::Repairing => "REPAIRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                "REPAIRING" => Some(Self::Repairing),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodeGroupsAddNodesRequest {
    #[prost(int32, optional, tag = "134997930")]
    pub additional_node_count: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsDeleteNodesRequest {
    #[prost(string, repeated, tag = "104993457")]
    pub nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsListNodes {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NodeGroupNode>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsPerformMaintenanceRequest {
    #[prost(string, repeated, tag = "104993457")]
    pub nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsScopedList {
    #[prost(message, repeated, tag = "73188017")]
    pub node_groups: ::prost::alloc::vec::Vec<NodeGroup>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsSetNodeTemplateRequest {
    #[prost(string, optional, tag = "323154455")]
    pub node_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeGroupsSimulateMaintenanceEventRequest {
    #[prost(string, repeated, tag = "104993457")]
    pub nodes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTemplate {
    #[prost(message, repeated, tag = "269577064")]
    pub accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(string, optional, tag = "247727959")]
    pub cpu_overcommit_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<LocalDisk>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "339007161")]
    pub node_affinity_labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "465832791")]
    pub node_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "315257905")]
    pub node_type_flexibility: ::core::option::Option<NodeTemplateNodeTypeFlexibility>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "208179593")]
    pub server_binding: ::core::option::Option<ServerBinding>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "297428154")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `NodeTemplate`.
pub mod node_template {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CpuOvercommitType {
        UndefinedCpuOvercommitType = 0,
        Unspecified = 520665615,
        Enabled = 182130465,
        None = 2402104,
    }
    impl CpuOvercommitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CpuOvercommitType::UndefinedCpuOvercommitType => {
                    "UNDEFINED_CPU_OVERCOMMIT_TYPE"
                }
                CpuOvercommitType::Unspecified => "CPU_OVERCOMMIT_TYPE_UNSPECIFIED",
                CpuOvercommitType::Enabled => "ENABLED",
                CpuOvercommitType::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CPU_OVERCOMMIT_TYPE" => Some(Self::UndefinedCpuOvercommitType),
                "CPU_OVERCOMMIT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Invalid = 530283991,
        Ready = 77848963,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTemplateAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NodeTemplatesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTemplateList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NodeTemplate>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTemplateNodeTypeFlexibility {
    #[prost(string, optional, tag = "3060683")]
    pub cpus: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "405741360")]
    pub local_ssd: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "532856065")]
    pub memory: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTemplatesScopedList {
    #[prost(message, repeated, tag = "354111804")]
    pub node_templates: ::prost::alloc::vec::Vec<NodeTemplate>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeType {
    #[prost(string, optional, tag = "410285354")]
    pub cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "393356754")]
    pub guest_cpus: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "329237578")]
    pub local_ssd_gb: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "116001171")]
    pub memory_mb: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTypeAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        NodeTypesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NodeType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NodeTypesScopedList {
    #[prost(message, repeated, tag = "482172924")]
    pub node_types: ::prost::alloc::vec::Vec<NodeType>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationEndpoint {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "456139556")]
    pub grpc_settings: ::core::option::Option<NotificationEndpointGrpcSettings>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationEndpointGrpcSettings {
    #[prost(string, optional, tag = "401868611")]
    pub authority: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "130489749")]
    pub endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "300358300")]
    pub payload_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "478288969")]
    pub resend_interval: ::core::option::Option<Duration>,
    #[prost(uint32, optional, tag = "115681117")]
    pub retry_duration_sec: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotificationEndpointList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<NotificationEndpoint>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Operation {
    #[prost(string, optional, tag = "297240295")]
    pub client_operation_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "114938801")]
    pub end_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<Error>,
    #[prost(string, optional, tag = "202521945")]
    pub http_error_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "312345196")]
    pub http_error_status_code: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "433722515")]
    pub insert_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "89146177")]
    pub instances_bulk_insert_operation_metadata: ::core::option::Option<
        InstancesBulkInsertOperationMetadata,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "40171187")]
    pub operation_group_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177650450")]
    pub operation_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "72663597")]
    pub progress: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "490378980")]
    pub set_common_instance_metadata_operation_metadata: ::core::option::Option<
        SetCommonInstanceMetadataOperationMetadata,
    >,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "operation::Status", optional, tag = "181260274")]
    pub status: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "297428154")]
    pub status_message: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "258165385")]
    pub target_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "62671336")]
    pub target_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3599307")]
    pub user: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "498091095")]
    pub warnings: ::prost::alloc::vec::Vec<Warnings>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Operation`.
pub mod operation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Done = 2104194,
        Pending = 35394935,
        Running = 121282975,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Done => "DONE",
                Status::Pending => "PENDING",
                Status::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DONE" => Some(Self::Done),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        OperationsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Operation>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationsScopedList {
    #[prost(message, repeated, tag = "4184044")]
    pub operations: ::prost::alloc::vec::Vec<Operation>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OutlierDetection {
    #[prost(message, optional, tag = "80997255")]
    pub base_ejection_time: ::core::option::Option<Duration>,
    #[prost(int32, optional, tag = "387193248")]
    pub consecutive_errors: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "417504250")]
    pub consecutive_gateway_failure: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "213133760")]
    pub enforcing_consecutive_errors: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "394440666")]
    pub enforcing_consecutive_gateway_failure: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "194508732")]
    pub enforcing_success_rate: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "33547461")]
    pub interval: ::core::option::Option<Duration>,
    #[prost(int32, optional, tag = "18436888")]
    pub max_ejection_percent: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "525766903")]
    pub success_rate_minimum_hosts: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "281425357")]
    pub success_rate_request_volume: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "174735773")]
    pub success_rate_stdev_factor: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketIntervals {
    #[prost(int64, optional, tag = "204811827")]
    pub avg_ms: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "155471252")]
    pub duration: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "529474145")]
    pub max_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "536564403")]
    pub min_ms: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "186329813")]
    pub num_intervals: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PacketIntervals`.
pub mod packet_intervals {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Duration {
        UndefinedDuration = 0,
        Unspecified = 529071340,
        Hour = 2223588,
        Max = 76100,
        Minute = 126786068,
    }
    impl Duration {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Duration::UndefinedDuration => "UNDEFINED_DURATION",
                Duration::Unspecified => "DURATION_UNSPECIFIED",
                Duration::Hour => "HOUR",
                Duration::Max => "MAX",
                Duration::Minute => "MINUTE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DURATION" => Some(Self::UndefinedDuration),
                "DURATION_UNSPECIFIED" => Some(Self::Unspecified),
                "HOUR" => Some(Self::Hour),
                "MAX" => Some(Self::Max),
                "MINUTE" => Some(Self::Minute),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Loopback = 356174219,
        Receive = 189660867,
        Transmit = 452903600,
        Unspecified = 437714322,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Loopback => "LOOPBACK",
                Type::Receive => "RECEIVE",
                Type::Transmit => "TRANSMIT",
                Type::Unspecified => "TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "LOOPBACK" => Some(Self::Loopback),
                "RECEIVE" => Some(Self::Receive),
                "TRANSMIT" => Some(Self::Transmit),
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroring {
    #[prost(message, optional, tag = "426607853")]
    pub collector_ilb: ::core::option::Option<PacketMirroringForwardingRuleInfo>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "311764355")]
    pub enable: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "336120696")]
    pub filter: ::core::option::Option<PacketMirroringFilter>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "124817348")]
    pub mirrored_resources: ::core::option::Option<PacketMirroringMirroredResourceInfo>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "232872494")]
    pub network: ::core::option::Option<PacketMirroringNetworkInfo>,
    #[prost(uint32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PacketMirroring`.
pub mod packet_mirroring {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Enable {
        UndefinedEnable = 0,
        False = 66658563,
        True = 2583950,
    }
    impl Enable {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Enable::UndefinedEnable => "UNDEFINED_ENABLE",
                Enable::False => "FALSE",
                Enable::True => "TRUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENABLE" => Some(Self::UndefinedEnable),
                "FALSE" => Some(Self::False),
                "TRUE" => Some(Self::True),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PacketMirroringsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringFilter {
    #[prost(string, repeated, tag = "98544854")]
    pub i_p_protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "487901697")]
    pub cidr_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111150975")]
    pub direction: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PacketMirroringFilter`.
pub mod packet_mirroring_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Direction {
        UndefinedDirection = 0,
        Both = 2044801,
        Egress = 432880501,
        Ingress = 516931221,
    }
    impl Direction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Direction::UndefinedDirection => "UNDEFINED_DIRECTION",
                Direction::Both => "BOTH",
                Direction::Egress => "EGRESS",
                Direction::Ingress => "INGRESS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DIRECTION" => Some(Self::UndefinedDirection),
                "BOTH" => Some(Self::Both),
                "EGRESS" => Some(Self::Egress),
                "INGRESS" => Some(Self::Ingress),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringForwardingRuleInfo {
    #[prost(string, optional, tag = "512294820")]
    pub canonical_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116079")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<PacketMirroring>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringMirroredResourceInfo {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<
        PacketMirroringMirroredResourceInfoInstanceInfo,
    >,
    #[prost(message, repeated, tag = "415853125")]
    pub subnetworks: ::prost::alloc::vec::Vec<
        PacketMirroringMirroredResourceInfoSubnetInfo,
    >,
    #[prost(string, repeated, tag = "3552281")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringMirroredResourceInfoInstanceInfo {
    #[prost(string, optional, tag = "512294820")]
    pub canonical_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116079")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringMirroredResourceInfoSubnetInfo {
    #[prost(string, optional, tag = "512294820")]
    pub canonical_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116079")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringNetworkInfo {
    #[prost(string, optional, tag = "512294820")]
    pub canonical_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116079")]
    pub url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PacketMirroringsScopedList {
    #[prost(message, repeated, tag = "154615079")]
    pub packet_mirrorings: ::prost::alloc::vec::Vec<PacketMirroring>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchAutoscalerRequest {
    #[prost(string, optional, tag = "517258967")]
    pub autoscaler: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "380757784")]
    pub backend_bucket_resource: ::core::option::Option<BackendBucket>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchFirewallRequest {
    #[prost(string, tag = "511016192")]
    pub firewall: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "41425005")]
    pub firewall_resource: ::core::option::Option<Firewall>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "301211695")]
    pub forwarding_rule_resource: ::core::option::Option<ForwardingRule>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchGlobalForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "301211695")]
    pub forwarding_rule_resource: ::core::option::Option<ForwardingRule>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchGlobalPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "47594501")]
    pub public_delegated_prefix_resource: ::core::option::Option<PublicDelegatedPrefix>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchImageRequest {
    #[prost(string, tag = "100313435")]
    pub image: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "371171954")]
    pub image_resource: ::core::option::Option<Image>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "261063946")]
    pub instance_group_manager_resource: ::core::option::Option<InstanceGroupManager>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchInstanceSettingRequest {
    #[prost(message, optional, tag = "290689920")]
    pub instance_settings_resource: ::core::option::Option<InstanceSettings>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchInterconnectAttachmentRequest {
    #[prost(string, tag = "308135284")]
    pub interconnect_attachment: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "212341369")]
    pub interconnect_attachment_resource: ::core::option::Option<InterconnectAttachment>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchInterconnectRequest {
    #[prost(string, tag = "224601230")]
    pub interconnect: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "397611167")]
    pub interconnect_resource: ::core::option::Option<Interconnect>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetworkAttachmentRequest {
    #[prost(string, tag = "224644052")]
    pub network_attachment: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "210974745")]
    pub network_attachment_resource: ::core::option::Option<NetworkAttachment>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetworkEdgeSecurityServiceRequest {
    #[prost(string, tag = "157011879")]
    pub network_edge_security_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "477548966")]
    pub network_edge_security_service_resource: ::core::option::Option<
        NetworkEdgeSecurityService,
    >,
    #[prost(string, optional, tag = "106438894")]
    pub paths: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "122105599")]
    pub network_resource: ::core::option::Option<Network>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "505321899")]
    pub node_group_resource: ::core::option::Option<NodeGroup>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPacketMirroringRequest {
    #[prost(string, tag = "22305996")]
    pub packet_mirroring: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "493501985")]
    pub packet_mirroring_resource: ::core::option::Option<PacketMirroring>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPerInstanceConfigsInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "356650495")]
    pub instance_group_managers_patch_per_instance_configs_req_resource: ::core::option::Option<
        InstanceGroupManagersPatchPerInstanceConfigsReq,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPerInstanceConfigsRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "197682890")]
    pub region_instance_group_manager_patch_instance_config_req_resource: ::core::option::Option<
        RegionInstanceGroupManagerPatchInstanceConfigReq,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "101874590")]
    pub public_advertised_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "233614223")]
    pub public_advertised_prefix_resource: ::core::option::Option<
        PublicAdvertisedPrefix,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "47594501")]
    pub public_delegated_prefix_resource: ::core::option::Option<PublicDelegatedPrefix>,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionAutoscalerRequest {
    #[prost(string, optional, tag = "517258967")]
    pub autoscaler: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionHealthCheckServiceRequest {
    #[prost(string, tag = "408374747")]
    pub health_check_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "477367794")]
    pub health_check_service_resource: ::core::option::Option<HealthCheckService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "261063946")]
    pub instance_group_manager_resource: ::core::option::Option<InstanceGroupManager>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "495049532")]
    pub firewall_policy_resource: ::core::option::Option<FirewallPolicy>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "216159612")]
    pub security_policy_resource: ::core::option::Option<SecurityPolicy>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "274891848")]
    pub ssl_policy_resource: ::core::option::Option<SslPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "433657473")]
    pub target_https_proxy_resource: ::core::option::Option<TargetHttpsProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "159240835")]
    pub resource_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "76826186")]
    pub resource_policy_resource: ::core::option::Option<ResourcePolicy>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "155222084")]
    pub router_resource: ::core::option::Option<Router>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRuleFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRuleNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRuleRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "250523523")]
    pub firewall_policy_rule_resource: ::core::option::Option<FirewallPolicyRule>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRuleRegionSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "402693443")]
    pub security_policy_rule_resource: ::core::option::Option<SecurityPolicyRule>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchRuleSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "402693443")]
    pub security_policy_rule_resource: ::core::option::Option<SecurityPolicyRule>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "242744629")]
    pub validate_only: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchSecurityPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "216159612")]
    pub security_policy_resource: ::core::option::Option<SecurityPolicy>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "338957549")]
    pub service_attachment: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "472980256")]
    pub service_attachment_resource: ::core::option::Option<ServiceAttachment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchSnapshotSettingRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "357664495")]
    pub snapshot_settings_resource: ::core::option::Option<SnapshotSettings>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchSslPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "295190213")]
    pub ssl_policy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "274891848")]
    pub ssl_policy_resource: ::core::option::Option<SslPolicy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchSubnetworkRequest {
    #[prost(int32, optional, tag = "357707098")]
    pub drain_timeout_seconds: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "307827694")]
    pub subnetwork: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "42233151")]
    pub subnetwork_resource: ::core::option::Option<Subnetwork>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchTargetGrpcProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "5020283")]
    pub target_grpc_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "328922450")]
    pub target_grpc_proxy_resource: ::core::option::Option<TargetGrpcProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "24696744")]
    pub target_http_proxy_resource: ::core::option::Option<TargetHttpProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "433657473")]
    pub target_https_proxy_resource: ::core::option::Option<TargetHttpsProxy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PatchUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathMatcher {
    #[prost(message, optional, tag = "378919466")]
    pub default_route_action: ::core::option::Option<HttpRouteAction>,
    #[prost(string, optional, tag = "370242231")]
    pub default_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "359503338")]
    pub default_url_redirect: ::core::option::Option<HttpRedirectAction>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328077352")]
    pub header_action: ::core::option::Option<HttpHeaderAction>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "104439901")]
    pub path_rules: ::prost::alloc::vec::Vec<PathRule>,
    #[prost(message, repeated, tag = "376292225")]
    pub route_rules: ::prost::alloc::vec::Vec<HttpRouteRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PathRule {
    #[prost(string, repeated, tag = "106438894")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "424563948")]
    pub route_action: ::core::option::Option<HttpRouteAction>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "405147820")]
    pub url_redirect: ::core::option::Option<HttpRedirectAction>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerInstanceConfig {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2634026")]
    pub preserved_state: ::core::option::Option<PreservedState>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PerInstanceConfig`.
pub mod per_instance_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Applying = 352003508,
        Deleting = 528602024,
        Effective = 244201863,
        None = 2402104,
        Unapplied = 483935140,
        UnappliedDeletion = 313956873,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Applying => "APPLYING",
                Status::Deleting => "DELETING",
                Status::Effective => "EFFECTIVE",
                Status::None => "NONE",
                Status::Unapplied => "UNAPPLIED",
                Status::UnappliedDeletion => "UNAPPLIED_DELETION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "APPLYING" => Some(Self::Applying),
                "DELETING" => Some(Self::Deleting),
                "EFFECTIVE" => Some(Self::Effective),
                "NONE" => Some(Self::None),
                "UNAPPLIED" => Some(Self::Unapplied),
                "UNAPPLIED_DELETION" => Some(Self::UnappliedDeletion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerformMaintenanceInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PerformMaintenanceNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "185310294")]
    pub node_groups_perform_maintenance_request_resource: ::core::option::Option<
        NodeGroupsPerformMaintenanceRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Policy {
    #[prost(message, repeated, tag = "328080653")]
    pub audit_configs: ::prost::alloc::vec::Vec<AuditConfig>,
    #[prost(message, repeated, tag = "403251854")]
    pub bindings: ::prost::alloc::vec::Vec<Binding>,
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "450566203")]
    pub iam_owned: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    #[prost(int32, optional, tag = "351608024")]
    pub version: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreconfiguredWafSet {
    #[prost(message, repeated, tag = "474011032")]
    pub expression_sets: ::prost::alloc::vec::Vec<WafExpressionSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreservedState {
    #[prost(map = "string, message", tag = "95594102")]
    pub disks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PreservedStatePreservedDisk,
    >,
    #[prost(map = "string, message", tag = "532687245")]
    pub external_i_ps: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PreservedStatePreservedNetworkIp,
    >,
    #[prost(map = "string, message", tag = "215731675")]
    pub internal_i_ps: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PreservedStatePreservedNetworkIp,
    >,
    #[prost(map = "string, string", tag = "86866735")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreservedStatePreservedDisk {
    #[prost(string, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PreservedStatePreservedDisk`.
pub mod preserved_state_preserved_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoDelete {
        UndefinedAutoDelete = 0,
        Never = 74175084,
        OnPermanentInstanceDeletion = 95727719,
    }
    impl AutoDelete {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoDelete::UndefinedAutoDelete => "UNDEFINED_AUTO_DELETE",
                AutoDelete::Never => "NEVER",
                AutoDelete::OnPermanentInstanceDeletion => {
                    "ON_PERMANENT_INSTANCE_DELETION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AUTO_DELETE" => Some(Self::UndefinedAutoDelete),
                "NEVER" => Some(Self::Never),
                "ON_PERMANENT_INSTANCE_DELETION" => {
                    Some(Self::OnPermanentInstanceDeletion)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        ReadOnly = 91950261,
        ReadWrite = 173607894,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::ReadOnly => "READ_ONLY",
                Mode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreservedStatePreservedNetworkIp {
    #[prost(string, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<PreservedStatePreservedNetworkIpIpAddress>,
}
/// Nested message and enum types in `PreservedStatePreservedNetworkIp`.
pub mod preserved_state_preserved_network_ip {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoDelete {
        UndefinedAutoDelete = 0,
        Never = 74175084,
        OnPermanentInstanceDeletion = 95727719,
    }
    impl AutoDelete {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoDelete::UndefinedAutoDelete => "UNDEFINED_AUTO_DELETE",
                AutoDelete::Never => "NEVER",
                AutoDelete::OnPermanentInstanceDeletion => {
                    "ON_PERMANENT_INSTANCE_DELETION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AUTO_DELETE" => Some(Self::UndefinedAutoDelete),
                "NEVER" => Some(Self::Never),
                "ON_PERMANENT_INSTANCE_DELETION" => {
                    Some(Self::OnPermanentInstanceDeletion)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreservedStatePreservedNetworkIpIpAddress {
    #[prost(string, optional, tag = "462920692")]
    pub address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "182460591")]
    pub literal: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreviewRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "155222084")]
    pub router_resource: ::core::option::Option<Router>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Project {
    #[prost(string, optional, tag = "4427052")]
    pub cloud_armor_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "185794117")]
    pub common_instance_metadata: ::core::option::Option<Metadata>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "471753361")]
    pub default_network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "298712229")]
    pub default_service_account: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "469017467")]
    pub enabled_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "125341947")]
    pub quotas: ::prost::alloc::vec::Vec<Quota>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "347543874")]
    pub usage_export_location: ::core::option::Option<UsageExportLocation>,
    #[prost(string, optional, tag = "58856370")]
    pub vm_dns_setting: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "228419265")]
    pub xpn_project_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Project`.
pub mod project {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CloudArmorTier {
        UndefinedCloudArmorTier = 0,
        CaEnterpriseAnnual = 219921116,
        CaEnterprisePaygo = 453530323,
        CaStandard = 13156734,
    }
    impl CloudArmorTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CloudArmorTier::UndefinedCloudArmorTier => "UNDEFINED_CLOUD_ARMOR_TIER",
                CloudArmorTier::CaEnterpriseAnnual => "CA_ENTERPRISE_ANNUAL",
                CloudArmorTier::CaEnterprisePaygo => "CA_ENTERPRISE_PAYGO",
                CloudArmorTier::CaStandard => "CA_STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CLOUD_ARMOR_TIER" => Some(Self::UndefinedCloudArmorTier),
                "CA_ENTERPRISE_ANNUAL" => Some(Self::CaEnterpriseAnnual),
                "CA_ENTERPRISE_PAYGO" => Some(Self::CaEnterprisePaygo),
                "CA_STANDARD" => Some(Self::CaStandard),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DefaultNetworkTier {
        UndefinedDefaultNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl DefaultNetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DefaultNetworkTier::UndefinedDefaultNetworkTier => {
                    "UNDEFINED_DEFAULT_NETWORK_TIER"
                }
                DefaultNetworkTier::FixedStandard => "FIXED_STANDARD",
                DefaultNetworkTier::Premium => "PREMIUM",
                DefaultNetworkTier::Standard => "STANDARD",
                DefaultNetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DEFAULT_NETWORK_TIER" => {
                    Some(Self::UndefinedDefaultNetworkTier)
                }
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VmDnsSetting {
        UndefinedVmDnsSetting = 0,
        GlobalDefault = 345419141,
        UnspecifiedVmDnsSetting = 35691930,
        ZonalDefault = 368475782,
        ZonalOnly = 521198951,
    }
    impl VmDnsSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VmDnsSetting::UndefinedVmDnsSetting => "UNDEFINED_VM_DNS_SETTING",
                VmDnsSetting::GlobalDefault => "GLOBAL_DEFAULT",
                VmDnsSetting::UnspecifiedVmDnsSetting => "UNSPECIFIED_VM_DNS_SETTING",
                VmDnsSetting::ZonalDefault => "ZONAL_DEFAULT",
                VmDnsSetting::ZonalOnly => "ZONAL_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_VM_DNS_SETTING" => Some(Self::UndefinedVmDnsSetting),
                "GLOBAL_DEFAULT" => Some(Self::GlobalDefault),
                "UNSPECIFIED_VM_DNS_SETTING" => Some(Self::UnspecifiedVmDnsSetting),
                "ZONAL_DEFAULT" => Some(Self::ZonalDefault),
                "ZONAL_ONLY" => Some(Self::ZonalOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum XpnProjectStatus {
        UndefinedXpnProjectStatus = 0,
        Host = 2223528,
        UnspecifiedXpnProjectStatus = 340393257,
    }
    impl XpnProjectStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                XpnProjectStatus::UndefinedXpnProjectStatus => {
                    "UNDEFINED_XPN_PROJECT_STATUS"
                }
                XpnProjectStatus::Host => "HOST",
                XpnProjectStatus::UnspecifiedXpnProjectStatus => {
                    "UNSPECIFIED_XPN_PROJECT_STATUS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_XPN_PROJECT_STATUS" => Some(Self::UndefinedXpnProjectStatus),
                "HOST" => Some(Self::Host),
                "UNSPECIFIED_XPN_PROJECT_STATUS" => {
                    Some(Self::UnspecifiedXpnProjectStatus)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsDisableXpnResourceRequest {
    #[prost(message, optional, tag = "133384631")]
    pub xpn_resource: ::core::option::Option<XpnResourceId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsEnableXpnResourceRequest {
    #[prost(message, optional, tag = "133384631")]
    pub xpn_resource: ::core::option::Option<XpnResourceId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsGetXpnResources {
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "164412965")]
    pub resources: ::prost::alloc::vec::Vec<XpnResourceId>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsListXpnHostsRequest {
    #[prost(string, optional, tag = "105180467")]
    pub organization: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsSetCloudArmorTierRequest {
    #[prost(string, optional, tag = "4427052")]
    pub cloud_armor_tier: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ProjectsSetCloudArmorTierRequest`.
pub mod projects_set_cloud_armor_tier_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CloudArmorTier {
        UndefinedCloudArmorTier = 0,
        CaEnterpriseAnnual = 219921116,
        CaEnterprisePaygo = 453530323,
        CaStandard = 13156734,
    }
    impl CloudArmorTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CloudArmorTier::UndefinedCloudArmorTier => "UNDEFINED_CLOUD_ARMOR_TIER",
                CloudArmorTier::CaEnterpriseAnnual => "CA_ENTERPRISE_ANNUAL",
                CloudArmorTier::CaEnterprisePaygo => "CA_ENTERPRISE_PAYGO",
                CloudArmorTier::CaStandard => "CA_STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CLOUD_ARMOR_TIER" => Some(Self::UndefinedCloudArmorTier),
                "CA_ENTERPRISE_ANNUAL" => Some(Self::CaEnterpriseAnnual),
                "CA_ENTERPRISE_PAYGO" => Some(Self::CaEnterprisePaygo),
                "CA_STANDARD" => Some(Self::CaStandard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectsSetDefaultNetworkTierRequest {
    #[prost(string, optional, tag = "517397843")]
    pub network_tier: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ProjectsSetDefaultNetworkTierRequest`.
pub mod projects_set_default_network_tier_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkTier {
        UndefinedNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl NetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkTier::UndefinedNetworkTier => "UNDEFINED_NETWORK_TIER",
                NetworkTier::FixedStandard => "FIXED_STANDARD",
                NetworkTier::Premium => "PREMIUM",
                NetworkTier::Standard => "STANDARD",
                NetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NETWORK_TIER" => Some(Self::UndefinedNetworkTier),
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAdvertisedPrefix {
    #[prost(string, optional, tag = "162683283")]
    pub byoip_api_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "241011381")]
    pub dns_verification_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "524264785")]
    pub pdp_scope: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "425811723")]
    pub public_delegated_prefixs: ::prost::alloc::vec::Vec<
        PublicAdvertisedPrefixPublicDelegatedPrefix,
    >,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "381932490")]
    pub shared_secret: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PublicAdvertisedPrefix`.
pub mod public_advertised_prefix {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ByoipApiVersion {
        UndefinedByoipApiVersion = 0,
        V1 = 2715,
        V2 = 2716,
    }
    impl ByoipApiVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ByoipApiVersion::UndefinedByoipApiVersion => {
                    "UNDEFINED_BYOIP_API_VERSION"
                }
                ByoipApiVersion::V1 => "V1",
                ByoipApiVersion::V2 => "V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BYOIP_API_VERSION" => Some(Self::UndefinedByoipApiVersion),
                "V1" => Some(Self::V1),
                "V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PdpScope {
        UndefinedPdpScope = 0,
        Global = 494663587,
        GlobalAndRegional = 318053059,
        Regional = 92288543,
    }
    impl PdpScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PdpScope::UndefinedPdpScope => "UNDEFINED_PDP_SCOPE",
                PdpScope::Global => "GLOBAL",
                PdpScope::GlobalAndRegional => "GLOBAL_AND_REGIONAL",
                PdpScope::Regional => "REGIONAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PDP_SCOPE" => Some(Self::UndefinedPdpScope),
                "GLOBAL" => Some(Self::Global),
                "GLOBAL_AND_REGIONAL" => Some(Self::GlobalAndRegional),
                "REGIONAL" => Some(Self::Regional),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        AnnouncedToInternet = 177880897,
        Initial = 518841124,
        PrefixConfigurationComplete = 480889551,
        PrefixConfigurationInProgress = 378550961,
        PrefixRemovalInProgress = 284375783,
        PtrConfigured = 513497167,
        ReadyToAnnounce = 64641265,
        ReverseDnsLookupFailed = 295755183,
        Validated = 66197998,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::AnnouncedToInternet => "ANNOUNCED_TO_INTERNET",
                Status::Initial => "INITIAL",
                Status::PrefixConfigurationComplete => "PREFIX_CONFIGURATION_COMPLETE",
                Status::PrefixConfigurationInProgress => {
                    "PREFIX_CONFIGURATION_IN_PROGRESS"
                }
                Status::PrefixRemovalInProgress => "PREFIX_REMOVAL_IN_PROGRESS",
                Status::PtrConfigured => "PTR_CONFIGURED",
                Status::ReadyToAnnounce => "READY_TO_ANNOUNCE",
                Status::ReverseDnsLookupFailed => "REVERSE_DNS_LOOKUP_FAILED",
                Status::Validated => "VALIDATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ANNOUNCED_TO_INTERNET" => Some(Self::AnnouncedToInternet),
                "INITIAL" => Some(Self::Initial),
                "PREFIX_CONFIGURATION_COMPLETE" => {
                    Some(Self::PrefixConfigurationComplete)
                }
                "PREFIX_CONFIGURATION_IN_PROGRESS" => {
                    Some(Self::PrefixConfigurationInProgress)
                }
                "PREFIX_REMOVAL_IN_PROGRESS" => Some(Self::PrefixRemovalInProgress),
                "PTR_CONFIGURED" => Some(Self::PtrConfigured),
                "READY_TO_ANNOUNCE" => Some(Self::ReadyToAnnounce),
                "REVERSE_DNS_LOOKUP_FAILED" => Some(Self::ReverseDnsLookupFailed),
                "VALIDATED" => Some(Self::Validated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAdvertisedPrefixList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<PublicAdvertisedPrefix>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicAdvertisedPrefixPublicDelegatedPrefix {
    #[prost(string, optional, tag = "145092645")]
    pub ip_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "227560217")]
    pub project: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicDelegatedPrefix {
    #[prost(int32, optional, tag = "38427446")]
    pub allocatable_prefix_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "162683283")]
    pub byoip_api_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "511823856")]
    pub is_live_migration: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "15233991")]
    pub parent_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "188940044")]
    pub public_delegated_sub_prefixs: ::prost::alloc::vec::Vec<
        PublicDelegatedPrefixPublicDelegatedSubPrefix,
    >,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PublicDelegatedPrefix`.
pub mod public_delegated_prefix {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ByoipApiVersion {
        UndefinedByoipApiVersion = 0,
        V1 = 2715,
        V2 = 2716,
    }
    impl ByoipApiVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ByoipApiVersion::UndefinedByoipApiVersion => {
                    "UNDEFINED_BYOIP_API_VERSION"
                }
                ByoipApiVersion::V1 => "V1",
                ByoipApiVersion::V2 => "V2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BYOIP_API_VERSION" => Some(Self::UndefinedByoipApiVersion),
                "V1" => Some(Self::V1),
                "V2" => Some(Self::V2),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        Delegation = 264149288,
        ExternalIpv6ForwardingRuleCreation = 398684356,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::Delegation => "DELEGATION",
                Mode::ExternalIpv6ForwardingRuleCreation => {
                    "EXTERNAL_IPV6_FORWARDING_RULE_CREATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "DELEGATION" => Some(Self::Delegation),
                "EXTERNAL_IPV6_FORWARDING_RULE_CREATION" => {
                    Some(Self::ExternalIpv6ForwardingRuleCreation)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Announced = 365103355,
        AnnouncedToGoogle = 454875705,
        AnnouncedToInternet = 177880897,
        Deleting = 528602024,
        Initializing = 306588749,
        ReadyToAnnounce = 64641265,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Announced => "ANNOUNCED",
                Status::AnnouncedToGoogle => "ANNOUNCED_TO_GOOGLE",
                Status::AnnouncedToInternet => "ANNOUNCED_TO_INTERNET",
                Status::Deleting => "DELETING",
                Status::Initializing => "INITIALIZING",
                Status::ReadyToAnnounce => "READY_TO_ANNOUNCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ANNOUNCED" => Some(Self::Announced),
                "ANNOUNCED_TO_GOOGLE" => Some(Self::AnnouncedToGoogle),
                "ANNOUNCED_TO_INTERNET" => Some(Self::AnnouncedToInternet),
                "DELETING" => Some(Self::Deleting),
                "INITIALIZING" => Some(Self::Initializing),
                "READY_TO_ANNOUNCE" => Some(Self::ReadyToAnnounce),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicDelegatedPrefixAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        PublicDelegatedPrefixesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicDelegatedPrefixList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<PublicDelegatedPrefix>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicDelegatedPrefixPublicDelegatedSubPrefix {
    #[prost(int32, optional, tag = "38427446")]
    pub allocatable_prefix_length: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "414860634")]
    pub delegatee_project: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "352617951")]
    pub is_address: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `PublicDelegatedPrefixPublicDelegatedSubPrefix`.
pub mod public_delegated_prefix_public_delegated_sub_prefix {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        Delegation = 264149288,
        ExternalIpv6ForwardingRuleCreation = 398684356,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::Delegation => "DELEGATION",
                Mode::ExternalIpv6ForwardingRuleCreation => {
                    "EXTERNAL_IPV6_FORWARDING_RULE_CREATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "DELEGATION" => Some(Self::Delegation),
                "EXTERNAL_IPV6_FORWARDING_RULE_CREATION" => {
                    Some(Self::ExternalIpv6ForwardingRuleCreation)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Active = 314733318,
        Inactive = 270421099,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Active => "ACTIVE",
                Status::Inactive => "INACTIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublicDelegatedPrefixesScopedList {
    #[prost(message, repeated, tag = "315261206")]
    pub public_delegated_prefixes: ::prost::alloc::vec::Vec<PublicDelegatedPrefix>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Quota {
    #[prost(double, optional, tag = "102976443")]
    pub limit: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "533067184")]
    pub metric: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "106164915")]
    pub owner: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(double, optional, tag = "111574433")]
    pub usage: ::core::option::Option<f64>,
}
/// Nested message and enum types in `Quota`.
pub mod quota {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Metric {
        UndefinedMetric = 0,
        A2Cpus = 153206585,
        AffinityGroups = 108303563,
        Autoscalers = 471248988,
        BackendBuckets = 137626846,
        BackendServices = 269623753,
        C2dCpus = 508182517,
        C2Cpus = 317601211,
        C3Cpus = 346230362,
        Commitments = 456141790,
        CommittedA2Cpus = 59330902,
        CommittedC2dCpus = 282390904,
        CommittedC2Cpus = 223725528,
        CommittedC3Cpus = 252354679,
        CommittedCpus = 292394702,
        CommittedE2Cpus = 388120154,
        CommittedLicenses = 357606869,
        CommittedLocalSsdTotalGb = 308393480,
        CommittedM3Cpus = 585985,
        CommittedMemoryOptimizedCpus = 489057886,
        CommittedN2aCpus = 40064304,
        CommittedN2dCpus = 125951757,
        CommittedN2Cpus = 322589603,
        CommittedNvidiaA10080gbGpus = 464326565,
        CommittedNvidiaA100Gpus = 375799445,
        CommittedNvidiaH100Gpus = 71649180,
        CommittedNvidiaK80Gpus = 3857188,
        CommittedNvidiaL4Gpus = 19163645,
        CommittedNvidiaP100Gpus = 107528100,
        CommittedNvidiaP4Gpus = 347952897,
        CommittedNvidiaT4Gpus = 139871237,
        CommittedNvidiaV100Gpus = 219562,
        CommittedT2aCpus = 296378986,
        CommittedT2dCpus = 382266439,
        CommittedZ3Cpus = 263844686,
        Cpus = 2075595,
        CpusAllRegions = 470911149,
        DisksTotalGb = 353520543,
        E2Cpus = 481995837,
        ExternalManagedForwardingRules = 150790089,
        ExternalNetworkLbForwardingRules = 374298265,
        ExternalProtocolForwardingRules = 63478888,
        ExternalVpnGateways = 272457134,
        Firewalls = 374485843,
        ForwardingRules = 432668949,
        GlobalExternalManagedBackendServices = 164566753,
        GlobalExternalManagedForwardingRules = 327611949,
        GlobalExternalProxyLbBackendServices = 400256169,
        GlobalInternalAddresses = 42738332,
        GlobalInternalManagedBackendServices = 256608303,
        GlobalInternalTrafficDirectorBackendServices = 323514196,
        GpusAllRegions = 39387177,
        HdbTotalGb = 319316271,
        HdbTotalIops = 309720317,
        HdbTotalThroughput = 20981374,
        HealthChecks = 289347502,
        Images = 15562360,
        Instances = 131337822,
        InstanceGroups = 355919038,
        InstanceGroupManagers = 101798192,
        InstanceTemplates = 226188271,
        Interconnects = 415204741,
        InterconnectAttachmentsPerRegion = 159968086,
        InterconnectAttachmentsTotalMbps = 425090419,
        InterconnectTotalGbps = 285341866,
        InternalAddresses = 197899392,
        InternalTrafficDirectorForwardingRules = 266433668,
        InPlaceSnapshots = 151359133,
        InUseAddresses = 402125072,
        InUseBackupSchedules = 32786705,
        InUseSnapshotSchedules = 462104083,
        LocalSsdTotalGb = 330878021,
        M1Cpus = 37203366,
        M2Cpus = 65832517,
        M3Cpus = 94461668,
        MachineImages = 446986640,
        N2aCpus = 265855917,
        N2dCpus = 351743370,
        N2Cpus = 416465286,
        Networks = 485481477,
        NetworkAttachments = 149028575,
        NetworkEndpointGroups = 102144909,
        NetworkFirewallPolicies = 101117374,
        NetLbSecurityPoliciesPerRegion = 157892269,
        NetLbSecurityPolicyRulesPerRegion = 356090931,
        NetLbSecurityPolicyRuleAttributesPerRegion = 311243888,
        NodeGroups = 24624817,
        NodeTemplates = 474896668,
        NvidiaA10080gbGpus = 286389320,
        NvidiaA100Gpus = 504872978,
        NvidiaK80Gpus = 163886599,
        NvidiaL4Gpus = 491923130,
        NvidiaP100Gpus = 236601633,
        NvidiaP100VwsGpus = 213970574,
        NvidiaP4Gpus = 283841470,
        NvidiaP4VwsGpus = 528296619,
        NvidiaT4Gpus = 75759810,
        NvidiaT4VwsGpus = 319813039,
        NvidiaV100Gpus = 129293095,
        PacketMirrorings = 15578407,
        PdExtremeTotalProvisionedIops = 69593965,
        PreemptibleCpus = 251184841,
        PreemptibleLocalSsdGb = 260819336,
        PreemptibleNvidiaA10080gbGpus = 151942410,
        PreemptibleNvidiaA100Gpus = 68832784,
        PreemptibleNvidiaH100Gpus = 301553431,
        PreemptibleNvidiaK80Gpus = 374960201,
        PreemptibleNvidiaL4Gpus = 100408376,
        PreemptibleNvidiaP100Gpus = 337432351,
        PreemptibleNvidiaP100VwsGpus = 313544076,
        PreemptibleNvidiaP4Gpus = 429197628,
        PreemptibleNvidiaP4VwsGpus = 252981545,
        PreemptibleNvidiaT4Gpus = 221115968,
        PreemptibleNvidiaT4VwsGpus = 44497965,
        PreemptibleNvidiaV100Gpus = 230123813,
        PreemptibleTpuLiteDeviceV5 = 174262523,
        PreemptibleTpuLitePodsliceV5 = 112281796,
        PreemptibleTpuPodsliceV4 = 425541132,
        PscIlbConsumerForwardingRulesPerProducerNetwork = 231164291,
        PscInternalLbForwardingRules = 169005435,
        PublicAdvertisedPrefixes = 471371980,
        PublicDelegatedPrefixes = 532465974,
        RegionalAutoscalers = 29363772,
        RegionalExternalManagedBackendServices = 4240989,
        RegionalExternalNetworkLbBackendServices = 409564525,
        RegionalInstanceGroupManagers = 37543696,
        RegionalInternalLbBackendServices = 137983760,
        RegionalInternalManagedBackendServices = 96282539,
        RegionalInternalTrafficDirectorBackendServices = 483162968,
        Reservations = 32644647,
        ResourcePolicies = 83955297,
        Routers = 493018666,
        Routes = 275680074,
        SecurityPolicies = 189518703,
        SecurityPoliciesPerRegion = 249041734,
        SecurityPolicyAdvancedRulesPerRegion = 371815341,
        SecurityPolicyCevalRules = 470815689,
        SecurityPolicyRules = 203549225,
        SecurityPolicyRulesPerRegion = 126510156,
        ServiceAttachments = 471521510,
        Snapshots = 343405327,
        SsdTotalGb = 161732561,
        SslCertificates = 378372399,
        SslPolicies = 523254339,
        StaticAddresses = 93624049,
        StaticByoipAddresses = 275809649,
        StaticExternalIpv6AddressRanges = 472346774,
        Subnetworks = 421330469,
        T2aCpus = 522170599,
        T2dCpus = 71187140,
        TargetHttpsProxies = 219522506,
        TargetHttpProxies = 164117155,
        TargetInstances = 284519728,
        TargetPools = 348261257,
        TargetSslProxies = 159216235,
        TargetTcpProxies = 182243136,
        TargetVpnGateways = 75029928,
        TpuLiteDeviceV5 = 449577597,
        TpuLitePodsliceV5 = 12708294,
        TpuPodsliceV4 = 214467530,
        UrlMaps = 378660743,
        VariableIpv6PublicDelegatedPrefixes = 128400161,
        VpnGateways = 35620282,
        VpnTunnels = 104327296,
        XpnServiceProjects = 95191981,
    }
    impl Metric {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Metric::UndefinedMetric => "UNDEFINED_METRIC",
                Metric::A2Cpus => "A2_CPUS",
                Metric::AffinityGroups => "AFFINITY_GROUPS",
                Metric::Autoscalers => "AUTOSCALERS",
                Metric::BackendBuckets => "BACKEND_BUCKETS",
                Metric::BackendServices => "BACKEND_SERVICES",
                Metric::C2dCpus => "C2D_CPUS",
                Metric::C2Cpus => "C2_CPUS",
                Metric::C3Cpus => "C3_CPUS",
                Metric::Commitments => "COMMITMENTS",
                Metric::CommittedA2Cpus => "COMMITTED_A2_CPUS",
                Metric::CommittedC2dCpus => "COMMITTED_C2D_CPUS",
                Metric::CommittedC2Cpus => "COMMITTED_C2_CPUS",
                Metric::CommittedC3Cpus => "COMMITTED_C3_CPUS",
                Metric::CommittedCpus => "COMMITTED_CPUS",
                Metric::CommittedE2Cpus => "COMMITTED_E2_CPUS",
                Metric::CommittedLicenses => "COMMITTED_LICENSES",
                Metric::CommittedLocalSsdTotalGb => "COMMITTED_LOCAL_SSD_TOTAL_GB",
                Metric::CommittedM3Cpus => "COMMITTED_M3_CPUS",
                Metric::CommittedMemoryOptimizedCpus => "COMMITTED_MEMORY_OPTIMIZED_CPUS",
                Metric::CommittedN2aCpus => "COMMITTED_N2A_CPUS",
                Metric::CommittedN2dCpus => "COMMITTED_N2D_CPUS",
                Metric::CommittedN2Cpus => "COMMITTED_N2_CPUS",
                Metric::CommittedNvidiaA10080gbGpus => "COMMITTED_NVIDIA_A100_80GB_GPUS",
                Metric::CommittedNvidiaA100Gpus => "COMMITTED_NVIDIA_A100_GPUS",
                Metric::CommittedNvidiaH100Gpus => "COMMITTED_NVIDIA_H100_GPUS",
                Metric::CommittedNvidiaK80Gpus => "COMMITTED_NVIDIA_K80_GPUS",
                Metric::CommittedNvidiaL4Gpus => "COMMITTED_NVIDIA_L4_GPUS",
                Metric::CommittedNvidiaP100Gpus => "COMMITTED_NVIDIA_P100_GPUS",
                Metric::CommittedNvidiaP4Gpus => "COMMITTED_NVIDIA_P4_GPUS",
                Metric::CommittedNvidiaT4Gpus => "COMMITTED_NVIDIA_T4_GPUS",
                Metric::CommittedNvidiaV100Gpus => "COMMITTED_NVIDIA_V100_GPUS",
                Metric::CommittedT2aCpus => "COMMITTED_T2A_CPUS",
                Metric::CommittedT2dCpus => "COMMITTED_T2D_CPUS",
                Metric::CommittedZ3Cpus => "COMMITTED_Z3_CPUS",
                Metric::Cpus => "CPUS",
                Metric::CpusAllRegions => "CPUS_ALL_REGIONS",
                Metric::DisksTotalGb => "DISKS_TOTAL_GB",
                Metric::E2Cpus => "E2_CPUS",
                Metric::ExternalManagedForwardingRules => {
                    "EXTERNAL_MANAGED_FORWARDING_RULES"
                }
                Metric::ExternalNetworkLbForwardingRules => {
                    "EXTERNAL_NETWORK_LB_FORWARDING_RULES"
                }
                Metric::ExternalProtocolForwardingRules => {
                    "EXTERNAL_PROTOCOL_FORWARDING_RULES"
                }
                Metric::ExternalVpnGateways => "EXTERNAL_VPN_GATEWAYS",
                Metric::Firewalls => "FIREWALLS",
                Metric::ForwardingRules => "FORWARDING_RULES",
                Metric::GlobalExternalManagedBackendServices => {
                    "GLOBAL_EXTERNAL_MANAGED_BACKEND_SERVICES"
                }
                Metric::GlobalExternalManagedForwardingRules => {
                    "GLOBAL_EXTERNAL_MANAGED_FORWARDING_RULES"
                }
                Metric::GlobalExternalProxyLbBackendServices => {
                    "GLOBAL_EXTERNAL_PROXY_LB_BACKEND_SERVICES"
                }
                Metric::GlobalInternalAddresses => "GLOBAL_INTERNAL_ADDRESSES",
                Metric::GlobalInternalManagedBackendServices => {
                    "GLOBAL_INTERNAL_MANAGED_BACKEND_SERVICES"
                }
                Metric::GlobalInternalTrafficDirectorBackendServices => {
                    "GLOBAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES"
                }
                Metric::GpusAllRegions => "GPUS_ALL_REGIONS",
                Metric::HdbTotalGb => "HDB_TOTAL_GB",
                Metric::HdbTotalIops => "HDB_TOTAL_IOPS",
                Metric::HdbTotalThroughput => "HDB_TOTAL_THROUGHPUT",
                Metric::HealthChecks => "HEALTH_CHECKS",
                Metric::Images => "IMAGES",
                Metric::Instances => "INSTANCES",
                Metric::InstanceGroups => "INSTANCE_GROUPS",
                Metric::InstanceGroupManagers => "INSTANCE_GROUP_MANAGERS",
                Metric::InstanceTemplates => "INSTANCE_TEMPLATES",
                Metric::Interconnects => "INTERCONNECTS",
                Metric::InterconnectAttachmentsPerRegion => {
                    "INTERCONNECT_ATTACHMENTS_PER_REGION"
                }
                Metric::InterconnectAttachmentsTotalMbps => {
                    "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS"
                }
                Metric::InterconnectTotalGbps => "INTERCONNECT_TOTAL_GBPS",
                Metric::InternalAddresses => "INTERNAL_ADDRESSES",
                Metric::InternalTrafficDirectorForwardingRules => {
                    "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES"
                }
                Metric::InPlaceSnapshots => "IN_PLACE_SNAPSHOTS",
                Metric::InUseAddresses => "IN_USE_ADDRESSES",
                Metric::InUseBackupSchedules => "IN_USE_BACKUP_SCHEDULES",
                Metric::InUseSnapshotSchedules => "IN_USE_SNAPSHOT_SCHEDULES",
                Metric::LocalSsdTotalGb => "LOCAL_SSD_TOTAL_GB",
                Metric::M1Cpus => "M1_CPUS",
                Metric::M2Cpus => "M2_CPUS",
                Metric::M3Cpus => "M3_CPUS",
                Metric::MachineImages => "MACHINE_IMAGES",
                Metric::N2aCpus => "N2A_CPUS",
                Metric::N2dCpus => "N2D_CPUS",
                Metric::N2Cpus => "N2_CPUS",
                Metric::Networks => "NETWORKS",
                Metric::NetworkAttachments => "NETWORK_ATTACHMENTS",
                Metric::NetworkEndpointGroups => "NETWORK_ENDPOINT_GROUPS",
                Metric::NetworkFirewallPolicies => "NETWORK_FIREWALL_POLICIES",
                Metric::NetLbSecurityPoliciesPerRegion => {
                    "NET_LB_SECURITY_POLICIES_PER_REGION"
                }
                Metric::NetLbSecurityPolicyRulesPerRegion => {
                    "NET_LB_SECURITY_POLICY_RULES_PER_REGION"
                }
                Metric::NetLbSecurityPolicyRuleAttributesPerRegion => {
                    "NET_LB_SECURITY_POLICY_RULE_ATTRIBUTES_PER_REGION"
                }
                Metric::NodeGroups => "NODE_GROUPS",
                Metric::NodeTemplates => "NODE_TEMPLATES",
                Metric::NvidiaA10080gbGpus => "NVIDIA_A100_80GB_GPUS",
                Metric::NvidiaA100Gpus => "NVIDIA_A100_GPUS",
                Metric::NvidiaK80Gpus => "NVIDIA_K80_GPUS",
                Metric::NvidiaL4Gpus => "NVIDIA_L4_GPUS",
                Metric::NvidiaP100Gpus => "NVIDIA_P100_GPUS",
                Metric::NvidiaP100VwsGpus => "NVIDIA_P100_VWS_GPUS",
                Metric::NvidiaP4Gpus => "NVIDIA_P4_GPUS",
                Metric::NvidiaP4VwsGpus => "NVIDIA_P4_VWS_GPUS",
                Metric::NvidiaT4Gpus => "NVIDIA_T4_GPUS",
                Metric::NvidiaT4VwsGpus => "NVIDIA_T4_VWS_GPUS",
                Metric::NvidiaV100Gpus => "NVIDIA_V100_GPUS",
                Metric::PacketMirrorings => "PACKET_MIRRORINGS",
                Metric::PdExtremeTotalProvisionedIops => {
                    "PD_EXTREME_TOTAL_PROVISIONED_IOPS"
                }
                Metric::PreemptibleCpus => "PREEMPTIBLE_CPUS",
                Metric::PreemptibleLocalSsdGb => "PREEMPTIBLE_LOCAL_SSD_GB",
                Metric::PreemptibleNvidiaA10080gbGpus => {
                    "PREEMPTIBLE_NVIDIA_A100_80GB_GPUS"
                }
                Metric::PreemptibleNvidiaA100Gpus => "PREEMPTIBLE_NVIDIA_A100_GPUS",
                Metric::PreemptibleNvidiaH100Gpus => "PREEMPTIBLE_NVIDIA_H100_GPUS",
                Metric::PreemptibleNvidiaK80Gpus => "PREEMPTIBLE_NVIDIA_K80_GPUS",
                Metric::PreemptibleNvidiaL4Gpus => "PREEMPTIBLE_NVIDIA_L4_GPUS",
                Metric::PreemptibleNvidiaP100Gpus => "PREEMPTIBLE_NVIDIA_P100_GPUS",
                Metric::PreemptibleNvidiaP100VwsGpus => {
                    "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS"
                }
                Metric::PreemptibleNvidiaP4Gpus => "PREEMPTIBLE_NVIDIA_P4_GPUS",
                Metric::PreemptibleNvidiaP4VwsGpus => "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS",
                Metric::PreemptibleNvidiaT4Gpus => "PREEMPTIBLE_NVIDIA_T4_GPUS",
                Metric::PreemptibleNvidiaT4VwsGpus => "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS",
                Metric::PreemptibleNvidiaV100Gpus => "PREEMPTIBLE_NVIDIA_V100_GPUS",
                Metric::PreemptibleTpuLiteDeviceV5 => "PREEMPTIBLE_TPU_LITE_DEVICE_V5",
                Metric::PreemptibleTpuLitePodsliceV5 => {
                    "PREEMPTIBLE_TPU_LITE_PODSLICE_V5"
                }
                Metric::PreemptibleTpuPodsliceV4 => "PREEMPTIBLE_TPU_PODSLICE_V4",
                Metric::PscIlbConsumerForwardingRulesPerProducerNetwork => {
                    "PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK"
                }
                Metric::PscInternalLbForwardingRules => {
                    "PSC_INTERNAL_LB_FORWARDING_RULES"
                }
                Metric::PublicAdvertisedPrefixes => "PUBLIC_ADVERTISED_PREFIXES",
                Metric::PublicDelegatedPrefixes => "PUBLIC_DELEGATED_PREFIXES",
                Metric::RegionalAutoscalers => "REGIONAL_AUTOSCALERS",
                Metric::RegionalExternalManagedBackendServices => {
                    "REGIONAL_EXTERNAL_MANAGED_BACKEND_SERVICES"
                }
                Metric::RegionalExternalNetworkLbBackendServices => {
                    "REGIONAL_EXTERNAL_NETWORK_LB_BACKEND_SERVICES"
                }
                Metric::RegionalInstanceGroupManagers => {
                    "REGIONAL_INSTANCE_GROUP_MANAGERS"
                }
                Metric::RegionalInternalLbBackendServices => {
                    "REGIONAL_INTERNAL_LB_BACKEND_SERVICES"
                }
                Metric::RegionalInternalManagedBackendServices => {
                    "REGIONAL_INTERNAL_MANAGED_BACKEND_SERVICES"
                }
                Metric::RegionalInternalTrafficDirectorBackendServices => {
                    "REGIONAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES"
                }
                Metric::Reservations => "RESERVATIONS",
                Metric::ResourcePolicies => "RESOURCE_POLICIES",
                Metric::Routers => "ROUTERS",
                Metric::Routes => "ROUTES",
                Metric::SecurityPolicies => "SECURITY_POLICIES",
                Metric::SecurityPoliciesPerRegion => "SECURITY_POLICIES_PER_REGION",
                Metric::SecurityPolicyAdvancedRulesPerRegion => {
                    "SECURITY_POLICY_ADVANCED_RULES_PER_REGION"
                }
                Metric::SecurityPolicyCevalRules => "SECURITY_POLICY_CEVAL_RULES",
                Metric::SecurityPolicyRules => "SECURITY_POLICY_RULES",
                Metric::SecurityPolicyRulesPerRegion => {
                    "SECURITY_POLICY_RULES_PER_REGION"
                }
                Metric::ServiceAttachments => "SERVICE_ATTACHMENTS",
                Metric::Snapshots => "SNAPSHOTS",
                Metric::SsdTotalGb => "SSD_TOTAL_GB",
                Metric::SslCertificates => "SSL_CERTIFICATES",
                Metric::SslPolicies => "SSL_POLICIES",
                Metric::StaticAddresses => "STATIC_ADDRESSES",
                Metric::StaticByoipAddresses => "STATIC_BYOIP_ADDRESSES",
                Metric::StaticExternalIpv6AddressRanges => {
                    "STATIC_EXTERNAL_IPV6_ADDRESS_RANGES"
                }
                Metric::Subnetworks => "SUBNETWORKS",
                Metric::T2aCpus => "T2A_CPUS",
                Metric::T2dCpus => "T2D_CPUS",
                Metric::TargetHttpsProxies => "TARGET_HTTPS_PROXIES",
                Metric::TargetHttpProxies => "TARGET_HTTP_PROXIES",
                Metric::TargetInstances => "TARGET_INSTANCES",
                Metric::TargetPools => "TARGET_POOLS",
                Metric::TargetSslProxies => "TARGET_SSL_PROXIES",
                Metric::TargetTcpProxies => "TARGET_TCP_PROXIES",
                Metric::TargetVpnGateways => "TARGET_VPN_GATEWAYS",
                Metric::TpuLiteDeviceV5 => "TPU_LITE_DEVICE_V5",
                Metric::TpuLitePodsliceV5 => "TPU_LITE_PODSLICE_V5",
                Metric::TpuPodsliceV4 => "TPU_PODSLICE_V4",
                Metric::UrlMaps => "URL_MAPS",
                Metric::VariableIpv6PublicDelegatedPrefixes => {
                    "VARIABLE_IPV6_PUBLIC_DELEGATED_PREFIXES"
                }
                Metric::VpnGateways => "VPN_GATEWAYS",
                Metric::VpnTunnels => "VPN_TUNNELS",
                Metric::XpnServiceProjects => "XPN_SERVICE_PROJECTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_METRIC" => Some(Self::UndefinedMetric),
                "A2_CPUS" => Some(Self::A2Cpus),
                "AFFINITY_GROUPS" => Some(Self::AffinityGroups),
                "AUTOSCALERS" => Some(Self::Autoscalers),
                "BACKEND_BUCKETS" => Some(Self::BackendBuckets),
                "BACKEND_SERVICES" => Some(Self::BackendServices),
                "C2D_CPUS" => Some(Self::C2dCpus),
                "C2_CPUS" => Some(Self::C2Cpus),
                "C3_CPUS" => Some(Self::C3Cpus),
                "COMMITMENTS" => Some(Self::Commitments),
                "COMMITTED_A2_CPUS" => Some(Self::CommittedA2Cpus),
                "COMMITTED_C2D_CPUS" => Some(Self::CommittedC2dCpus),
                "COMMITTED_C2_CPUS" => Some(Self::CommittedC2Cpus),
                "COMMITTED_C3_CPUS" => Some(Self::CommittedC3Cpus),
                "COMMITTED_CPUS" => Some(Self::CommittedCpus),
                "COMMITTED_E2_CPUS" => Some(Self::CommittedE2Cpus),
                "COMMITTED_LICENSES" => Some(Self::CommittedLicenses),
                "COMMITTED_LOCAL_SSD_TOTAL_GB" => Some(Self::CommittedLocalSsdTotalGb),
                "COMMITTED_M3_CPUS" => Some(Self::CommittedM3Cpus),
                "COMMITTED_MEMORY_OPTIMIZED_CPUS" => {
                    Some(Self::CommittedMemoryOptimizedCpus)
                }
                "COMMITTED_N2A_CPUS" => Some(Self::CommittedN2aCpus),
                "COMMITTED_N2D_CPUS" => Some(Self::CommittedN2dCpus),
                "COMMITTED_N2_CPUS" => Some(Self::CommittedN2Cpus),
                "COMMITTED_NVIDIA_A100_80GB_GPUS" => {
                    Some(Self::CommittedNvidiaA10080gbGpus)
                }
                "COMMITTED_NVIDIA_A100_GPUS" => Some(Self::CommittedNvidiaA100Gpus),
                "COMMITTED_NVIDIA_H100_GPUS" => Some(Self::CommittedNvidiaH100Gpus),
                "COMMITTED_NVIDIA_K80_GPUS" => Some(Self::CommittedNvidiaK80Gpus),
                "COMMITTED_NVIDIA_L4_GPUS" => Some(Self::CommittedNvidiaL4Gpus),
                "COMMITTED_NVIDIA_P100_GPUS" => Some(Self::CommittedNvidiaP100Gpus),
                "COMMITTED_NVIDIA_P4_GPUS" => Some(Self::CommittedNvidiaP4Gpus),
                "COMMITTED_NVIDIA_T4_GPUS" => Some(Self::CommittedNvidiaT4Gpus),
                "COMMITTED_NVIDIA_V100_GPUS" => Some(Self::CommittedNvidiaV100Gpus),
                "COMMITTED_T2A_CPUS" => Some(Self::CommittedT2aCpus),
                "COMMITTED_T2D_CPUS" => Some(Self::CommittedT2dCpus),
                "COMMITTED_Z3_CPUS" => Some(Self::CommittedZ3Cpus),
                "CPUS" => Some(Self::Cpus),
                "CPUS_ALL_REGIONS" => Some(Self::CpusAllRegions),
                "DISKS_TOTAL_GB" => Some(Self::DisksTotalGb),
                "E2_CPUS" => Some(Self::E2Cpus),
                "EXTERNAL_MANAGED_FORWARDING_RULES" => {
                    Some(Self::ExternalManagedForwardingRules)
                }
                "EXTERNAL_NETWORK_LB_FORWARDING_RULES" => {
                    Some(Self::ExternalNetworkLbForwardingRules)
                }
                "EXTERNAL_PROTOCOL_FORWARDING_RULES" => {
                    Some(Self::ExternalProtocolForwardingRules)
                }
                "EXTERNAL_VPN_GATEWAYS" => Some(Self::ExternalVpnGateways),
                "FIREWALLS" => Some(Self::Firewalls),
                "FORWARDING_RULES" => Some(Self::ForwardingRules),
                "GLOBAL_EXTERNAL_MANAGED_BACKEND_SERVICES" => {
                    Some(Self::GlobalExternalManagedBackendServices)
                }
                "GLOBAL_EXTERNAL_MANAGED_FORWARDING_RULES" => {
                    Some(Self::GlobalExternalManagedForwardingRules)
                }
                "GLOBAL_EXTERNAL_PROXY_LB_BACKEND_SERVICES" => {
                    Some(Self::GlobalExternalProxyLbBackendServices)
                }
                "GLOBAL_INTERNAL_ADDRESSES" => Some(Self::GlobalInternalAddresses),
                "GLOBAL_INTERNAL_MANAGED_BACKEND_SERVICES" => {
                    Some(Self::GlobalInternalManagedBackendServices)
                }
                "GLOBAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES" => {
                    Some(Self::GlobalInternalTrafficDirectorBackendServices)
                }
                "GPUS_ALL_REGIONS" => Some(Self::GpusAllRegions),
                "HDB_TOTAL_GB" => Some(Self::HdbTotalGb),
                "HDB_TOTAL_IOPS" => Some(Self::HdbTotalIops),
                "HDB_TOTAL_THROUGHPUT" => Some(Self::HdbTotalThroughput),
                "HEALTH_CHECKS" => Some(Self::HealthChecks),
                "IMAGES" => Some(Self::Images),
                "INSTANCES" => Some(Self::Instances),
                "INSTANCE_GROUPS" => Some(Self::InstanceGroups),
                "INSTANCE_GROUP_MANAGERS" => Some(Self::InstanceGroupManagers),
                "INSTANCE_TEMPLATES" => Some(Self::InstanceTemplates),
                "INTERCONNECTS" => Some(Self::Interconnects),
                "INTERCONNECT_ATTACHMENTS_PER_REGION" => {
                    Some(Self::InterconnectAttachmentsPerRegion)
                }
                "INTERCONNECT_ATTACHMENTS_TOTAL_MBPS" => {
                    Some(Self::InterconnectAttachmentsTotalMbps)
                }
                "INTERCONNECT_TOTAL_GBPS" => Some(Self::InterconnectTotalGbps),
                "INTERNAL_ADDRESSES" => Some(Self::InternalAddresses),
                "INTERNAL_TRAFFIC_DIRECTOR_FORWARDING_RULES" => {
                    Some(Self::InternalTrafficDirectorForwardingRules)
                }
                "IN_PLACE_SNAPSHOTS" => Some(Self::InPlaceSnapshots),
                "IN_USE_ADDRESSES" => Some(Self::InUseAddresses),
                "IN_USE_BACKUP_SCHEDULES" => Some(Self::InUseBackupSchedules),
                "IN_USE_SNAPSHOT_SCHEDULES" => Some(Self::InUseSnapshotSchedules),
                "LOCAL_SSD_TOTAL_GB" => Some(Self::LocalSsdTotalGb),
                "M1_CPUS" => Some(Self::M1Cpus),
                "M2_CPUS" => Some(Self::M2Cpus),
                "M3_CPUS" => Some(Self::M3Cpus),
                "MACHINE_IMAGES" => Some(Self::MachineImages),
                "N2A_CPUS" => Some(Self::N2aCpus),
                "N2D_CPUS" => Some(Self::N2dCpus),
                "N2_CPUS" => Some(Self::N2Cpus),
                "NETWORKS" => Some(Self::Networks),
                "NETWORK_ATTACHMENTS" => Some(Self::NetworkAttachments),
                "NETWORK_ENDPOINT_GROUPS" => Some(Self::NetworkEndpointGroups),
                "NETWORK_FIREWALL_POLICIES" => Some(Self::NetworkFirewallPolicies),
                "NET_LB_SECURITY_POLICIES_PER_REGION" => {
                    Some(Self::NetLbSecurityPoliciesPerRegion)
                }
                "NET_LB_SECURITY_POLICY_RULES_PER_REGION" => {
                    Some(Self::NetLbSecurityPolicyRulesPerRegion)
                }
                "NET_LB_SECURITY_POLICY_RULE_ATTRIBUTES_PER_REGION" => {
                    Some(Self::NetLbSecurityPolicyRuleAttributesPerRegion)
                }
                "NODE_GROUPS" => Some(Self::NodeGroups),
                "NODE_TEMPLATES" => Some(Self::NodeTemplates),
                "NVIDIA_A100_80GB_GPUS" => Some(Self::NvidiaA10080gbGpus),
                "NVIDIA_A100_GPUS" => Some(Self::NvidiaA100Gpus),
                "NVIDIA_K80_GPUS" => Some(Self::NvidiaK80Gpus),
                "NVIDIA_L4_GPUS" => Some(Self::NvidiaL4Gpus),
                "NVIDIA_P100_GPUS" => Some(Self::NvidiaP100Gpus),
                "NVIDIA_P100_VWS_GPUS" => Some(Self::NvidiaP100VwsGpus),
                "NVIDIA_P4_GPUS" => Some(Self::NvidiaP4Gpus),
                "NVIDIA_P4_VWS_GPUS" => Some(Self::NvidiaP4VwsGpus),
                "NVIDIA_T4_GPUS" => Some(Self::NvidiaT4Gpus),
                "NVIDIA_T4_VWS_GPUS" => Some(Self::NvidiaT4VwsGpus),
                "NVIDIA_V100_GPUS" => Some(Self::NvidiaV100Gpus),
                "PACKET_MIRRORINGS" => Some(Self::PacketMirrorings),
                "PD_EXTREME_TOTAL_PROVISIONED_IOPS" => {
                    Some(Self::PdExtremeTotalProvisionedIops)
                }
                "PREEMPTIBLE_CPUS" => Some(Self::PreemptibleCpus),
                "PREEMPTIBLE_LOCAL_SSD_GB" => Some(Self::PreemptibleLocalSsdGb),
                "PREEMPTIBLE_NVIDIA_A100_80GB_GPUS" => {
                    Some(Self::PreemptibleNvidiaA10080gbGpus)
                }
                "PREEMPTIBLE_NVIDIA_A100_GPUS" => Some(Self::PreemptibleNvidiaA100Gpus),
                "PREEMPTIBLE_NVIDIA_H100_GPUS" => Some(Self::PreemptibleNvidiaH100Gpus),
                "PREEMPTIBLE_NVIDIA_K80_GPUS" => Some(Self::PreemptibleNvidiaK80Gpus),
                "PREEMPTIBLE_NVIDIA_L4_GPUS" => Some(Self::PreemptibleNvidiaL4Gpus),
                "PREEMPTIBLE_NVIDIA_P100_GPUS" => Some(Self::PreemptibleNvidiaP100Gpus),
                "PREEMPTIBLE_NVIDIA_P100_VWS_GPUS" => {
                    Some(Self::PreemptibleNvidiaP100VwsGpus)
                }
                "PREEMPTIBLE_NVIDIA_P4_GPUS" => Some(Self::PreemptibleNvidiaP4Gpus),
                "PREEMPTIBLE_NVIDIA_P4_VWS_GPUS" => {
                    Some(Self::PreemptibleNvidiaP4VwsGpus)
                }
                "PREEMPTIBLE_NVIDIA_T4_GPUS" => Some(Self::PreemptibleNvidiaT4Gpus),
                "PREEMPTIBLE_NVIDIA_T4_VWS_GPUS" => {
                    Some(Self::PreemptibleNvidiaT4VwsGpus)
                }
                "PREEMPTIBLE_NVIDIA_V100_GPUS" => Some(Self::PreemptibleNvidiaV100Gpus),
                "PREEMPTIBLE_TPU_LITE_DEVICE_V5" => {
                    Some(Self::PreemptibleTpuLiteDeviceV5)
                }
                "PREEMPTIBLE_TPU_LITE_PODSLICE_V5" => {
                    Some(Self::PreemptibleTpuLitePodsliceV5)
                }
                "PREEMPTIBLE_TPU_PODSLICE_V4" => Some(Self::PreemptibleTpuPodsliceV4),
                "PSC_ILB_CONSUMER_FORWARDING_RULES_PER_PRODUCER_NETWORK" => {
                    Some(Self::PscIlbConsumerForwardingRulesPerProducerNetwork)
                }
                "PSC_INTERNAL_LB_FORWARDING_RULES" => {
                    Some(Self::PscInternalLbForwardingRules)
                }
                "PUBLIC_ADVERTISED_PREFIXES" => Some(Self::PublicAdvertisedPrefixes),
                "PUBLIC_DELEGATED_PREFIXES" => Some(Self::PublicDelegatedPrefixes),
                "REGIONAL_AUTOSCALERS" => Some(Self::RegionalAutoscalers),
                "REGIONAL_EXTERNAL_MANAGED_BACKEND_SERVICES" => {
                    Some(Self::RegionalExternalManagedBackendServices)
                }
                "REGIONAL_EXTERNAL_NETWORK_LB_BACKEND_SERVICES" => {
                    Some(Self::RegionalExternalNetworkLbBackendServices)
                }
                "REGIONAL_INSTANCE_GROUP_MANAGERS" => {
                    Some(Self::RegionalInstanceGroupManagers)
                }
                "REGIONAL_INTERNAL_LB_BACKEND_SERVICES" => {
                    Some(Self::RegionalInternalLbBackendServices)
                }
                "REGIONAL_INTERNAL_MANAGED_BACKEND_SERVICES" => {
                    Some(Self::RegionalInternalManagedBackendServices)
                }
                "REGIONAL_INTERNAL_TRAFFIC_DIRECTOR_BACKEND_SERVICES" => {
                    Some(Self::RegionalInternalTrafficDirectorBackendServices)
                }
                "RESERVATIONS" => Some(Self::Reservations),
                "RESOURCE_POLICIES" => Some(Self::ResourcePolicies),
                "ROUTERS" => Some(Self::Routers),
                "ROUTES" => Some(Self::Routes),
                "SECURITY_POLICIES" => Some(Self::SecurityPolicies),
                "SECURITY_POLICIES_PER_REGION" => Some(Self::SecurityPoliciesPerRegion),
                "SECURITY_POLICY_ADVANCED_RULES_PER_REGION" => {
                    Some(Self::SecurityPolicyAdvancedRulesPerRegion)
                }
                "SECURITY_POLICY_CEVAL_RULES" => Some(Self::SecurityPolicyCevalRules),
                "SECURITY_POLICY_RULES" => Some(Self::SecurityPolicyRules),
                "SECURITY_POLICY_RULES_PER_REGION" => {
                    Some(Self::SecurityPolicyRulesPerRegion)
                }
                "SERVICE_ATTACHMENTS" => Some(Self::ServiceAttachments),
                "SNAPSHOTS" => Some(Self::Snapshots),
                "SSD_TOTAL_GB" => Some(Self::SsdTotalGb),
                "SSL_CERTIFICATES" => Some(Self::SslCertificates),
                "SSL_POLICIES" => Some(Self::SslPolicies),
                "STATIC_ADDRESSES" => Some(Self::StaticAddresses),
                "STATIC_BYOIP_ADDRESSES" => Some(Self::StaticByoipAddresses),
                "STATIC_EXTERNAL_IPV6_ADDRESS_RANGES" => {
                    Some(Self::StaticExternalIpv6AddressRanges)
                }
                "SUBNETWORKS" => Some(Self::Subnetworks),
                "T2A_CPUS" => Some(Self::T2aCpus),
                "T2D_CPUS" => Some(Self::T2dCpus),
                "TARGET_HTTPS_PROXIES" => Some(Self::TargetHttpsProxies),
                "TARGET_HTTP_PROXIES" => Some(Self::TargetHttpProxies),
                "TARGET_INSTANCES" => Some(Self::TargetInstances),
                "TARGET_POOLS" => Some(Self::TargetPools),
                "TARGET_SSL_PROXIES" => Some(Self::TargetSslProxies),
                "TARGET_TCP_PROXIES" => Some(Self::TargetTcpProxies),
                "TARGET_VPN_GATEWAYS" => Some(Self::TargetVpnGateways),
                "TPU_LITE_DEVICE_V5" => Some(Self::TpuLiteDeviceV5),
                "TPU_LITE_PODSLICE_V5" => Some(Self::TpuLitePodsliceV5),
                "TPU_PODSLICE_V4" => Some(Self::TpuPodsliceV4),
                "URL_MAPS" => Some(Self::UrlMaps),
                "VARIABLE_IPV6_PUBLIC_DELEGATED_PREFIXES" => {
                    Some(Self::VariableIpv6PublicDelegatedPrefixes)
                }
                "VPN_GATEWAYS" => Some(Self::VpnGateways),
                "VPN_TUNNELS" => Some(Self::VpnTunnels),
                "XPN_SERVICE_PROJECTS" => Some(Self::XpnServiceProjects),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaExceededInfo {
    #[prost(map = "string, string", tag = "414334925")]
    pub dimensions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(double, optional, tag = "456564287")]
    pub future_limit: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "102976443")]
    pub limit: ::core::option::Option<f64>,
    #[prost(string, optional, tag = "398197903")]
    pub limit_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "409881530")]
    pub metric_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "476426816")]
    pub rollout_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `QuotaExceededInfo`.
pub mod quota_exceeded_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RolloutStatus {
        UndefinedRolloutStatus = 0,
        InProgress = 469193735,
        Unspecified = 26864568,
    }
    impl RolloutStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RolloutStatus::UndefinedRolloutStatus => "UNDEFINED_ROLLOUT_STATUS",
                RolloutStatus::InProgress => "IN_PROGRESS",
                RolloutStatus::Unspecified => "ROLLOUT_STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROLLOUT_STATUS" => Some(Self::UndefinedRolloutStatus),
                "IN_PROGRESS" => Some(Self::InProgress),
                "ROLLOUT_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaStatusWarning {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3076010")]
    pub data: ::prost::alloc::vec::Vec<Data>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `QuotaStatusWarning`.
pub mod quota_status_warning {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        UndefinedCode = 0,
        CleanupFailed = 150308440,
        DeprecatedResourceUsed = 391835586,
        DeprecatedTypeUsed = 346526230,
        DiskSizeLargerThanImageSize = 369442967,
        ExperimentalTypeUsed = 451954443,
        ExternalApiWarning = 175546307,
        FieldValueOverriden = 329669423,
        InjectedKernelsDeprecated = 417377419,
        InvalidHealthCheckForDynamicWieghtedLb = 401542606,
        LargeDeploymentWarning = 481440678,
        ListOverheadQuotaExceed = 47618117,
        MissingTypeDependency = 344505463,
        NextHopAddressNotAssigned = 324964999,
        NextHopCannotIpForward = 383382887,
        NextHopInstanceHasNoIpv6Interface = 146748434,
        NextHopInstanceNotFound = 464250446,
        NextHopInstanceNotOnNetwork = 243758146,
        NextHopNotRunning = 417081265,
        NotCriticalError = 105763924,
        NoResultsOnPage = 30036744,
        PartialSuccess = 39966469,
        RequiredTosAgreement = 3745539,
        ResourceInUseByOtherResourceWarning = 496728641,
        ResourceNotDeleted = 168598460,
        SchemaValidationIgnored = 275245642,
        SingleInstancePropertyTemplate = 268305617,
        UndeclaredProperties = 390513439,
        Unreachable = 13328052,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Code::UndefinedCode => "UNDEFINED_CODE",
                Code::CleanupFailed => "CLEANUP_FAILED",
                Code::DeprecatedResourceUsed => "DEPRECATED_RESOURCE_USED",
                Code::DeprecatedTypeUsed => "DEPRECATED_TYPE_USED",
                Code::DiskSizeLargerThanImageSize => "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
                Code::ExperimentalTypeUsed => "EXPERIMENTAL_TYPE_USED",
                Code::ExternalApiWarning => "EXTERNAL_API_WARNING",
                Code::FieldValueOverriden => "FIELD_VALUE_OVERRIDEN",
                Code::InjectedKernelsDeprecated => "INJECTED_KERNELS_DEPRECATED",
                Code::InvalidHealthCheckForDynamicWieghtedLb => {
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB"
                }
                Code::LargeDeploymentWarning => "LARGE_DEPLOYMENT_WARNING",
                Code::ListOverheadQuotaExceed => "LIST_OVERHEAD_QUOTA_EXCEED",
                Code::MissingTypeDependency => "MISSING_TYPE_DEPENDENCY",
                Code::NextHopAddressNotAssigned => "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
                Code::NextHopCannotIpForward => "NEXT_HOP_CANNOT_IP_FORWARD",
                Code::NextHopInstanceHasNoIpv6Interface => {
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE"
                }
                Code::NextHopInstanceNotFound => "NEXT_HOP_INSTANCE_NOT_FOUND",
                Code::NextHopInstanceNotOnNetwork => "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
                Code::NextHopNotRunning => "NEXT_HOP_NOT_RUNNING",
                Code::NotCriticalError => "NOT_CRITICAL_ERROR",
                Code::NoResultsOnPage => "NO_RESULTS_ON_PAGE",
                Code::PartialSuccess => "PARTIAL_SUCCESS",
                Code::RequiredTosAgreement => "REQUIRED_TOS_AGREEMENT",
                Code::ResourceInUseByOtherResourceWarning => {
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
                }
                Code::ResourceNotDeleted => "RESOURCE_NOT_DELETED",
                Code::SchemaValidationIgnored => "SCHEMA_VALIDATION_IGNORED",
                Code::SingleInstancePropertyTemplate => {
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
                }
                Code::UndeclaredProperties => "UNDECLARED_PROPERTIES",
                Code::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CODE" => Some(Self::UndefinedCode),
                "CLEANUP_FAILED" => Some(Self::CleanupFailed),
                "DEPRECATED_RESOURCE_USED" => Some(Self::DeprecatedResourceUsed),
                "DEPRECATED_TYPE_USED" => Some(Self::DeprecatedTypeUsed),
                "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => {
                    Some(Self::DiskSizeLargerThanImageSize)
                }
                "EXPERIMENTAL_TYPE_USED" => Some(Self::ExperimentalTypeUsed),
                "EXTERNAL_API_WARNING" => Some(Self::ExternalApiWarning),
                "FIELD_VALUE_OVERRIDEN" => Some(Self::FieldValueOverriden),
                "INJECTED_KERNELS_DEPRECATED" => Some(Self::InjectedKernelsDeprecated),
                "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                    Some(Self::InvalidHealthCheckForDynamicWieghtedLb)
                }
                "LARGE_DEPLOYMENT_WARNING" => Some(Self::LargeDeploymentWarning),
                "LIST_OVERHEAD_QUOTA_EXCEED" => Some(Self::ListOverheadQuotaExceed),
                "MISSING_TYPE_DEPENDENCY" => Some(Self::MissingTypeDependency),
                "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Some(Self::NextHopAddressNotAssigned),
                "NEXT_HOP_CANNOT_IP_FORWARD" => Some(Self::NextHopCannotIpForward),
                "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                    Some(Self::NextHopInstanceHasNoIpv6Interface)
                }
                "NEXT_HOP_INSTANCE_NOT_FOUND" => Some(Self::NextHopInstanceNotFound),
                "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => {
                    Some(Self::NextHopInstanceNotOnNetwork)
                }
                "NEXT_HOP_NOT_RUNNING" => Some(Self::NextHopNotRunning),
                "NOT_CRITICAL_ERROR" => Some(Self::NotCriticalError),
                "NO_RESULTS_ON_PAGE" => Some(Self::NoResultsOnPage),
                "PARTIAL_SUCCESS" => Some(Self::PartialSuccess),
                "REQUIRED_TOS_AGREEMENT" => Some(Self::RequiredTosAgreement),
                "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                    Some(Self::ResourceInUseByOtherResourceWarning)
                }
                "RESOURCE_NOT_DELETED" => Some(Self::ResourceNotDeleted),
                "SCHEMA_VALIDATION_IGNORED" => Some(Self::SchemaValidationIgnored),
                "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => {
                    Some(Self::SingleInstancePropertyTemplate)
                }
                "UNDECLARED_PROPERTIES" => Some(Self::UndeclaredProperties),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawDisk {
    #[prost(string, optional, tag = "318809144")]
    pub container_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "314444349")]
    pub sha1_checksum: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RawDisk`.
pub mod raw_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContainerType {
        UndefinedContainerType = 0,
        Tar = 82821,
    }
    impl ContainerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContainerType::UndefinedContainerType => "UNDEFINED_CONTAINER_TYPE",
                ContainerType::Tar => "TAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONTAINER_TYPE" => Some(Self::UndefinedContainerType),
                "TAR" => Some(Self::Tar),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecreateInstancesInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "21405952")]
    pub instance_group_managers_recreate_instances_request_resource: ::core::option::Option<
        InstanceGroupManagersRecreateInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecreateInstancesRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "170999316")]
    pub region_instance_group_managers_recreate_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersRecreateRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "247521198")]
    pub reference_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "351173663")]
    pub referrer: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "192835985")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Region {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "302941430")]
    pub quota_status_warning: ::core::option::Option<QuotaStatusWarning>,
    #[prost(message, repeated, tag = "125341947")]
    pub quotas: ::prost::alloc::vec::Vec<Quota>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "83983214")]
    pub supports_pzs: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "116085319")]
    pub zones: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Region`.
pub mod region {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Down = 2104482,
        Up = 2715,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Down => "DOWN",
                Status::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DOWN" => Some(Self::Down),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionAddressesMoveRequest {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "371693763")]
    pub destination_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionAutoscalerList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Autoscaler>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionDiskTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<DiskType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionDisksAddResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionDisksRemoveResourcePoliciesRequest {
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionDisksResizeRequest {
    #[prost(int64, optional, tag = "494929369")]
    pub size_gb: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionDisksStartAsyncReplicationRequest {
    #[prost(string, optional, tag = "131645867")]
    pub async_secondary_disk: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceGroup>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagerDeleteInstanceConfigReq {
    #[prost(string, repeated, tag = "104585032")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagerList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceGroupManager>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagerPatchInstanceConfigReq {
    #[prost(message, repeated, tag = "526265001")]
    pub per_instance_configs: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagerUpdateInstanceConfigReq {
    #[prost(message, repeated, tag = "526265001")]
    pub per_instance_configs: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersAbandonInstancesRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersApplyUpdatesRequest {
    #[prost(bool, optional, tag = "403676512")]
    pub all_instances: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "270567060")]
    pub minimal_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "66103053")]
    pub most_disruptive_allowed_action: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RegionInstanceGroupManagersApplyUpdatesRequest`.
pub mod region_instance_group_managers_apply_updates_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinimalAction {
        UndefinedMinimalAction = 0,
    }
    impl MinimalAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinimalAction::UndefinedMinimalAction => "UNDEFINED_MINIMAL_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MINIMAL_ACTION" => Some(Self::UndefinedMinimalAction),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MostDisruptiveAllowedAction {
        UndefinedMostDisruptiveAllowedAction = 0,
    }
    impl MostDisruptiveAllowedAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MostDisruptiveAllowedAction::UndefinedMostDisruptiveAllowedAction => {
                    "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION" => {
                    Some(Self::UndefinedMostDisruptiveAllowedAction)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersCreateInstancesRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<PerInstanceConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersDeleteInstancesRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "40631073")]
    pub skip_instances_on_validation_error: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersListErrorsResponse {
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceManagedByIgmError>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersListInstanceConfigsResp {
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<PerInstanceConfig>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersListInstancesResponse {
    #[prost(message, repeated, tag = "336219614")]
    pub managed_instances: ::prost::alloc::vec::Vec<ManagedInstance>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersRecreateRequest {
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersSetTargetPoolsRequest {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "336072617")]
    pub target_pools: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupManagersSetTemplateRequest {
    #[prost(string, optional, tag = "309248228")]
    pub instance_template: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupsListInstances {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<InstanceWithNamedPorts>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupsListInstancesRequest {
    #[prost(string, optional, tag = "92223591")]
    pub instance_state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RegionInstanceGroupsListInstancesRequest`.
pub mod region_instance_groups_list_instances_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceState {
        UndefinedInstanceState = 0,
        All = 64897,
        Running = 121282975,
    }
    impl InstanceState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceState::UndefinedInstanceState => "UNDEFINED_INSTANCE_STATE",
                InstanceState::All => "ALL",
                InstanceState::Running => "RUNNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANCE_STATE" => Some(Self::UndefinedInstanceState),
                "ALL" => Some(Self::All),
                "RUNNING" => Some(Self::Running),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionInstanceGroupsSetNamedPortsRequest {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "427598732")]
    pub named_ports: ::prost::alloc::vec::Vec<NamedPort>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Region>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionNetworkEndpointGroupsAttachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionNetworkEndpointGroupsDetachEndpointsRequest {
    #[prost(message, repeated, tag = "149850285")]
    pub network_endpoints: ::prost::alloc::vec::Vec<NetworkEndpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse {
    #[prost(message, repeated, tag = "410985794")]
    pub firewall_policys: ::prost::alloc::vec::Vec<
        RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy,
    >,
    #[prost(message, repeated, tag = "272245619")]
    pub firewalls: ::prost::alloc::vec::Vec<Firewall>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    #[prost(string, optional, tag = "4473832")]
    pub display_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<FirewallPolicyRule>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponseEffectiveFirewallPolicy`.
pub mod region_network_firewall_policies_get_effective_firewalls_response_effective_firewall_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Hierarchy = 69902869,
        Network = 413984270,
        NetworkRegional = 190804272,
        Unspecified = 526786327,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Hierarchy => "HIERARCHY",
                Type::Network => "NETWORK",
                Type::NetworkRegional => "NETWORK_REGIONAL",
                Type::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "HIERARCHY" => Some(Self::Hierarchy),
                "NETWORK" => Some(Self::Network),
                "NETWORK_REGIONAL" => Some(Self::NetworkRegional),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionSetLabelsRequest {
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionSetPolicyRequest {
    #[prost(message, repeated, tag = "403251854")]
    pub bindings: ::prost::alloc::vec::Vec<Binding>,
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "91071794")]
    pub policy: ::core::option::Option<Policy>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionTargetHttpsProxiesSetSslCertificatesRequest {
    #[prost(string, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegionUrlMapsValidateRequest {
    #[prost(message, optional, tag = "195806222")]
    pub resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAssociationFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAssociationNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveAssociationRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveHealthCheckTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "304985011")]
    pub target_pools_remove_health_check_request_resource: ::core::option::Option<
        TargetPoolsRemoveHealthCheckRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveInstanceTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "29548547")]
    pub target_pools_remove_instance_request_resource: ::core::option::Option<
        TargetPoolsRemoveInstanceRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveInstancesInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "390981817")]
    pub instance_groups_remove_instances_request_resource: ::core::option::Option<
        InstanceGroupsRemoveInstancesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemovePeeringNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "421162494")]
    pub networks_remove_peering_request_resource: ::core::option::Option<
        NetworksRemovePeeringRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveResourcePoliciesDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "436756718")]
    pub disks_remove_resource_policies_request_resource: ::core::option::Option<
        DisksRemoveResourcePoliciesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveResourcePoliciesInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "49229558")]
    pub instances_remove_resource_policies_request_resource: ::core::option::Option<
        InstancesRemoveResourcePoliciesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveResourcePoliciesRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8741283")]
    pub region_disks_remove_resource_policies_request_resource: ::core::option::Option<
        RegionDisksRemoveResourcePoliciesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveRuleFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveRuleNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveRuleRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "498173265")]
    pub firewall_policy: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveRuleRegionSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveRuleSecurityPolicyRequest {
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "171082513")]
    pub security_policy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMirrorPolicy {
    #[prost(string, optional, tag = "306946058")]
    pub backend_service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reservation {
    #[prost(message, optional, tag = "291567948")]
    pub aggregate_reservation: ::core::option::Option<AllocationAggregateReservation>,
    #[prost(string, optional, tag = "482134805")]
    pub commitment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "22220385")]
    pub resource_policies: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<AllocationResourceStatus>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "266668163")]
    pub share_settings: ::core::option::Option<ShareSettings>,
    #[prost(message, optional, tag = "404901951")]
    pub specific_reservation: ::core::option::Option<AllocationSpecificSkuReservation>,
    #[prost(bool, optional, tag = "226550687")]
    pub specific_reservation_required: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Reservation`.
pub mod reservation {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Invalid = 530283991,
        Ready = 77848963,
        Updating = 494614342,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
                Status::Updating => "UPDATING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                "UPDATING" => Some(Self::Updating),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationAffinity {
    #[prost(string, optional, tag = "300736944")]
    pub consume_reservation_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "249928994")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ReservationAffinity`.
pub mod reservation_affinity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsumeReservationType {
        UndefinedConsumeReservationType = 0,
        AnyReservation = 200008121,
        NoReservation = 169322030,
        SpecificReservation = 229889055,
        Unspecified = 526786327,
    }
    impl ConsumeReservationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConsumeReservationType::UndefinedConsumeReservationType => {
                    "UNDEFINED_CONSUME_RESERVATION_TYPE"
                }
                ConsumeReservationType::AnyReservation => "ANY_RESERVATION",
                ConsumeReservationType::NoReservation => "NO_RESERVATION",
                ConsumeReservationType::SpecificReservation => "SPECIFIC_RESERVATION",
                ConsumeReservationType::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONSUME_RESERVATION_TYPE" => {
                    Some(Self::UndefinedConsumeReservationType)
                }
                "ANY_RESERVATION" => Some(Self::AnyReservation),
                "NO_RESERVATION" => Some(Self::NoReservation),
                "SPECIFIC_RESERVATION" => Some(Self::SpecificReservation),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ReservationsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Reservation>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReservationsResizeRequest {
    #[prost(int64, optional, tag = "13890720")]
    pub specific_sku_count: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReservationsScopedList {
    #[prost(message, repeated, tag = "399717927")]
    pub reservations: ::prost::alloc::vec::Vec<Reservation>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResetInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "78307616")]
    pub disks_resize_request_resource: ::core::option::Option<DisksResizeRequest>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3530753")]
    pub size: i32,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "446633237")]
    pub region_disks_resize_request_resource: ::core::option::Option<
        RegionDisksResizeRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, tag = "3530753")]
    pub size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResizeReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "47530956")]
    pub reservation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "389262801")]
    pub reservations_resize_request_resource: ::core::option::Option<
        ReservationsResizeRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCommitment {
    #[prost(string, optional, tag = "138031246")]
    pub accelerator_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "196759640")]
    pub amount: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ResourceCommitment`.
pub mod resource_commitment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Accelerator = 429815371,
        LocalSsd = 508934896,
        Memory = 123056385,
        Unspecified = 526786327,
        Vcpu = 2628978,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Accelerator => "ACCELERATOR",
                Type::LocalSsd => "LOCAL_SSD",
                Type::Memory => "MEMORY",
                Type::Unspecified => "UNSPECIFIED",
                Type::Vcpu => "VCPU",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "ACCELERATOR" => Some(Self::Accelerator),
                "LOCAL_SSD" => Some(Self::LocalSsd),
                "MEMORY" => Some(Self::Memory),
                "UNSPECIFIED" => Some(Self::Unspecified),
                "VCPU" => Some(Self::Vcpu),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceGroupReference {
    #[prost(string, optional, tag = "98629247")]
    pub group: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePoliciesScopedList {
    #[prost(message, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<ResourcePolicy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicy {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "473727515")]
    pub disk_consistency_group_policy: ::core::option::Option<
        ResourcePolicyDiskConsistencyGroupPolicy,
    >,
    #[prost(message, optional, tag = "10931596")]
    pub group_placement_policy: ::core::option::Option<
        ResourcePolicyGroupPlacementPolicy,
    >,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, optional, tag = "344877104")]
    pub instance_schedule_policy: ::core::option::Option<
        ResourcePolicyInstanceSchedulePolicy,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<ResourcePolicyResourceStatus>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "218131295")]
    pub snapshot_schedule_policy: ::core::option::Option<
        ResourcePolicySnapshotSchedulePolicy,
    >,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ResourcePolicy`.
pub mod resource_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Expired = 482489093,
        Invalid = 530283991,
        Ready = 77848963,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Expired => "EXPIRED",
                Status::Invalid => "INVALID",
                Status::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "EXPIRED" => Some(Self::Expired),
                "INVALID" => Some(Self::Invalid),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyAggregatedList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ResourcePoliciesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyDailyCycle {
    #[prost(int32, optional, tag = "369790004")]
    pub days_in_cycle: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "155471252")]
    pub duration: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourcePolicyDiskConsistencyGroupPolicy {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyGroupPlacementPolicy {
    #[prost(int32, optional, tag = "12453432")]
    pub availability_domain_count: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "511156533")]
    pub collocation: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "261463431")]
    pub vm_count: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ResourcePolicyGroupPlacementPolicy`.
pub mod resource_policy_group_placement_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Collocation {
        UndefinedCollocation = 0,
        Collocated = 103257554,
        UnspecifiedCollocation = 464308205,
    }
    impl Collocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Collocation::UndefinedCollocation => "UNDEFINED_COLLOCATION",
                Collocation::Collocated => "COLLOCATED",
                Collocation::UnspecifiedCollocation => "UNSPECIFIED_COLLOCATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_COLLOCATION" => Some(Self::UndefinedCollocation),
                "COLLOCATED" => Some(Self::Collocated),
                "UNSPECIFIED_COLLOCATION" => Some(Self::UnspecifiedCollocation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyHourlyCycle {
    #[prost(string, optional, tag = "155471252")]
    pub duration: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "526763132")]
    pub hours_in_cycle: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyInstanceSchedulePolicy {
    #[prost(string, optional, tag = "230299229")]
    pub expiration_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "36848094")]
    pub time_zone: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "17762396")]
    pub vm_start_schedule: ::core::option::Option<
        ResourcePolicyInstanceSchedulePolicySchedule,
    >,
    #[prost(message, optional, tag = "426242732")]
    pub vm_stop_schedule: ::core::option::Option<
        ResourcePolicyInstanceSchedulePolicySchedule,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyInstanceSchedulePolicySchedule {
    #[prost(string, optional, tag = "375820951")]
    pub schedule: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<ResourcePolicy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyResourceStatus {
    #[prost(message, optional, tag = "344877104")]
    pub instance_schedule_policy: ::core::option::Option<
        ResourcePolicyResourceStatusInstanceSchedulePolicyStatus,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyResourceStatusInstanceSchedulePolicyStatus {
    #[prost(string, optional, tag = "303069063")]
    pub last_run_start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "318642570")]
    pub next_run_start_time: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicySnapshotSchedulePolicy {
    #[prost(message, optional, tag = "68625779")]
    pub retention_policy: ::core::option::Option<
        ResourcePolicySnapshotSchedulePolicyRetentionPolicy,
    >,
    #[prost(message, optional, tag = "375820951")]
    pub schedule: ::core::option::Option<ResourcePolicySnapshotSchedulePolicySchedule>,
    #[prost(message, optional, tag = "185371278")]
    pub snapshot_properties: ::core::option::Option<
        ResourcePolicySnapshotSchedulePolicySnapshotProperties,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicySnapshotSchedulePolicyRetentionPolicy {
    #[prost(int32, optional, tag = "324296979")]
    pub max_retention_days: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "321955529")]
    pub on_source_disk_delete: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ResourcePolicySnapshotSchedulePolicyRetentionPolicy`.
pub mod resource_policy_snapshot_schedule_policy_retention_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnSourceDiskDelete {
        UndefinedOnSourceDiskDelete = 0,
        ApplyRetentionPolicy = 535071332,
        KeepAutoSnapshots = 258925689,
        UnspecifiedOnSourceDiskDelete = 239140769,
    }
    impl OnSourceDiskDelete {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnSourceDiskDelete::UndefinedOnSourceDiskDelete => {
                    "UNDEFINED_ON_SOURCE_DISK_DELETE"
                }
                OnSourceDiskDelete::ApplyRetentionPolicy => "APPLY_RETENTION_POLICY",
                OnSourceDiskDelete::KeepAutoSnapshots => "KEEP_AUTO_SNAPSHOTS",
                OnSourceDiskDelete::UnspecifiedOnSourceDiskDelete => {
                    "UNSPECIFIED_ON_SOURCE_DISK_DELETE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ON_SOURCE_DISK_DELETE" => {
                    Some(Self::UndefinedOnSourceDiskDelete)
                }
                "APPLY_RETENTION_POLICY" => Some(Self::ApplyRetentionPolicy),
                "KEEP_AUTO_SNAPSHOTS" => Some(Self::KeepAutoSnapshots),
                "UNSPECIFIED_ON_SOURCE_DISK_DELETE" => {
                    Some(Self::UnspecifiedOnSourceDiskDelete)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicySnapshotSchedulePolicySchedule {
    #[prost(message, optional, tag = "86159869")]
    pub daily_schedule: ::core::option::Option<ResourcePolicyDailyCycle>,
    #[prost(message, optional, tag = "38328485")]
    pub hourly_schedule: ::core::option::Option<ResourcePolicyHourlyCycle>,
    #[prost(message, optional, tag = "359548053")]
    pub weekly_schedule: ::core::option::Option<ResourcePolicyWeeklyCycle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicySnapshotSchedulePolicySnapshotProperties {
    #[prost(string, optional, tag = "68644169")]
    pub chain_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "385550813")]
    pub guest_flush: ::core::option::Option<bool>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "328005274")]
    pub storage_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyWeeklyCycle {
    #[prost(message, repeated, tag = "257871834")]
    pub day_of_weeks: ::prost::alloc::vec::Vec<ResourcePolicyWeeklyCycleDayOfWeek>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourcePolicyWeeklyCycleDayOfWeek {
    #[prost(string, optional, tag = "99228")]
    pub day: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "155471252")]
    pub duration: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37467274")]
    pub start_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ResourcePolicyWeeklyCycleDayOfWeek`.
pub mod resource_policy_weekly_cycle_day_of_week {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Day {
        UndefinedDay = 0,
        Friday = 471398751,
        Invalid = 530283991,
        Monday = 132310288,
        Saturday = 279037881,
        Sunday = 309626320,
        Thursday = 207198682,
        Tuesday = 277509677,
        Wednesday = 422029110,
    }
    impl Day {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Day::UndefinedDay => "UNDEFINED_DAY",
                Day::Friday => "FRIDAY",
                Day::Invalid => "INVALID",
                Day::Monday => "MONDAY",
                Day::Saturday => "SATURDAY",
                Day::Sunday => "SUNDAY",
                Day::Thursday => "THURSDAY",
                Day::Tuesday => "TUESDAY",
                Day::Wednesday => "WEDNESDAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DAY" => Some(Self::UndefinedDay),
                "FRIDAY" => Some(Self::Friday),
                "INVALID" => Some(Self::Invalid),
                "MONDAY" => Some(Self::Monday),
                "SATURDAY" => Some(Self::Saturday),
                "SUNDAY" => Some(Self::Sunday),
                "THURSDAY" => Some(Self::Thursday),
                "TUESDAY" => Some(Self::Tuesday),
                "WEDNESDAY" => Some(Self::Wednesday),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceStatus {
    #[prost(string, optional, tag = "464370704")]
    pub physical_host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "227348592")]
    pub upcoming_maintenance: ::core::option::Option<UpcomingMaintenance>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Route {
    #[prost(message, repeated, tag = "137568929")]
    pub as_paths: ::prost::alloc::vec::Vec<RouteAsPath>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "381327712")]
    pub dest_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "377175298")]
    pub next_hop_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "198679219")]
    pub next_hop_hub: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "198679901")]
    pub next_hop_ilb: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "393508247")]
    pub next_hop_instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "110319529")]
    pub next_hop_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "262295788")]
    pub next_hop_network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "412682750")]
    pub next_hop_peering: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "519844501")]
    pub next_hop_vpn_tunnel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "418162344")]
    pub route_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "375888752")]
    pub route_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3552281")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "498091095")]
    pub warnings: ::prost::alloc::vec::Vec<Warnings>,
}
/// Nested message and enum types in `Route`.
pub mod route {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RouteStatus {
        UndefinedRouteStatus = 0,
        Active = 314733318,
        Dropped = 496235424,
        Inactive = 270421099,
        Pending = 35394935,
    }
    impl RouteStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RouteStatus::UndefinedRouteStatus => "UNDEFINED_ROUTE_STATUS",
                RouteStatus::Active => "ACTIVE",
                RouteStatus::Dropped => "DROPPED",
                RouteStatus::Inactive => "INACTIVE",
                RouteStatus::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROUTE_STATUS" => Some(Self::UndefinedRouteStatus),
                "ACTIVE" => Some(Self::Active),
                "DROPPED" => Some(Self::Dropped),
                "INACTIVE" => Some(Self::Inactive),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RouteType {
        UndefinedRouteType = 0,
        Bgp = 65707,
        Static = 308331118,
        Subnet = 309278557,
        Transit = 187793843,
    }
    impl RouteType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RouteType::UndefinedRouteType => "UNDEFINED_ROUTE_TYPE",
                RouteType::Bgp => "BGP",
                RouteType::Static => "STATIC",
                RouteType::Subnet => "SUBNET",
                RouteType::Transit => "TRANSIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROUTE_TYPE" => Some(Self::UndefinedRouteType),
                "BGP" => Some(Self::Bgp),
                "STATIC" => Some(Self::Static),
                "SUBNET" => Some(Self::Subnet),
                "TRANSIT" => Some(Self::Transit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteAsPath {
    #[prost(uint32, repeated, tag = "134112584")]
    pub as_lists: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, optional, tag = "513464992")]
    pub path_segment_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RouteAsPath`.
pub mod route_as_path {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PathSegmentType {
        UndefinedPathSegmentType = 0,
        AsConfedSequence = 222152624,
        AsConfedSet = 374040307,
        AsSequence = 106735918,
        AsSet = 329846453,
    }
    impl PathSegmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PathSegmentType::UndefinedPathSegmentType => {
                    "UNDEFINED_PATH_SEGMENT_TYPE"
                }
                PathSegmentType::AsConfedSequence => "AS_CONFED_SEQUENCE",
                PathSegmentType::AsConfedSet => "AS_CONFED_SET",
                PathSegmentType::AsSequence => "AS_SEQUENCE",
                PathSegmentType::AsSet => "AS_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PATH_SEGMENT_TYPE" => Some(Self::UndefinedPathSegmentType),
                "AS_CONFED_SEQUENCE" => Some(Self::AsConfedSequence),
                "AS_CONFED_SET" => Some(Self::AsConfedSet),
                "AS_SEQUENCE" => Some(Self::AsSequence),
                "AS_SET" => Some(Self::AsSet),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Route>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Router {
    #[prost(message, optional, tag = "97483")]
    pub bgp: ::core::option::Option<RouterBgp>,
    #[prost(message, repeated, tag = "452695773")]
    pub bgp_peers: ::prost::alloc::vec::Vec<RouterBgpPeer>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "297996575")]
    pub encrypted_interconnect_router: ::core::option::Option<bool>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(message, repeated, tag = "12073562")]
    pub interfaces: ::prost::alloc::vec::Vec<RouterInterface>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "71063322")]
    pub md5_authentication_keys: ::prost::alloc::vec::Vec<RouterMd5AuthenticationKey>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3373938")]
    pub nats: ::prost::alloc::vec::Vec<RouterNat>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterAdvertisedIpRange {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "108280125")]
    pub range: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        RoutersScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterBgp {
    #[prost(string, optional, tag = "312134331")]
    pub advertise_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "21065526")]
    pub advertised_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "35449932")]
    pub advertised_ip_ranges: ::prost::alloc::vec::Vec<RouterAdvertisedIpRange>,
    #[prost(uint32, optional, tag = "96892")]
    pub asn: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "501573159")]
    pub identifier_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "276771516")]
    pub keepalive_interval: ::core::option::Option<u32>,
}
/// Nested message and enum types in `RouterBgp`.
pub mod router_bgp {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertiseMode {
        UndefinedAdvertiseMode = 0,
        Custom = 388595569,
        Default = 115302945,
    }
    impl AdvertiseMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertiseMode::UndefinedAdvertiseMode => "UNDEFINED_ADVERTISE_MODE",
                AdvertiseMode::Custom => "CUSTOM",
                AdvertiseMode::Default => "DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADVERTISE_MODE" => Some(Self::UndefinedAdvertiseMode),
                "CUSTOM" => Some(Self::Custom),
                "DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisedGroups {
        UndefinedAdvertisedGroups = 0,
        AllSubnets = 3622872,
    }
    impl AdvertisedGroups {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisedGroups::UndefinedAdvertisedGroups => {
                    "UNDEFINED_ADVERTISED_GROUPS"
                }
                AdvertisedGroups::AllSubnets => "ALL_SUBNETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADVERTISED_GROUPS" => Some(Self::UndefinedAdvertisedGroups),
                "ALL_SUBNETS" => Some(Self::AllSubnets),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterBgpPeer {
    #[prost(string, optional, tag = "312134331")]
    pub advertise_mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "21065526")]
    pub advertised_groups: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "35449932")]
    pub advertised_ip_ranges: ::prost::alloc::vec::Vec<RouterAdvertisedIpRange>,
    #[prost(uint32, optional, tag = "186486332")]
    pub advertised_route_priority: ::core::option::Option<u32>,
    #[prost(message, optional, tag = "97440")]
    pub bfd: ::core::option::Option<RouterBgpPeerBfd>,
    #[prost(message, repeated, tag = "481363012")]
    pub custom_learned_ip_ranges: ::prost::alloc::vec::Vec<
        RouterBgpPeerCustomLearnedIpRange,
    >,
    #[prost(int32, optional, tag = "330412356")]
    pub custom_learned_route_priority: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "311764355")]
    pub enable: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "181467937")]
    pub enable_ipv4: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "181467939")]
    pub enable_ipv6: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "134084987")]
    pub export_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "451147946")]
    pub import_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "437854673")]
    pub interface_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5703377")]
    pub ipv4_nexthop_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "27968211")]
    pub ipv6_nexthop_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "173703606")]
    pub management_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "281075345")]
    pub md5_authentication_key_name: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "69573151")]
    pub peer_asn: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "207735769")]
    pub peer_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "469221774")]
    pub peer_ipv4_nexthop_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "491486608")]
    pub peer_ipv6_nexthop_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "468312989")]
    pub router_appliance_instance: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RouterBgpPeer`.
pub mod router_bgp_peer {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertiseMode {
        UndefinedAdvertiseMode = 0,
        Custom = 388595569,
        Default = 115302945,
    }
    impl AdvertiseMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertiseMode::UndefinedAdvertiseMode => "UNDEFINED_ADVERTISE_MODE",
                AdvertiseMode::Custom => "CUSTOM",
                AdvertiseMode::Default => "DEFAULT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADVERTISE_MODE" => Some(Self::UndefinedAdvertiseMode),
                "CUSTOM" => Some(Self::Custom),
                "DEFAULT" => Some(Self::Default),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisedGroups {
        UndefinedAdvertisedGroups = 0,
        AllSubnets = 3622872,
    }
    impl AdvertisedGroups {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisedGroups::UndefinedAdvertisedGroups => {
                    "UNDEFINED_ADVERTISED_GROUPS"
                }
                AdvertisedGroups::AllSubnets => "ALL_SUBNETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ADVERTISED_GROUPS" => Some(Self::UndefinedAdvertisedGroups),
                "ALL_SUBNETS" => Some(Self::AllSubnets),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Enable {
        UndefinedEnable = 0,
        False = 66658563,
        True = 2583950,
    }
    impl Enable {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Enable::UndefinedEnable => "UNDEFINED_ENABLE",
                Enable::False => "FALSE",
                Enable::True => "TRUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENABLE" => Some(Self::UndefinedEnable),
                "FALSE" => Some(Self::False),
                "TRUE" => Some(Self::True),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagementType {
        UndefinedManagementType = 0,
        ManagedByAttachment = 458926411,
        ManagedByUser = 317294067,
    }
    impl ManagementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ManagementType::UndefinedManagementType => "UNDEFINED_MANAGEMENT_TYPE",
                ManagementType::ManagedByAttachment => "MANAGED_BY_ATTACHMENT",
                ManagementType::ManagedByUser => "MANAGED_BY_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MANAGEMENT_TYPE" => Some(Self::UndefinedManagementType),
                "MANAGED_BY_ATTACHMENT" => Some(Self::ManagedByAttachment),
                "MANAGED_BY_USER" => Some(Self::ManagedByUser),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterBgpPeerBfd {
    #[prost(uint32, optional, tag = "186981614")]
    pub min_receive_interval: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "523282631")]
    pub min_transmit_interval: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "191331777")]
    pub multiplier: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "105957049")]
    pub session_initialization_mode: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RouterBgpPeerBfd`.
pub mod router_bgp_peer_bfd {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionInitializationMode {
        UndefinedSessionInitializationMode = 0,
        Active = 314733318,
        Disabled = 516696700,
        Passive = 462813959,
    }
    impl SessionInitializationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SessionInitializationMode::UndefinedSessionInitializationMode => {
                    "UNDEFINED_SESSION_INITIALIZATION_MODE"
                }
                SessionInitializationMode::Active => "ACTIVE",
                SessionInitializationMode::Disabled => "DISABLED",
                SessionInitializationMode::Passive => "PASSIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SESSION_INITIALIZATION_MODE" => {
                    Some(Self::UndefinedSessionInitializationMode)
                }
                "ACTIVE" => Some(Self::Active),
                "DISABLED" => Some(Self::Disabled),
                "PASSIVE" => Some(Self::Passive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterBgpPeerCustomLearnedIpRange {
    #[prost(string, optional, tag = "108280125")]
    pub range: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterInterface {
    #[prost(string, optional, tag = "145092645")]
    pub ip_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "294959552")]
    pub ip_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "501085518")]
    pub linked_interconnect_attachment: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "352296953")]
    pub linked_vpn_tunnel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "173703606")]
    pub management_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "100854040")]
    pub private_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "523187303")]
    pub redundant_interface: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RouterInterface`.
pub mod router_interface {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IpVersion {
        UndefinedIpVersion = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
    }
    impl IpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IpVersion::UndefinedIpVersion => "UNDEFINED_IP_VERSION",
                IpVersion::Ipv4 => "IPV4",
                IpVersion::Ipv6 => "IPV6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IP_VERSION" => Some(Self::UndefinedIpVersion),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagementType {
        UndefinedManagementType = 0,
        ManagedByAttachment = 458926411,
        ManagedByUser = 317294067,
    }
    impl ManagementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ManagementType::UndefinedManagementType => "UNDEFINED_MANAGEMENT_TYPE",
                ManagementType::ManagedByAttachment => "MANAGED_BY_ATTACHMENT",
                ManagementType::ManagedByUser => "MANAGED_BY_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MANAGEMENT_TYPE" => Some(Self::UndefinedManagementType),
                "MANAGED_BY_ATTACHMENT" => Some(Self::ManagedByAttachment),
                "MANAGED_BY_USER" => Some(Self::ManagedByUser),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Router>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterMd5AuthenticationKey {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterNat {
    #[prost(string, optional, tag = "269770211")]
    pub auto_network_tier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "504078535")]
    pub drain_nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "532106402")]
    pub enable_dynamic_port_allocation: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "259441819")]
    pub enable_endpoint_independent_mapping: ::core::option::Option<bool>,
    #[prost(string, repeated, tag = "502633807")]
    pub endpoint_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3647562")]
    pub icmp_idle_timeout_sec: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "351299741")]
    pub log_config: ::core::option::Option<RouterNatLogConfig>,
    #[prost(int32, optional, tag = "250062049")]
    pub max_ports_per_vm: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "186193587")]
    pub min_ports_per_vm: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "429726845")]
    pub nat_ip_allocate_option: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "117635086")]
    pub nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<RouterNatRule>,
    #[prost(string, optional, tag = "252213211")]
    pub source_subnetwork_ip_ranges_to_nat: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, repeated, tag = "415853125")]
    pub subnetworks: ::prost::alloc::vec::Vec<RouterNatSubnetworkToNat>,
    #[prost(int32, optional, tag = "223098349")]
    pub tcp_established_idle_timeout_sec: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "513596925")]
    pub tcp_time_wait_timeout_sec: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "205028774")]
    pub tcp_transitory_idle_timeout_sec: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "64919878")]
    pub udp_idle_timeout_sec: ::core::option::Option<i32>,
}
/// Nested message and enum types in `RouterNat`.
pub mod router_nat {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoNetworkTier {
        UndefinedAutoNetworkTier = 0,
        FixedStandard = 310464328,
        Premium = 399530551,
        Standard = 484642493,
        StandardOverridesFixedStandard = 465847234,
    }
    impl AutoNetworkTier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoNetworkTier::UndefinedAutoNetworkTier => {
                    "UNDEFINED_AUTO_NETWORK_TIER"
                }
                AutoNetworkTier::FixedStandard => "FIXED_STANDARD",
                AutoNetworkTier::Premium => "PREMIUM",
                AutoNetworkTier::Standard => "STANDARD",
                AutoNetworkTier::StandardOverridesFixedStandard => {
                    "STANDARD_OVERRIDES_FIXED_STANDARD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AUTO_NETWORK_TIER" => Some(Self::UndefinedAutoNetworkTier),
                "FIXED_STANDARD" => Some(Self::FixedStandard),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_OVERRIDES_FIXED_STANDARD" => {
                    Some(Self::StandardOverridesFixedStandard)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EndpointTypes {
        UndefinedEndpointTypes = 0,
        EndpointTypeManagedProxyLb = 439196930,
        EndpointTypeSwg = 159344456,
        EndpointTypeVm = 57095474,
    }
    impl EndpointTypes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EndpointTypes::UndefinedEndpointTypes => "UNDEFINED_ENDPOINT_TYPES",
                EndpointTypes::EndpointTypeManagedProxyLb => {
                    "ENDPOINT_TYPE_MANAGED_PROXY_LB"
                }
                EndpointTypes::EndpointTypeSwg => "ENDPOINT_TYPE_SWG",
                EndpointTypes::EndpointTypeVm => "ENDPOINT_TYPE_VM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENDPOINT_TYPES" => Some(Self::UndefinedEndpointTypes),
                "ENDPOINT_TYPE_MANAGED_PROXY_LB" => {
                    Some(Self::EndpointTypeManagedProxyLb)
                }
                "ENDPOINT_TYPE_SWG" => Some(Self::EndpointTypeSwg),
                "ENDPOINT_TYPE_VM" => Some(Self::EndpointTypeVm),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NatIpAllocateOption {
        UndefinedNatIpAllocateOption = 0,
        AutoOnly = 182333500,
        ManualOnly = 261251205,
    }
    impl NatIpAllocateOption {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NatIpAllocateOption::UndefinedNatIpAllocateOption => {
                    "UNDEFINED_NAT_IP_ALLOCATE_OPTION"
                }
                NatIpAllocateOption::AutoOnly => "AUTO_ONLY",
                NatIpAllocateOption::ManualOnly => "MANUAL_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NAT_IP_ALLOCATE_OPTION" => {
                    Some(Self::UndefinedNatIpAllocateOption)
                }
                "AUTO_ONLY" => Some(Self::AutoOnly),
                "MANUAL_ONLY" => Some(Self::ManualOnly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceSubnetworkIpRangesToNat {
        UndefinedSourceSubnetworkIpRangesToNat = 0,
        AllSubnetworksAllIpRanges = 179964376,
        AllSubnetworksAllPrimaryIpRanges = 185573819,
        ListOfSubnetworks = 517542270,
    }
    impl SourceSubnetworkIpRangesToNat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceSubnetworkIpRangesToNat::UndefinedSourceSubnetworkIpRangesToNat => {
                    "UNDEFINED_SOURCE_SUBNETWORK_IP_RANGES_TO_NAT"
                }
                SourceSubnetworkIpRangesToNat::AllSubnetworksAllIpRanges => {
                    "ALL_SUBNETWORKS_ALL_IP_RANGES"
                }
                SourceSubnetworkIpRangesToNat::AllSubnetworksAllPrimaryIpRanges => {
                    "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES"
                }
                SourceSubnetworkIpRangesToNat::ListOfSubnetworks => "LIST_OF_SUBNETWORKS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SOURCE_SUBNETWORK_IP_RANGES_TO_NAT" => {
                    Some(Self::UndefinedSourceSubnetworkIpRangesToNat)
                }
                "ALL_SUBNETWORKS_ALL_IP_RANGES" => Some(Self::AllSubnetworksAllIpRanges),
                "ALL_SUBNETWORKS_ALL_PRIMARY_IP_RANGES" => {
                    Some(Self::AllSubnetworksAllPrimaryIpRanges)
                }
                "LIST_OF_SUBNETWORKS" => Some(Self::ListOfSubnetworks),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Private = 403485027,
        Public = 223389289,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Private => "PRIVATE",
                Type::Public => "PUBLIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "PRIVATE" => Some(Self::Private),
                "PUBLIC" => Some(Self::Public),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterNatLogConfig {
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "336120696")]
    pub filter: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RouterNatLogConfig`.
pub mod router_nat_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Filter {
        UndefinedFilter = 0,
        All = 64897,
        ErrorsOnly = 307484672,
        TranslationsOnly = 357212649,
    }
    impl Filter {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Filter::UndefinedFilter => "UNDEFINED_FILTER",
                Filter::All => "ALL",
                Filter::ErrorsOnly => "ERRORS_ONLY",
                Filter::TranslationsOnly => "TRANSLATIONS_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_FILTER" => Some(Self::UndefinedFilter),
                "ALL" => Some(Self::All),
                "ERRORS_ONLY" => Some(Self::ErrorsOnly),
                "TRANSLATIONS_ONLY" => Some(Self::TranslationsOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterNatRule {
    #[prost(message, optional, tag = "187661878")]
    pub action: ::core::option::Option<RouterNatRuleAction>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "103668165")]
    pub r#match: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "535211500")]
    pub rule_number: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterNatRuleAction {
    #[prost(string, repeated, tag = "210378229")]
    pub source_nat_active_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "190556269")]
    pub source_nat_active_ranges: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "340812451")]
    pub source_nat_drain_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "84802815")]
    pub source_nat_drain_ranges: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterNatSubnetworkToNat {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "264315097")]
    pub secondary_ip_range_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "388310386")]
    pub source_ip_ranges_to_nat: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `RouterNatSubnetworkToNat`.
pub mod router_nat_subnetwork_to_nat {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SourceIpRangesToNat {
        UndefinedSourceIpRangesToNat = 0,
        AllIpRanges = 35608496,
        ListOfSecondaryIpRanges = 192289308,
        PrimaryIpRange = 297109954,
    }
    impl SourceIpRangesToNat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SourceIpRangesToNat::UndefinedSourceIpRangesToNat => {
                    "UNDEFINED_SOURCE_IP_RANGES_TO_NAT"
                }
                SourceIpRangesToNat::AllIpRanges => "ALL_IP_RANGES",
                SourceIpRangesToNat::ListOfSecondaryIpRanges => {
                    "LIST_OF_SECONDARY_IP_RANGES"
                }
                SourceIpRangesToNat::PrimaryIpRange => "PRIMARY_IP_RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SOURCE_IP_RANGES_TO_NAT" => {
                    Some(Self::UndefinedSourceIpRangesToNat)
                }
                "ALL_IP_RANGES" => Some(Self::AllIpRanges),
                "LIST_OF_SECONDARY_IP_RANGES" => Some(Self::ListOfSecondaryIpRanges),
                "PRIMARY_IP_RANGE" => Some(Self::PrimaryIpRange),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterStatus {
    #[prost(message, repeated, tag = "395826693")]
    pub best_routes: ::prost::alloc::vec::Vec<Route>,
    #[prost(message, repeated, tag = "119389689")]
    pub best_routes_for_router: ::prost::alloc::vec::Vec<Route>,
    #[prost(message, repeated, tag = "218459131")]
    pub bgp_peer_status: ::prost::alloc::vec::Vec<RouterStatusBgpPeerStatus>,
    #[prost(message, repeated, tag = "63098064")]
    pub nat_status: ::prost::alloc::vec::Vec<RouterStatusNatStatus>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterStatusBgpPeerStatus {
    #[prost(message, repeated, tag = "333393068")]
    pub advertised_routes: ::prost::alloc::vec::Vec<Route>,
    #[prost(message, optional, tag = "395631729")]
    pub bfd_status: ::core::option::Option<BfdStatus>,
    #[prost(bool, optional, tag = "181467937")]
    pub enable_ipv4: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "181467939")]
    pub enable_ipv6: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5703377")]
    pub ipv4_nexthop_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "27968211")]
    pub ipv6_nexthop_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "352296953")]
    pub linked_vpn_tunnel: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "451152075")]
    pub md5_auth_enabled: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint32, optional, tag = "135457535")]
    pub num_learned_routes: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "207735769")]
    pub peer_ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "469221774")]
    pub peer_ipv4_nexthop_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "491486608")]
    pub peer_ipv6_nexthop_address: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "468312989")]
    pub router_appliance_instance: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "342706993")]
    pub status_reason: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "235379688")]
    pub uptime: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "104736040")]
    pub uptime_seconds: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RouterStatusBgpPeerStatus`.
pub mod router_status_bgp_peer_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Down = 2104482,
        Unknown = 433141802,
        Up = 2715,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Down => "DOWN",
                Status::Unknown => "UNKNOWN",
                Status::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DOWN" => Some(Self::Down),
                "UNKNOWN" => Some(Self::Unknown),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StatusReason {
        UndefinedStatusReason = 0,
        Ipv4PeerOnIpv6OnlyConnection = 435936662,
        Ipv6PeerOnIpv4OnlyConnection = 436304082,
        Md5AuthInternalProblem = 140462259,
        Unspecified = 394331913,
    }
    impl StatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StatusReason::UndefinedStatusReason => "UNDEFINED_STATUS_REASON",
                StatusReason::Ipv4PeerOnIpv6OnlyConnection => {
                    "IPV4_PEER_ON_IPV6_ONLY_CONNECTION"
                }
                StatusReason::Ipv6PeerOnIpv4OnlyConnection => {
                    "IPV6_PEER_ON_IPV4_ONLY_CONNECTION"
                }
                StatusReason::Md5AuthInternalProblem => "MD5_AUTH_INTERNAL_PROBLEM",
                StatusReason::Unspecified => "STATUS_REASON_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS_REASON" => Some(Self::UndefinedStatusReason),
                "IPV4_PEER_ON_IPV6_ONLY_CONNECTION" => {
                    Some(Self::Ipv4PeerOnIpv6OnlyConnection)
                }
                "IPV6_PEER_ON_IPV4_ONLY_CONNECTION" => {
                    Some(Self::Ipv6PeerOnIpv4OnlyConnection)
                }
                "MD5_AUTH_INTERNAL_PROBLEM" => Some(Self::Md5AuthInternalProblem),
                "STATUS_REASON_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterStatusNatStatus {
    #[prost(string, repeated, tag = "510794246")]
    pub auto_allocated_nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "309184557")]
    pub drain_auto_allocated_nat_ips: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "305268553")]
    pub drain_user_allocated_nat_ips: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(int32, optional, tag = "365786338")]
    pub min_extra_nat_ips_needed: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "512367468")]
    pub num_vm_endpoints_with_nat_mappings: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "140223125")]
    pub rule_status: ::prost::alloc::vec::Vec<RouterStatusNatStatusNatRuleStatus>,
    #[prost(string, repeated, tag = "212776151")]
    pub user_allocated_nat_ip_resources: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "506878242")]
    pub user_allocated_nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterStatusNatStatusNatRuleStatus {
    #[prost(string, repeated, tag = "208517077")]
    pub active_nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "504078535")]
    pub drain_nat_ips: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "353002756")]
    pub min_extra_ips_needed: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "512367468")]
    pub num_vm_endpoints_with_nat_mappings: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "535211500")]
    pub rule_number: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouterStatusResponse {
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "139315229")]
    pub result: ::core::option::Option<RouterStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutersPreviewResponse {
    #[prost(message, optional, tag = "195806222")]
    pub resource: ::core::option::Option<Router>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoutersScopedList {
    #[prost(message, repeated, tag = "311906890")]
    pub routers: ::prost::alloc::vec::Vec<Router>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(string, optional, tag = "187661878")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "142882488")]
    pub conditions: ::prost::alloc::vec::Vec<Condition>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "104430")]
    pub ins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "152873846")]
    pub log_configs: ::prost::alloc::vec::Vec<LogConfig>,
    #[prost(string, repeated, tag = "518443138")]
    pub not_ins: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "59962500")]
    pub permissions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Action {
        UndefinedAction = 0,
        Allow = 62368553,
        AllowWithLog = 76034177,
        Deny = 2094604,
        DenyWithLog = 351433982,
        Log = 75556,
        NoAction = 260643444,
    }
    impl Action {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Action::UndefinedAction => "UNDEFINED_ACTION",
                Action::Allow => "ALLOW",
                Action::AllowWithLog => "ALLOW_WITH_LOG",
                Action::Deny => "DENY",
                Action::DenyWithLog => "DENY_WITH_LOG",
                Action::Log => "LOG",
                Action::NoAction => "NO_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ACTION" => Some(Self::UndefinedAction),
                "ALLOW" => Some(Self::Allow),
                "ALLOW_WITH_LOG" => Some(Self::AllowWithLog),
                "DENY" => Some(Self::Deny),
                "DENY_WITH_LOG" => Some(Self::DenyWithLog),
                "LOG" => Some(Self::Log),
                "NO_ACTION" => Some(Self::NoAction),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslHealthCheck {
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21951119")]
    pub request: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "196547649")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SSLHealthCheck`.
pub mod ssl_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedAttachedDisk {
    #[prost(bool, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3029746")]
    pub boot: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "67541716")]
    pub device_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "271660677")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "93009052")]
    pub disk_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "79294545")]
    pub guest_os_features: ::prost::alloc::vec::Vec<GuestOsFeature>,
    #[prost(int32, optional, tag = "100346066")]
    pub index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "502623545")]
    pub interface: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3357091")]
    pub mode: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "177235995")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "424631719")]
    pub storage_bytes: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "490739082")]
    pub storage_bytes_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SavedAttachedDisk`.
pub mod saved_attached_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Interface {
        UndefinedInterface = 0,
        Nvme = 2408800,
        Scsi = 2539686,
    }
    impl Interface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Interface::UndefinedInterface => "UNDEFINED_INTERFACE",
                Interface::Nvme => "NVME",
                Interface::Scsi => "SCSI",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INTERFACE" => Some(Self::UndefinedInterface),
                "NVME" => Some(Self::Nvme),
                "SCSI" => Some(Self::Scsi),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Mode {
        UndefinedMode = 0,
        ReadOnly = 91950261,
        ReadWrite = 173607894,
    }
    impl Mode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Mode::UndefinedMode => "UNDEFINED_MODE",
                Mode::ReadOnly => "READ_ONLY",
                Mode::ReadWrite => "READ_WRITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MODE" => Some(Self::UndefinedMode),
                "READ_ONLY" => Some(Self::ReadOnly),
                "READ_WRITE" => Some(Self::ReadWrite),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageBytesStatus {
        UndefinedStorageBytesStatus = 0,
        Updating = 494614342,
        UpToDate = 101306702,
    }
    impl StorageBytesStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StorageBytesStatus::UndefinedStorageBytesStatus => {
                    "UNDEFINED_STORAGE_BYTES_STATUS"
                }
                StorageBytesStatus::Updating => "UPDATING",
                StorageBytesStatus::UpToDate => "UP_TO_DATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STORAGE_BYTES_STATUS" => {
                    Some(Self::UndefinedStorageBytesStatus)
                }
                "UPDATING" => Some(Self::Updating),
                "UP_TO_DATE" => Some(Self::UpToDate),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Persistent = 460683927,
        Scratch = 496778970,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Persistent => "PERSISTENT",
                Type::Scratch => "SCRATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "PERSISTENT" => Some(Self::Persistent),
                "SCRATCH" => Some(Self::Scratch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SavedDisk {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "424631719")]
    pub storage_bytes: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "490739082")]
    pub storage_bytes_status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SavedDisk`.
pub mod saved_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageBytesStatus {
        UndefinedStorageBytesStatus = 0,
        Updating = 494614342,
        UpToDate = 101306702,
    }
    impl StorageBytesStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StorageBytesStatus::UndefinedStorageBytesStatus => {
                    "UNDEFINED_STORAGE_BYTES_STATUS"
                }
                StorageBytesStatus::Updating => "UPDATING",
                StorageBytesStatus::UpToDate => "UP_TO_DATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STORAGE_BYTES_STATUS" => {
                    Some(Self::UndefinedStorageBytesStatus)
                }
                "UPDATING" => Some(Self::Updating),
                "UP_TO_DATE" => Some(Self::UpToDate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScalingScheduleStatus {
    #[prost(string, optional, tag = "34545107")]
    pub last_start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "97270102")]
    pub next_start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ScalingScheduleStatus`.
pub mod scaling_schedule_status {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Active = 314733318,
        Disabled = 516696700,
        Obsolete = 66532761,
        Ready = 77848963,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Active => "ACTIVE",
                State::Disabled => "DISABLED",
                State::Obsolete => "OBSOLETE",
                State::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ACTIVE" => Some(Self::Active),
                "DISABLED" => Some(Self::Disabled),
                "OBSOLETE" => Some(Self::Obsolete),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Scheduling {
    #[prost(bool, optional, tag = "350821371")]
    pub automatic_restart: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "107380667")]
    pub instance_termination_action: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "268015590")]
    pub local_ssd_recovery_timeout: ::core::option::Option<Duration>,
    #[prost(string, optional, tag = "350519505")]
    pub location_hint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "317231675")]
    pub min_node_cpus: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "461799971")]
    pub node_affinities: ::prost::alloc::vec::Vec<SchedulingNodeAffinity>,
    #[prost(string, optional, tag = "64616796")]
    pub on_host_maintenance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "324203169")]
    pub preemptible: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "494423")]
    pub provisioning_model: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Scheduling`.
pub mod scheduling {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InstanceTerminationAction {
        UndefinedInstanceTerminationAction = 0,
        Delete = 402225579,
        Unspecified = 92954803,
        Stop = 2555906,
    }
    impl InstanceTerminationAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InstanceTerminationAction::UndefinedInstanceTerminationAction => {
                    "UNDEFINED_INSTANCE_TERMINATION_ACTION"
                }
                InstanceTerminationAction::Delete => "DELETE",
                InstanceTerminationAction::Unspecified => {
                    "INSTANCE_TERMINATION_ACTION_UNSPECIFIED"
                }
                InstanceTerminationAction::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_INSTANCE_TERMINATION_ACTION" => {
                    Some(Self::UndefinedInstanceTerminationAction)
                }
                "DELETE" => Some(Self::Delete),
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Some(Self::Unspecified),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnHostMaintenance {
        UndefinedOnHostMaintenance = 0,
        Migrate = 165699979,
        Terminate = 527617601,
    }
    impl OnHostMaintenance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnHostMaintenance::UndefinedOnHostMaintenance => {
                    "UNDEFINED_ON_HOST_MAINTENANCE"
                }
                OnHostMaintenance::Migrate => "MIGRATE",
                OnHostMaintenance::Terminate => "TERMINATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ON_HOST_MAINTENANCE" => Some(Self::UndefinedOnHostMaintenance),
                "MIGRATE" => Some(Self::Migrate),
                "TERMINATE" => Some(Self::Terminate),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProvisioningModel {
        UndefinedProvisioningModel = 0,
        Spot = 2552066,
        Standard = 484642493,
    }
    impl ProvisioningModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProvisioningModel::UndefinedProvisioningModel => {
                    "UNDEFINED_PROVISIONING_MODEL"
                }
                ProvisioningModel::Spot => "SPOT",
                ProvisioningModel::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROVISIONING_MODEL" => Some(Self::UndefinedProvisioningModel),
                "SPOT" => Some(Self::Spot),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SchedulingNodeAffinity {
    #[prost(string, optional, tag = "106079")]
    pub key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "36317348")]
    pub operator: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "249928994")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SchedulingNodeAffinity`.
pub mod scheduling_node_affinity {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operator {
        UndefinedOperator = 0,
        In = 2341,
        NotIn = 161144369,
        Unspecified = 128892924,
    }
    impl Operator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operator::UndefinedOperator => "UNDEFINED_OPERATOR",
                Operator::In => "IN",
                Operator::NotIn => "NOT_IN",
                Operator::Unspecified => "OPERATOR_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OPERATOR" => Some(Self::UndefinedOperator),
                "IN" => Some(Self::In),
                "NOT_IN" => Some(Self::NotIn),
                "OPERATOR_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScratchDisks {
    #[prost(int32, optional, tag = "60990141")]
    pub disk_gb: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Screenshot {
    #[prost(string, optional, tag = "506419994")]
    pub contents: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPoliciesAggregatedList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SecurityPoliciesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPoliciesListPreconfiguredExpressionSetsResponse {
    #[prost(message, optional, tag = "536200826")]
    pub preconfigured_expression_sets: ::core::option::Option<SecurityPoliciesWafConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPoliciesScopedList {
    #[prost(message, repeated, tag = "127783791")]
    pub security_policies: ::prost::alloc::vec::Vec<SecurityPolicy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPoliciesWafConfig {
    #[prost(message, optional, tag = "74899924")]
    pub waf_rules: ::core::option::Option<PreconfiguredWafSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicy {
    #[prost(message, optional, tag = "150240735")]
    pub adaptive_protection_config: ::core::option::Option<
        SecurityPolicyAdaptiveProtectionConfig,
    >,
    #[prost(message, optional, tag = "449276352")]
    pub advanced_options_config: ::core::option::Option<
        SecurityPolicyAdvancedOptionsConfig,
    >,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50315853")]
    pub ddos_protection_config: ::core::option::Option<
        SecurityPolicyDdosProtectionConfig,
    >,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "519006811")]
    pub recaptcha_options_config: ::core::option::Option<
        SecurityPolicyRecaptchaOptionsConfig,
    >,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "108873975")]
    pub rules: ::prost::alloc::vec::Vec<SecurityPolicyRule>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "28312739")]
    pub user_defined_fields: ::prost::alloc::vec::Vec<SecurityPolicyUserDefinedField>,
}
/// Nested message and enum types in `SecurityPolicy`.
pub mod security_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        CloudArmor = 260640373,
        CloudArmorEdge = 250728775,
        CloudArmorNetwork = 488527428,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::CloudArmor => "CLOUD_ARMOR",
                Type::CloudArmorEdge => "CLOUD_ARMOR_EDGE",
                Type::CloudArmorNetwork => "CLOUD_ARMOR_NETWORK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "CLOUD_ARMOR" => Some(Self::CloudArmor),
                "CLOUD_ARMOR_EDGE" => Some(Self::CloudArmorEdge),
                "CLOUD_ARMOR_NETWORK" => Some(Self::CloudArmorNetwork),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyAdaptiveProtectionConfig {
    #[prost(message, optional, tag = "437316771")]
    pub layer7_ddos_defense_config: ::core::option::Option<
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig {
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "453258293")]
    pub rule_visibility: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "60347805")]
    pub threshold_configs: ::prost::alloc::vec::Vec<
        SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig,
    >,
}
/// Nested message and enum types in `SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfig`.
pub mod security_policy_adaptive_protection_config_layer7_ddos_defense_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RuleVisibility {
        UndefinedRuleVisibility = 0,
        Premium = 399530551,
        Standard = 484642493,
    }
    impl RuleVisibility {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RuleVisibility::UndefinedRuleVisibility => "UNDEFINED_RULE_VISIBILITY",
                RuleVisibility::Premium => "PREMIUM",
                RuleVisibility::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_RULE_VISIBILITY" => Some(Self::UndefinedRuleVisibility),
                "PREMIUM" => Some(Self::Premium),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyAdaptiveProtectionConfigLayer7DdosDefenseConfigThresholdConfig {
    #[prost(float, optional, tag = "84309694")]
    pub auto_deploy_confidence_threshold: ::core::option::Option<f32>,
    #[prost(int32, optional, tag = "69638793")]
    pub auto_deploy_expiration_sec: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "292441667")]
    pub auto_deploy_impacted_baseline_threshold: ::core::option::Option<f32>,
    #[prost(float, optional, tag = "522227738")]
    pub auto_deploy_load_threshold: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyAdvancedOptionsConfig {
    #[prost(message, optional, tag = "111570105")]
    pub json_custom_config: ::core::option::Option<
        SecurityPolicyAdvancedOptionsConfigJsonCustomConfig,
    >,
    #[prost(string, optional, tag = "282493529")]
    pub json_parsing: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "140582601")]
    pub log_level: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "421050290")]
    pub user_ip_request_headers: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `SecurityPolicyAdvancedOptionsConfig`.
pub mod security_policy_advanced_options_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JsonParsing {
        UndefinedJsonParsing = 0,
        Disabled = 516696700,
        Standard = 484642493,
        StandardWithGraphql = 106979218,
    }
    impl JsonParsing {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                JsonParsing::UndefinedJsonParsing => "UNDEFINED_JSON_PARSING",
                JsonParsing::Disabled => "DISABLED",
                JsonParsing::Standard => "STANDARD",
                JsonParsing::StandardWithGraphql => "STANDARD_WITH_GRAPHQL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_JSON_PARSING" => Some(Self::UndefinedJsonParsing),
                "DISABLED" => Some(Self::Disabled),
                "STANDARD" => Some(Self::Standard),
                "STANDARD_WITH_GRAPHQL" => Some(Self::StandardWithGraphql),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogLevel {
        UndefinedLogLevel = 0,
        Normal = 161067239,
        Verbose = 532219234,
    }
    impl LogLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LogLevel::UndefinedLogLevel => "UNDEFINED_LOG_LEVEL",
                LogLevel::Normal => "NORMAL",
                LogLevel::Verbose => "VERBOSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOG_LEVEL" => Some(Self::UndefinedLogLevel),
                "NORMAL" => Some(Self::Normal),
                "VERBOSE" => Some(Self::Verbose),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyAdvancedOptionsConfigJsonCustomConfig {
    #[prost(string, repeated, tag = "17428787")]
    pub content_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyDdosProtectionConfig {
    #[prost(string, optional, tag = "275173268")]
    pub ddos_protection: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SecurityPolicyDdosProtectionConfig`.
pub mod security_policy_ddos_protection_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DdosProtection {
        UndefinedDdosProtection = 0,
        Advanced = 63789090,
        Standard = 484642493,
    }
    impl DdosProtection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DdosProtection::UndefinedDdosProtection => "UNDEFINED_DDOS_PROTECTION",
                DdosProtection::Advanced => "ADVANCED",
                DdosProtection::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_DDOS_PROTECTION" => Some(Self::UndefinedDdosProtection),
                "ADVANCED" => Some(Self::Advanced),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<SecurityPolicy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRecaptchaOptionsConfig {
    #[prost(string, optional, tag = "447677034")]
    pub redirect_site_key: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyReference {
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRule {
    #[prost(string, optional, tag = "187661878")]
    pub action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328077352")]
    pub header_action: ::core::option::Option<SecurityPolicyRuleHttpHeaderAction>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "103668165")]
    pub r#match: ::core::option::Option<SecurityPolicyRuleMatcher>,
    #[prost(message, optional, tag = "463387764")]
    pub network_match: ::core::option::Option<SecurityPolicyRuleNetworkMatcher>,
    #[prost(message, optional, tag = "117805027")]
    pub preconfigured_waf_config: ::core::option::Option<
        SecurityPolicyRulePreconfiguredWafConfig,
    >,
    #[prost(bool, optional, tag = "218686408")]
    pub preview: ::core::option::Option<bool>,
    #[prost(int32, optional, tag = "445151652")]
    pub priority: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "67544315")]
    pub rate_limit_options: ::core::option::Option<SecurityPolicyRuleRateLimitOptions>,
    #[prost(message, optional, tag = "163285307")]
    pub redirect_options: ::core::option::Option<SecurityPolicyRuleRedirectOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleHttpHeaderAction {
    #[prost(message, repeated, tag = "87987661")]
    pub request_headers_to_adds: ::prost::alloc::vec::Vec<
        SecurityPolicyRuleHttpHeaderActionHttpHeaderOption,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleHttpHeaderActionHttpHeaderOption {
    #[prost(string, optional, tag = "110223613")]
    pub header_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "203094335")]
    pub header_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleMatcher {
    #[prost(message, optional, tag = "255820610")]
    pub config: ::core::option::Option<SecurityPolicyRuleMatcherConfig>,
    #[prost(message, optional, tag = "3127797")]
    pub expr: ::core::option::Option<Expr>,
    #[prost(message, optional, tag = "486220372")]
    pub expr_options: ::core::option::Option<SecurityPolicyRuleMatcherExprOptions>,
    #[prost(string, optional, tag = "322286013")]
    pub versioned_expr: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SecurityPolicyRuleMatcher`.
pub mod security_policy_rule_matcher {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VersionedExpr {
        UndefinedVersionedExpr = 0,
        SrcIpsV1 = 70925961,
    }
    impl VersionedExpr {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VersionedExpr::UndefinedVersionedExpr => "UNDEFINED_VERSIONED_EXPR",
                VersionedExpr::SrcIpsV1 => "SRC_IPS_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_VERSIONED_EXPR" => Some(Self::UndefinedVersionedExpr),
                "SRC_IPS_V1" => Some(Self::SrcIpsV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleMatcherConfig {
    #[prost(string, repeated, tag = "432128083")]
    pub src_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleMatcherExprOptions {
    #[prost(message, optional, tag = "389151558")]
    pub recaptcha_options: ::core::option::Option<
        SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleMatcherExprOptionsRecaptchaOptions {
    #[prost(string, repeated, tag = "59929885")]
    pub action_token_site_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "333363581")]
    pub session_token_site_keys: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleNetworkMatcher {
    #[prost(string, repeated, tag = "337357713")]
    pub dest_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "379902005")]
    pub dest_ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "259213251")]
    pub ip_protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint32, repeated, tag = "117825266")]
    pub src_asns: ::prost::alloc::vec::Vec<u32>,
    #[prost(string, repeated, tag = "432128083")]
    pub src_ip_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "445095415")]
    pub src_ports: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "99086742")]
    pub src_region_codes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "28312739")]
    pub user_defined_fields: ::prost::alloc::vec::Vec<
        SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleNetworkMatcherUserDefinedFieldMatch {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "249928994")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRulePreconfiguredWafConfig {
    #[prost(message, repeated, tag = "208665701")]
    pub exclusions: ::prost::alloc::vec::Vec<
        SecurityPolicyRulePreconfiguredWafConfigExclusion,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRulePreconfiguredWafConfigExclusion {
    #[prost(message, repeated, tag = "156757878")]
    pub request_cookies_to_exclude: ::prost::alloc::vec::Vec<
        SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams,
    >,
    #[prost(message, repeated, tag = "63230495")]
    pub request_headers_to_exclude: ::prost::alloc::vec::Vec<
        SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams,
    >,
    #[prost(message, repeated, tag = "340692744")]
    pub request_query_params_to_exclude: ::prost::alloc::vec::Vec<
        SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams,
    >,
    #[prost(message, repeated, tag = "90690846")]
    pub request_uris_to_exclude: ::prost::alloc::vec::Vec<
        SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams,
    >,
    #[prost(string, repeated, tag = "498430435")]
    pub target_rule_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "498440077")]
    pub target_rule_set: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams {
    #[prost(string, optional, tag = "3553")]
    pub op: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "116513")]
    pub val: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SecurityPolicyRulePreconfiguredWafConfigExclusionFieldParams`.
pub mod security_policy_rule_preconfigured_waf_config_exclusion_field_params {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Op {
        UndefinedOp = 0,
        Contains = 215180831,
        EndsWith = 490402221,
        Equals = 442201023,
        EqualsAny = 337226060,
        StartsWith = 139505652,
    }
    impl Op {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Op::UndefinedOp => "UNDEFINED_OP",
                Op::Contains => "CONTAINS",
                Op::EndsWith => "ENDS_WITH",
                Op::Equals => "EQUALS",
                Op::EqualsAny => "EQUALS_ANY",
                Op::StartsWith => "STARTS_WITH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_OP" => Some(Self::UndefinedOp),
                "CONTAINS" => Some(Self::Contains),
                "ENDS_WITH" => Some(Self::EndsWith),
                "EQUALS" => Some(Self::Equals),
                "EQUALS_ANY" => Some(Self::EqualsAny),
                "STARTS_WITH" => Some(Self::StartsWith),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleRateLimitOptions {
    #[prost(int32, optional, tag = "42896726")]
    pub ban_duration_sec: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "501208123")]
    pub ban_threshold: ::core::option::Option<
        SecurityPolicyRuleRateLimitOptionsThreshold,
    >,
    #[prost(string, optional, tag = "517612367")]
    pub conform_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "416648956")]
    pub enforce_on_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "33906478")]
    pub enforce_on_key_configs: ::prost::alloc::vec::Vec<
        SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig,
    >,
    #[prost(string, optional, tag = "132555246")]
    pub enforce_on_key_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "167159073")]
    pub exceed_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "473646694")]
    pub exceed_redirect_options: ::core::option::Option<
        SecurityPolicyRuleRedirectOptions,
    >,
    #[prost(message, optional, tag = "315875208")]
    pub rate_limit_threshold: ::core::option::Option<
        SecurityPolicyRuleRateLimitOptionsThreshold,
    >,
}
/// Nested message and enum types in `SecurityPolicyRuleRateLimitOptions`.
pub mod security_policy_rule_rate_limit_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnforceOnKey {
        UndefinedEnforceOnKey = 0,
        All = 64897,
        HttpCookie = 494981627,
        HttpHeader = 91597348,
        HttpPath = 311503228,
        Ip = 2343,
        RegionCode = 79559768,
        Sni = 82254,
        TlsJa3Fingerprint = 327127933,
        UserIp = 34009627,
        XffIp = 438707118,
    }
    impl EnforceOnKey {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnforceOnKey::UndefinedEnforceOnKey => "UNDEFINED_ENFORCE_ON_KEY",
                EnforceOnKey::All => "ALL",
                EnforceOnKey::HttpCookie => "HTTP_COOKIE",
                EnforceOnKey::HttpHeader => "HTTP_HEADER",
                EnforceOnKey::HttpPath => "HTTP_PATH",
                EnforceOnKey::Ip => "IP",
                EnforceOnKey::RegionCode => "REGION_CODE",
                EnforceOnKey::Sni => "SNI",
                EnforceOnKey::TlsJa3Fingerprint => "TLS_JA3_FINGERPRINT",
                EnforceOnKey::UserIp => "USER_IP",
                EnforceOnKey::XffIp => "XFF_IP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENFORCE_ON_KEY" => Some(Self::UndefinedEnforceOnKey),
                "ALL" => Some(Self::All),
                "HTTP_COOKIE" => Some(Self::HttpCookie),
                "HTTP_HEADER" => Some(Self::HttpHeader),
                "HTTP_PATH" => Some(Self::HttpPath),
                "IP" => Some(Self::Ip),
                "REGION_CODE" => Some(Self::RegionCode),
                "SNI" => Some(Self::Sni),
                "TLS_JA3_FINGERPRINT" => Some(Self::TlsJa3Fingerprint),
                "USER_IP" => Some(Self::UserIp),
                "XFF_IP" => Some(Self::XffIp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig {
    #[prost(string, optional, tag = "132555246")]
    pub enforce_on_key_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "132757149")]
    pub enforce_on_key_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SecurityPolicyRuleRateLimitOptionsEnforceOnKeyConfig`.
pub mod security_policy_rule_rate_limit_options_enforce_on_key_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnforceOnKeyType {
        UndefinedEnforceOnKeyType = 0,
        All = 64897,
        HttpCookie = 494981627,
        HttpHeader = 91597348,
        HttpPath = 311503228,
        Ip = 2343,
        RegionCode = 79559768,
        Sni = 82254,
        TlsJa3Fingerprint = 327127933,
        UserIp = 34009627,
        XffIp = 438707118,
    }
    impl EnforceOnKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnforceOnKeyType::UndefinedEnforceOnKeyType => {
                    "UNDEFINED_ENFORCE_ON_KEY_TYPE"
                }
                EnforceOnKeyType::All => "ALL",
                EnforceOnKeyType::HttpCookie => "HTTP_COOKIE",
                EnforceOnKeyType::HttpHeader => "HTTP_HEADER",
                EnforceOnKeyType::HttpPath => "HTTP_PATH",
                EnforceOnKeyType::Ip => "IP",
                EnforceOnKeyType::RegionCode => "REGION_CODE",
                EnforceOnKeyType::Sni => "SNI",
                EnforceOnKeyType::TlsJa3Fingerprint => "TLS_JA3_FINGERPRINT",
                EnforceOnKeyType::UserIp => "USER_IP",
                EnforceOnKeyType::XffIp => "XFF_IP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ENFORCE_ON_KEY_TYPE" => Some(Self::UndefinedEnforceOnKeyType),
                "ALL" => Some(Self::All),
                "HTTP_COOKIE" => Some(Self::HttpCookie),
                "HTTP_HEADER" => Some(Self::HttpHeader),
                "HTTP_PATH" => Some(Self::HttpPath),
                "IP" => Some(Self::Ip),
                "REGION_CODE" => Some(Self::RegionCode),
                "SNI" => Some(Self::Sni),
                "TLS_JA3_FINGERPRINT" => Some(Self::TlsJa3Fingerprint),
                "USER_IP" => Some(Self::UserIp),
                "XFF_IP" => Some(Self::XffIp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleRateLimitOptionsThreshold {
    #[prost(int32, optional, tag = "94851343")]
    pub count: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "41084375")]
    pub interval_sec: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyRuleRedirectOptions {
    #[prost(string, optional, tag = "192835985")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SecurityPolicyRuleRedirectOptions`.
pub mod security_policy_rule_redirect_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        External302 = 395733761,
        GoogleRecaptcha = 518803009,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::External302 => "EXTERNAL_302",
                Type::GoogleRecaptcha => "GOOGLE_RECAPTCHA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "EXTERNAL_302" => Some(Self::External302),
                "GOOGLE_RECAPTCHA" => Some(Self::GoogleRecaptcha),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecurityPolicyUserDefinedField {
    #[prost(string, optional, tag = "3016401")]
    pub base: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3344108")]
    pub mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "53961875")]
    pub offset: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "3530753")]
    pub size: ::core::option::Option<i32>,
}
/// Nested message and enum types in `SecurityPolicyUserDefinedField`.
pub mod security_policy_user_defined_field {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Base {
        UndefinedBase = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
        Tcp = 82881,
        Udp = 83873,
    }
    impl Base {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Base::UndefinedBase => "UNDEFINED_BASE",
                Base::Ipv4 => "IPV4",
                Base::Ipv6 => "IPV6",
                Base::Tcp => "TCP",
                Base::Udp => "UDP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_BASE" => Some(Self::UndefinedBase),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                "TCP" => Some(Self::Tcp),
                "UDP" => Some(Self::Udp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SecuritySettings {
    #[prost(message, optional, tag = "433993111")]
    pub aws_v4_authentication: ::core::option::Option<Awsv4Signature>,
    #[prost(string, optional, tag = "462325226")]
    pub client_tls_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "330029535")]
    pub subject_alt_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendDiagnosticInterruptInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SendDiagnosticInterruptInstanceResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SerialPortOutput {
    #[prost(string, optional, tag = "506419994")]
    pub contents: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "3377907")]
    pub next: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "109757538")]
    pub start: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerBinding {
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ServerBinding`.
pub mod server_binding {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        RestartNodeOnAnyServer = 502950985,
        RestartNodeOnMinimalServers = 204166495,
        ServerBindingTypeUnspecified = 180825512,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::RestartNodeOnAnyServer => "RESTART_NODE_ON_ANY_SERVER",
                Type::RestartNodeOnMinimalServers => "RESTART_NODE_ON_MINIMAL_SERVERS",
                Type::ServerBindingTypeUnspecified => "SERVER_BINDING_TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "RESTART_NODE_ON_ANY_SERVER" => Some(Self::RestartNodeOnAnyServer),
                "RESTART_NODE_ON_MINIMAL_SERVERS" => {
                    Some(Self::RestartNodeOnMinimalServers)
                }
                "SERVER_BINDING_TYPE_UNSPECIFIED" => {
                    Some(Self::ServerBindingTypeUnspecified)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAccount {
    #[prost(string, optional, tag = "96619420")]
    pub email: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "165973151")]
    pub scopes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachment {
    #[prost(message, repeated, tag = "72223688")]
    pub connected_endpoints: ::prost::alloc::vec::Vec<
        ServiceAttachmentConnectedEndpoint,
    >,
    #[prost(string, optional, tag = "285818076")]
    pub connection_preference: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "402725703")]
    pub consumer_accept_lists: ::prost::alloc::vec::Vec<
        ServiceAttachmentConsumerProjectLimit,
    >,
    #[prost(string, repeated, tag = "204033182")]
    pub consumer_reject_lists: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "6450189")]
    pub domain_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "363791237")]
    pub enable_proxy_protocol: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "374785944")]
    pub nat_subnets: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "247927889")]
    pub producer_forwarding_rule: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "527695214")]
    pub psc_service_attachment_id: ::core::option::Option<Uint128>,
    #[prost(bool, optional, tag = "125493732")]
    pub reconcile_connections: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "1293831")]
    pub target_service: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ServiceAttachment`.
pub mod service_attachment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConnectionPreference {
        UndefinedConnectionPreference = 0,
        AcceptAutomatic = 75250580,
        AcceptManual = 373061341,
        Unspecified = 34590772,
    }
    impl ConnectionPreference {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConnectionPreference::UndefinedConnectionPreference => {
                    "UNDEFINED_CONNECTION_PREFERENCE"
                }
                ConnectionPreference::AcceptAutomatic => "ACCEPT_AUTOMATIC",
                ConnectionPreference::AcceptManual => "ACCEPT_MANUAL",
                ConnectionPreference::Unspecified => "CONNECTION_PREFERENCE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CONNECTION_PREFERENCE" => {
                    Some(Self::UndefinedConnectionPreference)
                }
                "ACCEPT_AUTOMATIC" => Some(Self::AcceptAutomatic),
                "ACCEPT_MANUAL" => Some(Self::AcceptManual),
                "CONNECTION_PREFERENCE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachmentAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ServiceAttachmentsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachmentConnectedEndpoint {
    #[prost(string, optional, tag = "254357221")]
    pub consumer_network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "130489749")]
    pub endpoint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "292082397")]
    pub psc_connection_id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ServiceAttachmentConnectedEndpoint`.
pub mod service_attachment_connected_endpoint {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Accepted = 246714279,
        Closed = 380163436,
        NeedsAttention = 344491452,
        Pending = 35394935,
        Rejected = 174130302,
        Unspecified = 42133066,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Accepted => "ACCEPTED",
                Status::Closed => "CLOSED",
                Status::NeedsAttention => "NEEDS_ATTENTION",
                Status::Pending => "PENDING",
                Status::Rejected => "REJECTED",
                Status::Unspecified => "STATUS_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACCEPTED" => Some(Self::Accepted),
                "CLOSED" => Some(Self::Closed),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "PENDING" => Some(Self::Pending),
                "REJECTED" => Some(Self::Rejected),
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachmentConsumerProjectLimit {
    #[prost(uint32, optional, tag = "131403546")]
    pub connection_limit: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "207194078")]
    pub network_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "349783336")]
    pub project_id_or_num: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachmentList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<ServiceAttachment>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceAttachmentsScopedList {
    #[prost(message, repeated, tag = "307136806")]
    pub service_attachments: ::prost::alloc::vec::Vec<ServiceAttachment>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBackendServiceTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "139080868")]
    pub target_ssl_proxies_set_backend_service_request_resource: ::core::option::Option<
        TargetSslProxiesSetBackendServiceRequest,
    >,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBackendServiceTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "273721583")]
    pub target_tcp_proxies_set_backend_service_request_resource: ::core::option::Option<
        TargetTcpProxiesSetBackendServiceRequest,
    >,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetBackupTargetPoolRequest {
    #[prost(float, optional, tag = "212667006")]
    pub failover_ratio: ::core::option::Option<f32>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "523721712")]
    pub target_reference_resource: ::core::option::Option<TargetReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCertificateMapTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "467639099")]
    pub target_https_proxies_set_certificate_map_request_resource: ::core::option::Option<
        TargetHttpsProxiesSetCertificateMapRequest,
    >,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCertificateMapTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "343984954")]
    pub target_ssl_proxies_set_certificate_map_request_resource: ::core::option::Option<
        TargetSslProxiesSetCertificateMapRequest,
    >,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCloudArmorTierProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "77053391")]
    pub projects_set_cloud_armor_tier_request_resource: ::core::option::Option<
        ProjectsSetCloudArmorTierRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCommonInstanceMetadataOperationMetadata {
    #[prost(string, optional, tag = "297240295")]
    pub client_operation_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "408987796")]
    pub per_location_operations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {
    #[prost(message, optional, tag = "96784904")]
    pub error: ::core::option::Option<Status>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo`.
pub mod set_common_instance_metadata_operation_metadata_per_location_operation_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Abandoned = 81797556,
        Done = 2104194,
        Failed = 455706685,
        Propagated = 507550299,
        Propagating = 164807046,
        Unspecified = 526786327,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Abandoned => "ABANDONED",
                State::Done => "DONE",
                State::Failed => "FAILED",
                State::Propagated => "PROPAGATED",
                State::Propagating => "PROPAGATING",
                State::Unspecified => "UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "ABANDONED" => Some(Self::Abandoned),
                "DONE" => Some(Self::Done),
                "FAILED" => Some(Self::Failed),
                "PROPAGATED" => Some(Self::Propagated),
                "PROPAGATING" => Some(Self::Propagating),
                "UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetCommonInstanceMetadataProjectRequest {
    #[prost(message, optional, tag = "291086110")]
    pub metadata_resource: ::core::option::Option<Metadata>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDefaultNetworkTierProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "126410762")]
    pub projects_set_default_network_tier_request_resource: ::core::option::Option<
        ProjectsSetDefaultNetworkTierRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDeletionProtectionInstanceRequest {
    #[prost(bool, optional, tag = "458014698")]
    pub deletion_protection: ::core::option::Option<bool>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetDiskAutoDeleteInstanceRequest {
    #[prost(bool, tag = "464761403")]
    pub auto_delete: bool,
    #[prost(string, tag = "67541716")]
    pub device_name: ::prost::alloc::string::String,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetEdgeSecurityPolicyBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetEdgeSecurityPolicyBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyBackendBucketRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyBackendServiceRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyFirewallPolicyRequest {
    #[prost(message, optional, tag = "177408606")]
    pub global_organization_set_policy_request_resource: ::core::option::Option<
        GlobalOrganizationSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyImageRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyInstanceTemplateRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyLicenseRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyMachineImageRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyNetworkAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyNetworkFirewallPolicyRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyNodeGroupRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyNodeTemplateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyRegionBackendServiceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyRegionDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyRegionInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicySnapshotRequest {
    #[prost(message, optional, tag = "337048498")]
    pub global_set_policy_request_resource: ::core::option::Option<
        GlobalSetPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicyStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "382082107")]
    pub zone_set_policy_request_resource: ::core::option::Option<ZoneSetPolicyRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetIamPolicySubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "276489091")]
    pub region_set_policy_request_resource: ::core::option::Option<
        RegionSetPolicyRequest,
    >,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetInstanceTemplateInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9809093")]
    pub instance_group_managers_set_instance_template_request_resource: ::core::option::Option<
        InstanceGroupManagersSetInstanceTemplateRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetInstanceTemplateRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "187310412")]
    pub region_instance_group_managers_set_template_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersSetTemplateRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsAddressRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "364950798")]
    pub zone_set_labels_request_resource: ::core::option::Option<ZoneSetLabelsRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsExternalVpnGatewayRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsForwardingRuleRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsGlobalAddressRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsGlobalForwardingRuleRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsImageRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "207749344")]
    pub instances_set_labels_request_resource: ::core::option::Option<
        InstancesSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "364950798")]
    pub zone_set_labels_request_resource: ::core::option::Option<ZoneSetLabelsRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsInterconnectAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsInterconnectRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsRegionDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsRegionInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsSecurityPolicyRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsSnapshotRequest {
    #[prost(message, optional, tag = "319917189")]
    pub global_set_labels_request_resource: ::core::option::Option<
        GlobalSetLabelsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsTargetVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetLabelsVpnTunnelRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "259357782")]
    pub region_set_labels_request_resource: ::core::option::Option<
        RegionSetLabelsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMachineResourcesInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "196286318")]
    pub instances_set_machine_resources_request_resource: ::core::option::Option<
        InstancesSetMachineResourcesRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMachineTypeInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "254157709")]
    pub instances_set_machine_type_request_resource: ::core::option::Option<
        InstancesSetMachineTypeRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMetadataInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "291086110")]
    pub metadata_resource: ::core::option::Option<Metadata>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetMinCpuPlatformInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "148459368")]
    pub instances_set_min_cpu_platform_request_resource: ::core::option::Option<
        InstancesSetMinCpuPlatformRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNameInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "272080980")]
    pub instances_set_name_request_resource: ::core::option::Option<
        InstancesSetNameRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNamedPortsInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "385151535")]
    pub instance_groups_set_named_ports_request_resource: ::core::option::Option<
        InstanceGroupsSetNamedPortsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNamedPortsRegionInstanceGroupRequest {
    #[prost(string, tag = "81095253")]
    pub instance_group: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1574938")]
    pub region_instance_groups_set_named_ports_request_resource: ::core::option::Option<
        RegionInstanceGroupsSetNamedPortsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetNodeTemplateNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "117382321")]
    pub node_groups_set_node_template_request_resource: ::core::option::Option<
        NodeGroupsSetNodeTemplateRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetPrivateIpGoogleAccessSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "307827694")]
    pub subnetwork: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "268920696")]
    pub subnetworks_set_private_ip_google_access_request_resource: ::core::option::Option<
        SubnetworksSetPrivateIpGoogleAccessRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProxyHeaderTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "205284526")]
    pub target_ssl_proxies_set_proxy_header_request_resource: ::core::option::Option<
        TargetSslProxiesSetProxyHeaderRequest,
    >,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetProxyHeaderTargetTcpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "219958339")]
    pub target_tcp_proxies_set_proxy_header_request_resource: ::core::option::Option<
        TargetTcpProxiesSetProxyHeaderRequest,
    >,
    #[prost(string, tag = "503065442")]
    pub target_tcp_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetQuicOverrideTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "72940258")]
    pub target_https_proxies_set_quic_override_request_resource: ::core::option::Option<
        TargetHttpsProxiesSetQuicOverrideRequest,
    >,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSchedulingInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "463181401")]
    pub scheduling_resource: ::core::option::Option<Scheduling>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSecurityPolicyBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSecurityPolicyInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "248424586")]
    pub instances_set_security_policy_request_resource: ::core::option::Option<
        InstancesSetSecurityPolicyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSecurityPolicyRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSecurityPolicyTargetInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
    #[prost(string, tag = "289769347")]
    pub target_instance: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSecurityPolicyTargetPoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "204135024")]
    pub security_policy_reference_resource: ::core::option::Option<
        SecurityPolicyReference,
    >,
    #[prost(string, tag = "62796298")]
    pub target_pool: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetServiceAccountInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "275550008")]
    pub instances_set_service_account_request_resource: ::core::option::Option<
        InstancesSetServiceAccountRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetShieldedInstanceIntegrityPolicyInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "409169462")]
    pub shielded_instance_integrity_policy_resource: ::core::option::Option<
        ShieldedInstanceIntegrityPolicy,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSslCertificatesRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "390693383")]
    pub region_target_https_proxies_set_ssl_certificates_request_resource: ::core::option::Option<
        RegionTargetHttpsProxiesSetSslCertificatesRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSslCertificatesTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "223122908")]
    pub target_https_proxies_set_ssl_certificates_request_resource: ::core::option::Option<
        TargetHttpsProxiesSetSslCertificatesRequest,
    >,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSslCertificatesTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "147940797")]
    pub target_ssl_proxies_set_ssl_certificates_request_resource: ::core::option::Option<
        TargetSslProxiesSetSslCertificatesRequest,
    >,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSslPolicyTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "235403836")]
    pub ssl_policy_reference_resource: ::core::option::Option<SslPolicyReference>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetSslPolicyTargetSslProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "235403836")]
    pub ssl_policy_reference_resource: ::core::option::Option<SslPolicyReference>,
    #[prost(string, tag = "338795853")]
    pub target_ssl_proxy: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTagsInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "331435380")]
    pub tags_resource: ::core::option::Option<Tags>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTargetForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "523721712")]
    pub target_reference_resource: ::core::option::Option<TargetReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTargetGlobalForwardingRuleRequest {
    #[prost(string, tag = "269964030")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "523721712")]
    pub target_reference_resource: ::core::option::Option<TargetReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTargetPoolsInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "281150216")]
    pub instance_group_managers_set_target_pools_request_resource: ::core::option::Option<
        InstanceGroupManagersSetTargetPoolsRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetTargetPoolsRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "78734717")]
    pub region_instance_group_managers_set_target_pools_request_resource: ::core::option::Option<
        RegionInstanceGroupManagersSetTargetPoolsRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUrlMapRegionTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "398701333")]
    pub url_map_reference_resource: ::core::option::Option<UrlMapReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUrlMapRegionTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "398701333")]
    pub url_map_reference_resource: ::core::option::Option<UrlMapReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUrlMapTargetHttpProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "206872421")]
    pub target_http_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "398701333")]
    pub url_map_reference_resource: ::core::option::Option<UrlMapReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUrlMapTargetHttpsProxyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "52336748")]
    pub target_https_proxy: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "398701333")]
    pub url_map_reference_resource: ::core::option::Option<UrlMapReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetUsageExportBucketProjectRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "20260459")]
    pub usage_export_location_resource: ::core::option::Option<UsageExportLocation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareSettings {
    #[prost(map = "string, message", tag = "134212406")]
    pub project_map: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ShareSettingsProjectConfig,
    >,
    #[prost(string, optional, tag = "359533466")]
    pub share_type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `ShareSettings`.
pub mod share_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ShareType {
        UndefinedShareType = 0,
        Local = 72607563,
        Organization = 274978099,
        Unspecified = 494771730,
        SpecificProjects = 347838695,
    }
    impl ShareType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ShareType::UndefinedShareType => "UNDEFINED_SHARE_TYPE",
                ShareType::Local => "LOCAL",
                ShareType::Organization => "ORGANIZATION",
                ShareType::Unspecified => "SHARE_TYPE_UNSPECIFIED",
                ShareType::SpecificProjects => "SPECIFIC_PROJECTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SHARE_TYPE" => Some(Self::UndefinedShareType),
                "LOCAL" => Some(Self::Local),
                "ORGANIZATION" => Some(Self::Organization),
                "SHARE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SPECIFIC_PROJECTS" => Some(Self::SpecificProjects),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShareSettingsProjectConfig {
    #[prost(string, optional, tag = "177513473")]
    pub project_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedInstanceConfig {
    #[prost(bool, optional, tag = "409071030")]
    pub enable_integrity_monitoring: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "123568638")]
    pub enable_secure_boot: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "181858935")]
    pub enable_vtpm: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShieldedInstanceIdentity {
    #[prost(message, optional, tag = "488268707")]
    pub encryption_key: ::core::option::Option<ShieldedInstanceIdentityEntry>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "320948261")]
    pub signing_key: ::core::option::Option<ShieldedInstanceIdentityEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShieldedInstanceIdentityEntry {
    #[prost(string, optional, tag = "450178589")]
    pub ek_cert: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "308947940")]
    pub ek_pub: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShieldedInstanceIntegrityPolicy {
    #[prost(bool, optional, tag = "245490215")]
    pub update_auto_learn_policy: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignedUrlKey {
    #[prost(string, optional, tag = "500938859")]
    pub key_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "504106897")]
    pub key_value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateMaintenanceEventInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "405957627")]
    pub with_extended_notifications: ::core::option::Option<bool>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimulateMaintenanceEventNodeGroupRequest {
    #[prost(string, tag = "469958146")]
    pub node_group: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "351468764")]
    pub node_groups_simulate_maintenance_event_request_resource: ::core::option::Option<
        NodeGroupsSimulateMaintenanceEventRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Snapshot {
    #[prost(string, optional, tag = "302803283")]
    pub architecture: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "463922264")]
    pub auto_created: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "68644169")]
    pub chain_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "125400077")]
    pub creation_size_bytes: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "316263735")]
    pub disk_size_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "435054068")]
    pub download_bytes: ::core::option::Option<i64>,
    #[prost(bool, optional, tag = "102135228")]
    pub enable_confidential_compute: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "79294545")]
    pub guest_os_features: ::prost::alloc::vec::Vec<GuestOsFeature>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(int64, repeated, tag = "45482664")]
    pub license_codes: ::prost::alloc::vec::Vec<i64>,
    #[prost(string, repeated, tag = "337642578")]
    pub licenses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "350519505")]
    pub location_hint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "480964257")]
    pub satisfies_pzi: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "480964267")]
    pub satisfies_pzs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "43334526")]
    pub snapshot_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "124349653")]
    pub snapshot_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "531501153")]
    pub source_disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "359837950")]
    pub source_disk_for_recovery_checkpoint: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "454190809")]
    pub source_disk_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "219202054")]
    pub source_instant_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "436536060")]
    pub source_instant_snapshot_encryption_key: ::core::option::Option<
        CustomerEncryptionKey,
    >,
    #[prost(string, optional, tag = "287582708")]
    pub source_instant_snapshot_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "235756291")]
    pub source_snapshot_schedule_policy: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "70489047")]
    pub source_snapshot_schedule_policy_id: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "424631719")]
    pub storage_bytes: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "490739082")]
    pub storage_bytes_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "328005274")]
    pub storage_locations: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Snapshot`.
pub mod snapshot {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Architecture {
        UndefinedArchitecture = 0,
        Unspecified = 394750507,
        Arm64 = 62547450,
        X8664 = 425300551,
    }
    impl Architecture {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Architecture::UndefinedArchitecture => "UNDEFINED_ARCHITECTURE",
                Architecture::Unspecified => "ARCHITECTURE_UNSPECIFIED",
                Architecture::Arm64 => "ARM64",
                Architecture::X8664 => "X86_64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ARCHITECTURE" => Some(Self::UndefinedArchitecture),
                "ARCHITECTURE_UNSPECIFIED" => Some(Self::Unspecified),
                "ARM64" => Some(Self::Arm64),
                "X86_64" => Some(Self::X8664),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SnapshotType {
        UndefinedSnapshotType = 0,
        Archive = 506752162,
        Standard = 484642493,
    }
    impl SnapshotType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SnapshotType::UndefinedSnapshotType => "UNDEFINED_SNAPSHOT_TYPE",
                SnapshotType::Archive => "ARCHIVE",
                SnapshotType::Standard => "STANDARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SNAPSHOT_TYPE" => Some(Self::UndefinedSnapshotType),
                "ARCHIVE" => Some(Self::Archive),
                "STANDARD" => Some(Self::Standard),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
        Uploading = 267603489,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Ready => "READY",
                Status::Uploading => "UPLOADING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                "UPLOADING" => Some(Self::Uploading),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StorageBytesStatus {
        UndefinedStorageBytesStatus = 0,
        Updating = 494614342,
        UpToDate = 101306702,
    }
    impl StorageBytesStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StorageBytesStatus::UndefinedStorageBytesStatus => {
                    "UNDEFINED_STORAGE_BYTES_STATUS"
                }
                StorageBytesStatus::Updating => "UPDATING",
                StorageBytesStatus::UpToDate => "UP_TO_DATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STORAGE_BYTES_STATUS" => {
                    Some(Self::UndefinedStorageBytesStatus)
                }
                "UPDATING" => Some(Self::Updating),
                "UP_TO_DATE" => Some(Self::UpToDate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Snapshot>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotSettings {
    #[prost(message, optional, tag = "460859641")]
    pub storage_location: ::core::option::Option<
        SnapshotSettingsStorageLocationSettings,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotSettingsStorageLocationSettings {
    #[prost(map = "string, message", tag = "413423454")]
    pub locations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SnapshotSettingsStorageLocationSettingsStorageLocationPreference,
    >,
    #[prost(string, optional, tag = "91071794")]
    pub policy: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SnapshotSettingsStorageLocationSettings`.
pub mod snapshot_settings_storage_location_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Policy {
        UndefinedPolicy = 0,
        LocalRegion = 403535464,
        NearestMultiRegion = 212467515,
        SpecificLocations = 280093809,
        StorageLocationPolicyUnspecified = 250644592,
    }
    impl Policy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Policy::UndefinedPolicy => "UNDEFINED_POLICY",
                Policy::LocalRegion => "LOCAL_REGION",
                Policy::NearestMultiRegion => "NEAREST_MULTI_REGION",
                Policy::SpecificLocations => "SPECIFIC_LOCATIONS",
                Policy::StorageLocationPolicyUnspecified => {
                    "STORAGE_LOCATION_POLICY_UNSPECIFIED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_POLICY" => Some(Self::UndefinedPolicy),
                "LOCAL_REGION" => Some(Self::LocalRegion),
                "NEAREST_MULTI_REGION" => Some(Self::NearestMultiRegion),
                "SPECIFIC_LOCATIONS" => Some(Self::SpecificLocations),
                "STORAGE_LOCATION_POLICY_UNSPECIFIED" => {
                    Some(Self::StorageLocationPolicyUnspecified)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SnapshotSettingsStorageLocationSettingsStorageLocationPreference {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceDiskEncryptionKey {
    #[prost(message, optional, tag = "271660677")]
    pub disk_encryption_key: ::core::option::Option<CustomerEncryptionKey>,
    #[prost(string, optional, tag = "451753793")]
    pub source_disk: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceInstanceParams {
    #[prost(message, repeated, tag = "235580623")]
    pub disk_configs: ::prost::alloc::vec::Vec<DiskInstantiationConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceInstanceProperties {
    #[prost(bool, optional, tag = "467731324")]
    pub can_ip_forward: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "458014698")]
    pub deletion_protection: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "95594102")]
    pub disks: ::prost::alloc::vec::Vec<SavedAttachedDisk>,
    #[prost(message, repeated, tag = "463595119")]
    pub guest_accelerators: ::prost::alloc::vec::Vec<AcceleratorConfig>,
    #[prost(string, optional, tag = "235941474")]
    pub key_revocation_action_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "227711026")]
    pub machine_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<Metadata>,
    #[prost(string, optional, tag = "242912759")]
    pub min_cpu_platform: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "52735243")]
    pub network_interfaces: ::prost::alloc::vec::Vec<NetworkInterface>,
    #[prost(message, optional, tag = "386688404")]
    pub scheduling: ::core::option::Option<Scheduling>,
    #[prost(message, repeated, tag = "277537328")]
    pub service_accounts: ::prost::alloc::vec::Vec<ServiceAccount>,
    #[prost(message, optional, tag = "3552281")]
    pub tags: ::core::option::Option<Tags>,
}
/// Nested message and enum types in `SourceInstanceProperties`.
pub mod source_instance_properties {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeyRevocationActionType {
        UndefinedKeyRevocationActionType = 0,
        Unspecified = 467110106,
        None = 2402104,
        Stop = 2555906,
    }
    impl KeyRevocationActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeyRevocationActionType::UndefinedKeyRevocationActionType => {
                    "UNDEFINED_KEY_REVOCATION_ACTION_TYPE"
                }
                KeyRevocationActionType::Unspecified => {
                    "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED"
                }
                KeyRevocationActionType::None => "NONE",
                KeyRevocationActionType::Stop => "STOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_KEY_REVOCATION_ACTION_TYPE" => {
                    Some(Self::UndefinedKeyRevocationActionType)
                }
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NONE" => Some(Self::None),
                "STOP" => Some(Self::Stop),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificate {
    #[prost(string, optional, tag = "341787031")]
    pub certificate: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "440691181")]
    pub expire_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "298389407")]
    pub managed: ::core::option::Option<SslCertificateManagedSslCertificate>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "361331107")]
    pub private_key: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "329284012")]
    pub self_managed: ::core::option::Option<SslCertificateSelfManagedSslCertificate>,
    #[prost(string, repeated, tag = "528807907")]
    pub subject_alternative_names: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SslCertificate`.
pub mod ssl_certificate {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Managed = 479501183,
        SelfManaged = 434437516,
        Unspecified = 437714322,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Managed => "MANAGED",
                Type::SelfManaged => "SELF_MANAGED",
                Type::Unspecified => "TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "MANAGED" => Some(Self::Managed),
                "SELF_MANAGED" => Some(Self::SelfManaged),
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificateAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SslCertificatesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificateList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<SslCertificate>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificateManagedSslCertificate {
    #[prost(map = "string, string", tag = "360305613")]
    pub domain_status: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "226935855")]
    pub domains: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SslCertificateManagedSslCertificate`.
pub mod ssl_certificate_managed_ssl_certificate {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Active = 314733318,
        ManagedCertificateStatusUnspecified = 474800850,
        Provisioning = 290896621,
        ProvisioningFailed = 76813775,
        ProvisioningFailedPermanently = 275036203,
        RenewalFailed = 434659076,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Active => "ACTIVE",
                Status::ManagedCertificateStatusUnspecified => {
                    "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED"
                }
                Status::Provisioning => "PROVISIONING",
                Status::ProvisioningFailed => "PROVISIONING_FAILED",
                Status::ProvisioningFailedPermanently => {
                    "PROVISIONING_FAILED_PERMANENTLY"
                }
                Status::RenewalFailed => "RENEWAL_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ACTIVE" => Some(Self::Active),
                "MANAGED_CERTIFICATE_STATUS_UNSPECIFIED" => {
                    Some(Self::ManagedCertificateStatusUnspecified)
                }
                "PROVISIONING" => Some(Self::Provisioning),
                "PROVISIONING_FAILED" => Some(Self::ProvisioningFailed),
                "PROVISIONING_FAILED_PERMANENTLY" => {
                    Some(Self::ProvisioningFailedPermanently)
                }
                "RENEWAL_FAILED" => Some(Self::RenewalFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificateSelfManagedSslCertificate {
    #[prost(string, optional, tag = "341787031")]
    pub certificate: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "361331107")]
    pub private_key: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslCertificatesScopedList {
    #[prost(message, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<SslCertificate>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPoliciesAggregatedList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SslPoliciesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPoliciesList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<SslPolicy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPoliciesListAvailableFeaturesResponse {
    #[prost(string, repeated, tag = "246211645")]
    pub features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPoliciesScopedList {
    #[prost(message, repeated, tag = "209941027")]
    pub ssl_policies: ::prost::alloc::vec::Vec<SslPolicy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPolicy {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "34789707")]
    pub custom_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "469017467")]
    pub enabled_features: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8155943")]
    pub min_tls_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "227445161")]
    pub profile: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "498091095")]
    pub warnings: ::prost::alloc::vec::Vec<Warnings>,
}
/// Nested message and enum types in `SslPolicy`.
pub mod ssl_policy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinTlsVersion {
        UndefinedMinTlsVersion = 0,
        Tls10 = 33116734,
        Tls11 = 33116735,
        Tls12 = 33116736,
    }
    impl MinTlsVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinTlsVersion::UndefinedMinTlsVersion => "UNDEFINED_MIN_TLS_VERSION",
                MinTlsVersion::Tls10 => "TLS_1_0",
                MinTlsVersion::Tls11 => "TLS_1_1",
                MinTlsVersion::Tls12 => "TLS_1_2",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MIN_TLS_VERSION" => Some(Self::UndefinedMinTlsVersion),
                "TLS_1_0" => Some(Self::Tls10),
                "TLS_1_1" => Some(Self::Tls11),
                "TLS_1_2" => Some(Self::Tls12),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Profile {
        UndefinedProfile = 0,
        Compatible = 179357396,
        Custom = 388595569,
        Modern = 132013855,
        Restricted = 261551195,
    }
    impl Profile {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Profile::UndefinedProfile => "UNDEFINED_PROFILE",
                Profile::Compatible => "COMPATIBLE",
                Profile::Custom => "CUSTOM",
                Profile::Modern => "MODERN",
                Profile::Restricted => "RESTRICTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROFILE" => Some(Self::UndefinedProfile),
                "COMPATIBLE" => Some(Self::Compatible),
                "CUSTOM" => Some(Self::Custom),
                "MODERN" => Some(Self::Modern),
                "RESTRICTED" => Some(Self::Restricted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SslPolicyReference {
    #[prost(string, optional, tag = "295190213")]
    pub ssl_policy: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartAsyncReplicationDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "470814554")]
    pub disks_start_async_replication_request_resource: ::core::option::Option<
        DisksStartAsyncReplicationRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartAsyncReplicationRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "474326021")]
    pub region_disks_start_async_replication_request_resource: ::core::option::Option<
        RegionDisksStartAsyncReplicationRequest,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWithEncryptionKeyInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "441712511")]
    pub instances_start_with_encryption_key_request_resource: ::core::option::Option<
        InstancesStartWithEncryptionKeyRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulPolicy {
    #[prost(message, optional, tag = "2634026")]
    pub preserved_state: ::core::option::Option<StatefulPolicyPreservedState>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulPolicyPreservedState {
    #[prost(map = "string, message", tag = "95594102")]
    pub disks: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StatefulPolicyPreservedStateDiskDevice,
    >,
    #[prost(map = "string, message", tag = "532687245")]
    pub external_i_ps: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StatefulPolicyPreservedStateNetworkIp,
    >,
    #[prost(map = "string, message", tag = "215731675")]
    pub internal_i_ps: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StatefulPolicyPreservedStateNetworkIp,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulPolicyPreservedStateDiskDevice {
    #[prost(string, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StatefulPolicyPreservedStateDiskDevice`.
pub mod stateful_policy_preserved_state_disk_device {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoDelete {
        UndefinedAutoDelete = 0,
        Never = 74175084,
        OnPermanentInstanceDeletion = 95727719,
    }
    impl AutoDelete {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoDelete::UndefinedAutoDelete => "UNDEFINED_AUTO_DELETE",
                AutoDelete::Never => "NEVER",
                AutoDelete::OnPermanentInstanceDeletion => {
                    "ON_PERMANENT_INSTANCE_DELETION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AUTO_DELETE" => Some(Self::UndefinedAutoDelete),
                "NEVER" => Some(Self::Never),
                "ON_PERMANENT_INSTANCE_DELETION" => {
                    Some(Self::OnPermanentInstanceDeletion)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatefulPolicyPreservedStateNetworkIp {
    #[prost(string, optional, tag = "464761403")]
    pub auto_delete: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StatefulPolicyPreservedStateNetworkIp`.
pub mod stateful_policy_preserved_state_network_ip {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AutoDelete {
        UndefinedAutoDelete = 0,
        Never = 74175084,
        OnPermanentInstanceDeletion = 95727719,
    }
    impl AutoDelete {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AutoDelete::UndefinedAutoDelete => "UNDEFINED_AUTO_DELETE",
                AutoDelete::Never => "NEVER",
                AutoDelete::OnPermanentInstanceDeletion => {
                    "ON_PERMANENT_INSTANCE_DELETION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AUTO_DELETE" => Some(Self::UndefinedAutoDelete),
                "NEVER" => Some(Self::Never),
                "ON_PERMANENT_INSTANCE_DELETION" => {
                    Some(Self::OnPermanentInstanceDeletion)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Status {
    #[prost(int32, optional, tag = "3059181")]
    pub code: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "483979842")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopAsyncReplicationDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopAsyncReplicationRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopGroupAsyncReplicationDiskRequest {
    #[prost(message, optional, tag = "346815509")]
    pub disks_stop_group_async_replication_resource_resource: ::core::option::Option<
        DisksStopGroupAsyncReplicationResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopGroupAsyncReplicationRegionDiskRequest {
    #[prost(message, optional, tag = "346815509")]
    pub disks_stop_group_async_replication_resource_resource: ::core::option::Option<
        DisksStopGroupAsyncReplicationResource,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopInstanceRequest {
    #[prost(bool, optional, tag = "319517903")]
    pub discard_local_ssd: ::core::option::Option<bool>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePool {
    #[prost(string, optional, tag = "251610375")]
    pub capacity_provisioning_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "468553469")]
    pub performance_provisioning_type: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(int64, optional, tag = "478537682")]
    pub pool_provisioned_capacity_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "112092311")]
    pub pool_provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "169215640")]
    pub pool_provisioned_throughput: ::core::option::Option<i64>,
    #[prost(message, optional, tag = "249429315")]
    pub resource_status: ::core::option::Option<StoragePoolResourceStatus>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "181260274")]
    pub status: ::core::option::Option<StoragePoolResourceStatus>,
    #[prost(string, optional, tag = "285999289")]
    pub storage_pool_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `StoragePool`.
pub mod storage_pool {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CapacityProvisioningType {
        UndefinedCapacityProvisioningType = 0,
    }
    impl CapacityProvisioningType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CapacityProvisioningType::UndefinedCapacityProvisioningType => {
                    "UNDEFINED_CAPACITY_PROVISIONING_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CAPACITY_PROVISIONING_TYPE" => {
                    Some(Self::UndefinedCapacityProvisioningType)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PerformanceProvisioningType {
        UndefinedPerformanceProvisioningType = 0,
    }
    impl PerformanceProvisioningType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PerformanceProvisioningType::UndefinedPerformanceProvisioningType => {
                    "UNDEFINED_PERFORMANCE_PROVISIONING_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PERFORMANCE_PROVISIONING_TYPE" => {
                    Some(Self::UndefinedPerformanceProvisioningType)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Creating => "CREATING",
                State::Deleting => "DELETING",
                State::Failed => "FAILED",
                State::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolAggregatedList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StoragePoolsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolDisk {
    #[prost(string, repeated, tag = "65255843")]
    pub attached_instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3083677")]
    pub disk: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "186769108")]
    pub provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "526524181")]
    pub provisioned_throughput: ::core::option::Option<i64>,
    #[prost(string, repeated, tag = "22220385")]
    pub resource_policies: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "494929369")]
    pub size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "231640425")]
    pub used_bytes: ::core::option::Option<i64>,
}
/// Nested message and enum types in `StoragePoolDisk`.
pub mod storage_pool_disk {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
        Restoring = 404263851,
        Unavailable = 413756464,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Ready => "READY",
                Status::Restoring => "RESTORING",
                Status::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                "RESTORING" => Some(Self::Restoring),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolList {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<StoragePool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolListDisks {
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<StoragePoolDisk>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolResourceStatus {
    #[prost(int64, optional, tag = "182933485")]
    pub disk_count: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "500825556")]
    pub last_resize_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "165818207")]
    pub max_total_provisioned_disk_capacity_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "510407877")]
    pub pool_used_capacity_bytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "99558536")]
    pub pool_used_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "206130633")]
    pub pool_used_throughput: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "228964050")]
    pub pool_user_written_bytes: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "520930980")]
    pub total_provisioned_disk_capacity_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "32812549")]
    pub total_provisioned_disk_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "447677830")]
    pub total_provisioned_disk_throughput: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolType {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int64, optional, tag = "182139085")]
    pub max_pool_provisioned_capacity_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "515270652")]
    pub max_pool_provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "228928061")]
    pub max_pool_provisioned_throughput: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "191022751")]
    pub min_pool_provisioned_capacity_gb: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "416473706")]
    pub min_pool_provisioned_iops: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "367761963")]
    pub min_pool_provisioned_throughput: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "385278188")]
    pub min_size_gb: ::core::option::Option<i64>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "150587272")]
    pub supported_disk_types: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolTypeAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        StoragePoolTypesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolTypeList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<StoragePoolType>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolTypesScopedList {
    #[prost(message, repeated, tag = "276043482")]
    pub storage_pool_types: ::prost::alloc::vec::Vec<StoragePoolType>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StoragePoolsScopedList {
    #[prost(message, repeated, tag = "437258515")]
    pub storage_pools: ::prost::alloc::vec::Vec<StoragePool>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subnetwork {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "151544420")]
    pub enable_flow_logs: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "139299190")]
    pub external_ipv6_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "459867385")]
    pub gateway_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "506270056")]
    pub internal_ipv6_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "504658653")]
    pub ipv6_access_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "273141258")]
    pub ipv6_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "351299741")]
    pub log_config: ::core::option::Option<SubnetworkLogConfig>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "421491790")]
    pub private_ip_google_access: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "48277006")]
    pub private_ipv6_google_access: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "316407070")]
    pub purpose: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "286248754")]
    pub reserved_internal_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3506294")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "136658915")]
    pub secondary_ip_ranges: ::prost::alloc::vec::Vec<SubnetworkSecondaryRange>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Subnetwork`.
pub mod subnetwork {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Ipv6AccessType {
        UndefinedIpv6AccessType = 0,
        External = 35607499,
        Internal = 279295677,
        UnspecifiedIpv6AccessType = 313080613,
    }
    impl Ipv6AccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Ipv6AccessType::UndefinedIpv6AccessType => "UNDEFINED_IPV6_ACCESS_TYPE",
                Ipv6AccessType::External => "EXTERNAL",
                Ipv6AccessType::Internal => "INTERNAL",
                Ipv6AccessType::UnspecifiedIpv6AccessType => {
                    "UNSPECIFIED_IPV6_ACCESS_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IPV6_ACCESS_TYPE" => Some(Self::UndefinedIpv6AccessType),
                "EXTERNAL" => Some(Self::External),
                "INTERNAL" => Some(Self::Internal),
                "UNSPECIFIED_IPV6_ACCESS_TYPE" => Some(Self::UnspecifiedIpv6AccessType),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PrivateIpv6GoogleAccess {
        UndefinedPrivateIpv6GoogleAccess = 0,
        DisableGoogleAccess = 450958579,
        EnableBidirectionalAccessToGoogle = 427975994,
        EnableOutboundVmAccessToGoogle = 288210263,
    }
    impl PrivateIpv6GoogleAccess {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PrivateIpv6GoogleAccess::UndefinedPrivateIpv6GoogleAccess => {
                    "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS"
                }
                PrivateIpv6GoogleAccess::DisableGoogleAccess => "DISABLE_GOOGLE_ACCESS",
                PrivateIpv6GoogleAccess::EnableBidirectionalAccessToGoogle => {
                    "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE"
                }
                PrivateIpv6GoogleAccess::EnableOutboundVmAccessToGoogle => {
                    "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PRIVATE_IPV6_GOOGLE_ACCESS" => {
                    Some(Self::UndefinedPrivateIpv6GoogleAccess)
                }
                "DISABLE_GOOGLE_ACCESS" => Some(Self::DisableGoogleAccess),
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableBidirectionalAccessToGoogle)
                }
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => {
                    Some(Self::EnableOutboundVmAccessToGoogle)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Purpose {
        UndefinedPurpose = 0,
        GlobalManagedProxy = 236463602,
        InternalHttpsLoadBalancer = 248748889,
        Private = 403485027,
        PrivateNat = 367764517,
        PrivateRfc1918 = 254902107,
        PrivateServiceConnect = 48134724,
        RegionalManagedProxy = 153049966,
    }
    impl Purpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Purpose::UndefinedPurpose => "UNDEFINED_PURPOSE",
                Purpose::GlobalManagedProxy => "GLOBAL_MANAGED_PROXY",
                Purpose::InternalHttpsLoadBalancer => "INTERNAL_HTTPS_LOAD_BALANCER",
                Purpose::Private => "PRIVATE",
                Purpose::PrivateNat => "PRIVATE_NAT",
                Purpose::PrivateRfc1918 => "PRIVATE_RFC_1918",
                Purpose::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
                Purpose::RegionalManagedProxy => "REGIONAL_MANAGED_PROXY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PURPOSE" => Some(Self::UndefinedPurpose),
                "GLOBAL_MANAGED_PROXY" => Some(Self::GlobalManagedProxy),
                "INTERNAL_HTTPS_LOAD_BALANCER" => Some(Self::InternalHttpsLoadBalancer),
                "PRIVATE" => Some(Self::Private),
                "PRIVATE_NAT" => Some(Self::PrivateNat),
                "PRIVATE_RFC_1918" => Some(Self::PrivateRfc1918),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                "REGIONAL_MANAGED_PROXY" => Some(Self::RegionalManagedProxy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        UndefinedRole = 0,
        Active = 314733318,
        Backup = 341010882,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Role::UndefinedRole => "UNDEFINED_ROLE",
                Role::Active => "ACTIVE",
                Role::Backup => "BACKUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROLE" => Some(Self::UndefinedRole),
                "ACTIVE" => Some(Self::Active),
                "BACKUP" => Some(Self::Backup),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
        UnspecifiedStackType = 298084569,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
                StackType::UnspecifiedStackType => "UNSPECIFIED_STACK_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                "UNSPECIFIED_STACK_TYPE" => Some(Self::UnspecifiedStackType),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        Draining = 480455402,
        Ready = 77848963,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::Draining => "DRAINING",
                State::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "DRAINING" => Some(Self::Draining),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworkAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        SubnetworksScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworkList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Subnetwork>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworkLogConfig {
    #[prost(string, optional, tag = "174919042")]
    pub aggregation_interval: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "311764355")]
    pub enable: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "183374428")]
    pub filter_expr: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "530150360")]
    pub flow_sampling: ::core::option::Option<f32>,
    #[prost(string, optional, tag = "86866735")]
    pub metadata: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "378461641")]
    pub metadata_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `SubnetworkLogConfig`.
pub mod subnetwork_log_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AggregationInterval {
        UndefinedAggregationInterval = 0,
        Interval10Min = 487155916,
        Interval15Min = 491773521,
        Interval1Min = 69052714,
        Interval30Sec = 7548937,
        Interval5Min = 72746798,
        Interval5Sec = 72752429,
    }
    impl AggregationInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AggregationInterval::UndefinedAggregationInterval => {
                    "UNDEFINED_AGGREGATION_INTERVAL"
                }
                AggregationInterval::Interval10Min => "INTERVAL_10_MIN",
                AggregationInterval::Interval15Min => "INTERVAL_15_MIN",
                AggregationInterval::Interval1Min => "INTERVAL_1_MIN",
                AggregationInterval::Interval30Sec => "INTERVAL_30_SEC",
                AggregationInterval::Interval5Min => "INTERVAL_5_MIN",
                AggregationInterval::Interval5Sec => "INTERVAL_5_SEC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_AGGREGATION_INTERVAL" => {
                    Some(Self::UndefinedAggregationInterval)
                }
                "INTERVAL_10_MIN" => Some(Self::Interval10Min),
                "INTERVAL_15_MIN" => Some(Self::Interval15Min),
                "INTERVAL_1_MIN" => Some(Self::Interval1Min),
                "INTERVAL_30_SEC" => Some(Self::Interval30Sec),
                "INTERVAL_5_MIN" => Some(Self::Interval5Min),
                "INTERVAL_5_SEC" => Some(Self::Interval5Sec),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Metadata {
        UndefinedMetadata = 0,
        CustomMetadata = 62450749,
        ExcludeAllMetadata = 334519954,
        IncludeAllMetadata = 164619908,
    }
    impl Metadata {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Metadata::UndefinedMetadata => "UNDEFINED_METADATA",
                Metadata::CustomMetadata => "CUSTOM_METADATA",
                Metadata::ExcludeAllMetadata => "EXCLUDE_ALL_METADATA",
                Metadata::IncludeAllMetadata => "INCLUDE_ALL_METADATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_METADATA" => Some(Self::UndefinedMetadata),
                "CUSTOM_METADATA" => Some(Self::CustomMetadata),
                "EXCLUDE_ALL_METADATA" => Some(Self::ExcludeAllMetadata),
                "INCLUDE_ALL_METADATA" => Some(Self::IncludeAllMetadata),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworkSecondaryRange {
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "332216397")]
    pub range_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "286248754")]
    pub reserved_internal_range: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworksExpandIpCidrRangeRequest {
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubnetworksScopedList {
    #[prost(message, repeated, tag = "415853125")]
    pub subnetworks: ::prost::alloc::vec::Vec<Subnetwork>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubnetworksSetPrivateIpGoogleAccessRequest {
    #[prost(bool, optional, tag = "421491790")]
    pub private_ip_google_access: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subsetting {
    #[prost(string, optional, tag = "91071794")]
    pub policy: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Subsetting`.
pub mod subsetting {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Policy {
        UndefinedPolicy = 0,
        ConsistentHashSubsetting = 108989492,
        None = 2402104,
    }
    impl Policy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Policy::UndefinedPolicy => "UNDEFINED_POLICY",
                Policy::ConsistentHashSubsetting => "CONSISTENT_HASH_SUBSETTING",
                Policy::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_POLICY" => Some(Self::UndefinedPolicy),
                "CONSISTENT_HASH_SUBSETTING" => Some(Self::ConsistentHashSubsetting),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendInstanceRequest {
    #[prost(bool, optional, tag = "319517903")]
    pub discard_local_ssd: ::core::option::Option<bool>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SwitchToCustomModeNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TcpHealthCheck {
    #[prost(int32, optional, tag = "3446913")]
    pub port: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "41534345")]
    pub port_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "51590597")]
    pub port_specification: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "21951119")]
    pub request: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "196547649")]
    pub response: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TCPHealthCheck`.
pub mod tcp_health_check {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PortSpecification {
        UndefinedPortSpecification = 0,
        UseFixedPort = 190235748,
        UseNamedPort = 349300671,
        UseServingPort = 362637516,
    }
    impl PortSpecification {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PortSpecification::UndefinedPortSpecification => {
                    "UNDEFINED_PORT_SPECIFICATION"
                }
                PortSpecification::UseFixedPort => "USE_FIXED_PORT",
                PortSpecification::UseNamedPort => "USE_NAMED_PORT",
                PortSpecification::UseServingPort => "USE_SERVING_PORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PORT_SPECIFICATION" => Some(Self::UndefinedPortSpecification),
                "USE_FIXED_PORT" => Some(Self::UseFixedPort),
                "USE_NAMED_PORT" => Some(Self::UseNamedPort),
                "USE_SERVING_PORT" => Some(Self::UseServingPort),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tags {
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetGrpcProxy {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44520962")]
    pub self_link_with_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "367020684")]
    pub url_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "101822888")]
    pub validate_for_proxyless: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetGrpcProxyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetGrpcProxy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpProxiesScopedList {
    #[prost(message, repeated, tag = "162147011")]
    pub target_http_proxies: ::prost::alloc::vec::Vec<TargetHttpProxy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpProxy {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "447326046")]
    pub http_keep_alive_timeout_sec: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "286025582")]
    pub proxy_bind: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "367020684")]
    pub url_map: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpProxyAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetHttpProxiesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpProxyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetHttpProxy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxiesScopedList {
    #[prost(message, repeated, tag = "366607882")]
    pub target_https_proxies: ::prost::alloc::vec::Vec<TargetHttpsProxy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxiesSetCertificateMapRequest {
    #[prost(string, optional, tag = "156463796")]
    pub certificate_map: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxiesSetQuicOverrideRequest {
    #[prost(string, optional, tag = "456577197")]
    pub quic_override: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetHttpsProxiesSetQuicOverrideRequest`.
pub mod target_https_proxies_set_quic_override_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuicOverride {
        UndefinedQuicOverride = 0,
        Disable = 241807048,
        Enable = 438835587,
        None = 2402104,
    }
    impl QuicOverride {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuicOverride::UndefinedQuicOverride => "UNDEFINED_QUIC_OVERRIDE",
                QuicOverride::Disable => "DISABLE",
                QuicOverride::Enable => "ENABLE",
                QuicOverride::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_QUIC_OVERRIDE" => Some(Self::UndefinedQuicOverride),
                "DISABLE" => Some(Self::Disable),
                "ENABLE" => Some(Self::Enable),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxiesSetSslCertificatesRequest {
    #[prost(string, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxy {
    #[prost(string, optional, tag = "33945528")]
    pub authorization_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "156463796")]
    pub certificate_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "447326046")]
    pub http_keep_alive_timeout_sec: ::core::option::Option<i32>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "286025582")]
    pub proxy_bind: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "456577197")]
    pub quic_override: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "295825266")]
    pub server_tls_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "295190213")]
    pub ssl_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "367020684")]
    pub url_map: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetHttpsProxy`.
pub mod target_https_proxy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuicOverride {
        UndefinedQuicOverride = 0,
        Disable = 241807048,
        Enable = 438835587,
        None = 2402104,
    }
    impl QuicOverride {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuicOverride::UndefinedQuicOverride => "UNDEFINED_QUIC_OVERRIDE",
                QuicOverride::Disable => "DISABLE",
                QuicOverride::Enable => "ENABLE",
                QuicOverride::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_QUIC_OVERRIDE" => Some(Self::UndefinedQuicOverride),
                "DISABLE" => Some(Self::Disable),
                "ENABLE" => Some(Self::Enable),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxyAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetHttpsProxiesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetHttpsProxyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetHttpsProxy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetInstance {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "18257045")]
    pub instance: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "509780496")]
    pub nat_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3744684")]
    pub zone: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetInstance`.
pub mod target_instance {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NatPolicy {
        UndefinedNatPolicy = 0,
        NoNat = 161455491,
    }
    impl NatPolicy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NatPolicy::UndefinedNatPolicy => "UNDEFINED_NAT_POLICY",
                NatPolicy::NoNat => "NO_NAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_NAT_POLICY" => Some(Self::UndefinedNatPolicy),
                "NO_NAT" => Some(Self::NoNat),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetInstanceAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetInstancesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetInstanceList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetInstance>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetInstancesScopedList {
    #[prost(message, repeated, tag = "392915280")]
    pub target_instances: ::prost::alloc::vec::Vec<TargetInstance>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPool {
    #[prost(string, optional, tag = "45884537")]
    pub backup_pool: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(float, optional, tag = "212667006")]
    pub failover_ratio: ::core::option::Option<f32>,
    #[prost(string, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "171082513")]
    pub security_policy: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "463888561")]
    pub session_affinity: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetPool`.
pub mod target_pool {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SessionAffinity {
        UndefinedSessionAffinity = 0,
        ClientIp = 345665051,
        ClientIpNoDestination = 106122516,
        ClientIpPortProto = 221722926,
        ClientIpProto = 25322148,
        GeneratedCookie = 370321204,
        HeaderField = 200737960,
        HttpCookie = 494981627,
        None = 2402104,
    }
    impl SessionAffinity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SessionAffinity::UndefinedSessionAffinity => "UNDEFINED_SESSION_AFFINITY",
                SessionAffinity::ClientIp => "CLIENT_IP",
                SessionAffinity::ClientIpNoDestination => "CLIENT_IP_NO_DESTINATION",
                SessionAffinity::ClientIpPortProto => "CLIENT_IP_PORT_PROTO",
                SessionAffinity::ClientIpProto => "CLIENT_IP_PROTO",
                SessionAffinity::GeneratedCookie => "GENERATED_COOKIE",
                SessionAffinity::HeaderField => "HEADER_FIELD",
                SessionAffinity::HttpCookie => "HTTP_COOKIE",
                SessionAffinity::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_SESSION_AFFINITY" => Some(Self::UndefinedSessionAffinity),
                "CLIENT_IP" => Some(Self::ClientIp),
                "CLIENT_IP_NO_DESTINATION" => Some(Self::ClientIpNoDestination),
                "CLIENT_IP_PORT_PROTO" => Some(Self::ClientIpPortProto),
                "CLIENT_IP_PROTO" => Some(Self::ClientIpProto),
                "GENERATED_COOKIE" => Some(Self::GeneratedCookie),
                "HEADER_FIELD" => Some(Self::HeaderField),
                "HTTP_COOKIE" => Some(Self::HttpCookie),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetPoolsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolInstanceHealth {
    #[prost(message, repeated, tag = "380545845")]
    pub health_status: ::prost::alloc::vec::Vec<HealthStatus>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetPool>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolsAddHealthCheckRequest {
    #[prost(message, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<HealthCheckReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolsAddInstanceRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<InstanceReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolsRemoveHealthCheckRequest {
    #[prost(message, repeated, tag = "448370606")]
    pub health_checks: ::prost::alloc::vec::Vec<HealthCheckReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolsRemoveInstanceRequest {
    #[prost(message, repeated, tag = "29097598")]
    pub instances: ::prost::alloc::vec::Vec<InstanceReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPoolsScopedList {
    #[prost(message, repeated, tag = "336072617")]
    pub target_pools: ::prost::alloc::vec::Vec<TargetPool>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetReference {
    #[prost(string, optional, tag = "192835985")]
    pub target: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxiesSetBackendServiceRequest {
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxiesSetCertificateMapRequest {
    #[prost(string, optional, tag = "156463796")]
    pub certificate_map: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxiesSetProxyHeaderRequest {
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetSslProxiesSetProxyHeaderRequest`.
pub mod target_ssl_proxies_set_proxy_header_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxiesSetSslCertificatesRequest {
    #[prost(string, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxy {
    #[prost(string, optional, tag = "156463796")]
    pub certificate_map: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "366006543")]
    pub ssl_certificates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "295190213")]
    pub ssl_policy: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetSslProxy`.
pub mod target_ssl_proxy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetSslProxyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetSslProxy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxiesScopedList {
    #[prost(message, repeated, tag = "262056832")]
    pub target_tcp_proxies: ::prost::alloc::vec::Vec<TargetTcpProxy>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxiesSetBackendServiceRequest {
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxiesSetProxyHeaderRequest {
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetTcpProxiesSetProxyHeaderRequest`.
pub mod target_tcp_proxies_set_proxy_header_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxy {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "286025582")]
    pub proxy_bind: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "160374142")]
    pub proxy_header: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetTcpProxy`.
pub mod target_tcp_proxy {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProxyHeader {
        UndefinedProxyHeader = 0,
        None = 2402104,
        ProxyV1 = 334352940,
    }
    impl ProxyHeader {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProxyHeader::UndefinedProxyHeader => "UNDEFINED_PROXY_HEADER",
                ProxyHeader::None => "NONE",
                ProxyHeader::ProxyV1 => "PROXY_V1",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PROXY_HEADER" => Some(Self::UndefinedProxyHeader),
                "NONE" => Some(Self::None),
                "PROXY_V1" => Some(Self::ProxyV1),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxyAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetTcpProxiesScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetTcpProxyList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetTcpProxy>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetVpnGateway {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "315821365")]
    pub forwarding_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "104561931")]
    pub tunnels: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `TargetVpnGateway`.
pub mod target_vpn_gateway {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Creating = 455564985,
        Deleting = 528602024,
        Failed = 455706685,
        Ready = 77848963,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Creating => "CREATING",
                Status::Deleting => "DELETING",
                Status::Failed => "FAILED",
                Status::Ready => "READY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "CREATING" => Some(Self::Creating),
                "DELETING" => Some(Self::Deleting),
                "FAILED" => Some(Self::Failed),
                "READY" => Some(Self::Ready),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetVpnGatewayAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        TargetVpnGatewaysScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetVpnGatewayList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<TargetVpnGateway>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetVpnGatewaysScopedList {
    #[prost(message, repeated, tag = "401770888")]
    pub target_vpn_gateways: ::prost::alloc::vec::Vec<TargetVpnGateway>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestFailure {
    #[prost(string, optional, tag = "287075458")]
    pub actual_output_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "42926553")]
    pub actual_redirect_response_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "440379652")]
    pub actual_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "433967384")]
    pub expected_output_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "18888047")]
    pub expected_redirect_response_code: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "133987374")]
    pub expected_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "258436998")]
    pub headers: ::prost::alloc::vec::Vec<UrlMapTestHeader>,
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3433509")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsBackendBucketRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsBackendServiceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsExternalVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsFirewallPolicyRequest {
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsImageRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsInstanceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsInstanceTemplateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsLicenseCodeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsLicenseRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsMachineImageRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsNetworkAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsNetworkEndpointGroupRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsNetworkFirewallPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsNodeGroupRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsNodeTemplateRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsPacketMirroringRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsRegionBackendServiceRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsRegionDiskRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsRegionInstantSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsRegionNetworkFirewallPolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsReservationRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsResourcePolicyRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsServiceAttachmentRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsSnapshotRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsSubnetworkRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestIamPermissionsVpnGatewayRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, tag = "195806222")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "439214758")]
    pub test_permissions_request_resource: ::core::option::Option<
        TestPermissionsRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPermissionsRequest {
    #[prost(string, repeated, tag = "59962500")]
    pub permissions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TestPermissionsResponse {
    #[prost(string, repeated, tag = "59962500")]
    pub permissions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Uint128 {
    #[prost(uint64, optional, tag = "3202466")]
    pub high: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "107348")]
    pub low: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpcomingMaintenance {
    #[prost(bool, optional, tag = "95981977")]
    pub can_reschedule: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "128032129")]
    pub latest_window_start_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "81645214")]
    pub maintenance_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "271816480")]
    pub window_end_time: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "473061433")]
    pub window_start_time: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UpcomingMaintenance`.
pub mod upcoming_maintenance {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MaintenanceStatus {
        UndefinedMaintenanceStatus = 0,
        Ongoing = 473158491,
        Pending = 35394935,
        Unknown = 433141802,
    }
    impl MaintenanceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MaintenanceStatus::UndefinedMaintenanceStatus => {
                    "UNDEFINED_MAINTENANCE_STATUS"
                }
                MaintenanceStatus::Ongoing => "ONGOING",
                MaintenanceStatus::Pending => "PENDING",
                MaintenanceStatus::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MAINTENANCE_STATUS" => Some(Self::UndefinedMaintenanceStatus),
                "ONGOING" => Some(Self::Ongoing),
                "PENDING" => Some(Self::Pending),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Scheduled = 478400653,
        UnknownType = 490705455,
        Unscheduled = 450077204,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Scheduled => "SCHEDULED",
                Type::UnknownType => "UNKNOWN_TYPE",
                Type::Unscheduled => "UNSCHEDULED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "SCHEDULED" => Some(Self::Scheduled),
                "UNKNOWN_TYPE" => Some(Self::UnknownType),
                "UNSCHEDULED" => Some(Self::Unscheduled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccessConfigInstanceRequest {
    #[prost(message, optional, tag = "387825552")]
    pub access_config_resource: ::core::option::Option<AccessConfig>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "365387880")]
    pub network_interface: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAutoscalerRequest {
    #[prost(string, optional, tag = "517258967")]
    pub autoscaler: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackendBucketRequest {
    #[prost(string, tag = "91714037")]
    pub backend_bucket: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "380757784")]
    pub backend_bucket_resource: ::core::option::Option<BackendBucket>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "25880688")]
    pub disk_resource: ::core::option::Option<Disk>,
    #[prost(string, optional, tag = "106438894")]
    pub paths: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDisplayDeviceInstanceRequest {
    #[prost(message, optional, tag = "289686106")]
    pub display_device_resource: ::core::option::Option<DisplayDevice>,
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateFirewallRequest {
    #[prost(string, tag = "511016192")]
    pub firewall: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "41425005")]
    pub firewall_resource: ::core::option::Option<Firewall>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "215988344")]
    pub instance_resource: ::core::option::Option<Instance>,
    #[prost(string, optional, tag = "270567060")]
    pub minimal_action: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "66103053")]
    pub most_disruptive_allowed_action: ::core::option::Option<
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
/// Nested message and enum types in `UpdateInstanceRequest`.
pub mod update_instance_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinimalAction {
        UndefinedMinimalAction = 0,
    }
    impl MinimalAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinimalAction::UndefinedMinimalAction => "UNDEFINED_MINIMAL_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MINIMAL_ACTION" => Some(Self::UndefinedMinimalAction),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MostDisruptiveAllowedAction {
        UndefinedMostDisruptiveAllowedAction = 0,
    }
    impl MostDisruptiveAllowedAction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MostDisruptiveAllowedAction::UndefinedMostDisruptiveAllowedAction => {
                    "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_MOST_DISRUPTIVE_ALLOWED_ACTION" => {
                    Some(Self::UndefinedMostDisruptiveAllowedAction)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateNetworkInterfaceInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "365387880")]
    pub network_interface: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "325814789")]
    pub network_interface_resource: ::core::option::Option<NetworkInterface>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePeeringNetworkRequest {
    #[prost(string, tag = "232872494")]
    pub network: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "224433497")]
    pub networks_update_peering_request_resource: ::core::option::Option<
        NetworksUpdatePeeringRequest,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePerInstanceConfigsInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "141402302")]
    pub instance_group_managers_update_per_instance_configs_req_resource: ::core::option::Option<
        InstanceGroupManagersUpdatePerInstanceConfigsReq,
    >,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest {
    #[prost(string, tag = "249363395")]
    pub instance_group_manager: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "89036583")]
    pub region_instance_group_manager_update_instance_config_req_resource: ::core::option::Option<
        RegionInstanceGroupManagerUpdateInstanceConfigReq,
    >,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionAutoscalerRequest {
    #[prost(string, optional, tag = "517258967")]
    pub autoscaler: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "207616118")]
    pub autoscaler_resource: ::core::option::Option<Autoscaler>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionBackendServiceRequest {
    #[prost(string, tag = "306946058")]
    pub backend_service: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "347586723")]
    pub backend_service_resource: ::core::option::Option<BackendService>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionCommitmentRequest {
    #[prost(string, tag = "482134805")]
    pub commitment: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "244240888")]
    pub commitment_resource: ::core::option::Option<Commitment>,
    #[prost(string, optional, tag = "106438894")]
    pub paths: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionDiskRequest {
    #[prost(string, tag = "3083677")]
    pub disk: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "25880688")]
    pub disk_resource: ::core::option::Option<Disk>,
    #[prost(string, optional, tag = "106438894")]
    pub paths: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionHealthCheckRequest {
    #[prost(string, tag = "308876645")]
    pub health_check: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "201925032")]
    pub health_check_resource: ::core::option::Option<HealthCheck>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReservationRequest {
    #[prost(string, optional, tag = "106438894")]
    pub paths: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "47530956")]
    pub reservation: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "285030177")]
    pub reservation_resource: ::core::option::Option<Reservation>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRouterRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "148608841")]
    pub router: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "155222084")]
    pub router_resource: ::core::option::Option<Router>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateShieldedInstanceConfigInstanceRequest {
    #[prost(string, tag = "18257045")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "272059224")]
    pub shielded_instance_config_resource: ::core::option::Option<
        ShieldedInstanceConfig,
    >,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateStoragePoolRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "360473440")]
    pub storage_pool: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "157179405")]
    pub storage_pool_resource: ::core::option::Option<StoragePool>,
    #[prost(string, optional, tag = "500079778")]
    pub update_mask: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "168675425")]
    pub url_map_resource: ::core::option::Option<UrlMap>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMap {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "378919466")]
    pub default_route_action: ::core::option::Option<HttpRouteAction>,
    #[prost(string, optional, tag = "370242231")]
    pub default_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "359503338")]
    pub default_url_redirect: ::core::option::Option<HttpRedirectAction>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "234678500")]
    pub fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328077352")]
    pub header_action: ::core::option::Option<HttpHeaderAction>,
    #[prost(message, repeated, tag = "311804832")]
    pub host_rules: ::prost::alloc::vec::Vec<HostRule>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "271664219")]
    pub path_matchers: ::prost::alloc::vec::Vec<PathMatcher>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "110251553")]
    pub tests: ::prost::alloc::vec::Vec<UrlMapTest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<UrlMap>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapReference {
    #[prost(string, optional, tag = "367020684")]
    pub url_map: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapTest {
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "433967384")]
    pub expected_output_url: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "18888047")]
    pub expected_redirect_response_code: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "258436998")]
    pub headers: ::prost::alloc::vec::Vec<UrlMapTestHeader>,
    #[prost(string, optional, tag = "3208616")]
    pub host: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3433509")]
    pub path: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "373540533")]
    pub service: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapTestHeader {
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "111972721")]
    pub value: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapValidationResult {
    #[prost(string, repeated, tag = "310147300")]
    pub load_errors: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "128326216")]
    pub load_succeeded: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "505934134")]
    pub test_failures: ::prost::alloc::vec::Vec<TestFailure>,
    #[prost(bool, optional, tag = "192708797")]
    pub test_passed: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapsAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        UrlMapsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapsScopedList {
    #[prost(message, repeated, tag = "103352167")]
    pub url_maps: ::prost::alloc::vec::Vec<UrlMap>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapsValidateRequest {
    #[prost(string, repeated, tag = "6308527")]
    pub load_balancing_schemes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "195806222")]
    pub resource: ::core::option::Option<UrlMap>,
}
/// Nested message and enum types in `UrlMapsValidateRequest`.
pub mod url_maps_validate_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancingSchemes {
        UndefinedLoadBalancingSchemes = 0,
        External = 35607499,
        ExternalManaged = 512006923,
        LoadBalancingSchemeUnspecified = 526507452,
    }
    impl LoadBalancingSchemes {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LoadBalancingSchemes::UndefinedLoadBalancingSchemes => {
                    "UNDEFINED_LOAD_BALANCING_SCHEMES"
                }
                LoadBalancingSchemes::External => "EXTERNAL",
                LoadBalancingSchemes::ExternalManaged => "EXTERNAL_MANAGED",
                LoadBalancingSchemes::LoadBalancingSchemeUnspecified => {
                    "LOAD_BALANCING_SCHEME_UNSPECIFIED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_LOAD_BALANCING_SCHEMES" => {
                    Some(Self::UndefinedLoadBalancingSchemes)
                }
                "EXTERNAL" => Some(Self::External),
                "EXTERNAL_MANAGED" => Some(Self::ExternalManaged),
                "LOAD_BALANCING_SCHEME_UNSPECIFIED" => {
                    Some(Self::LoadBalancingSchemeUnspecified)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlMapsValidateResponse {
    #[prost(message, optional, tag = "139315229")]
    pub result: ::core::option::Option<UrlMapValidationResult>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UrlRewrite {
    #[prost(string, optional, tag = "159819253")]
    pub host_rewrite: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41186361")]
    pub path_prefix_rewrite: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "423409569")]
    pub path_template_rewrite: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsableSubnetwork {
    #[prost(string, optional, tag = "139299190")]
    pub external_ipv6_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "506270056")]
    pub internal_ipv6_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "504658653")]
    pub ipv6_access_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "316407070")]
    pub purpose: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3506294")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "136658915")]
    pub secondary_ip_ranges: ::prost::alloc::vec::Vec<UsableSubnetworkSecondaryRange>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "307827694")]
    pub subnetwork: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UsableSubnetwork`.
pub mod usable_subnetwork {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Ipv6AccessType {
        UndefinedIpv6AccessType = 0,
        External = 35607499,
        Internal = 279295677,
    }
    impl Ipv6AccessType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Ipv6AccessType::UndefinedIpv6AccessType => "UNDEFINED_IPV6_ACCESS_TYPE",
                Ipv6AccessType::External => "EXTERNAL",
                Ipv6AccessType::Internal => "INTERNAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_IPV6_ACCESS_TYPE" => Some(Self::UndefinedIpv6AccessType),
                "EXTERNAL" => Some(Self::External),
                "INTERNAL" => Some(Self::Internal),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Purpose {
        UndefinedPurpose = 0,
        GlobalManagedProxy = 236463602,
        InternalHttpsLoadBalancer = 248748889,
        Private = 403485027,
        PrivateNat = 367764517,
        PrivateRfc1918 = 254902107,
        PrivateServiceConnect = 48134724,
        RegionalManagedProxy = 153049966,
    }
    impl Purpose {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Purpose::UndefinedPurpose => "UNDEFINED_PURPOSE",
                Purpose::GlobalManagedProxy => "GLOBAL_MANAGED_PROXY",
                Purpose::InternalHttpsLoadBalancer => "INTERNAL_HTTPS_LOAD_BALANCER",
                Purpose::Private => "PRIVATE",
                Purpose::PrivateNat => "PRIVATE_NAT",
                Purpose::PrivateRfc1918 => "PRIVATE_RFC_1918",
                Purpose::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
                Purpose::RegionalManagedProxy => "REGIONAL_MANAGED_PROXY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_PURPOSE" => Some(Self::UndefinedPurpose),
                "GLOBAL_MANAGED_PROXY" => Some(Self::GlobalManagedProxy),
                "INTERNAL_HTTPS_LOAD_BALANCER" => Some(Self::InternalHttpsLoadBalancer),
                "PRIVATE" => Some(Self::Private),
                "PRIVATE_NAT" => Some(Self::PrivateNat),
                "PRIVATE_RFC_1918" => Some(Self::PrivateRfc1918),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                "REGIONAL_MANAGED_PROXY" => Some(Self::RegionalManagedProxy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Role {
        UndefinedRole = 0,
        Active = 314733318,
        Backup = 341010882,
    }
    impl Role {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Role::UndefinedRole => "UNDEFINED_ROLE",
                Role::Active => "ACTIVE",
                Role::Backup => "BACKUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_ROLE" => Some(Self::UndefinedRole),
                "ACTIVE" => Some(Self::Active),
                "BACKUP" => Some(Self::Backup),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsableSubnetworkSecondaryRange {
    #[prost(string, optional, tag = "98117322")]
    pub ip_cidr_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "332216397")]
    pub range_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsableSubnetworksAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<UsableSubnetwork>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UsageExportLocation {
    #[prost(string, optional, tag = "283610048")]
    pub bucket_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "320198715")]
    pub report_name_prefix: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateRegionUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "56632858")]
    pub region_url_maps_validate_request_resource: ::core::option::Option<
        RegionUrlMapsValidateRequest,
    >,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidateUrlMapRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "367020684")]
    pub url_map: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "395913455")]
    pub url_maps_validate_request_resource: ::core::option::Option<
        UrlMapsValidateRequest,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmEndpointNatMappings {
    #[prost(string, optional, tag = "227947509")]
    pub instance_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "256196617")]
    pub interface_nat_mappings: ::prost::alloc::vec::Vec<
        VmEndpointNatMappingsInterfaceNatMappings,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmEndpointNatMappingsInterfaceNatMappings {
    #[prost(string, repeated, tag = "395440577")]
    pub drain_nat_ip_port_ranges: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "531830810")]
    pub nat_ip_port_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "335532793")]
    pub num_total_drain_nat_ports: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "299904384")]
    pub num_total_nat_ports: ::core::option::Option<i32>,
    #[prost(message, repeated, tag = "486192968")]
    pub rule_mappings: ::prost::alloc::vec::Vec<
        VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings,
    >,
    #[prost(string, optional, tag = "440340952")]
    pub source_alias_ip_range: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "149836159")]
    pub source_virtual_ip: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmEndpointNatMappingsInterfaceNatMappingsNatRuleMappings {
    #[prost(string, repeated, tag = "395440577")]
    pub drain_nat_ip_port_ranges: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "531830810")]
    pub nat_ip_port_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "335532793")]
    pub num_total_drain_nat_ports: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "299904384")]
    pub num_total_nat_ports: ::core::option::Option<i32>,
    #[prost(int32, optional, tag = "535211500")]
    pub rule_number: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VmEndpointNatMappingsList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "139315229")]
    pub result: ::prost::alloc::vec::Vec<VmEndpointNatMappings>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGateway {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "65074843")]
    pub gateway_ip_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "232872494")]
    pub network: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "425908881")]
    pub stack_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "91842181")]
    pub vpn_interfaces: ::prost::alloc::vec::Vec<VpnGatewayVpnGatewayInterface>,
}
/// Nested message and enum types in `VpnGateway`.
pub mod vpn_gateway {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GatewayIpVersion {
        UndefinedGatewayIpVersion = 0,
        Ipv4 = 2254341,
        Ipv6 = 2254343,
    }
    impl GatewayIpVersion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GatewayIpVersion::UndefinedGatewayIpVersion => {
                    "UNDEFINED_GATEWAY_IP_VERSION"
                }
                GatewayIpVersion::Ipv4 => "IPV4",
                GatewayIpVersion::Ipv6 => "IPV6",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_GATEWAY_IP_VERSION" => Some(Self::UndefinedGatewayIpVersion),
                "IPV4" => Some(Self::Ipv4),
                "IPV6" => Some(Self::Ipv6),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StackType {
        UndefinedStackType = 0,
        Ipv4Ipv6 = 22197249,
        Ipv4Only = 22373798,
    }
    impl StackType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StackType::UndefinedStackType => "UNDEFINED_STACK_TYPE",
                StackType::Ipv4Ipv6 => "IPV4_IPV6",
                StackType::Ipv4Only => "IPV4_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STACK_TYPE" => Some(Self::UndefinedStackType),
                "IPV4_IPV6" => Some(Self::Ipv4Ipv6),
                "IPV4_ONLY" => Some(Self::Ipv4Only),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        VpnGatewaysScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<VpnGateway>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayStatus {
    #[prost(message, repeated, tag = "439334538")]
    pub vpn_connections: ::prost::alloc::vec::Vec<VpnGatewayStatusVpnConnection>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayStatusHighAvailabilityRequirementState {
    #[prost(string, optional, tag = "109757585")]
    pub state: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "55016330")]
    pub unsatisfied_reason: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `VpnGatewayStatusHighAvailabilityRequirementState`.
pub mod vpn_gateway_status_high_availability_requirement_state {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        UndefinedState = 0,
        ConnectionRedundancyMet = 505242907,
        ConnectionRedundancyNotMet = 511863311,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::UndefinedState => "UNDEFINED_STATE",
                State::ConnectionRedundancyMet => "CONNECTION_REDUNDANCY_MET",
                State::ConnectionRedundancyNotMet => "CONNECTION_REDUNDANCY_NOT_MET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATE" => Some(Self::UndefinedState),
                "CONNECTION_REDUNDANCY_MET" => Some(Self::ConnectionRedundancyMet),
                "CONNECTION_REDUNDANCY_NOT_MET" => Some(Self::ConnectionRedundancyNotMet),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UnsatisfiedReason {
        UndefinedUnsatisfiedReason = 0,
        IncompleteTunnelsCoverage = 55917437,
    }
    impl UnsatisfiedReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UnsatisfiedReason::UndefinedUnsatisfiedReason => {
                    "UNDEFINED_UNSATISFIED_REASON"
                }
                UnsatisfiedReason::IncompleteTunnelsCoverage => {
                    "INCOMPLETE_TUNNELS_COVERAGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_UNSATISFIED_REASON" => Some(Self::UndefinedUnsatisfiedReason),
                "INCOMPLETE_TUNNELS_COVERAGE" => Some(Self::IncompleteTunnelsCoverage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayStatusTunnel {
    #[prost(uint32, optional, tag = "158764330")]
    pub local_gateway_interface: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "214380385")]
    pub peer_gateway_interface: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "78975256")]
    pub tunnel_url: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayStatusVpnConnection {
    #[prost(string, optional, tag = "384956173")]
    pub peer_external_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "281867452")]
    pub peer_gcp_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "109757585")]
    pub state: ::core::option::Option<VpnGatewayStatusHighAvailabilityRequirementState>,
    #[prost(message, repeated, tag = "104561931")]
    pub tunnels: ::prost::alloc::vec::Vec<VpnGatewayStatusTunnel>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayVpnGatewayInterface {
    #[prost(uint32, optional, tag = "3355")]
    pub id: ::core::option::Option<u32>,
    #[prost(string, optional, tag = "308135284")]
    pub interconnect_attachment: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "406272220")]
    pub ip_address: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "341563804")]
    pub ipv6_address: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewaysGetStatusResponse {
    #[prost(message, optional, tag = "139315229")]
    pub result: ::core::option::Option<VpnGatewayStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewaysScopedList {
    #[prost(message, repeated, tag = "259177882")]
    pub vpn_gateways: ::prost::alloc::vec::Vec<VpnGateway>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnTunnel {
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "333501025")]
    pub detailed_status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(int32, optional, tag = "218376220")]
    pub ike_version: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "317314613")]
    pub local_traffic_selector: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "384956173")]
    pub peer_external_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "452768391")]
    pub peer_external_gateway_interface: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "281867452")]
    pub peer_gcp_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "383249700")]
    pub peer_ip: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "358887098")]
    pub remote_traffic_selector: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "148608841")]
    pub router: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "381932490")]
    pub shared_secret: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "398881891")]
    pub shared_secret_hash: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "532512843")]
    pub target_vpn_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "406684153")]
    pub vpn_gateway: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "95979123")]
    pub vpn_gateway_interface: ::core::option::Option<i32>,
}
/// Nested message and enum types in `VpnTunnel`.
pub mod vpn_tunnel {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        AllocatingResources = 320922816,
        AuthorizationError = 23580290,
        Deprovisioning = 428935662,
        Established = 88852344,
        Failed = 455706685,
        FirstHandshake = 191393000,
        NegotiationFailure = 360325868,
        NetworkError = 193912951,
        NoIncomingPackets = 119983216,
        Provisioning = 290896621,
        Rejected = 174130302,
        Stopped = 444276141,
        WaitingForFullConfig = 41640522,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::AllocatingResources => "ALLOCATING_RESOURCES",
                Status::AuthorizationError => "AUTHORIZATION_ERROR",
                Status::Deprovisioning => "DEPROVISIONING",
                Status::Established => "ESTABLISHED",
                Status::Failed => "FAILED",
                Status::FirstHandshake => "FIRST_HANDSHAKE",
                Status::NegotiationFailure => "NEGOTIATION_FAILURE",
                Status::NetworkError => "NETWORK_ERROR",
                Status::NoIncomingPackets => "NO_INCOMING_PACKETS",
                Status::Provisioning => "PROVISIONING",
                Status::Rejected => "REJECTED",
                Status::Stopped => "STOPPED",
                Status::WaitingForFullConfig => "WAITING_FOR_FULL_CONFIG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "ALLOCATING_RESOURCES" => Some(Self::AllocatingResources),
                "AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
                "DEPROVISIONING" => Some(Self::Deprovisioning),
                "ESTABLISHED" => Some(Self::Established),
                "FAILED" => Some(Self::Failed),
                "FIRST_HANDSHAKE" => Some(Self::FirstHandshake),
                "NEGOTIATION_FAILURE" => Some(Self::NegotiationFailure),
                "NETWORK_ERROR" => Some(Self::NetworkError),
                "NO_INCOMING_PACKETS" => Some(Self::NoIncomingPackets),
                "PROVISIONING" => Some(Self::Provisioning),
                "REJECTED" => Some(Self::Rejected),
                "STOPPED" => Some(Self::Stopped),
                "WAITING_FOR_FULL_CONFIG" => Some(Self::WaitingForFullConfig),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnTunnelAggregatedList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, message", tag = "100526016")]
    pub items: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        VpnTunnelsScopedList,
    >,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "243372063")]
    pub unreachables: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnTunnelList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<VpnTunnel>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnTunnelsScopedList {
    #[prost(message, repeated, tag = "163494080")]
    pub vpn_tunnels: ::prost::alloc::vec::Vec<VpnTunnel>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WafExpressionSet {
    #[prost(string, repeated, tag = "159207166")]
    pub aliases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "175554779")]
    pub expressions: ::prost::alloc::vec::Vec<WafExpressionSetExpression>,
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WafExpressionSetExpression {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "27532959")]
    pub sensitivity: ::core::option::Option<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitGlobalOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitRegionOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitZoneOperationRequest {
    #[prost(string, tag = "52090215")]
    pub operation: ::prost::alloc::string::String,
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "3744684")]
    pub zone: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warning {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3076010")]
    pub data: ::prost::alloc::vec::Vec<Data>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Warning`.
pub mod warning {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        UndefinedCode = 0,
        CleanupFailed = 150308440,
        DeprecatedResourceUsed = 391835586,
        DeprecatedTypeUsed = 346526230,
        DiskSizeLargerThanImageSize = 369442967,
        ExperimentalTypeUsed = 451954443,
        ExternalApiWarning = 175546307,
        FieldValueOverriden = 329669423,
        InjectedKernelsDeprecated = 417377419,
        InvalidHealthCheckForDynamicWieghtedLb = 401542606,
        LargeDeploymentWarning = 481440678,
        ListOverheadQuotaExceed = 47618117,
        MissingTypeDependency = 344505463,
        NextHopAddressNotAssigned = 324964999,
        NextHopCannotIpForward = 383382887,
        NextHopInstanceHasNoIpv6Interface = 146748434,
        NextHopInstanceNotFound = 464250446,
        NextHopInstanceNotOnNetwork = 243758146,
        NextHopNotRunning = 417081265,
        NotCriticalError = 105763924,
        NoResultsOnPage = 30036744,
        PartialSuccess = 39966469,
        RequiredTosAgreement = 3745539,
        ResourceInUseByOtherResourceWarning = 496728641,
        ResourceNotDeleted = 168598460,
        SchemaValidationIgnored = 275245642,
        SingleInstancePropertyTemplate = 268305617,
        UndeclaredProperties = 390513439,
        Unreachable = 13328052,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Code::UndefinedCode => "UNDEFINED_CODE",
                Code::CleanupFailed => "CLEANUP_FAILED",
                Code::DeprecatedResourceUsed => "DEPRECATED_RESOURCE_USED",
                Code::DeprecatedTypeUsed => "DEPRECATED_TYPE_USED",
                Code::DiskSizeLargerThanImageSize => "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
                Code::ExperimentalTypeUsed => "EXPERIMENTAL_TYPE_USED",
                Code::ExternalApiWarning => "EXTERNAL_API_WARNING",
                Code::FieldValueOverriden => "FIELD_VALUE_OVERRIDEN",
                Code::InjectedKernelsDeprecated => "INJECTED_KERNELS_DEPRECATED",
                Code::InvalidHealthCheckForDynamicWieghtedLb => {
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB"
                }
                Code::LargeDeploymentWarning => "LARGE_DEPLOYMENT_WARNING",
                Code::ListOverheadQuotaExceed => "LIST_OVERHEAD_QUOTA_EXCEED",
                Code::MissingTypeDependency => "MISSING_TYPE_DEPENDENCY",
                Code::NextHopAddressNotAssigned => "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
                Code::NextHopCannotIpForward => "NEXT_HOP_CANNOT_IP_FORWARD",
                Code::NextHopInstanceHasNoIpv6Interface => {
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE"
                }
                Code::NextHopInstanceNotFound => "NEXT_HOP_INSTANCE_NOT_FOUND",
                Code::NextHopInstanceNotOnNetwork => "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
                Code::NextHopNotRunning => "NEXT_HOP_NOT_RUNNING",
                Code::NotCriticalError => "NOT_CRITICAL_ERROR",
                Code::NoResultsOnPage => "NO_RESULTS_ON_PAGE",
                Code::PartialSuccess => "PARTIAL_SUCCESS",
                Code::RequiredTosAgreement => "REQUIRED_TOS_AGREEMENT",
                Code::ResourceInUseByOtherResourceWarning => {
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
                }
                Code::ResourceNotDeleted => "RESOURCE_NOT_DELETED",
                Code::SchemaValidationIgnored => "SCHEMA_VALIDATION_IGNORED",
                Code::SingleInstancePropertyTemplate => {
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
                }
                Code::UndeclaredProperties => "UNDECLARED_PROPERTIES",
                Code::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CODE" => Some(Self::UndefinedCode),
                "CLEANUP_FAILED" => Some(Self::CleanupFailed),
                "DEPRECATED_RESOURCE_USED" => Some(Self::DeprecatedResourceUsed),
                "DEPRECATED_TYPE_USED" => Some(Self::DeprecatedTypeUsed),
                "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => {
                    Some(Self::DiskSizeLargerThanImageSize)
                }
                "EXPERIMENTAL_TYPE_USED" => Some(Self::ExperimentalTypeUsed),
                "EXTERNAL_API_WARNING" => Some(Self::ExternalApiWarning),
                "FIELD_VALUE_OVERRIDEN" => Some(Self::FieldValueOverriden),
                "INJECTED_KERNELS_DEPRECATED" => Some(Self::InjectedKernelsDeprecated),
                "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                    Some(Self::InvalidHealthCheckForDynamicWieghtedLb)
                }
                "LARGE_DEPLOYMENT_WARNING" => Some(Self::LargeDeploymentWarning),
                "LIST_OVERHEAD_QUOTA_EXCEED" => Some(Self::ListOverheadQuotaExceed),
                "MISSING_TYPE_DEPENDENCY" => Some(Self::MissingTypeDependency),
                "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Some(Self::NextHopAddressNotAssigned),
                "NEXT_HOP_CANNOT_IP_FORWARD" => Some(Self::NextHopCannotIpForward),
                "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                    Some(Self::NextHopInstanceHasNoIpv6Interface)
                }
                "NEXT_HOP_INSTANCE_NOT_FOUND" => Some(Self::NextHopInstanceNotFound),
                "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => {
                    Some(Self::NextHopInstanceNotOnNetwork)
                }
                "NEXT_HOP_NOT_RUNNING" => Some(Self::NextHopNotRunning),
                "NOT_CRITICAL_ERROR" => Some(Self::NotCriticalError),
                "NO_RESULTS_ON_PAGE" => Some(Self::NoResultsOnPage),
                "PARTIAL_SUCCESS" => Some(Self::PartialSuccess),
                "REQUIRED_TOS_AGREEMENT" => Some(Self::RequiredTosAgreement),
                "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                    Some(Self::ResourceInUseByOtherResourceWarning)
                }
                "RESOURCE_NOT_DELETED" => Some(Self::ResourceNotDeleted),
                "SCHEMA_VALIDATION_IGNORED" => Some(Self::SchemaValidationIgnored),
                "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => {
                    Some(Self::SingleInstancePropertyTemplate)
                }
                "UNDECLARED_PROPERTIES" => Some(Self::UndeclaredProperties),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Warnings {
    #[prost(string, optional, tag = "3059181")]
    pub code: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3076010")]
    pub data: ::prost::alloc::vec::Vec<Data>,
    #[prost(string, optional, tag = "418054151")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `Warnings`.
pub mod warnings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Code {
        UndefinedCode = 0,
        CleanupFailed = 150308440,
        DeprecatedResourceUsed = 391835586,
        DeprecatedTypeUsed = 346526230,
        DiskSizeLargerThanImageSize = 369442967,
        ExperimentalTypeUsed = 451954443,
        ExternalApiWarning = 175546307,
        FieldValueOverriden = 329669423,
        InjectedKernelsDeprecated = 417377419,
        InvalidHealthCheckForDynamicWieghtedLb = 401542606,
        LargeDeploymentWarning = 481440678,
        ListOverheadQuotaExceed = 47618117,
        MissingTypeDependency = 344505463,
        NextHopAddressNotAssigned = 324964999,
        NextHopCannotIpForward = 383382887,
        NextHopInstanceHasNoIpv6Interface = 146748434,
        NextHopInstanceNotFound = 464250446,
        NextHopInstanceNotOnNetwork = 243758146,
        NextHopNotRunning = 417081265,
        NotCriticalError = 105763924,
        NoResultsOnPage = 30036744,
        PartialSuccess = 39966469,
        RequiredTosAgreement = 3745539,
        ResourceInUseByOtherResourceWarning = 496728641,
        ResourceNotDeleted = 168598460,
        SchemaValidationIgnored = 275245642,
        SingleInstancePropertyTemplate = 268305617,
        UndeclaredProperties = 390513439,
        Unreachable = 13328052,
    }
    impl Code {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Code::UndefinedCode => "UNDEFINED_CODE",
                Code::CleanupFailed => "CLEANUP_FAILED",
                Code::DeprecatedResourceUsed => "DEPRECATED_RESOURCE_USED",
                Code::DeprecatedTypeUsed => "DEPRECATED_TYPE_USED",
                Code::DiskSizeLargerThanImageSize => "DISK_SIZE_LARGER_THAN_IMAGE_SIZE",
                Code::ExperimentalTypeUsed => "EXPERIMENTAL_TYPE_USED",
                Code::ExternalApiWarning => "EXTERNAL_API_WARNING",
                Code::FieldValueOverriden => "FIELD_VALUE_OVERRIDEN",
                Code::InjectedKernelsDeprecated => "INJECTED_KERNELS_DEPRECATED",
                Code::InvalidHealthCheckForDynamicWieghtedLb => {
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB"
                }
                Code::LargeDeploymentWarning => "LARGE_DEPLOYMENT_WARNING",
                Code::ListOverheadQuotaExceed => "LIST_OVERHEAD_QUOTA_EXCEED",
                Code::MissingTypeDependency => "MISSING_TYPE_DEPENDENCY",
                Code::NextHopAddressNotAssigned => "NEXT_HOP_ADDRESS_NOT_ASSIGNED",
                Code::NextHopCannotIpForward => "NEXT_HOP_CANNOT_IP_FORWARD",
                Code::NextHopInstanceHasNoIpv6Interface => {
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE"
                }
                Code::NextHopInstanceNotFound => "NEXT_HOP_INSTANCE_NOT_FOUND",
                Code::NextHopInstanceNotOnNetwork => "NEXT_HOP_INSTANCE_NOT_ON_NETWORK",
                Code::NextHopNotRunning => "NEXT_HOP_NOT_RUNNING",
                Code::NotCriticalError => "NOT_CRITICAL_ERROR",
                Code::NoResultsOnPage => "NO_RESULTS_ON_PAGE",
                Code::PartialSuccess => "PARTIAL_SUCCESS",
                Code::RequiredTosAgreement => "REQUIRED_TOS_AGREEMENT",
                Code::ResourceInUseByOtherResourceWarning => {
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING"
                }
                Code::ResourceNotDeleted => "RESOURCE_NOT_DELETED",
                Code::SchemaValidationIgnored => "SCHEMA_VALIDATION_IGNORED",
                Code::SingleInstancePropertyTemplate => {
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE"
                }
                Code::UndeclaredProperties => "UNDECLARED_PROPERTIES",
                Code::Unreachable => "UNREACHABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_CODE" => Some(Self::UndefinedCode),
                "CLEANUP_FAILED" => Some(Self::CleanupFailed),
                "DEPRECATED_RESOURCE_USED" => Some(Self::DeprecatedResourceUsed),
                "DEPRECATED_TYPE_USED" => Some(Self::DeprecatedTypeUsed),
                "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => {
                    Some(Self::DiskSizeLargerThanImageSize)
                }
                "EXPERIMENTAL_TYPE_USED" => Some(Self::ExperimentalTypeUsed),
                "EXTERNAL_API_WARNING" => Some(Self::ExternalApiWarning),
                "FIELD_VALUE_OVERRIDEN" => Some(Self::FieldValueOverriden),
                "INJECTED_KERNELS_DEPRECATED" => Some(Self::InjectedKernelsDeprecated),
                "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                    Some(Self::InvalidHealthCheckForDynamicWieghtedLb)
                }
                "LARGE_DEPLOYMENT_WARNING" => Some(Self::LargeDeploymentWarning),
                "LIST_OVERHEAD_QUOTA_EXCEED" => Some(Self::ListOverheadQuotaExceed),
                "MISSING_TYPE_DEPENDENCY" => Some(Self::MissingTypeDependency),
                "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Some(Self::NextHopAddressNotAssigned),
                "NEXT_HOP_CANNOT_IP_FORWARD" => Some(Self::NextHopCannotIpForward),
                "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                    Some(Self::NextHopInstanceHasNoIpv6Interface)
                }
                "NEXT_HOP_INSTANCE_NOT_FOUND" => Some(Self::NextHopInstanceNotFound),
                "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => {
                    Some(Self::NextHopInstanceNotOnNetwork)
                }
                "NEXT_HOP_NOT_RUNNING" => Some(Self::NextHopNotRunning),
                "NOT_CRITICAL_ERROR" => Some(Self::NotCriticalError),
                "NO_RESULTS_ON_PAGE" => Some(Self::NoResultsOnPage),
                "PARTIAL_SUCCESS" => Some(Self::PartialSuccess),
                "REQUIRED_TOS_AGREEMENT" => Some(Self::RequiredTosAgreement),
                "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                    Some(Self::ResourceInUseByOtherResourceWarning)
                }
                "RESOURCE_NOT_DELETED" => Some(Self::ResourceNotDeleted),
                "SCHEMA_VALIDATION_IGNORED" => Some(Self::SchemaValidationIgnored),
                "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => {
                    Some(Self::SingleInstancePropertyTemplate)
                }
                "UNDECLARED_PROPERTIES" => Some(Self::UndeclaredProperties),
                "UNREACHABLE" => Some(Self::Unreachable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightedBackendService {
    #[prost(string, optional, tag = "306946058")]
    pub backend_service: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "328077352")]
    pub header_action: ::core::option::Option<HttpHeaderAction>,
    #[prost(uint32, optional, tag = "282149496")]
    pub weight: ::core::option::Option<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawPublicAdvertisedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "101874590")]
    pub public_advertised_prefix: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawPublicDelegatedPrefixeRequest {
    #[prost(string, tag = "227560217")]
    pub project: ::prost::alloc::string::String,
    #[prost(string, tag = "204238440")]
    pub public_delegated_prefix: ::prost::alloc::string::String,
    #[prost(string, tag = "138946292")]
    pub region: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "37109963")]
    pub request_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XpnHostList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Project>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct XpnResourceId {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3575610")]
    pub r#type: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `XpnResourceId`.
pub mod xpn_resource_id {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        UndefinedType = 0,
        Project = 408671993,
        XpnResourceTypeUnspecified = 151607034,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::UndefinedType => "UNDEFINED_TYPE",
                Type::Project => "PROJECT",
                Type::XpnResourceTypeUnspecified => "XPN_RESOURCE_TYPE_UNSPECIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_TYPE" => Some(Self::UndefinedType),
                "PROJECT" => Some(Self::Project),
                "XPN_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::XpnResourceTypeUnspecified),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Zone {
    #[prost(string, repeated, tag = "175536531")]
    pub available_cpu_platforms: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, optional, tag = "30525366")]
    pub creation_timestamp: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "515138995")]
    pub deprecated: ::core::option::Option<DeprecationStatus>,
    #[prost(string, optional, tag = "422937596")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "3355")]
    pub id: ::core::option::Option<u64>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3373707")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "138946292")]
    pub region: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "181260274")]
    pub status: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "83983214")]
    pub supports_pzs: ::core::option::Option<bool>,
}
/// Nested message and enum types in `Zone`.
pub mod zone {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        UndefinedStatus = 0,
        Down = 2104482,
        Up = 2715,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Status::UndefinedStatus => "UNDEFINED_STATUS",
                Status::Down => "DOWN",
                Status::Up => "UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNDEFINED_STATUS" => Some(Self::UndefinedStatus),
                "DOWN" => Some(Self::Down),
                "UP" => Some(Self::Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneList {
    #[prost(string, optional, tag = "3355")]
    pub id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "100526016")]
    pub items: ::prost::alloc::vec::Vec<Zone>,
    #[prost(string, optional, tag = "3292052")]
    pub kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "79797525")]
    pub next_page_token: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "456214797")]
    pub self_link: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50704284")]
    pub warning: ::core::option::Option<Warning>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneSetLabelsRequest {
    #[prost(string, optional, tag = "178124825")]
    pub label_fingerprint: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "500195327")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneSetPolicyRequest {
    #[prost(message, repeated, tag = "403251854")]
    pub bindings: ::prost::alloc::vec::Vec<Binding>,
    #[prost(string, optional, tag = "3123477")]
    pub etag: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "91071794")]
    pub policy: ::core::option::Option<Policy>,
}
/// Generated client implementations.
pub mod accelerator_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Services
    ///
    /// The AcceleratorTypes API.
    #[derive(Debug, Clone)]
    pub struct AcceleratorTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AcceleratorTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AcceleratorTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AcceleratorTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of accelerator types. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListAcceleratorTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::AcceleratorTypeAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.AcceleratorTypes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.AcceleratorTypes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified accelerator type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAcceleratorTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcceleratorType>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.AcceleratorTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.AcceleratorTypes", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of accelerator types that are available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAcceleratorTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcceleratorTypeList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.AcceleratorTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.AcceleratorTypes", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod addresses_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Addresses API.
    #[derive(Debug, Clone)]
    pub struct AddressesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AddressesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AddressesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AddressesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of addresses. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListAddressesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddressAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Addresses",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified address resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Addresses", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified address resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Address>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Addresses", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an address resource in the specified project by using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Addresses", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of addresses contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAddressesRequest>,
        ) -> std::result::Result<tonic::Response<super::AddressList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Addresses", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Moves the specified address resource.
        pub async fn r#move(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/Move",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Addresses", "Move"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on an Address. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Addresses/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Addresses", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod autoscalers_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Autoscalers API.
    #[derive(Debug, Clone)]
    pub struct AutoscalersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AutoscalersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AutoscalersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AutoscalersClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of autoscalers. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListAutoscalersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AutoscalerAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Autoscalers",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified autoscaler.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified autoscaler resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Autoscaler>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates an autoscaler in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of autoscalers contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAutoscalersRequest>,
        ) -> std::result::Result<tonic::Response<super::AutoscalerList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates an autoscaler in the specified project using the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Autoscalers/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Autoscalers", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod backend_buckets_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The BackendBuckets API.
    #[derive(Debug, Clone)]
    pub struct BackendBucketsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> BackendBucketsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackendBucketsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BackendBucketsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds a key for validating requests with signed URLs for this backend bucket.
        pub async fn add_signed_url_key(
            &mut self,
            request: impl tonic::IntoRequest<super::AddSignedUrlKeyBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/AddSignedUrlKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "AddSignedUrlKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified BackendBucket resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a key for validating requests with signed URLs for this backend bucket.
        pub async fn delete_signed_url_key(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteSignedUrlKeyBackendBucketRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/DeleteSignedUrlKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "DeleteSignedUrlKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified BackendBucket resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::BackendBucket>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a BackendBucket resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of BackendBucket resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackendBucketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendBucketList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified BackendBucket resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the edge security policy for the specified backend bucket.
        pub async fn set_edge_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetEdgeSecurityPolicyBackendBucketRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/SetEdgeSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "SetEdgeSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsBackendBucketRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendBuckets",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified BackendBucket resource with the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackendBucketRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendBuckets/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendBuckets", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod backend_services_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The BackendServices API.
    #[derive(Debug, Clone)]
    pub struct BackendServicesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> BackendServicesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> BackendServicesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            BackendServicesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds a key for validating requests with signed URLs for this backend service.
        pub async fn add_signed_url_key(
            &mut self,
            request: impl tonic::IntoRequest<super::AddSignedUrlKeyBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/AddSignedUrlKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "AddSignedUrlKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of all BackendService resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListBackendServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified BackendService resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a key for validating requests with signed URLs for this backend service.
        pub async fn delete_signed_url_key(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteSignedUrlKeyBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/DeleteSignedUrlKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "DeleteSignedUrlKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified BackendService resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::BackendService>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the most recent health check results for this BackendService. Example request body: { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" }
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthBackendServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceGroupHealth>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "GetHealth",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview .
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of BackendService resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBackendServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of all usable backend services in the specified project.
        pub async fn list_usable(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsableBackendServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceListUsable>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/ListUsable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "ListUsable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified BackendService resource with the data included in the request. For more information, see Backend services overview. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the edge security policy for the specified backend service.
        pub async fn set_edge_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetEdgeSecurityPolicyBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/SetEdgeSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "SetEdgeSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview
        pub async fn set_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSecurityPolicyBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/SetSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "SetSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsBackendServiceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.BackendServices",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified BackendService resource with the data included in the request. For more information, see Backend services overview.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.BackendServices/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.BackendServices", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod disk_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The DiskTypes API.
    #[derive(Debug, Clone)]
    pub struct DiskTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DiskTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DiskTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DiskTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of disk types. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListDiskTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiskTypeAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.DiskTypes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.DiskTypes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified disk type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDiskTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::DiskType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.DiskTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.DiskTypes", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of disk types available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDiskTypesRequest>,
        ) -> std::result::Result<tonic::Response<super::DiskTypeList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.DiskTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.DiskTypes", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod disks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Disks API.
    #[derive(Debug, Clone)]
    pub struct DisksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DisksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DisksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DisksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds existing resource policies to a disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation.
        pub async fn add_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::AddResourcePoliciesDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/AddResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "AddResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of persistent disks. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListDisksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DiskAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Disks", "AggregatedList"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk create a set of disks.
        pub async fn bulk_insert(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkInsertDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/BulkInsert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "BulkInsert"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project.
        pub async fn create_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnapshotDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/CreateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Disks", "CreateSnapshot"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified persistent disk. Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified persistent disk.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Disk>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Disks", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a persistent disk in the specified project using the data in the request. You can create a disk from a source (sourceImage, sourceSnapshot, or sourceDisk) or create an empty 500 GB data disk by omitting all properties. You can also create a disk that is larger than the default size by specifying the sizeGb property.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of persistent disks contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDisksRequest>,
        ) -> std::result::Result<tonic::Response<super::DiskList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes resource policies from a disk.
        pub async fn remove_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveResourcePoliciesDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/RemoveResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "RemoveResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resizes the specified persistent disk. You can only increase the size of the disk.
        pub async fn resize(
            &mut self,
            request: impl tonic::IntoRequest<super::ResizeDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/Resize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "Resize"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Disks", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a disk. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "SetLabels"));
            self.inner.unary(req, path, codec).await
        }
        /// Starts asynchronous replication. Must be invoked on the primary disk.
        pub async fn start_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<super::StartAsyncReplicationDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/StartAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "StartAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk.
        pub async fn stop_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<super::StopAsyncReplicationDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/StopAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "StopAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope.
        pub async fn stop_group_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<super::StopGroupAsyncReplicationDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/StopGroupAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "StopGroupAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsDiskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Disks",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified disk with the data included in the request. The update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Disks/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Disks", "Update"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod external_vpn_gateways_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ExternalVpnGateways API.
    #[derive(Debug, Clone)]
    pub struct ExternalVpnGatewaysClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ExternalVpnGatewaysClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ExternalVpnGatewaysClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ExternalVpnGatewaysClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified externalVpnGateway.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExternalVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ExternalVpnGateways",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified externalVpnGateway. Get a list of available externalVpnGateways by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExternalVpnGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExternalVpnGateway>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ExternalVpnGateways", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ExternalVpnGateway in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertExternalVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ExternalVpnGateways",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of ExternalVpnGateway available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExternalVpnGatewaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExternalVpnGatewayList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ExternalVpnGateways",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on an ExternalVpnGateway. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsExternalVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ExternalVpnGateways",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsExternalVpnGatewayRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ExternalVpnGateways/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ExternalVpnGateways",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod firewall_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The FirewallPolicies API.
    #[derive(Debug, Clone)]
    pub struct FirewallPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FirewallPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FirewallPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FirewallPoliciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inserts an association for the specified firewall policy.
        pub async fn add_association(
            &mut self,
            request: impl tonic::IntoRequest<super::AddAssociationFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/AddAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "AddAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a rule into a firewall policy.
        pub async fn add_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::AddRuleFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/AddRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "AddRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Copies rules to the specified firewall policy.
        pub async fn clone_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::CloneRulesFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/CloneRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "CloneRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified firewall policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an association with the specified name.
        pub async fn get_association(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAssociationFirewallPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/GetAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "GetAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a rule of the specified priority.
        pub async fn get_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuleFirewallPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/GetRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "GetRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new policy in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the policies that have been configured for the specified folder or organization.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists associations of a specified target, i.e., organization or folder.
        pub async fn list_associations(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListAssociationsFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPoliciesListAssociationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/ListAssociations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "ListAssociations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Moves the specified firewall policy.
        pub async fn r#move(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/Move",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "Move"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified policy with the data included in the request.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.FirewallPolicies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches a rule of the specified priority.
        pub async fn patch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRuleFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/PatchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "PatchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes an association for the specified firewall policy.
        pub async fn remove_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveAssociationFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/RemoveAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "RemoveAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a rule of the specified priority.
        pub async fn remove_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveRuleFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/RemoveRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "RemoveRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.FirewallPolicies/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.FirewallPolicies",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod firewalls_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Firewalls API.
    #[derive(Debug, Clone)]
    pub struct FirewallsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> FirewallsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> FirewallsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            FirewallsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified firewall.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified firewall.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::Firewall>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a firewall rule in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of firewall rules available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirewallsRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified firewall rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified firewall rule with the data included in the request. Note that all fields will be updated if using PUT, even fields that are not specified. To update individual fields, please use PATCH instead.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateFirewallRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Firewalls/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Firewalls", "Update"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod forwarding_rules_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ForwardingRules API.
    #[derive(Debug, Clone)]
    pub struct ForwardingRulesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ForwardingRulesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ForwardingRulesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ForwardingRulesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of forwarding rules. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListForwardingRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForwardingRuleAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ForwardingRules",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified ForwardingRule resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ForwardingRules", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified ForwardingRule resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::ForwardingRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ForwardingRules", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ForwardingRule resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ForwardingRules", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of ForwardingRule resources available to the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListForwardingRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForwardingRuleList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ForwardingRules", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ForwardingRules", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on the specified resource. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ForwardingRules",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes target URL for forwarding rule. The new target should be of the same type as the old target.
        pub async fn set_target(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTargetForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ForwardingRules/SetTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ForwardingRules",
                        "SetTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_addresses_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalAddresses API.
    #[derive(Debug, Clone)]
    pub struct GlobalAddressesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalAddressesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalAddressesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalAddressesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified address resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGlobalAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalAddresses", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified address resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Address>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalAddresses", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an address resource in the specified project by using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertGlobalAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalAddresses", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of global addresses.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGlobalAddressesRequest>,
        ) -> std::result::Result<tonic::Response<super::AddressList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalAddresses", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Moves the specified address resource from one project to another project.
        pub async fn r#move(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveGlobalAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/Move",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalAddresses", "Move"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a GlobalAddress. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsGlobalAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalAddresses/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalAddresses",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_forwarding_rules_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalForwardingRules API.
    #[derive(Debug, Clone)]
    pub struct GlobalForwardingRulesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalForwardingRulesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalForwardingRulesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalForwardingRulesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified GlobalForwardingRule resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified GlobalForwardingRule resource. Gets a list of available forwarding rules by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::ForwardingRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a GlobalForwardingRule resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of GlobalForwardingRule resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGlobalForwardingRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ForwardingRuleList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently, you can only patch the network_tier field.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on the specified resource. To learn more about labels, read the Labeling resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes target URL for the GlobalForwardingRule resource. The new target should be of the same type as the old target.
        pub async fn set_target(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTargetGlobalForwardingRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalForwardingRules/SetTarget",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalForwardingRules",
                        "SetTarget",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_network_endpoint_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalNetworkEndpointGroups API.
    #[derive(Debug, Clone)]
    pub struct GlobalNetworkEndpointGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalNetworkEndpointGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalNetworkEndpointGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalNetworkEndpointGroupsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Attach a network endpoint to the specified network endpoint group.
        pub async fn attach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/AttachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "AttachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified network endpoint group.Note that the NEG cannot be deleted if there are backend services referencing it.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteGlobalNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Detach the network endpoint from the specified network endpoint group.
        pub async fn detach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/DetachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "DetachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network endpoint group.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalNetworkEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a network endpoint group in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertGlobalNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of network endpoint groups that are located in the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListGlobalNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the network endpoints in the specified network endpoint group.
        pub async fn list_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupsListNetworkEndpoints>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/ListNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
                        "ListNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_operations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalOperations API.
    #[derive(Debug, Clone)]
    pub struct GlobalOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalOperationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of all operations. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListGlobalOperationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::OperationAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOperations/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalOperations",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified Operations resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGlobalOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteGlobalOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOperations/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalOperations", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified Operations resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOperations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalOperations", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of Operation resources contained within the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGlobalOperationsRequest>,
        ) -> std::result::Result<tonic::Response<super::OperationList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOperations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalOperations", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
        pub async fn wait(
            &mut self,
            request: impl tonic::IntoRequest<super::WaitGlobalOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOperations/Wait",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.GlobalOperations", "Wait"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_organization_operations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalOrganizationOperations API.
    #[derive(Debug, Clone)]
    pub struct GlobalOrganizationOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalOrganizationOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalOrganizationOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalOrganizationOperationsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified Operations resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteGlobalOrganizationOperationRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DeleteGlobalOrganizationOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOrganizationOperations/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalOrganizationOperations",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified Operations resource. Gets a list of operations by making a `list()` request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetGlobalOrganizationOperationRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOrganizationOperations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalOrganizationOperations",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of Operation resources contained within the specified organization.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListGlobalOrganizationOperationsRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::OperationList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalOrganizationOperations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalOrganizationOperations",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod global_public_delegated_prefixes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The GlobalPublicDelegatedPrefixes API.
    #[derive(Debug, Clone)]
    pub struct GlobalPublicDelegatedPrefixesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> GlobalPublicDelegatedPrefixesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> GlobalPublicDelegatedPrefixesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            GlobalPublicDelegatedPrefixesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified global PublicDelegatedPrefix.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteGlobalPublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified global PublicDelegatedPrefix resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetGlobalPublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PublicDelegatedPrefix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a global PublicDelegatedPrefix in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertGlobalPublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the global PublicDelegatedPrefixes for a project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListGlobalPublicDelegatedPrefixesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PublicDelegatedPrefixList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified global PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchGlobalPublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod health_checks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The HealthChecks API.
    #[derive(Debug, Clone)]
    pub struct HealthChecksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> HealthChecksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> HealthChecksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            HealthChecksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all HealthCheck resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListHealthChecksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthChecksAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.HealthChecks",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified HealthCheck resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified HealthCheck resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthCheck>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a HealthCheck resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of HealthCheck resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListHealthChecksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a HealthCheck resource in the specified project using the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.HealthChecks/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.HealthChecks", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod image_family_views_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ImageFamilyViews API.
    #[derive(Debug, Clone)]
    pub struct ImageFamilyViewsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ImageFamilyViewsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ImageFamilyViewsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ImageFamilyViewsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the latest image that is part of an image family, is not deprecated and is rolled out in the specified zone.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImageFamilyViewRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ImageFamilyView>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ImageFamilyViews/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ImageFamilyViews", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod images_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Images API.
    #[derive(Debug, Clone)]
    pub struct ImagesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ImagesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ImagesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ImagesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified image.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the deprecation status of an image. If an empty request body is given, clears the deprecation status instead.
        pub async fn deprecate(
            &mut self,
            request: impl tonic::IntoRequest<super::DeprecateImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/Deprecate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "Deprecate"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified image.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Image>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the latest image that is part of an image family and is not deprecated. For more information on image families, see Public image families documentation.
        pub async fn get_from_family(
            &mut self,
            request: impl tonic::IntoRequest<super::GetFromFamilyImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Image>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/GetFromFamily",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Images", "GetFromFamily"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Images", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an image in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of custom images available to the specified project. Custom images are images you create that belong to your project. This method does not get any images that belong to other projects, including publicly-available images, like Debian 8. If you want to get a list of publicly-available images, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListImagesRequest>,
        ) -> std::result::Result<tonic::Response<super::ImageList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified image with the data included in the request. Only the following fields can be modified: family, description, deprecation status.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Images", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on an image. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Images", "SetLabels"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsImageRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Images/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Images",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instance_group_manager_resize_requests_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstanceGroupManagerResizeRequests API.
    #[derive(Debug, Clone)]
    pub struct InstanceGroupManagerResizeRequestsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstanceGroupManagerResizeRequestsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceGroupManagerResizeRequestsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceGroupManagerResizeRequestsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Cancels the specified resize request and removes it from the queue. Cancelled resize request does no longer wait for the resources to be provisioned. Cancel is only possible for requests that are accepted in the queue.
        pub async fn cancel(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CancelInstanceGroupManagerResizeRequestRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Cancel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
                        "Cancel",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified, inactive resize request. Requests that are still active cannot be deleted. Deleting request does not delete instances that were provisioned previously.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteInstanceGroupManagerResizeRequestRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all of the details about the specified resize request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetInstanceGroupManagerResizeRequestRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagerResizeRequest>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new resize request that starts provisioning VMs immediately or queues VM creation.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertInstanceGroupManagerResizeRequestRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of resize requests that are contained in the managed instance group.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListInstanceGroupManagerResizeRequestsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagerResizeRequestsListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instance_group_managers_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstanceGroupManagers API.
    #[derive(Debug, Clone)]
    pub struct InstanceGroupManagersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstanceGroupManagersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceGroupManagersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceGroupManagersClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Flags the specified instances to be removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn abandon_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AbandonInstancesInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/AbandonInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "AbandonInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of managed instance groups and groups them by zone. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagerAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Applies changes to selected instances on the managed instance group. This method can be used to apply new overrides and/or new versions.
        pub async fn apply_updates_to_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ApplyUpdatesToInstancesInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/ApplyUpdatesToInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "ApplyUpdatesToInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates instances with per-instance configurations in this managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method.
        pub async fn create_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateInstancesInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/CreateInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "CreateInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified managed instance group and all of the instances in that group. Note that the instance group must not belong to a backend service. Read Deleting an instance group for more information.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceGroupManagerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Flags the specified instances in the managed instance group for immediate deletion. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. This operation is marked as DONE when the action is scheduled even if the instances are still being deleted. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn delete_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteInstancesInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/DeleteInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "DeleteInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes selected per-instance configurations for the managed instance group.
        pub async fn delete_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeletePerInstanceConfigsInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/DeletePerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "DeletePerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all of the details about the specified managed instance group.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceGroupManagerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManager>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A managed instance group can have up to 1000 VM instances per group. Please contact Cloud Support if you need an increase in this limit.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInstanceGroupManagerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of managed instance groups that are contained within the specified project and zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstanceGroupManagersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagerList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all errors thrown by actions on instances for a given managed instance group. The filter and orderBy query parameters are not supported.
        pub async fn list_errors(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListErrorsInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagersListErrorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/ListErrors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "ListErrors",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the instances in the managed instance group. Each instance in the list has a currentAction, which indicates the action that the managed instance group is performing on the instance. For example, if the group is still creating an instance, the currentAction is CREATING. If a previous action failed, the list displays the errors for that failed action. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only if the group's `listManagedInstancesResults` field is set to `PAGINATED`.
        pub async fn list_managed_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListManagedInstancesInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagersListManagedInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/ListManagedInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "ListManagedInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported.
        pub async fn list_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListPerInstanceConfigsInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManagersListPerInstanceConfigsResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/ListPerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "ListPerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listManagedInstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchInstanceGroupManagerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
        pub async fn patch_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchPerInstanceConfigsInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/PatchPerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "PatchPerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn recreate_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RecreateInstancesInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/RecreateInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "RecreateInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resizes the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes instances. The resize operation is marked DONE when the resize actions are scheduled even if the group has not yet added or deleted any instances. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. When resizing down, the instance group arbitrarily chooses the order in which VMs are deleted. The group takes into account some VM attributes when making the selection including: + The status of the VM instance. + The health of the VM instance. + The instance template version the VM is based on. + For regional managed instance groups, the location of the VM instance. This list is subject to change. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
        pub async fn resize(
            &mut self,
            request: impl tonic::IntoRequest<super::ResizeInstanceGroupManagerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/Resize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "Resize",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Specifies the instance template to use when creating new instances in this group. The templates for existing instances in the group do not change unless you run recreateInstances, run applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
        pub async fn set_instance_template(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetInstanceTemplateInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/SetInstanceTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "SetInstanceTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies the target pools to which all instances in this managed instance group are assigned. The target pools automatically apply to all of the instances in the managed instance group. This operation is marked DONE when you make the request even if the instances have not yet been added to their target pools. The change might take some time to apply to all of the instances in the group depending on the size of the group.
        pub async fn set_target_pools(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetTargetPoolsInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/SetTargetPools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "SetTargetPools",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
        pub async fn update_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdatePerInstanceConfigsInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroupManagers/UpdatePerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroupManagers",
                        "UpdatePerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instance_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstanceGroups API.
    #[derive(Debug, Clone)]
    pub struct InstanceGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstanceGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceGroupsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds a list of instances to the specified instance group. All of the instances in the instance group must be in the same network/subnetwork. Read Adding instances for more information.
        pub async fn add_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::AddInstancesInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/AddInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroups",
                        "AddInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of instance groups and sorts them by zone. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListInstanceGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroups",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified instance group. The instances in the group are not deleted. Note that instance group must not belong to a backend service. Read Deleting an instance group for more information.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceGroups", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified zonal instance group. Get a list of available zonal instance groups by making a list() request. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::InstanceGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceGroups", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instance group in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceGroups", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of zonal instance group resources contained within the specified zone. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers methods instead.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstanceGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceGroups", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the instances in the specified instance group. The orderBy query parameter is not supported. The filter query parameter is supported, but only for expressions that use `eq` (equal) or `ne` (not equal) operators.
        pub async fn list_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesInstanceGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupsListInstances>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/ListInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroups",
                        "ListInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes one or more instances from the specified instance group, but does not delete those instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration before the VM instance is removed or deleted.
        pub async fn remove_instances(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveInstancesInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/RemoveInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroups",
                        "RemoveInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the named ports for the specified instance group.
        pub async fn set_named_ports(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNamedPortsInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceGroups/SetNamedPorts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceGroups",
                        "SetNamedPorts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instance_settings_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstanceSettings API.
    #[derive(Debug, Clone)]
    pub struct InstanceSettingsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstanceSettingsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceSettingsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceSettingsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get Instance settings.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceSettingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceSettingsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceSettingsService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patch Instance settings
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchInstanceSettingRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceSettingsService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceSettingsService",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instance_templates_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstanceTemplates API.
    #[derive(Debug, Clone)]
    pub struct InstanceTemplatesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstanceTemplatesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstanceTemplatesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstanceTemplatesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all InstanceTemplates resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListInstanceTemplatesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstanceTemplateAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone. It is not possible to delete templates that are already in use by a managed instance group.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified instance template.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceTemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceTemplate>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceTemplates", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instance template in the specified project using the data that is included in the request. If you are creating a new template to update an existing instance group, your new instance template must use the same network or, if applicable, the same subnetwork as the original template.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of instance templates that are contained within the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstanceTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceTemplateList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstanceTemplates", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsInstanceTemplateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstanceTemplates/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstanceTemplates",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instances_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Instances API.
    #[derive(Debug, Clone)]
    pub struct InstancesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstancesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstancesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstancesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds an access config to an instance's network interface.
        pub async fn add_access_config(
            &mut self,
            request: impl tonic::IntoRequest<super::AddAccessConfigInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/AddAccessConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "AddAccessConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds existing resource policies to an instance. You can only add one policy right now which will be applied to this instance for scheduling live migrations.
        pub async fn add_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::AddResourcePoliciesInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/AddResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "AddResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of all of the instances in your project across all regions and zones. The performance of this method degrades when a filter is specified on a project that has a very large number of instances. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Attaches an existing Disk resource to an instance. You must first create the disk before you can attach it. It is not possible to create and attach a disk at the same time. For more information, read Adding a persistent disk to your instance.
        pub async fn attach_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::AttachDiskInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/AttachDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "AttachDisk"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates multiple instances. Count specifies the number of instances to create. For more information, see About bulk creation of VMs.
        pub async fn bulk_insert(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkInsertInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/BulkInsert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "BulkInsert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified Instance resource. For more information, see Deleting an instance.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an access config from an instance's network interface.
        pub async fn delete_access_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccessConfigInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/DeleteAccessConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "DeleteAccessConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Detaches a disk from an instance.
        pub async fn detach_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::DetachDiskInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/DetachDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "DetachDisk"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Instance resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Instance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns effective firewalls applied to an interface of the instance.
        pub async fn get_effective_firewalls(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEffectiveFirewallsInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstancesGetEffectiveFirewallsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetEffectiveFirewalls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "GetEffectiveFirewalls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified guest attributes entry.
        pub async fn get_guest_attributes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGuestAttributesInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GuestAttributes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetGuestAttributes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "GetGuestAttributes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the screenshot from the specified instance.
        pub async fn get_screenshot(
            &mut self,
            request: impl tonic::IntoRequest<super::GetScreenshotInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Screenshot>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetScreenshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "GetScreenshot"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the last 1 MB of serial port output from the specified instance.
        pub async fn get_serial_port_output(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSerialPortOutputInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SerialPortOutput>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetSerialPortOutput",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "GetSerialPortOutput",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the Shielded Instance Identity of an instance
        pub async fn get_shielded_instance_identity(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetShieldedInstanceIdentityInstanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ShieldedInstanceIdentity>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/GetShieldedInstanceIdentity",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "GetShieldedInstanceIdentity",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instance resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of instances contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstancesRequest>,
        ) -> std::result::Result<tonic::Response<super::InstanceList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of resources that refer to the VM instance specified in the request. For example, if the VM instance is part of a managed or unmanaged instance group, the referrers list includes the instance group. For more information, read Viewing referrers to VM instances.
        pub async fn list_referrers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReferrersInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceListReferrers>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/ListReferrers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "ListReferrers"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Perform a manual maintenance on the instance.
        pub async fn perform_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<super::PerformMaintenanceInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/PerformMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "PerformMaintenance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes resource policies from an instance.
        pub async fn remove_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveResourcePoliciesInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/RemoveResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "RemoveResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Performs a reset on the instance. This is a hard reset. The VM does not do a graceful shutdown. For more information, see Resetting an instance.
        pub async fn reset(
            &mut self,
            request: impl tonic::IntoRequest<super::ResetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Reset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Reset"));
            self.inner.unary(req, path, codec).await
        }
        /// Resumes an instance that was suspended using the instances().suspend method.
        pub async fn resume(
            &mut self,
            request: impl tonic::IntoRequest<super::ResumeInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Resume",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Resume"));
            self.inner.unary(req, path, codec).await
        }
        /// Sends diagnostic interrupt to the instance.
        pub async fn send_diagnostic_interrupt(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SendDiagnosticInterruptInstanceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SendDiagnosticInterruptInstanceResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SendDiagnosticInterrupt",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SendDiagnosticInterrupt",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets deletion protection on the instance.
        pub async fn set_deletion_protection(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDeletionProtectionInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetDeletionProtection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetDeletionProtection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the auto-delete flag for a disk attached to an instance.
        pub async fn set_disk_auto_delete(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDiskAutoDeleteInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetDiskAutoDelete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetDiskAutoDelete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets labels on an instance. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the number and/or type of accelerator for a stopped instance to the values specified in the request.
        pub async fn set_machine_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMachineResourcesInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetMachineResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetMachineResources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the machine type for a stopped instance to the machine type specified in the request.
        pub async fn set_machine_type(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMachineTypeInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetMachineType",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetMachineType",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets metadata for the specified instance to the data included in the request.
        pub async fn set_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMetadataInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "SetMetadata"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the minimum CPU platform that this instance should use. This method can only be called on a stopped instance. For more information, read Specifying a Minimum CPU Platform.
        pub async fn set_min_cpu_platform(
            &mut self,
            request: impl tonic::IntoRequest<super::SetMinCpuPlatformInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetMinCpuPlatform",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetMinCpuPlatform",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets name of an instance.
        pub async fn set_name(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNameInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetName",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "SetName"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets an instance's scheduling options. You can only call this method on a stopped instance, that is, a VM instance that is in a `TERMINATED` state. See Instance Life Cycle for more information on the possible instance states. For more information about setting scheduling options for a VM, see Set VM host maintenance policy.
        pub async fn set_scheduling(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSchedulingInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetScheduling",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Instances", "SetScheduling"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Google Cloud Armor security policy for the specified instance. For more information, see Google Cloud Armor Overview
        pub async fn set_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSecurityPolicyInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the service account on the instance. For more information, read Changing the service account and access scopes for an instance.
        pub async fn set_service_account(
            &mut self,
            request: impl tonic::IntoRequest<super::SetServiceAccountInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetServiceAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetServiceAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Shielded Instance integrity policy for an instance. You can only use this method on a running instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn set_shielded_instance_integrity_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetShieldedInstanceIntegrityPolicyInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetShieldedInstanceIntegrityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SetShieldedInstanceIntegrityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets network tags for the specified instance to the data included in the request.
        pub async fn set_tags(
            &mut self,
            request: impl tonic::IntoRequest<super::SetTagsInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SetTags",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "SetTags"));
            self.inner.unary(req, path, codec).await
        }
        /// Simulates a host maintenance event on a VM. For more information, see Simulate a host maintenance event.
        pub async fn simulate_maintenance_event(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SimulateMaintenanceEventInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/SimulateMaintenanceEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "SimulateMaintenanceEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance.
        pub async fn start(
            &mut self,
            request: impl tonic::IntoRequest<super::StartInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Start",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Start"));
            self.inner.unary(req, path, codec).await
        }
        /// Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance.
        pub async fn start_with_encryption_key(
            &mut self,
            request: impl tonic::IntoRequest<
                super::StartWithEncryptionKeyInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/StartWithEncryptionKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "StartWithEncryptionKey",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops a running instance, shutting it down cleanly, and allows you to restart the instance at a later time. Stopped instances do not incur VM usage charges while they are stopped. However, resources that the VM is using, such as persistent disks and static IP addresses, will continue to be charged until they are deleted. For more information, see Stopping an instance.
        pub async fn stop(
            &mut self,
            request: impl tonic::IntoRequest<super::StopInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Stop",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Stop"));
            self.inner.unary(req, path, codec).await
        }
        /// This method suspends a running instance, saving its state to persistent storage, and allows you to resume the instance at a later time. Suspended instances have no compute costs (cores or RAM), and incur only storage charges for the saved VM memory and localSSD data. Any charged resources the virtual machine was using, such as persistent disks and static IP addresses, will continue to be charged while the instance is suspended. For more information, see Suspending and resuming an instance.
        pub async fn suspend(
            &mut self,
            request: impl tonic::IntoRequest<super::SuspendInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Suspend",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Suspend"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsInstanceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an instance only if the necessary resources are available. This method can update only a specific set of instance properties. See Updating a running instance for a list of updatable instance properties.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Instances", "Update"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified access config from an instance's network interface with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn update_access_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccessConfigInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/UpdateAccessConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "UpdateAccessConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Display config for a VM instance. You can only use this method on a stopped VM instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn update_display_device(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDisplayDeviceInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/UpdateDisplayDevice",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "UpdateDisplayDevice",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an instance's network interface. This method can only update an interface's alias IP range and attached network. See Modifying alias IP ranges for an existing instance for instructions on changing alias IP ranges. See Migrating a VM between networks for instructions on migrating an interface. This method follows PATCH semantics.
        pub async fn update_network_interface(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateNetworkInterfaceInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/UpdateNetworkInterface",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "UpdateNetworkInterface",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the Shielded Instance config for an instance. You can only use this method on a stopped instance. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn update_shielded_instance_config(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateShieldedInstanceConfigInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Instances/UpdateShieldedInstanceConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Instances",
                        "UpdateShieldedInstanceConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod instant_snapshots_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InstantSnapshots API.
    #[derive(Debug, Clone)]
    pub struct InstantSnapshotsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InstantSnapshotsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InstantSnapshotsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InstantSnapshotsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of instantSnapshots. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListInstantSnapshotsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InstantSnapshotAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstantSnapshots",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified InstantSnapshot resource. Keep in mind that deleting a single instantSnapshot might not necessarily delete all the data on that instantSnapshot. If any data on the instantSnapshot that is marked for deletion is needed for subsequent instantSnapshots, the data will be moved to the next corresponding instantSnapshot. For more information, see Deleting instantSnapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstantSnapshots", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified InstantSnapshot resource in the specified zone.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInstantSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstantSnapshot>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstantSnapshots", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstantSnapshots",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instant snapshot in the specified zone.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstantSnapshots", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of InstantSnapshot resources contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInstantSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstantSnapshotList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.InstantSnapshots", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstantSnapshots",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a instantSnapshot in the given zone. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstantSnapshots",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsInstantSnapshotRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InstantSnapshots/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InstantSnapshots",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod interconnect_attachments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InterconnectAttachments API.
    #[derive(Debug, Clone)]
    pub struct InterconnectAttachmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InterconnectAttachmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterconnectAttachmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InterconnectAttachmentsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of interconnect attachments. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListInterconnectAttachmentsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectAttachmentAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified interconnect attachment.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInterconnectAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified interconnect attachment.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterconnectAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an InterconnectAttachment in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInterconnectAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of interconnect attachments contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterconnectAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectAttachmentList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified interconnect attachment with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchInterconnectAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on an InterconnectAttachment. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetLabelsInterconnectAttachmentRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectAttachments/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectAttachments",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod interconnect_locations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InterconnectLocations API.
    #[derive(Debug, Clone)]
    pub struct InterconnectLocationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InterconnectLocationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterconnectLocationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InterconnectLocationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the details for the specified interconnect location. Gets a list of available interconnect locations by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterconnectLocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectLocation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectLocations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectLocations",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of interconnect locations available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterconnectLocationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectLocationList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectLocations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectLocations",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod interconnect_remote_locations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The InterconnectRemoteLocations API.
    #[derive(Debug, Clone)]
    pub struct InterconnectRemoteLocationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InterconnectRemoteLocationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterconnectRemoteLocationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InterconnectRemoteLocationsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the details for the specified interconnect remote location. Gets a list of available interconnect remote locations by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterconnectRemoteLocationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectRemoteLocation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectRemoteLocations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectRemoteLocations",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of interconnect remote locations available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListInterconnectRemoteLocationsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectRemoteLocationList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.InterconnectRemoteLocations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.InterconnectRemoteLocations",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod interconnects_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Interconnects API.
    #[derive(Debug, Clone)]
    pub struct InterconnectsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> InterconnectsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterconnectsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            InterconnectsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified Interconnect.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteInterconnectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Interconnects", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Interconnect. Get a list of available Interconnects by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInterconnectRequest>,
        ) -> std::result::Result<tonic::Response<super::Interconnect>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Interconnects", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the interconnectDiagnostics for the specified Interconnect. In the event of a global outage, do not use this API to make decisions about where to redirect your network traffic. Unlike a VLAN attachment, which is regional, a Cloud Interconnect connection is a global resource. A global outage can prevent this API from functioning properly.
        pub async fn get_diagnostics(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDiagnosticsInterconnectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectsGetDiagnosticsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/GetDiagnostics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Interconnects",
                        "GetDiagnostics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the interconnectMacsecConfig for the specified Interconnect.
        pub async fn get_macsec_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMacsecConfigInterconnectRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectsGetMacsecConfigResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/GetMacsecConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Interconnects",
                        "GetMacsecConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an Interconnect in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertInterconnectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Interconnects", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of Interconnects available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListInterconnectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InterconnectList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Interconnects", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified Interconnect with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchInterconnectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Interconnects", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on an Interconnect. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsInterconnectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Interconnects/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Interconnects", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod license_codes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The LicenseCodes API.
    #[derive(Debug, Clone)]
    pub struct LicenseCodesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LicenseCodesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LicenseCodesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LicenseCodesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Return a specified license code. License codes are mirrored across all projects that have permissions to read the License Code. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLicenseCodeRequest>,
        ) -> std::result::Result<tonic::Response<super::LicenseCode>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.LicenseCodes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.LicenseCodes", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsLicenseCodeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.LicenseCodes/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.LicenseCodes",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod licenses_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Licenses API.
    #[derive(Debug, Clone)]
    pub struct LicensesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> LicensesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> LicensesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            LicensesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified license. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteLicenseRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Licenses", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified License resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetLicenseRequest>,
        ) -> std::result::Result<tonic::Response<super::License>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Licenses", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyLicenseRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Licenses", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a License resource in the specified project. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertLicenseRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Licenses", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of licenses available in the specified project. This method does not get any licenses that belong to other projects, including licenses attached to publicly-available images, like Debian 9. If you want to get a list of publicly-available licenses, use this method to make a request to the respective image project, such as debian-cloud or windows-cloud. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLicensesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::LicensesListResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Licenses", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyLicenseRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Licenses", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsLicenseRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Licenses/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Licenses",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod machine_images_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The MachineImages API.
    #[derive(Debug, Clone)]
    pub struct MachineImagesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MachineImagesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineImagesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MachineImagesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified machine image. Deleting a machine image is permanent and cannot be undone.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteMachineImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.MachineImages", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified machine image.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMachineImageRequest>,
        ) -> std::result::Result<tonic::Response<super::MachineImage>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.MachineImages", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyMachineImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.MachineImages",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a machine image in the specified project using the data that is included in the request. If you are creating a new machine image to update an existing instance, your new machine image should use the same network or, if applicable, the same subnetwork as the original instance.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertMachineImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.MachineImages", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of machine images that are contained within the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMachineImagesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MachineImageList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.MachineImages", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyMachineImageRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.MachineImages",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsMachineImageRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineImages/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.MachineImages",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod machine_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The MachineTypes API.
    #[derive(Debug, Clone)]
    pub struct MachineTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> MachineTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MachineTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            MachineTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of machine types. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListMachineTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MachineTypeAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineTypes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.MachineTypes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified machine type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMachineTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::MachineType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.MachineTypes", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of machine types available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMachineTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MachineTypeList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.MachineTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.MachineTypes", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod network_attachments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NetworkAttachments API.
    #[derive(Debug, Clone)]
    pub struct NetworkAttachmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworkAttachmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkAttachmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworkAttachmentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all NetworkAttachment resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListNetworkAttachmentsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkAttachmentAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified NetworkAttachment in the given scope
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified NetworkAttachment resource in the given scope.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NetworkAttachments", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyNetworkAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a NetworkAttachment in the specified project in the given scope using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNetworkAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the NetworkAttachments for a project in the given scope.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworkAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkAttachmentList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NetworkAttachments", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified NetworkAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchNetworkAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyNetworkAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsNetworkAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkAttachments/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkAttachments",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod network_edge_security_services_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NetworkEdgeSecurityServices API.
    #[derive(Debug, Clone)]
    pub struct NetworkEdgeSecurityServicesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworkEdgeSecurityServicesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkEdgeSecurityServicesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworkEdgeSecurityServicesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all NetworkEdgeSecurityService resources available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListNetworkEdgeSecurityServicesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEdgeSecurityServiceAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEdgeSecurityServices/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEdgeSecurityServices",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified service.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteNetworkEdgeSecurityServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEdgeSecurityServices",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a specified NetworkEdgeSecurityService.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkEdgeSecurityServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEdgeSecurityService>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEdgeSecurityServices",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new service in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertNetworkEdgeSecurityServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEdgeSecurityServices",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified policy with the data included in the request.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchNetworkEdgeSecurityServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEdgeSecurityServices",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod network_endpoint_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NetworkEndpointGroups API.
    #[derive(Debug, Clone)]
    pub struct NetworkEndpointGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworkEndpointGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkEndpointGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworkEndpointGroupsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of network endpoint groups and sorts them by zone. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Attach a list of network endpoints to the specified network endpoint group.
        pub async fn attach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AttachNetworkEndpointsNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/AttachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "AttachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified network endpoint group. The network endpoints in the NEG and the VM instances they belong to are not terminated when the NEG is deleted. Note that the NEG cannot be deleted if there are backend services referencing it.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkEndpointGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Detach a list of network endpoints from the specified network endpoint group.
        pub async fn detach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DetachNetworkEndpointsNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/DetachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "DetachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network endpoint group.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a network endpoint group in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNetworkEndpointGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of network endpoint groups that are located in the specified project and zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworkEndpointGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the network endpoints in the specified network endpoint group.
        pub async fn list_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListNetworkEndpointsNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupsListNetworkEndpoints>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/ListNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "ListNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkEndpointGroups/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkEndpointGroups",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod network_firewall_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NetworkFirewallPolicies API.
    #[derive(Debug, Clone)]
    pub struct NetworkFirewallPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworkFirewallPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworkFirewallPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworkFirewallPoliciesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inserts an association for the specified firewall policy.
        pub async fn add_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AddAssociationNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/AddAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "AddAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a rule into a firewall policy.
        pub async fn add_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::AddRuleNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/AddRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "AddRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Copies rules to the specified firewall policy.
        pub async fn clone_rules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CloneRulesNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/CloneRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "CloneRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network firewall policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an association with the specified name.
        pub async fn get_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetAssociationNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/GetAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "GetAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetIamPolicyNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a rule of the specified priority.
        pub async fn get_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuleNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/GetRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "GetRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new policy in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the policies that have been configured for the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworkFirewallPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified policy with the data included in the request.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchNetworkFirewallPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches a rule of the specified priority.
        pub async fn patch_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchRuleNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/PatchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "PatchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes an association for the specified firewall policy.
        pub async fn remove_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveAssociationNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/RemoveAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "RemoveAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a rule of the specified priority.
        pub async fn remove_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveRuleNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/RemoveRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "RemoveRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetIamPolicyNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NetworkFirewallPolicies/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NetworkFirewallPolicies",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod networks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Networks API.
    #[derive(Debug, Clone)]
    pub struct NetworksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NetworksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NetworksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NetworksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds a peering to the specified network.
        pub async fn add_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::AddPeeringNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/AddPeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Networks", "AddPeering"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified network.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Networks", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Network>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Networks", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the effective firewalls on a given network.
        pub async fn get_effective_firewalls(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEffectiveFirewallsNetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworksGetEffectiveFirewallsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/GetEffectiveFirewalls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Networks",
                        "GetEffectiveFirewalls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a network in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Networks", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of networks available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNetworksRequest>,
        ) -> std::result::Result<tonic::Response<super::NetworkList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Networks", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the peering routes exchanged over peering connection.
        pub async fn list_peering_routes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPeeringRoutesNetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExchangedPeeringRoutesList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/ListPeeringRoutes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Networks",
                        "ListPeeringRoutes",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified network with the data included in the request. Only the following fields can be modified: routingConfig.routingMode.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Networks", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes a peering from the specified network.
        pub async fn remove_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::RemovePeeringNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/RemovePeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Networks", "RemovePeering"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Switches the network mode from auto subnet mode to custom subnet mode.
        pub async fn switch_to_custom_mode(
            &mut self,
            request: impl tonic::IntoRequest<super::SwitchToCustomModeNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/SwitchToCustomMode",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Networks",
                        "SwitchToCustomMode",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified network peering with the data included in the request. You can only modify the NetworkPeering.export_custom_routes field and the NetworkPeering.import_custom_routes field.
        pub async fn update_peering(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePeeringNetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Networks/UpdatePeering",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Networks", "UpdatePeering"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod node_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NodeGroups API.
    #[derive(Debug, Clone)]
    pub struct NodeGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NodeGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NodeGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NodeGroupsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds specified number of nodes to the node group.
        pub async fn add_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::AddNodesNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/AddNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "AddNodes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes for more details about each group. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListNodeGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NodeGroupAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeGroups",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified NodeGroup resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Deletes specified nodes from the node group.
        pub async fn delete_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNodesNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/DeleteNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "DeleteNodes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified NodeGroup. Get a list of available NodeGroups by making a list() request. Note: the "nodes" field should not be used. Use nodeGroups.listNodes instead.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a NodeGroup resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of node groups available to the specified project. Note: use nodeGroups.listNodes for more details about each group.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodeGroupsRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeGroupList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists nodes in the node group.
        pub async fn list_nodes(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodesNodeGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NodeGroupsListNodes>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/ListNodes",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "ListNodes"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified node group.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Perform maintenance on a subset of nodes in the node group.
        pub async fn perform_maintenance(
            &mut self,
            request: impl tonic::IntoRequest<super::PerformMaintenanceNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/PerformMaintenance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeGroups",
                        "PerformMaintenance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeGroups", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the node template of the node group.
        pub async fn set_node_template(
            &mut self,
            request: impl tonic::IntoRequest<super::SetNodeTemplateNodeGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/SetNodeTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeGroups",
                        "SetNodeTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Simulates maintenance event on specified nodes from the node group.
        pub async fn simulate_maintenance_event(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SimulateMaintenanceEventNodeGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/SimulateMaintenanceEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeGroups",
                        "SimulateMaintenanceEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsNodeGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeGroups/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeGroups",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod node_templates_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NodeTemplates API.
    #[derive(Debug, Clone)]
    pub struct NodeTemplatesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NodeTemplatesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NodeTemplatesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NodeTemplatesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of node templates. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListNodeTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NodeTemplateAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeTemplates",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified NodeTemplate resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteNodeTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeTemplates", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified node template.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeTemplate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeTemplates", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyNodeTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeTemplates",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a NodeTemplate resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertNodeTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeTemplates", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of node templates available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodeTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NodeTemplateList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.NodeTemplates", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyNodeTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeTemplates",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsNodeTemplateRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTemplates/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeTemplates",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod node_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The NodeTypes API.
    #[derive(Debug, Clone)]
    pub struct NodeTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> NodeTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> NodeTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            NodeTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of node types. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListNodeTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NodeTypeAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTypes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.NodeTypes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified node type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNodeTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeTypes", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of node types available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListNodeTypesRequest>,
        ) -> std::result::Result<tonic::Response<super::NodeTypeList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.NodeTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.NodeTypes", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod packet_mirrorings_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The PacketMirrorings API.
    #[derive(Debug, Clone)]
    pub struct PacketMirroringsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PacketMirroringsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PacketMirroringsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PacketMirroringsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of packetMirrorings. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListPacketMirroringsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PacketMirroringAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PacketMirrorings",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified PacketMirroring resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePacketMirroringRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.PacketMirrorings", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified PacketMirroring resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPacketMirroringRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PacketMirroring>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.PacketMirrorings", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a PacketMirroring resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertPacketMirroringRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.PacketMirrorings", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of PacketMirroring resources available to the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPacketMirroringsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PacketMirroringList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.PacketMirrorings", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified PacketMirroring resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchPacketMirroringRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.PacketMirrorings", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsPacketMirroringRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PacketMirrorings/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PacketMirrorings",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod projects_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Projects API.
    #[derive(Debug, Clone)]
    pub struct ProjectsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ProjectsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ProjectsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ProjectsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Disable this project as a shared VPC host project.
        pub async fn disable_xpn_host(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableXpnHostProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/DisableXpnHost",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Projects", "DisableXpnHost"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Disable a service resource (also known as service project) associated with this host project.
        pub async fn disable_xpn_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::DisableXpnResourceProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/DisableXpnResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "DisableXpnResource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enable this project as a shared VPC host project.
        pub async fn enable_xpn_host(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableXpnHostProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/EnableXpnHost",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Projects", "EnableXpnHost"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enable service resource (a.k.a service project) for a host project, so that subnets in the host project can be used by instances in the service project.
        pub async fn enable_xpn_resource(
            &mut self,
            request: impl tonic::IntoRequest<super::EnableXpnResourceProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/EnableXpnResource",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "EnableXpnResource",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Project resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Project>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Projects", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the shared VPC host project that this project links to. May be empty if no link exists.
        pub async fn get_xpn_host(
            &mut self,
            request: impl tonic::IntoRequest<super::GetXpnHostProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Project>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/GetXpnHost",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Projects", "GetXpnHost"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets service resources (a.k.a service project) associated with this host project.
        pub async fn get_xpn_resources(
            &mut self,
            request: impl tonic::IntoRequest<super::GetXpnResourcesProjectsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProjectsGetXpnResources>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/GetXpnResources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "GetXpnResources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all shared VPC host projects visible to the user in an organization.
        pub async fn list_xpn_hosts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListXpnHostsProjectsRequest>,
        ) -> std::result::Result<tonic::Response<super::XpnHostList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/ListXpnHosts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Projects", "ListXpnHosts"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Moves a persistent disk from one zone to another.
        pub async fn move_disk(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveDiskProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/MoveDisk",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Projects", "MoveDisk"));
            self.inner.unary(req, path, codec).await
        }
        /// Moves an instance and its attached persistent disks from one zone to another. *Note*: Moving VMs or disks by using this method might cause unexpected behavior. For more information, see the [known issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior). \[Deprecated\] This method is deprecated. See [moving instance across zones](/compute/docs/instances/moving-instance-across-zones) instead.
        pub async fn move_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::MoveInstanceProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/MoveInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Projects", "MoveInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the billing account of the project must be subscribed to Cloud Armor Enterprise. See Subscribing to Cloud Armor Enterprise for more information.
        pub async fn set_cloud_armor_tier(
            &mut self,
            request: impl tonic::IntoRequest<super::SetCloudArmorTierProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/SetCloudArmorTier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "SetCloudArmorTier",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets metadata common to all instances within the specified project using the data included in the request.
        pub async fn set_common_instance_metadata(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetCommonInstanceMetadataProjectRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/SetCommonInstanceMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "SetCommonInstanceMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the default network tier of the project. The default network tier is used when an address/forwardingRule/instance is created without specifying the network tier field.
        pub async fn set_default_network_tier(
            &mut self,
            request: impl tonic::IntoRequest<super::SetDefaultNetworkTierProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/SetDefaultNetworkTier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "SetDefaultNetworkTier",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Enables the usage export feature and sets the usage export bucket where reports are stored. If you provide an empty request body using this method, the usage export feature will be disabled.
        pub async fn set_usage_export_bucket(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUsageExportBucketProjectRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Projects/SetUsageExportBucket",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Projects",
                        "SetUsageExportBucket",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod public_advertised_prefixes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The PublicAdvertisedPrefixes API.
    #[derive(Debug, Clone)]
    pub struct PublicAdvertisedPrefixesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PublicAdvertisedPrefixesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PublicAdvertisedPrefixesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PublicAdvertisedPrefixesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Announces the specified PublicAdvertisedPrefix
        pub async fn announce(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AnnouncePublicAdvertisedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Announce",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Announce",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified PublicAdvertisedPrefix
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePublicAdvertisedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified PublicAdvertisedPrefix resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPublicAdvertisedPrefixeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublicAdvertisedPrefix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a PublicAdvertisedPrefix in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertPublicAdvertisedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the PublicAdvertisedPrefixes for a project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPublicAdvertisedPrefixesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublicAdvertisedPrefixList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchPublicAdvertisedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Withdraws the specified PublicAdvertisedPrefix
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<
                super::WithdrawPublicAdvertisedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Withdraw",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicAdvertisedPrefixes",
                        "Withdraw",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod public_delegated_prefixes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The PublicDelegatedPrefixes API.
    #[derive(Debug, Clone)]
    pub struct PublicDelegatedPrefixesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PublicDelegatedPrefixesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PublicDelegatedPrefixesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PublicDelegatedPrefixesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all PublicDelegatedPrefix resources owned by the specific project across all scopes. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListPublicDelegatedPrefixesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::PublicDelegatedPrefixAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Announces the specified PublicDelegatedPrefix in the given region.
        pub async fn announce(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AnnouncePublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Announce",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Announce",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified PublicDelegatedPrefix in the given region.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePublicDelegatedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified PublicDelegatedPrefix resource in the given region.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPublicDelegatedPrefixeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublicDelegatedPrefix>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a PublicDelegatedPrefix in the specified project in the given region using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertPublicDelegatedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the PublicDelegatedPrefixes for a project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPublicDelegatedPrefixesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PublicDelegatedPrefixList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchPublicDelegatedPrefixeRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Withdraws the specified PublicDelegatedPrefix in the given region.
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<
                super::WithdrawPublicDelegatedPrefixeRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.PublicDelegatedPrefixes/Withdraw",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.PublicDelegatedPrefixes",
                        "Withdraw",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_autoscalers_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionAutoscalers API.
    #[derive(Debug, Clone)]
    pub struct RegionAutoscalersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionAutoscalersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionAutoscalersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionAutoscalersClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified autoscaler.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionAutoscalers",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified autoscaler.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Autoscaler>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionAutoscalers", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an autoscaler in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionAutoscalers",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of autoscalers contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionAutoscalersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegionAutoscalerList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionAutoscalers", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionAutoscalers", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an autoscaler in the specified project using the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionAutoscalerRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionAutoscalers/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionAutoscalers",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_backend_services_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionBackendServices API.
    #[derive(Debug, Clone)]
    pub struct RegionBackendServicesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionBackendServicesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionBackendServicesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionBackendServicesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified regional BackendService resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified regional BackendService resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::BackendService>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the most recent health check results for this regional BackendService.
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthRegionBackendServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceGroupHealth>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "GetHealth",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetIamPolicyRegionBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a regional BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of regional BackendService resources available to the specified project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionBackendServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of all usable backend services in the specified project in the given region.
        pub async fn list_usable(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListUsableRegionBackendServicesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::BackendServiceListUsable>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/ListUsable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "ListUsable",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified regional BackendService resource with the data included in the request. For more information, see Understanding backend services This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetIamPolicyRegionBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview
        pub async fn set_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSecurityPolicyRegionBackendServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/SetSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "SetSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsRegionBackendServiceRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified regional BackendService resource with the data included in the request. For more information, see Backend services overview .
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionBackendServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionBackendServices/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionBackendServices",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_commitments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionCommitments API.
    #[derive(Debug, Clone)]
    pub struct RegionCommitmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionCommitmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionCommitmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionCommitmentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of commitments by region. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListRegionCommitmentsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::CommitmentAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionCommitments/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionCommitments",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified commitment resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Commitment>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionCommitments/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionCommitments", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a commitment in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionCommitments/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionCommitments",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of commitments contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionCommitmentsRequest>,
        ) -> std::result::Result<tonic::Response<super::CommitmentList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionCommitments/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionCommitments", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified commitment with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: auto_renew.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionCommitmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionCommitments/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionCommitments",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_disk_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionDiskTypes API.
    #[derive(Debug, Clone)]
    pub struct RegionDiskTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionDiskTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionDiskTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionDiskTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the specified regional disk type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionDiskTypeRequest>,
        ) -> std::result::Result<tonic::Response<super::DiskType>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDiskTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDiskTypes", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of regional disk types available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionDiskTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegionDiskTypeList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDiskTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDiskTypes", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_disks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionDisks API.
    #[derive(Debug, Clone)]
    pub struct RegionDisksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionDisksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionDisksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionDisksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds existing resource policies to a regional disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation.
        pub async fn add_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<super::AddResourcePoliciesRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/AddResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "AddResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Bulk create a set of disks.
        pub async fn bulk_insert(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkInsertRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/BulkInsert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "BulkInsert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating snapshots in a project different from the source disk project.
        pub async fn create_snapshot(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSnapshotRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/CreateSnapshot",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "CreateSnapshot",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified regional persistent disk. Deleting a regional disk removes all the replicas of its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the disk. You must separately delete snapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a specified regional persistent disk.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Disk>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a persistent regional disk in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of persistent disks contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionDisksRequest>,
        ) -> std::result::Result<tonic::Response<super::DiskList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes resource policies from a regional disk.
        pub async fn remove_resource_policies(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveResourcePoliciesRegionDiskRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/RemoveResourcePolicies",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "RemoveResourcePolicies",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resizes the specified regional persistent disk.
        pub async fn resize(
            &mut self,
            request: impl tonic::IntoRequest<super::ResizeRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/Resize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "Resize"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on the target regional disk.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Starts asynchronous replication. Must be invoked on the primary disk.
        pub async fn start_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<
                super::StartAsyncReplicationRegionDiskRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/StartAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "StartAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk.
        pub async fn stop_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<
                super::StopAsyncReplicationRegionDiskRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/StopAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "StopAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope.
        pub async fn stop_group_async_replication(
            &mut self,
            request: impl tonic::IntoRequest<
                super::StopGroupAsyncReplicationRegionDiskRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/StopGroupAsyncReplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "StopGroupAsyncReplication",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsRegionDiskRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionDisks",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the specified disk with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: user_license.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionDiskRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionDisks/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionDisks", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_health_check_services_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionHealthCheckServices API.
    #[derive(Debug, Clone)]
    pub struct RegionHealthCheckServicesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionHealthCheckServicesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionHealthCheckServicesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionHealthCheckServicesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified regional HealthCheckService.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRegionHealthCheckServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthCheckServices/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthCheckServices",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified regional HealthCheckService resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionHealthCheckServiceRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckService>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthCheckServices/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthCheckServices",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a regional HealthCheckService resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertRegionHealthCheckServiceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthCheckServices/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthCheckServices",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the HealthCheckService resources that have been configured for the specified project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionHealthCheckServicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckServicesList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthCheckServices/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthCheckServices",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified regional HealthCheckService resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionHealthCheckServiceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthCheckServices/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthCheckServices",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_health_checks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionHealthChecks API.
    #[derive(Debug, Clone)]
    pub struct RegionHealthChecksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionHealthChecksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionHealthChecksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionHealthChecksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified HealthCheck resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthChecks",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified HealthCheck resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::HealthCheck>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionHealthChecks", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a HealthCheck resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthChecks",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of HealthCheck resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionHealthChecksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::HealthCheckList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionHealthChecks", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthChecks",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a HealthCheck resource in the specified project using the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionHealthCheckRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionHealthChecks/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionHealthChecks",
                        "Update",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_instance_group_managers_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionInstanceGroupManagers API.
    #[derive(Debug, Clone)]
    pub struct RegionInstanceGroupManagersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionInstanceGroupManagersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionInstanceGroupManagersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionInstanceGroupManagersClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Flags the specified instances to be immediately removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn abandon_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AbandonInstancesRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/AbandonInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "AbandonInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Apply updates to selected instances the managed instance group.
        pub async fn apply_updates_to_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/ApplyUpdatesToInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "ApplyUpdatesToInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates instances with per-instance configurations in this regional managed instance group. Instances are created using the current instance template. The create instances operation is marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the listmanagedinstances method.
        pub async fn create_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateInstancesRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/CreateInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "CreateInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified managed instance group and all of the instances in that group.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Flags the specified instances in the managed instance group to be immediately deleted. The instances are also removed from any target pools of which they were a member. This method reduces the targetSize of the managed instance group by the number of instances that you delete. The deleteInstances operation is marked DONE if the deleteInstances request is successful. The underlying actions take additional time. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn delete_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteInstancesRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/DeleteInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "DeleteInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes selected per-instance configurations for the managed instance group.
        pub async fn delete_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeletePerInstanceConfigsRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/DeletePerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "DeletePerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all of the details about the specified managed instance group.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionInstanceGroupManagerRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceGroupManager>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the individual instances with the listmanagedinstances method. A regional managed instance group can contain up to 2000 instances.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of managed instance groups that are contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRegionInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupManagerList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all errors thrown by actions on instances for a given regional managed instance group. The filter and orderBy query parameters are not supported.
        pub async fn list_errors(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListErrorsRegionInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupManagersListErrorsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListErrors",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "ListErrors",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the instances in the managed instance group and instances that are scheduled to be created. The list includes any current actions that the group has scheduled for its instances. The orderBy query parameter is not supported. The `pageToken` query parameter is supported only if the group's `listManagedInstancesResults` field is set to `PAGINATED`.
        pub async fn list_managed_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListManagedInstancesRegionInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupManagersListInstancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListManagedInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "ListManagedInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported.
        pub async fn list_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListPerInstanceConfigsRegionInstanceGroupManagersRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupManagersListInstanceConfigsResp>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListPerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "ListPerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are still in the process of being patched. You must separately verify the status of the individual instances with the listmanagedinstances method. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
        pub async fn patch_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchPerInstanceConfigsRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/PatchPerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "PatchPerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
        pub async fn recreate_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RecreateInstancesRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/RecreateInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "RecreateInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the intended size of the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes one or more instances. The resize operation is marked DONE if the resize request is successful. The underlying actions take additional time. You must separately verify the status of the creating or deleting actions with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
        pub async fn resize(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ResizeRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/Resize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "Resize",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the instance template to use when creating new instances or recreating instances in this group. Existing instances are not affected.
        pub async fn set_instance_template(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetInstanceTemplateRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/SetInstanceTemplate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "SetInstanceTemplate",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modifies the target pools to which all new instances in this group are assigned. Existing instances in the group are not affected.
        pub async fn set_target_pools(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetTargetPoolsRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/SetTargetPools",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "SetTargetPools",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch.
        pub async fn update_per_instance_configs(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroupManagers/UpdatePerInstanceConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroupManagers",
                        "UpdatePerInstanceConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_instance_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionInstanceGroups API.
    #[derive(Debug, Clone)]
    pub struct RegionInstanceGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionInstanceGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionInstanceGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionInstanceGroupsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the specified instance group resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionInstanceGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::InstanceGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroups",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of instance group resources contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionInstanceGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroups",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the instances in the specified instance group and displays information about the named ports. Depending on the specified options, this method can list all instances or only the instances that are running. The orderBy query parameter is not supported.
        pub async fn list_instances(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListInstancesRegionInstanceGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RegionInstanceGroupsListInstances>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroups/ListInstances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroups",
                        "ListInstances",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the named ports for the specified regional instance group.
        pub async fn set_named_ports(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetNamedPortsRegionInstanceGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceGroups/SetNamedPorts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceGroups",
                        "SetNamedPorts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_instance_templates_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionInstanceTemplates API.
    #[derive(Debug, Clone)]
    pub struct RegionInstanceTemplatesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionInstanceTemplatesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionInstanceTemplatesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionInstanceTemplatesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceTemplates/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceTemplates",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified instance template.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionInstanceTemplateRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceTemplate>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceTemplates/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceTemplates",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instance template in the specified project and region using the global instance template whose URL is included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionInstanceTemplateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceTemplates/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceTemplates",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of instance templates that are contained within the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionInstanceTemplatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstanceTemplateList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstanceTemplates/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstanceTemplates",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_instances_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionInstances API.
    #[derive(Debug, Clone)]
    pub struct RegionInstancesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionInstancesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionInstancesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionInstancesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates multiple instances in a given region. Count specifies the number of instances to create.
        pub async fn bulk_insert(
            &mut self,
            request: impl tonic::IntoRequest<super::BulkInsertRegionInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstances/BulkInsert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstances",
                        "BulkInsert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_instant_snapshots_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionInstantSnapshots API.
    #[derive(Debug, Clone)]
    pub struct RegionInstantSnapshotsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionInstantSnapshotsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionInstantSnapshotsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionInstantSnapshotsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified InstantSnapshot resource. Keep in mind that deleting a single instantSnapshot might not necessarily delete all the data on that instantSnapshot. If any data on the instantSnapshot that is marked for deletion is needed for subsequent instantSnapshots, the data will be moved to the next corresponding instantSnapshot. For more information, see Deleting instantSnapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified InstantSnapshot resource in the specified region.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionInstantSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstantSnapshot>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetIamPolicyRegionInstantSnapshotRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an instant snapshot in the specified region.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionInstantSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of InstantSnapshot resources contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionInstantSnapshotsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::InstantSnapshotList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetIamPolicyRegionInstantSnapshotRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a instantSnapshot in the given region. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetLabelsRegionInstantSnapshotRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsRegionInstantSnapshotRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionInstantSnapshots/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionInstantSnapshots",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_network_endpoint_groups_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionNetworkEndpointGroups API.
    #[derive(Debug, Clone)]
    pub struct RegionNetworkEndpointGroupsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionNetworkEndpointGroupsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionNetworkEndpointGroupsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionNetworkEndpointGroupsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Attach a list of network endpoints to the specified network endpoint group.
        pub async fn attach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AttachNetworkEndpointsRegionNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/AttachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "AttachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified network endpoint group. Note that the NEG cannot be deleted if it is configured as a backend of a backend service.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRegionNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Detach the network endpoint from the specified network endpoint group.
        pub async fn detach_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DetachNetworkEndpointsRegionNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/DetachNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "DetachNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network endpoint group.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionNetworkEndpointGroupRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroup>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a network endpoint group in the specified project using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertRegionNetworkEndpointGroupRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of regional network endpoint groups available to the specified project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRegionNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the network endpoints in the specified network endpoint group.
        pub async fn list_network_endpoints(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListNetworkEndpointsRegionNetworkEndpointGroupsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NetworkEndpointGroupsListNetworkEndpoints>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkEndpointGroups/ListNetworkEndpoints",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkEndpointGroups",
                        "ListNetworkEndpoints",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_network_firewall_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionNetworkFirewallPolicies API.
    #[derive(Debug, Clone)]
    pub struct RegionNetworkFirewallPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionNetworkFirewallPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionNetworkFirewallPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionNetworkFirewallPoliciesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inserts an association for the specified network firewall policy.
        pub async fn add_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AddAssociationRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/AddAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "AddAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Inserts a rule into a network firewall policy.
        pub async fn add_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AddRuleRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/AddRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "AddRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Copies rules to the specified network firewall policy.
        pub async fn clone_rules(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CloneRulesRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/CloneRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "CloneRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified network firewall policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified network firewall policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::FirewallPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an association with the specified name.
        pub async fn get_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetAssociationRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyAssociation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "GetAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the effective firewalls on a given network.
        pub async fn get_effective_firewalls(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetEffectiveFirewalls",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "GetEffectiveFirewalls",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetIamPolicyRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a rule of the specified priority.
        pub async fn get_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetRuleRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "GetRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new network firewall policy in the specified project and region.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the network firewall policies that have been configured for the specified project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRegionNetworkFirewallPoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FirewallPolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified network firewall policy.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches a rule of the specified priority.
        pub async fn patch_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::PatchRuleRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/PatchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "PatchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes an association for the specified network firewall policy.
        pub async fn remove_association(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveAssociationRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/RemoveAssociation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "RemoveAssociation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a rule of the specified priority.
        pub async fn remove_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveRuleRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/RemoveRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "RemoveRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetIamPolicyRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsRegionNetworkFirewallPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_notification_endpoints_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionNotificationEndpoints API.
    #[derive(Debug, Clone)]
    pub struct RegionNotificationEndpointsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionNotificationEndpointsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionNotificationEndpointsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionNotificationEndpointsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified NotificationEndpoint in the given region
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRegionNotificationEndpointRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNotificationEndpoints/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNotificationEndpoints",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified NotificationEndpoint resource in the given region.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionNotificationEndpointRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NotificationEndpoint>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNotificationEndpoints/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNotificationEndpoints",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a NotificationEndpoint in the specified project in the given region using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<
                super::InsertRegionNotificationEndpointRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNotificationEndpoints/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNotificationEndpoints",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the NotificationEndpoints for a project in the given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListRegionNotificationEndpointsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::NotificationEndpointList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionNotificationEndpoints/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionNotificationEndpoints",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_operations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionOperations API.
    #[derive(Debug, Clone)]
    pub struct RegionOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionOperationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified region-specific Operations resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteRegionOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionOperations/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionOperations", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified region-specific Operations resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionOperations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionOperations", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of Operation resources contained within the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionOperationsRequest>,
        ) -> std::result::Result<tonic::Response<super::OperationList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionOperations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionOperations", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
        pub async fn wait(
            &mut self,
            request: impl tonic::IntoRequest<super::WaitRegionOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionOperations/Wait",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionOperations", "Wait"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_security_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionSecurityPolicies API.
    #[derive(Debug, Clone)]
    pub struct RegionSecurityPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionSecurityPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionSecurityPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionSecurityPoliciesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inserts a rule into a security policy.
        pub async fn add_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::AddRuleRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/AddRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "AddRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all of the ordered rules present in a single specified policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::SecurityPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a rule at the specified priority.
        pub async fn get_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuleRegionSecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/GetRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "GetRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new policy in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all the policies that have been configured for the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionSecurityPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityPolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified policy with the data included in the request. To clear fields in the policy, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches a rule at the specified priority. To clear fields in the rule, leave the fields empty and specify them in the updateMask.
        pub async fn patch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRuleRegionSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/PatchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "PatchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a rule at the specified priority.
        pub async fn remove_rule(
            &mut self,
            request: impl tonic::IntoRequest<
                super::RemoveRuleRegionSecurityPolicyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSecurityPolicies/RemoveRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSecurityPolicies",
                        "RemoveRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_ssl_certificates_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionSslCertificates API.
    #[derive(Debug, Clone)]
    pub struct RegionSslCertificatesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionSslCertificatesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionSslCertificatesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionSslCertificatesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified SslCertificate resource in the region.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslCertificates/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslCertificates",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified SslCertificate resource in the specified region. Get a list of available SSL certificates by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::SslCertificate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslCertificates/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslCertificates",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a SslCertificate resource in the specified project and region using the data included in the request
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslCertificates/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslCertificates",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of SslCertificate resources available to the specified project in the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionSslCertificatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertificateList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslCertificates/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslCertificates",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_ssl_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionSslPolicies API.
    #[derive(Debug, Clone)]
    pub struct RegionSslPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionSslPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionSslPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionSslPoliciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslPolicies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the ordered rules present in a single specified policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::SslPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionSslPolicies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new policy in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslPolicies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the SSL policies that have been configured for the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionSslPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslPoliciesList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionSslPolicies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all features that can be specified in the SSL policy when using custom profile.
        pub async fn list_available_features(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListAvailableFeaturesRegionSslPoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SslPoliciesListAvailableFeaturesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/ListAvailableFeatures",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionSslPolicies",
                        "ListAvailableFeatures",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified SSL policy with the data included in the request.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionSslPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionSslPolicies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_target_http_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionTargetHttpProxies API.
    #[derive(Debug, Clone)]
    pub struct RegionTargetHttpProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionTargetHttpProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionTargetHttpProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionTargetHttpProxiesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified TargetHttpProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetHttpProxy resource in the specified region.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionTargetHttpProxyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpProxy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpProxies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetHttpProxy resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetHttpProxy resources available to the specified project in the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionTargetHttpProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpProxies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the URL map for TargetHttpProxy.
        pub async fn set_url_map(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetUrlMapRegionTargetHttpProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpProxies/SetUrlMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpProxies",
                        "SetUrlMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_target_https_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionTargetHttpsProxies API.
    #[derive(Debug, Clone)]
    pub struct RegionTargetHttpsProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionTargetHttpsProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionTargetHttpsProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionTargetHttpsProxiesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified TargetHttpsProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetHttpsProxy resource in the specified region.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionTargetHttpsProxyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpsProxy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetHttpsProxy resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetHttpsProxy resources available to the specified project in the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionTargetHttpsProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpsProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified regional TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replaces SslCertificates for TargetHttpsProxy.
        pub async fn set_ssl_certificates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSslCertificatesRegionTargetHttpsProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/SetSslCertificates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "SetSslCertificates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the URL map for TargetHttpsProxy.
        pub async fn set_url_map(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetUrlMapRegionTargetHttpsProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetHttpsProxies/SetUrlMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetHttpsProxies",
                        "SetUrlMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_target_tcp_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionTargetTcpProxies API.
    #[derive(Debug, Clone)]
    pub struct RegionTargetTcpProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionTargetTcpProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionTargetTcpProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionTargetTcpProxiesClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified TargetTcpProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetTcpProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetTcpProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetTcpProxy resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetTcpProxy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetTcpProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetTcpProxies",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetTcpProxy resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetTcpProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetTcpProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of TargetTcpProxy resources available to the specified project in a given region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionTargetTcpProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetTcpProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionTargetTcpProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.RegionTargetTcpProxies",
                        "List",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_url_maps_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionUrlMaps API.
    #[derive(Debug, Clone)]
    pub struct RegionUrlMapsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionUrlMapsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionUrlMapsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionUrlMapsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified UrlMap resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRegionUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified UrlMap resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::UrlMap>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a UrlMap resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRegionUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of UrlMap resources available to the specified project in the specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionUrlMapsRequest>,
        ) -> std::result::Result<tonic::Response<super::UrlMapList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRegionUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified UrlMap resource with the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRegionUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap.
        pub async fn validate(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateRegionUrlMapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UrlMapsValidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionUrlMaps/Validate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.RegionUrlMaps", "Validate"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod region_zones_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The RegionZones API.
    #[derive(Debug, Clone)]
    pub struct RegionZonesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionZonesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionZonesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionZonesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of Zone resources under the specific region available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionZonesRequest>,
        ) -> std::result::Result<tonic::Response<super::ZoneList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.RegionZones/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.RegionZones", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod regions_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Regions API.
    #[derive(Debug, Clone)]
    pub struct RegionsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RegionsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RegionsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RegionsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the specified Region resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRegionRequest>,
        ) -> std::result::Result<tonic::Response<super::Region>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Regions/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Regions", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of region resources available to the specified project. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is especially recommended for unused quota information (the `items.quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRegionsRequest>,
        ) -> std::result::Result<tonic::Response<super::RegionList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Regions/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Regions", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod reservations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Reservations API.
    #[derive(Debug, Clone)]
    pub struct ReservationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReservationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReservationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ReservationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of reservations. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReservationAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Reservations",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified reservation.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Reservations", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves information about the specified reservation.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Reservation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Reservations", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Reservations",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new reservation. For more information, read Reserving zonal resources.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Reservations", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// A list of all the reservations that have been configured for the specified project in specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListReservationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReservationList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Reservations", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Resizes the reservation (applicable to standalone reservations only). For more information, read Modifying reservations.
        pub async fn resize(
            &mut self,
            request: impl tonic::IntoRequest<super::ResizeReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/Resize",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Reservations", "Resize"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Reservations",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsReservationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Reservations",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update share settings of the reservation.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReservationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Reservations/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Reservations", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod resource_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ResourcePolicies API.
    #[derive(Debug, Clone)]
    pub struct ResourcePoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ResourcePoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ResourcePoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ResourcePoliciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of resource policies. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListResourcePoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ResourcePolicyAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ResourcePolicies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified resource policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ResourcePolicies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves all information of the specified resource policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::ResourcePolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ResourcePolicies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ResourcePolicies",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new resource policy.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ResourcePolicies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// A list all the resource policies that have been configured for the specified project in specified region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListResourcePoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ResourcePolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ResourcePolicies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Modify the specified resource policy.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ResourcePolicies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyResourcePolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ResourcePolicies",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsResourcePolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ResourcePolicies/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ResourcePolicies",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod routers_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Routers API.
    #[derive(Debug, Clone)]
    pub struct RoutersClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RoutersClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RoutersClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RoutersClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of routers. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListRoutersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RouterAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Routers", "AggregatedList"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified Router resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRouterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Router resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRouterRequest>,
        ) -> std::result::Result<tonic::Response<super::Router>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves runtime NAT IP information.
        pub async fn get_nat_ip_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNatIpInfoRouterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NatIpInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/GetNatIpInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Routers", "GetNatIpInfo"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves runtime Nat mapping information of VM endpoints.
        pub async fn get_nat_mapping_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetNatMappingInfoRoutersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VmEndpointNatMappingsList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/GetNatMappingInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Routers",
                        "GetNatMappingInfo",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves runtime information of the specified router.
        pub async fn get_router_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRouterStatusRouterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RouterStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/GetRouterStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Routers", "GetRouterStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Router resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRouterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of Router resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRoutersRequest>,
        ) -> std::result::Result<tonic::Response<super::RouterList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRouterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Preview fields auto-generated during router create and update operations. Calling this method does NOT create or update the router.
        pub async fn preview(
            &mut self,
            request: impl tonic::IntoRequest<super::PreviewRouterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RoutersPreviewResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Preview",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Preview"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified Router resource with the data included in the request. This method conforms to PUT semantics, which requests that the state of the target resource be created or replaced with the state defined by the representation enclosed in the request message payload.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRouterRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routers/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routers", "Update"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod routes_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Routes API.
    #[derive(Debug, Clone)]
    pub struct RoutesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RoutesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RoutesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RoutesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified Route resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routes/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routes", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Route resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::Route>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routes", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Route resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertRouteRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routes/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routes", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of Route resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRoutesRequest>,
        ) -> std::result::Result<tonic::Response<super::RouteList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Routes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Routes", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod security_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The SecurityPolicies API.
    #[derive(Debug, Clone)]
    pub struct SecurityPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SecurityPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SecurityPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SecurityPoliciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Inserts a rule into a security policy.
        pub async fn add_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::AddRuleSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/AddRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "AddRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of all SecurityPolicy resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListSecurityPoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SecurityPoliciesAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified policy.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SecurityPolicies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all of the ordered rules present in a single specified policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::SecurityPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SecurityPolicies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a rule at the specified priority.
        pub async fn get_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuleSecurityPolicyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityPolicyRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/GetRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "GetRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new policy in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SecurityPolicies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all the policies that have been configured for the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSecurityPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SecurityPolicyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SecurityPolicies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the current list of preconfigured Web Application Firewall (WAF) expressions.
        pub async fn list_preconfigured_expression_sets(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListPreconfiguredExpressionSetsSecurityPoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                super::SecurityPoliciesListPreconfiguredExpressionSetsResponse,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/ListPreconfiguredExpressionSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "ListPreconfiguredExpressionSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified policy with the data included in the request. To clear fields in the policy, leave the fields empty and specify them in the updateMask. This cannot be used to be update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SecurityPolicies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches a rule at the specified priority. To clear fields in the rule, leave the fields empty and specify them in the updateMask.
        pub async fn patch_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchRuleSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/PatchRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "PatchRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a rule at the specified priority.
        pub async fn remove_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveRuleSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/RemoveRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "RemoveRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a security policy. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsSecurityPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SecurityPolicies/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SecurityPolicies",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod service_attachments_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ServiceAttachments API.
    #[derive(Debug, Clone)]
    pub struct ServiceAttachmentsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ServiceAttachmentsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ServiceAttachmentsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ServiceAttachmentsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all ServiceAttachment resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListServiceAttachmentsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ServiceAttachmentAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified ServiceAttachment in the given scope
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteServiceAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified ServiceAttachment resource in the given scope.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetServiceAttachmentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceAttachment>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ServiceAttachments", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyServiceAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ServiceAttachment in the specified project in the given scope using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertServiceAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the ServiceAttachments for a project in the given scope.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListServiceAttachmentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ServiceAttachmentList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ServiceAttachments", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified ServiceAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchServiceAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyServiceAttachmentRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::TestIamPermissionsServiceAttachmentRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ServiceAttachments/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.ServiceAttachments",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod snapshot_settings_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The SnapshotSettings API.
    #[derive(Debug, Clone)]
    pub struct SnapshotSettingsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SnapshotSettingsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SnapshotSettingsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SnapshotSettingsServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Get snapshot settings.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSnapshotSettingRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SnapshotSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SnapshotSettingsService/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SnapshotSettingsService",
                        "Get",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patch snapshot settings.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchSnapshotSettingRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SnapshotSettingsService/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SnapshotSettingsService",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod snapshots_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Snapshots API.
    #[derive(Debug, Clone)]
    pub struct SnapshotsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SnapshotsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SnapshotsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SnapshotsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified Snapshot resource. Keep in mind that deleting a single snapshot might not necessarily delete all the data on that snapshot. If any data on the snapshot that is marked for deletion is needed for subsequent snapshots, the data will be moved to the next corresponding snapshot. For more information, see Deleting snapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Snapshots", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified Snapshot resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Snapshot>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Snapshots", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicySnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Snapshots", "GetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a snapshot in the specified project using the data included in the request. For regular snapshot creation, consider using this method instead of disks.createSnapshot, as this method supports more features, such as creating snapshots in a project different from the source disk project.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Snapshots", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of Snapshot resources contained within the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSnapshotsRequest>,
        ) -> std::result::Result<tonic::Response<super::SnapshotList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Snapshots", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicySnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Snapshots", "SetIamPolicy"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a snapshot. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsSnapshotRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Snapshots", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsSnapshotRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Snapshots/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Snapshots",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod ssl_certificates_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The SslCertificates API.
    #[derive(Debug, Clone)]
    pub struct SslCertificatesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SslCertificatesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SslCertificatesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SslCertificatesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all SslCertificate resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListSslCertificatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertificateAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslCertificates/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SslCertificates",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified SslCertificate resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslCertificates/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslCertificates", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified SslCertificate resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::SslCertificate>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslCertificates/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslCertificates", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a SslCertificate resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertSslCertificateRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslCertificates/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslCertificates", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of SslCertificate resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSslCertificatesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslCertificateList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslCertificates/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslCertificates", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod ssl_policies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The SslPolicies API.
    #[derive(Debug, Clone)]
    pub struct SslPoliciesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SslPoliciesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SslPoliciesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SslPoliciesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all SslPolicy resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListSslPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslPoliciesAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SslPolicies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslPolicies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all of the ordered rules present in a single specified policy.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::SslPolicy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.SslPolicies", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified SSL policy resource.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.SslPolicies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all the SSL policies that have been configured for the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSslPoliciesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SslPoliciesList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.SslPolicies", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists all features that can be specified in the SSL policy when using custom profile.
        pub async fn list_available_features(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListAvailableFeaturesSslPoliciesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SslPoliciesListAvailableFeaturesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/ListAvailableFeatures",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.SslPolicies",
                        "ListAvailableFeatures",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified SSL policy with the data included in the request.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchSslPolicyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.SslPolicies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.SslPolicies", "Patch"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod storage_pool_types_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The StoragePoolTypes API.
    #[derive(Debug, Clone)]
    pub struct StoragePoolTypesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StoragePoolTypesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StoragePoolTypesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StoragePoolTypesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of storage pool types. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListStoragePoolTypesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolTypeAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePoolTypes/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.StoragePoolTypes",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified storage pool type.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStoragePoolTypeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolType>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePoolTypes/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePoolTypes", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of storage pool types available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListStoragePoolTypesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolTypeList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePoolTypes/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePoolTypes", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod storage_pools_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The StoragePools API.
    #[derive(Debug, Clone)]
    pub struct StoragePoolsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StoragePoolsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StoragePoolsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StoragePoolsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of storage pools. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListStoragePoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.StoragePools",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified storage pool. Deleting a storagePool removes its data permanently and is irreversible. However, deleting a storagePool does not delete any snapshots previously made from the storagePool. You must separately delete snapshots.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePools", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a specified storage pool. Gets a list of available storage pools by making a list() request.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::StoragePool>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.StoragePools", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicyStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.StoragePools",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a storage pool in the specified project using the data in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePools", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of storage pools contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListStoragePoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.StoragePools", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Lists the disks in a specified storage pool.
        pub async fn list_disks(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDisksStoragePoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::StoragePoolListDisks>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/ListDisks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePools", "ListDisks"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicyStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.StoragePools",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsStoragePoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.StoragePools",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified storagePool with the data included in the request. The update is performed only on selected fields included as part of update-mask. Only the following fields can be modified: size_tb and provisioned_iops.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateStoragePoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.StoragePools/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.StoragePools", "Update"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod subnetworks_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Subnetworks API.
    #[derive(Debug, Clone)]
    pub struct SubnetworksClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SubnetworksClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SubnetworksClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SubnetworksClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of subnetworks. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListSubnetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubnetworkAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified subnetwork.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Expands the IP CIDR range of the subnetwork to a specified value.
        pub async fn expand_ip_cidr_range(
            &mut self,
            request: impl tonic::IntoRequest<super::ExpandIpCidrRangeSubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/ExpandIpCidrRange",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "ExpandIpCidrRange",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified subnetwork.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Subnetwork>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. May be empty if no such policy or resource exists.
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::GetIamPolicySubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a subnetwork in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertSubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of subnetworks available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubnetworksRequest>,
        ) -> std::result::Result<tonic::Response<super::SubnetworkList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of all usable subnetworks in the project.
        pub async fn list_usable(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUsableSubnetworksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UsableSubnetworksAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/ListUsable",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "ListUsable"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified subnetwork with the data included in the request. Only certain fields can be updated with a patch request as indicated in the field descriptions. You must specify the current fingerprint of the subnetwork resource being patched.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchSubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Subnetworks", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified resource. Replaces any existing policy.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetIamPolicySubnetworkRequest>,
        ) -> std::result::Result<tonic::Response<super::Policy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Set whether VMs in this subnet can access Google services without assigning external IP addresses through Private Google Access.
        pub async fn set_private_ip_google_access(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetPrivateIpGoogleAccessSubnetworkRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/SetPrivateIpGoogleAccess",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "SetPrivateIpGoogleAccess",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsSubnetworkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Subnetworks/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.Subnetworks",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_grpc_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetGrpcProxies API.
    #[derive(Debug, Clone)]
    pub struct TargetGrpcProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetGrpcProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetGrpcProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetGrpcProxiesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified TargetGrpcProxy in the given scope
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetGrpcProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetGrpcProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetGrpcProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetGrpcProxy resource in the given scope.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetGrpcProxyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetGrpcProxy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetGrpcProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetGrpcProxies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetGrpcProxy in the specified project in the given scope using the parameters that are included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetGrpcProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetGrpcProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetGrpcProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the TargetGrpcProxies for a project in the given scope.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetGrpcProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetGrpcProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetGrpcProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetGrpcProxies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified TargetGrpcProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchTargetGrpcProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetGrpcProxies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetGrpcProxies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_http_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetHttpProxies API.
    #[derive(Debug, Clone)]
    pub struct TargetHttpProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetHttpProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetHttpProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetHttpProxiesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all TargetHttpProxy resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListTargetHttpProxiesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpProxyAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpProxies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified TargetHttpProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetHttpProxy resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetHttpProxyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpProxy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetHttpProxies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetHttpProxy resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetHttpProxy resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetHttpProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetHttpProxies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified TargetHttpProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetHttpProxies", "Patch"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the URL map for TargetHttpProxy.
        pub async fn set_url_map(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUrlMapTargetHttpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpProxies/SetUrlMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpProxies",
                        "SetUrlMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_https_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetHttpsProxies API.
    #[derive(Debug, Clone)]
    pub struct TargetHttpsProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetHttpsProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetHttpsProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetHttpsProxiesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all TargetHttpsProxy resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListTargetHttpsProxiesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpsProxyAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified TargetHttpsProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetHttpsProxy resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetHttpsProxyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpsProxy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetHttpsProxies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetHttpsProxy resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetHttpsProxy resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetHttpsProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetHttpsProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetHttpsProxies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "Patch",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the Certificate Map for TargetHttpsProxy.
        pub async fn set_certificate_map(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetCertificateMapTargetHttpsProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/SetCertificateMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "SetCertificateMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the QUIC override policy for TargetHttpsProxy.
        pub async fn set_quic_override(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetQuicOverrideTargetHttpsProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/SetQuicOverride",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "SetQuicOverride",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Replaces SslCertificates for TargetHttpsProxy.
        pub async fn set_ssl_certificates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSslCertificatesTargetHttpsProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/SetSslCertificates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "SetSslCertificates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the HTTPS proxy load balancer. They do not affect the connection between the load balancer and the backends.
        pub async fn set_ssl_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSslPolicyTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/SetSslPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "SetSslPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the URL map for TargetHttpsProxy.
        pub async fn set_url_map(
            &mut self,
            request: impl tonic::IntoRequest<super::SetUrlMapTargetHttpsProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetHttpsProxies/SetUrlMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetHttpsProxies",
                        "SetUrlMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_instances_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetInstances API.
    #[derive(Debug, Clone)]
    pub struct TargetInstancesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetInstancesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetInstancesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetInstancesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of target instances. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListTargetInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetInstanceAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetInstances",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified TargetInstance resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetInstances", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetInstance resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetInstance>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetInstances", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetInstance resource in the specified project and zone using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetInstanceRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetInstances", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of TargetInstance resources available to the specified project and zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetInstancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetInstanceList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetInstances", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Google Cloud Armor security policy for the specified target instance. For more information, see Google Cloud Armor Overview
        pub async fn set_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSecurityPolicyTargetInstanceRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetInstances/SetSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetInstances",
                        "SetSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_pools_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetPools API.
    #[derive(Debug, Clone)]
    pub struct TargetPoolsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetPoolsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetPoolsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetPoolsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Adds health check URLs to a target pool.
        pub async fn add_health_check(
            &mut self,
            request: impl tonic::IntoRequest<super::AddHealthCheckTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/AddHealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetPools",
                        "AddHealthCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Adds an instance to a target pool.
        pub async fn add_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::AddInstanceTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/AddInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetPools", "AddInstance"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves an aggregated list of target pools. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListTargetPoolsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetPoolAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetPools",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified target pool.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetPools", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified target pool.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetPool>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.TargetPools", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Gets the most recent health check results for each IP for the instance that is referenced by the given target pool.
        pub async fn get_health(
            &mut self,
            request: impl tonic::IntoRequest<super::GetHealthTargetPoolRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetPoolInstanceHealth>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/GetHealth",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetPools", "GetHealth"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a target pool in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetPools", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of target pools available to the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetPoolsRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetPoolList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.TargetPools", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Removes health check URL from a target pool.
        pub async fn remove_health_check(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveHealthCheckTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/RemoveHealthCheck",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetPools",
                        "RemoveHealthCheck",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Removes instance URL from a target pool.
        pub async fn remove_instance(
            &mut self,
            request: impl tonic::IntoRequest<super::RemoveInstanceTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/RemoveInstance",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetPools",
                        "RemoveInstance",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes a backup target pool's configurations.
        pub async fn set_backup(
            &mut self,
            request: impl tonic::IntoRequest<super::SetBackupTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/SetBackup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetPools", "SetBackup"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the Google Cloud Armor security policy for the specified target pool. For more information, see Google Cloud Armor Overview
        pub async fn set_security_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSecurityPolicyTargetPoolRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetPools/SetSecurityPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetPools",
                        "SetSecurityPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_ssl_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetSslProxies API.
    #[derive(Debug, Clone)]
    pub struct TargetSslProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetSslProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetSslProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetSslProxiesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified TargetSslProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetSslProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetSslProxies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetSslProxy resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetSslProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetSslProxy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetSslProxies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetSslProxy resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetSslProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetSslProxies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetSslProxy resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetSslProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetSslProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetSslProxies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the BackendService for TargetSslProxy.
        pub async fn set_backend_service(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetBackendServiceTargetSslProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/SetBackendService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetSslProxies",
                        "SetBackendService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the Certificate Map for TargetSslProxy.
        pub async fn set_certificate_map(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetCertificateMapTargetSslProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/SetCertificateMap",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetSslProxies",
                        "SetCertificateMap",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the ProxyHeaderType for TargetSslProxy.
        pub async fn set_proxy_header(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProxyHeaderTargetSslProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/SetProxyHeader",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetSslProxies",
                        "SetProxyHeader",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes SslCertificates for TargetSslProxy.
        pub async fn set_ssl_certificates(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetSslCertificatesTargetSslProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/SetSslCertificates",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetSslProxies",
                        "SetSslCertificates",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the load balancer. They do not affect the connection between the load balancer and the backends.
        pub async fn set_ssl_policy(
            &mut self,
            request: impl tonic::IntoRequest<super::SetSslPolicyTargetSslProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetSslProxies/SetSslPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetSslProxies",
                        "SetSslPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_tcp_proxies_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetTcpProxies API.
    #[derive(Debug, Clone)]
    pub struct TargetTcpProxiesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetTcpProxiesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetTcpProxiesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetTcpProxiesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all TargetTcpProxy resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListTargetTcpProxiesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TargetTcpProxyAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetTcpProxies",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified TargetTcpProxy resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetTcpProxies", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified TargetTcpProxy resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::TargetTcpProxy>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetTcpProxies", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a TargetTcpProxy resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetTcpProxies", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of TargetTcpProxy resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetTcpProxiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetTcpProxyList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetTcpProxies", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the BackendService for TargetTcpProxy.
        pub async fn set_backend_service(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetBackendServiceTargetTcpProxyRequest,
            >,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/SetBackendService",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetTcpProxies",
                        "SetBackendService",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the ProxyHeaderType for TargetTcpProxy.
        pub async fn set_proxy_header(
            &mut self,
            request: impl tonic::IntoRequest<super::SetProxyHeaderTargetTcpProxyRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetTcpProxies/SetProxyHeader",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetTcpProxies",
                        "SetProxyHeader",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod target_vpn_gateways_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The TargetVpnGateways API.
    #[derive(Debug, Clone)]
    pub struct TargetVpnGatewaysClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> TargetVpnGatewaysClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TargetVpnGatewaysClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            TargetVpnGatewaysClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of target VPN gateways. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<
                super::AggregatedListTargetVpnGatewaysRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::TargetVpnGatewayAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetVpnGateways",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified target VPN gateway.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTargetVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetVpnGateways",
                        "Delete",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified target VPN gateway.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTargetVpnGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetVpnGateway>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetVpnGateways", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a target VPN gateway in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertTargetVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetVpnGateways",
                        "Insert",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of target VPN gateways available to the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTargetVpnGatewaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TargetVpnGatewayList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.TargetVpnGateways", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a TargetVpnGateway. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsTargetVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.TargetVpnGateways/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.TargetVpnGateways",
                        "SetLabels",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod url_maps_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The UrlMaps API.
    #[derive(Debug, Clone)]
    pub struct UrlMapsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> UrlMapsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> UrlMapsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            UrlMapsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves the list of all UrlMap resources, regional and global, available to the specified project. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListUrlMapsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UrlMapsAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "AggregatedList"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified UrlMap resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified UrlMap resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::UrlMap>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a UrlMap resource in the specified project using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Initiates a cache invalidation operation, invalidating the specified path, scoped to the specified UrlMap. For more information, see [Invalidating cached content](/cdn/docs/invalidating-cached-content).
        pub async fn invalidate_cache(
            &mut self,
            request: impl tonic::IntoRequest<super::InvalidateCacheUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/InvalidateCache",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "InvalidateCache"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of UrlMap resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUrlMapsRequest>,
        ) -> std::result::Result<tonic::Response<super::UrlMapList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules.
        pub async fn patch(
            &mut self,
            request: impl tonic::IntoRequest<super::PatchUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Patch",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Patch"));
            self.inner.unary(req, path, codec).await
        }
        /// Updates the specified UrlMap resource with the data included in the request.
        pub async fn update(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateUrlMapRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Update",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Update"));
            self.inner.unary(req, path, codec).await
        }
        /// Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap.
        pub async fn validate(
            &mut self,
            request: impl tonic::IntoRequest<super::ValidateUrlMapRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UrlMapsValidateResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.UrlMaps/Validate",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.UrlMaps", "Validate"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod vpn_gateways_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The VpnGateways API.
    #[derive(Debug, Clone)]
    pub struct VpnGatewaysClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VpnGatewaysClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VpnGatewaysClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VpnGatewaysClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of VPN gateways. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListVpnGatewaysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VpnGatewayAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.VpnGateways",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified VPN gateway.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified VPN gateway.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::VpnGateway>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the status for the specified VPN gateway.
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStatusVpnGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VpnGatewaysGetStatusResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/GetStatus",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "GetStatus"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a VPN gateway in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "Insert"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of VPN gateways available to the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVpnGatewaysRequest>,
        ) -> std::result::Result<tonic::Response<super::VpnGatewayList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a VpnGateway. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsVpnGatewayRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.VpnGateways", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<super::TestIamPermissionsVpnGatewayRequest>,
        ) -> std::result::Result<
            tonic::Response<super::TestPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnGateways/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.VpnGateways",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod vpn_tunnels_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The VpnTunnels API.
    #[derive(Debug, Clone)]
    pub struct VpnTunnelsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VpnTunnelsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VpnTunnelsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VpnTunnelsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Retrieves an aggregated list of VPN tunnels. To prevent failure, Google recommends that you set the `returnPartialSuccess` parameter to `true`.
        pub async fn aggregated_list(
            &mut self,
            request: impl tonic::IntoRequest<super::AggregatedListVpnTunnelsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VpnTunnelAggregatedList>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/AggregatedList",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.compute.v1.VpnTunnels",
                        "AggregatedList",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes the specified VpnTunnel resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVpnTunnelRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnTunnels", "Delete"));
            self.inner.unary(req, path, codec).await
        }
        /// Returns the specified VpnTunnel resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVpnTunnelRequest>,
        ) -> std::result::Result<tonic::Response<super::VpnTunnel>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnTunnels", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Creates a VpnTunnel resource in the specified project and region using the data included in the request.
        pub async fn insert(
            &mut self,
            request: impl tonic::IntoRequest<super::InsertVpnTunnelRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/Insert",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnTunnels", "Insert"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of VpnTunnel resources contained in the specified project and region.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVpnTunnelsRequest>,
        ) -> std::result::Result<tonic::Response<super::VpnTunnelList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.VpnTunnels", "List"));
            self.inner.unary(req, path, codec).await
        }
        /// Sets the labels on a VpnTunnel. To learn more about labels, read the Labeling Resources documentation.
        pub async fn set_labels(
            &mut self,
            request: impl tonic::IntoRequest<super::SetLabelsVpnTunnelRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.VpnTunnels/SetLabels",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.VpnTunnels", "SetLabels"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod zone_operations_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The ZoneOperations API.
    #[derive(Debug, Clone)]
    pub struct ZoneOperationsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ZoneOperationsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ZoneOperationsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ZoneOperationsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Deletes the specified zone-specific Operations resource.
        pub async fn delete(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteZoneOperationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DeleteZoneOperationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ZoneOperations/Delete",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ZoneOperations", "Delete"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the specified zone-specific Operations resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ZoneOperations/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ZoneOperations", "Get"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves a list of Operation resources contained within the specified zone.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZoneOperationsRequest>,
        ) -> std::result::Result<tonic::Response<super::OperationList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ZoneOperations/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ZoneOperations", "List"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method waits for no more than the 2 minutes and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
        pub async fn wait(
            &mut self,
            request: impl tonic::IntoRequest<super::WaitZoneOperationRequest>,
        ) -> std::result::Result<tonic::Response<super::Operation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.ZoneOperations/Wait",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.cloud.compute.v1.ZoneOperations", "Wait"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod zones_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Zones API.
    #[derive(Debug, Clone)]
    pub struct ZonesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ZonesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ZonesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ZonesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns the specified Zone resource.
        pub async fn get(
            &mut self,
            request: impl tonic::IntoRequest<super::GetZoneRequest>,
        ) -> std::result::Result<tonic::Response<super::Zone>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Zones/Get",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Zones", "Get"));
            self.inner.unary(req, path, codec).await
        }
        /// Retrieves the list of Zone resources available to the specified project.
        pub async fn list(
            &mut self,
            request: impl tonic::IntoRequest<super::ListZonesRequest>,
        ) -> std::result::Result<tonic::Response<super::ZoneList>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.compute.v1.Zones/List",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("google.cloud.compute.v1.Zones", "List"));
            self.inner.unary(req, path, codec).await
        }
    }
}
