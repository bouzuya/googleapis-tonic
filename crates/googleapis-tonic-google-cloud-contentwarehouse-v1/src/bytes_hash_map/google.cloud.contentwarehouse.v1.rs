// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SynonymSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub context: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub synonyms: ::prost::alloc::vec::Vec<synonym_set::Synonym>,
}
/// Nested message and enum types in `SynonymSet`.
pub mod synonym_set {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Synonym {
        #[prost(string, repeated, tag = "1")]
        pub words: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSynonymSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub synonym_set: ::core::option::Option<SynonymSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSynonymSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSynonymSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSynonymSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub synonym_sets: ::prost::alloc::vec::Vec<SynonymSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSynonymSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub synonym_set: ::core::option::Option<SynonymSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSynonymSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod synonym_set_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A Service that manage/custom customer specified SynonymSets.
    #[derive(Debug, Clone)]
    pub struct SynonymSetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> SynonymSetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> SynonymSetServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            SynonymSetServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a SynonymSet for a single context.
        /// Throws an ALREADY_EXISTS exception if a synonymset already exists
        /// for the context.
        pub async fn create_synonym_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSynonymSetRequest>,
        ) -> std::result::Result<tonic::Response<super::SynonymSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.SynonymSetService/CreateSynonymSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.SynonymSetService",
                        "CreateSynonymSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a SynonymSet for a particular context.
        /// Throws a NOT_FOUND exception if the Synonymset
        /// does not exist
        pub async fn get_synonym_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSynonymSetRequest>,
        ) -> std::result::Result<tonic::Response<super::SynonymSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.SynonymSetService/GetSynonymSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.SynonymSetService",
                        "GetSynonymSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Remove the existing SynonymSet for the context and replaces it
        /// with a new one.
        /// Throws a NOT_FOUND exception if the SynonymSet is not found.
        pub async fn update_synonym_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSynonymSetRequest>,
        ) -> std::result::Result<tonic::Response<super::SynonymSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.SynonymSetService/UpdateSynonymSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.SynonymSetService",
                        "UpdateSynonymSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a SynonymSet for a given context.
        /// Throws a NOT_FOUND exception if the SynonymSet is not found.
        pub async fn delete_synonym_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSynonymSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.SynonymSetService/DeleteSynonymSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.SynonymSetService",
                        "DeleteSynonymSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all SynonymSets (for all contexts) for the specified location.
        pub async fn list_synonym_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSynonymSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSynonymSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.SynonymSetService/ListSynonymSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.SynonymSetService",
                        "ListSynonymSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub property_definitions: ::prost::alloc::vec::Vec<PropertyDefinition>,
    #[prost(bool, tag = "4")]
    pub document_is_folder: bool,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyDefinition {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_repeatable: bool,
    #[prost(bool, tag = "3")]
    pub is_filterable: bool,
    #[prost(bool, tag = "4")]
    pub is_searchable: bool,
    #[prost(bool, tag = "5")]
    pub is_metadata: bool,
    #[prost(bool, tag = "14")]
    pub is_required: bool,
    #[prost(enumeration = "property_definition::RetrievalImportance", tag = "18")]
    pub retrieval_importance: i32,
    #[prost(message, repeated, tag = "19")]
    pub schema_sources: ::prost::alloc::vec::Vec<property_definition::SchemaSource>,
    #[prost(
        oneof = "property_definition::ValueTypeOptions",
        tags = "7, 8, 9, 10, 11, 13, 15, 16"
    )]
    pub value_type_options: ::core::option::Option<
        property_definition::ValueTypeOptions,
    >,
}
/// Nested message and enum types in `PropertyDefinition`.
pub mod property_definition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SchemaSource {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub processor_type: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RetrievalImportance {
        Unspecified = 0,
        Highest = 1,
        Higher = 2,
        High = 3,
        Medium = 4,
        Low = 5,
        Lowest = 6,
    }
    impl RetrievalImportance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RetrievalImportance::Unspecified => "RETRIEVAL_IMPORTANCE_UNSPECIFIED",
                RetrievalImportance::Highest => "HIGHEST",
                RetrievalImportance::Higher => "HIGHER",
                RetrievalImportance::High => "HIGH",
                RetrievalImportance::Medium => "MEDIUM",
                RetrievalImportance::Low => "LOW",
                RetrievalImportance::Lowest => "LOWEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETRIEVAL_IMPORTANCE_UNSPECIFIED" => Some(Self::Unspecified),
                "HIGHEST" => Some(Self::Highest),
                "HIGHER" => Some(Self::Higher),
                "HIGH" => Some(Self::High),
                "MEDIUM" => Some(Self::Medium),
                "LOW" => Some(Self::Low),
                "LOWEST" => Some(Self::Lowest),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueTypeOptions {
        #[prost(message, tag = "7")]
        IntegerTypeOptions(super::IntegerTypeOptions),
        #[prost(message, tag = "8")]
        FloatTypeOptions(super::FloatTypeOptions),
        #[prost(message, tag = "9")]
        TextTypeOptions(super::TextTypeOptions),
        #[prost(message, tag = "10")]
        PropertyTypeOptions(super::PropertyTypeOptions),
        #[prost(message, tag = "11")]
        EnumTypeOptions(super::EnumTypeOptions),
        #[prost(message, tag = "13")]
        DateTimeTypeOptions(super::DateTimeTypeOptions),
        #[prost(message, tag = "15")]
        MapTypeOptions(super::MapTypeOptions),
        #[prost(message, tag = "16")]
        TimestampTypeOptions(super::TimestampTypeOptions),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IntegerTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloatTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TextTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateTimeTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MapTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimestampTypeOptions {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyTypeOptions {
    #[prost(message, repeated, tag = "1")]
    pub property_definitions: ::prost::alloc::vec::Vec<PropertyDefinition>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumTypeOptions {
    #[prost(string, repeated, tag = "1")]
    pub possible_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub validation_check_disabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleSet {
    #[prost(string, tag = "6")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(enumeration = "rule::TriggerType", tag = "3")]
    pub trigger_type: i32,
    #[prost(string, tag = "4")]
    pub condition: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub actions: ::prost::alloc::vec::Vec<Action>,
}
/// Nested message and enum types in `Rule`.
pub mod rule {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TriggerType {
        Unknown = 0,
        OnCreate = 1,
        OnUpdate = 4,
        OnCreateLink = 7,
        OnDeleteLink = 8,
    }
    impl TriggerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TriggerType::Unknown => "UNKNOWN",
                TriggerType::OnCreate => "ON_CREATE",
                TriggerType::OnUpdate => "ON_UPDATE",
                TriggerType::OnCreateLink => "ON_CREATE_LINK",
                TriggerType::OnDeleteLink => "ON_DELETE_LINK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "ON_CREATE" => Some(Self::OnCreate),
                "ON_UPDATE" => Some(Self::OnUpdate),
                "ON_CREATE_LINK" => Some(Self::OnCreateLink),
                "ON_DELETE_LINK" => Some(Self::OnDeleteLink),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Action {
    #[prost(string, tag = "1")]
    pub action_id: ::prost::alloc::string::String,
    #[prost(oneof = "action::Action", tags = "2, 3, 4, 5, 6, 9, 10")]
    pub action: ::core::option::Option<action::Action>,
}
/// Nested message and enum types in `Action`.
pub mod action {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Action {
        #[prost(message, tag = "2")]
        AccessControl(super::AccessControlAction),
        #[prost(message, tag = "3")]
        DataValidation(super::DataValidationAction),
        #[prost(message, tag = "4")]
        DataUpdate(super::DataUpdateAction),
        #[prost(message, tag = "5")]
        AddToFolder(super::AddToFolderAction),
        #[prost(message, tag = "6")]
        PublishToPubSub(super::PublishAction),
        #[prost(message, tag = "9")]
        RemoveFromFolderAction(super::RemoveFromFolderAction),
        #[prost(message, tag = "10")]
        DeleteDocumentAction(super::DeleteDocumentAction),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessControlAction {
    #[prost(enumeration = "access_control_action::OperationType", tag = "1")]
    pub operation_type: i32,
    #[prost(message, optional, tag = "2")]
    pub policy: ::core::option::Option<super::super::super::iam::v1::Policy>,
}
/// Nested message and enum types in `AccessControlAction`.
pub mod access_control_action {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationType {
        Unknown = 0,
        AddPolicyBinding = 1,
        RemovePolicyBinding = 2,
        ReplacePolicyBinding = 3,
    }
    impl OperationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationType::Unknown => "UNKNOWN",
                OperationType::AddPolicyBinding => "ADD_POLICY_BINDING",
                OperationType::RemovePolicyBinding => "REMOVE_POLICY_BINDING",
                OperationType::ReplacePolicyBinding => "REPLACE_POLICY_BINDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "ADD_POLICY_BINDING" => Some(Self::AddPolicyBinding),
                "REMOVE_POLICY_BINDING" => Some(Self::RemovePolicyBinding),
                "REPLACE_POLICY_BINDING" => Some(Self::ReplacePolicyBinding),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataValidationAction {
    #[prost(map = "string, string", tag = "1")]
    pub conditions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataUpdateAction {
    #[prost(map = "string, string", tag = "1")]
    pub entries: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddToFolderAction {
    #[prost(string, repeated, tag = "1")]
    pub folders: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveFromFolderAction {
    #[prost(string, tag = "1")]
    pub condition: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub folder: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PublishAction {
    #[prost(string, tag = "1")]
    pub topic_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub messages: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteDocumentAction {
    #[prost(bool, tag = "1")]
    pub enable_hard_delete: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleEngineOutput {
    #[prost(string, tag = "3")]
    pub document_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "1")]
    pub rule_evaluator_output: ::core::option::Option<RuleEvaluatorOutput>,
    #[prost(message, optional, tag = "2")]
    pub action_executor_output: ::core::option::Option<ActionExecutorOutput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleEvaluatorOutput {
    #[prost(message, repeated, tag = "1")]
    pub triggered_rules: ::prost::alloc::vec::Vec<Rule>,
    #[prost(message, repeated, tag = "2")]
    pub matched_rules: ::prost::alloc::vec::Vec<Rule>,
    #[prost(message, repeated, tag = "3")]
    pub invalid_rules: ::prost::alloc::vec::Vec<InvalidRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InvalidRule {
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<Rule>,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionExecutorOutput {
    #[prost(message, repeated, tag = "1")]
    pub rule_actions_pairs: ::prost::alloc::vec::Vec<RuleActionsPair>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleActionsPair {
    #[prost(message, optional, tag = "1")]
    pub rule: ::core::option::Option<Rule>,
    #[prost(message, repeated, tag = "2")]
    pub action_outputs: ::prost::alloc::vec::Vec<ActionOutput>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ActionOutput {
    #[prost(string, tag = "1")]
    pub action_id: ::prost::alloc::string::String,
    #[prost(enumeration = "action_output::State", tag = "2")]
    pub action_state: i32,
    #[prost(string, tag = "3")]
    pub output_message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ActionOutput`.
pub mod action_output {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unknown = 0,
        ActionSucceeded = 1,
        ActionFailed = 2,
        ActionTimedOut = 3,
        ActionPending = 4,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unknown => "UNKNOWN",
                State::ActionSucceeded => "ACTION_SUCCEEDED",
                State::ActionFailed => "ACTION_FAILED",
                State::ActionTimedOut => "ACTION_TIMED_OUT",
                State::ActionPending => "ACTION_PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNKNOWN" => Some(Self::Unknown),
                "ACTION_SUCCEEDED" => Some(Self::ActionSucceeded),
                "ACTION_FAILED" => Some(Self::ActionFailed),
                "ACTION_TIMED_OUT" => Some(Self::ActionTimedOut),
                "ACTION_PENDING" => Some(Self::ActionPending),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Document {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub reference_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "18")]
    pub title: ::prost::alloc::string::String,
    #[prost(string, tag = "17")]
    pub display_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub document_schema_name: ::prost::alloc::string::String,
    #[deprecated]
    #[prost(string, tag = "16")]
    pub structured_content_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "7")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "RawDocumentFileType", tag = "10")]
    pub raw_document_file_type: i32,
    #[deprecated]
    #[prost(bool, tag = "12")]
    pub async_enabled: bool,
    #[prost(enumeration = "ContentCategory", tag = "20")]
    pub content_category: i32,
    #[deprecated]
    #[prost(bool, tag = "19")]
    pub text_extraction_disabled: bool,
    #[prost(bool, tag = "21")]
    pub text_extraction_enabled: bool,
    #[prost(string, tag = "13")]
    pub creator: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub updater: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "22")]
    pub disposition_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "23")]
    pub legal_hold: bool,
    #[prost(oneof = "document::StructuredContent", tags = "15, 4")]
    pub structured_content: ::core::option::Option<document::StructuredContent>,
    #[prost(oneof = "document::RawDocument", tags = "5, 6")]
    pub raw_document: ::core::option::Option<document::RawDocument>,
}
/// Nested message and enum types in `Document`.
pub mod document {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StructuredContent {
        #[prost(string, tag = "15")]
        PlainText(::prost::alloc::string::String),
        #[prost(message, tag = "4")]
        CloudAiDocument(super::super::super::documentai::v1::Document),
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RawDocument {
        #[prost(string, tag = "5")]
        RawDocumentPath(::prost::alloc::string::String),
        #[prost(bytes, tag = "6")]
        InlineRawDocument(::prost::bytes::Bytes),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentReference {
    #[prost(string, tag = "1")]
    pub document_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub snippet: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub document_is_folder: bool,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "8")]
    pub document_is_retention_folder: bool,
    #[prost(bool, tag = "9")]
    pub document_is_legal_hold_folder: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "property::Values", tags = "2, 3, 4, 5, 6, 7, 8, 9")]
    pub values: ::core::option::Option<property::Values>,
}
/// Nested message and enum types in `Property`.
pub mod property {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Values {
        #[prost(message, tag = "2")]
        IntegerValues(super::IntegerArray),
        #[prost(message, tag = "3")]
        FloatValues(super::FloatArray),
        #[prost(message, tag = "4")]
        TextValues(super::TextArray),
        #[prost(message, tag = "5")]
        EnumValues(super::EnumArray),
        #[prost(message, tag = "6")]
        PropertyValues(super::PropertyArray),
        #[prost(message, tag = "7")]
        DateTimeValues(super::DateTimeArray),
        #[prost(message, tag = "8")]
        MapProperty(super::MapProperty),
        #[prost(message, tag = "9")]
        TimestampValues(super::TimestampArray),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IntegerArray {
    #[prost(int32, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FloatArray {
    #[prost(float, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<f32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TextArray {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumArray {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DateTimeArray {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<super::super::super::r#type::DateTime>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampArray {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<TimestampValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimestampValue {
    #[prost(oneof = "timestamp_value::Value", tags = "1, 2")]
    pub value: ::core::option::Option<timestamp_value::Value>,
}
/// Nested message and enum types in `TimestampValue`.
pub mod timestamp_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "1")]
        TimestampValue(::prost_types::Timestamp),
        #[prost(string, tag = "2")]
        TextValue(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyArray {
    #[prost(message, repeated, tag = "1")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MapProperty {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::Kind", tags = "1, 2, 3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(float, tag = "1")]
        FloatValue(f32),
        #[prost(int32, tag = "2")]
        IntValue(i32),
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        #[prost(message, tag = "4")]
        EnumValue(super::EnumValue),
        #[prost(message, tag = "5")]
        DatetimeValue(super::super::super::super::r#type::DateTime),
        #[prost(message, tag = "6")]
        TimestampValue(super::TimestampValue),
        #[prost(bool, tag = "7")]
        BooleanValue(bool),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RawDocumentFileType {
    Unspecified = 0,
    Pdf = 1,
    Docx = 2,
    Xlsx = 3,
    Pptx = 4,
    Text = 5,
    Tiff = 6,
}
impl RawDocumentFileType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RawDocumentFileType::Unspecified => "RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED",
            RawDocumentFileType::Pdf => "RAW_DOCUMENT_FILE_TYPE_PDF",
            RawDocumentFileType::Docx => "RAW_DOCUMENT_FILE_TYPE_DOCX",
            RawDocumentFileType::Xlsx => "RAW_DOCUMENT_FILE_TYPE_XLSX",
            RawDocumentFileType::Pptx => "RAW_DOCUMENT_FILE_TYPE_PPTX",
            RawDocumentFileType::Text => "RAW_DOCUMENT_FILE_TYPE_TEXT",
            RawDocumentFileType::Tiff => "RAW_DOCUMENT_FILE_TYPE_TIFF",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "RAW_DOCUMENT_FILE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RAW_DOCUMENT_FILE_TYPE_PDF" => Some(Self::Pdf),
            "RAW_DOCUMENT_FILE_TYPE_DOCX" => Some(Self::Docx),
            "RAW_DOCUMENT_FILE_TYPE_XLSX" => Some(Self::Xlsx),
            "RAW_DOCUMENT_FILE_TYPE_PPTX" => Some(Self::Pptx),
            "RAW_DOCUMENT_FILE_TYPE_TEXT" => Some(Self::Text),
            "RAW_DOCUMENT_FILE_TYPE_TIFF" => Some(Self::Tiff),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ContentCategory {
    Unspecified = 0,
    Image = 1,
    Audio = 2,
    Video = 3,
}
impl ContentCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ContentCategory::Unspecified => "CONTENT_CATEGORY_UNSPECIFIED",
            ContentCategory::Image => "CONTENT_CATEGORY_IMAGE",
            ContentCategory::Audio => "CONTENT_CATEGORY_AUDIO",
            ContentCategory::Video => "CONTENT_CATEGORY_VIDEO",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CONTENT_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "CONTENT_CATEGORY_IMAGE" => Some(Self::Image),
            "CONTENT_CATEGORY_AUDIO" => Some(Self::Audio),
            "CONTENT_CATEGORY_VIDEO" => Some(Self::Video),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentQuery {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(bool, tag = "12")]
    pub is_nl_query: bool,
    #[deprecated]
    #[prost(string, tag = "4")]
    pub custom_property_filter: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub time_filters: ::prost::alloc::vec::Vec<TimeFilter>,
    #[prost(string, repeated, tag = "6")]
    pub document_schema_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "7")]
    pub property_filter: ::prost::alloc::vec::Vec<PropertyFilter>,
    #[prost(message, optional, tag = "8")]
    pub file_type_filter: ::core::option::Option<FileTypeFilter>,
    #[prost(string, tag = "9")]
    pub folder_name_filter: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "14")]
    pub document_name_filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "10")]
    pub query_context: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "11")]
    pub document_creator_filter: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "13")]
    pub custom_weights_metadata: ::core::option::Option<CustomWeightsMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeFilter {
    #[prost(message, optional, tag = "1")]
    pub time_range: ::core::option::Option<super::super::super::r#type::Interval>,
    #[prost(enumeration = "time_filter::TimeField", tag = "2")]
    pub time_field: i32,
}
/// Nested message and enum types in `TimeFilter`.
pub mod time_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeField {
        Unspecified = 0,
        CreateTime = 1,
        UpdateTime = 2,
        DispositionTime = 3,
    }
    impl TimeField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeField::Unspecified => "TIME_FIELD_UNSPECIFIED",
                TimeField::CreateTime => "CREATE_TIME",
                TimeField::UpdateTime => "UPDATE_TIME",
                TimeField::DispositionTime => "DISPOSITION_TIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TIME_FIELD_UNSPECIFIED" => Some(Self::Unspecified),
                "CREATE_TIME" => Some(Self::CreateTime),
                "UPDATE_TIME" => Some(Self::UpdateTime),
                "DISPOSITION_TIME" => Some(Self::DispositionTime),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertyFilter {
    #[prost(string, tag = "1")]
    pub document_schema_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub condition: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FileTypeFilter {
    #[prost(enumeration = "file_type_filter::FileType", tag = "1")]
    pub file_type: i32,
}
/// Nested message and enum types in `FileTypeFilter`.
pub mod file_type_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FileType {
        Unspecified = 0,
        All = 1,
        Folder = 2,
        Document = 3,
        RootFolder = 4,
    }
    impl FileType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FileType::Unspecified => "FILE_TYPE_UNSPECIFIED",
                FileType::All => "ALL",
                FileType::Folder => "FOLDER",
                FileType::Document => "DOCUMENT",
                FileType::RootFolder => "ROOT_FOLDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FILE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ALL" => Some(Self::All),
                "FOLDER" => Some(Self::Folder),
                "DOCUMENT" => Some(Self::Document),
                "ROOT_FOLDER" => Some(Self::RootFolder),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomWeightsMetadata {
    #[prost(message, repeated, tag = "1")]
    pub weighted_schema_properties: ::prost::alloc::vec::Vec<WeightedSchemaProperty>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WeightedSchemaProperty {
    #[prost(string, tag = "1")]
    pub document_schema_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub property_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document_schema: ::core::option::Option<DocumentSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document_schema: ::core::option::Option<DocumentSchema>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDocumentSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub document_schemas: ::prost::alloc::vec::Vec<DocumentSchema>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod document_schema_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service lets you manage document schema.
    #[derive(Debug, Clone)]
    pub struct DocumentSchemaServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DocumentSchemaServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentSchemaServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DocumentSchemaServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a document schema.
        pub async fn create_document_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DocumentSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentSchemaService/CreateDocumentSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentSchemaService",
                        "CreateDocumentSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Document Schema. Returns INVALID_ARGUMENT if the name of the
        /// Document Schema is non-empty and does not equal the existing name.
        /// Supports only appending new properties, adding new ENUM possible values,
        /// and updating the
        /// \[EnumTypeOptions.validation_check_disabled\]\[google.cloud.contentwarehouse.v1.EnumTypeOptions.validation_check_disabled\]
        /// flag for ENUM possible values. Updating existing properties will result
        /// into INVALID_ARGUMENT.
        pub async fn update_document_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DocumentSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentSchemaService/UpdateDocumentSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentSchemaService",
                        "UpdateDocumentSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a document schema. Returns NOT_FOUND if the document schema does not
        /// exist.
        pub async fn get_document_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentSchemaRequest>,
        ) -> std::result::Result<tonic::Response<super::DocumentSchema>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentSchemaService/GetDocumentSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentSchemaService",
                        "GetDocumentSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a document schema. Returns NOT_FOUND if the document schema does
        /// not exist. Returns BAD_REQUEST if the document schema has documents
        /// depending on it.
        pub async fn delete_document_schema(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentSchemaRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentSchemaService/DeleteDocumentSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentSchemaService",
                        "DeleteDocumentSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists document schemas.
        pub async fn list_document_schemas(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDocumentSchemasRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDocumentSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentSchemaService/ListDocumentSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentSchemaService",
                        "ListDocumentSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestMetadata {
    #[prost(message, optional, tag = "1")]
    pub user_info: ::core::option::Option<UserInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResponseMetadata {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateOptions {
    #[prost(enumeration = "UpdateType", tag = "1")]
    pub update_type: i32,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "3")]
    pub merge_fields_options: ::core::option::Option<MergeFieldsOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MergeFieldsOptions {
    #[prost(bool, optional, tag = "1")]
    pub replace_message_fields: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2")]
    pub replace_repeated_fields: ::core::option::Option<bool>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UpdateType {
    Unspecified = 0,
    Replace = 1,
    Merge = 2,
    InsertPropertiesByNames = 3,
    ReplacePropertiesByNames = 4,
    DeletePropertiesByNames = 5,
    MergeAndReplaceOrInsertPropertiesByNames = 6,
}
impl UpdateType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            UpdateType::Unspecified => "UPDATE_TYPE_UNSPECIFIED",
            UpdateType::Replace => "UPDATE_TYPE_REPLACE",
            UpdateType::Merge => "UPDATE_TYPE_MERGE",
            UpdateType::InsertPropertiesByNames => {
                "UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES"
            }
            UpdateType::ReplacePropertiesByNames => {
                "UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES"
            }
            UpdateType::DeletePropertiesByNames => {
                "UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES"
            }
            UpdateType::MergeAndReplaceOrInsertPropertiesByNames => {
                "UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPDATE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "UPDATE_TYPE_REPLACE" => Some(Self::Replace),
            "UPDATE_TYPE_MERGE" => Some(Self::Merge),
            "UPDATE_TYPE_INSERT_PROPERTIES_BY_NAMES" => {
                Some(Self::InsertPropertiesByNames)
            }
            "UPDATE_TYPE_REPLACE_PROPERTIES_BY_NAMES" => {
                Some(Self::ReplacePropertiesByNames)
            }
            "UPDATE_TYPE_DELETE_PROPERTIES_BY_NAMES" => {
                Some(Self::DeletePropertiesByNames)
            }
            "UPDATE_TYPE_MERGE_AND_REPLACE_OR_INSERT_PROPERTIES_BY_NAMES" => {
                Some(Self::MergeAndReplaceOrInsertPropertiesByNames)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DatabaseType {
    DbUnknown = 0,
    DbInfraSpanner = 1,
    DbCloudSqlPostgres = 2,
}
impl DatabaseType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DatabaseType::DbUnknown => "DB_UNKNOWN",
            DatabaseType::DbInfraSpanner => "DB_INFRA_SPANNER",
            DatabaseType::DbCloudSqlPostgres => "DB_CLOUD_SQL_POSTGRES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DB_UNKNOWN" => Some(Self::DbUnknown),
            "DB_INFRA_SPANNER" => Some(Self::DbInfraSpanner),
            "DB_CLOUD_SQL_POSTGRES" => Some(Self::DbCloudSqlPostgres),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AccessControlMode {
    AclModeUnknown = 0,
    AclModeUniversalAccess = 1,
    AclModeDocumentLevelAccessControlByoid = 2,
    AclModeDocumentLevelAccessControlGci = 3,
}
impl AccessControlMode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AccessControlMode::AclModeUnknown => "ACL_MODE_UNKNOWN",
            AccessControlMode::AclModeUniversalAccess => "ACL_MODE_UNIVERSAL_ACCESS",
            AccessControlMode::AclModeDocumentLevelAccessControlByoid => {
                "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID"
            }
            AccessControlMode::AclModeDocumentLevelAccessControlGci => {
                "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACL_MODE_UNKNOWN" => Some(Self::AclModeUnknown),
            "ACL_MODE_UNIVERSAL_ACCESS" => Some(Self::AclModeUniversalAccess),
            "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_BYOID" => {
                Some(Self::AclModeDocumentLevelAccessControlByoid)
            }
            "ACL_MODE_DOCUMENT_LEVEL_ACCESS_CONTROL_GCI" => {
                Some(Self::AclModeDocumentLevelAccessControlGci)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DocumentCreatorDefaultRole {
    Unspecified = 0,
    DocumentAdmin = 1,
    DocumentEditor = 2,
    DocumentViewer = 3,
}
impl DocumentCreatorDefaultRole {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DocumentCreatorDefaultRole::Unspecified => {
                "DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED"
            }
            DocumentCreatorDefaultRole::DocumentAdmin => "DOCUMENT_ADMIN",
            DocumentCreatorDefaultRole::DocumentEditor => "DOCUMENT_EDITOR",
            DocumentCreatorDefaultRole::DocumentViewer => "DOCUMENT_VIEWER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DOCUMENT_CREATOR_DEFAULT_ROLE_UNSPECIFIED" => Some(Self::Unspecified),
            "DOCUMENT_ADMIN" => Some(Self::DocumentAdmin),
            "DOCUMENT_EDITOR" => Some(Self::DocumentEditor),
            "DOCUMENT_VIEWER" => Some(Self::DocumentViewer),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramQuery {
    #[prost(string, tag = "1")]
    pub histogram_query: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub require_precise_result_size: bool,
    #[prost(message, optional, tag = "3")]
    pub filters: ::core::option::Option<HistogramQueryPropertyNameFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramQueryPropertyNameFilter {
    #[prost(string, repeated, tag = "1")]
    pub document_schemas: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub property_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(
        enumeration = "histogram_query_property_name_filter::HistogramYAxis",
        tag = "3"
    )]
    pub y_axis: i32,
}
/// Nested message and enum types in `HistogramQueryPropertyNameFilter`.
pub mod histogram_query_property_name_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HistogramYAxis {
        HistogramYaxisDocument = 0,
        HistogramYaxisProperty = 1,
    }
    impl HistogramYAxis {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HistogramYAxis::HistogramYaxisDocument => "HISTOGRAM_YAXIS_DOCUMENT",
                HistogramYAxis::HistogramYaxisProperty => "HISTOGRAM_YAXIS_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HISTOGRAM_YAXIS_DOCUMENT" => Some(Self::HistogramYaxisDocument),
                "HISTOGRAM_YAXIS_PROPERTY" => Some(Self::HistogramYaxisProperty),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HistogramQueryResult {
    #[prost(string, tag = "1")]
    pub histogram_query: ::prost::alloc::string::String,
    #[prost(map = "string, int64", tag = "2")]
    pub histogram: ::std::collections::HashMap<::prost::alloc::string::String, i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudAiDocumentOption {
    #[prost(bool, tag = "1")]
    pub enable_entities_conversions: bool,
    #[prost(map = "string, string", tag = "2")]
    pub customized_entities_properties_conversions: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "3")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(message, optional, tag = "4")]
    pub policy: ::core::option::Option<super::super::super::iam::v1::Policy>,
    #[prost(message, optional, tag = "5")]
    pub cloud_ai_document_option: ::core::option::Option<CloudAiDocumentOption>,
    #[prost(message, optional, tag = "6")]
    pub create_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "3")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(message, optional, tag = "5")]
    pub cloud_ai_document_option: ::core::option::Option<CloudAiDocumentOption>,
    #[prost(message, optional, tag = "6")]
    pub update_options: ::core::option::Option<UpdateOptions>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDocumentsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(message, optional, tag = "4")]
    pub document_query: ::core::option::Option<DocumentQuery>,
    #[prost(int32, tag = "5")]
    pub offset: i32,
    #[prost(int32, tag = "6")]
    pub page_size: i32,
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub order_by: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "9")]
    pub histogram_queries: ::prost::alloc::vec::Vec<HistogramQuery>,
    #[prost(bool, tag = "10")]
    pub require_total_size: bool,
    #[prost(enumeration = "search_documents_request::TotalResultSize", tag = "12")]
    pub total_result_size: i32,
    #[prost(int32, tag = "11")]
    pub qa_size_limit: i32,
}
/// Nested message and enum types in `SearchDocumentsRequest`.
pub mod search_documents_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TotalResultSize {
        Unspecified = 0,
        EstimatedSize = 1,
        ActualSize = 2,
    }
    impl TotalResultSize {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TotalResultSize::Unspecified => "TOTAL_RESULT_SIZE_UNSPECIFIED",
                TotalResultSize::EstimatedSize => "ESTIMATED_SIZE",
                TotalResultSize::ActualSize => "ACTUAL_SIZE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TOTAL_RESULT_SIZE_UNSPECIFIED" => Some(Self::Unspecified),
                "ESTIMATED_SIZE" => Some(Self::EstimatedSize),
                "ACTUAL_SIZE" => Some(Self::ActualSize),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockDocumentRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub collection_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub locking_user: ::core::option::Option<UserInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchAclRequest {
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(bool, tag = "3")]
    pub project_owner: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAclRequest {
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub policy: ::core::option::Option<super::super::super::iam::v1::Policy>,
    #[prost(message, optional, tag = "3")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(bool, tag = "4")]
    pub project_owner: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentResponse {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "2")]
    pub rule_engine_output: ::core::option::Option<RuleEngineOutput>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    #[prost(message, repeated, tag = "4")]
    pub long_running_operations: ::prost::alloc::vec::Vec<
        super::super::super::longrunning::Operation,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDocumentResponse {
    #[prost(message, optional, tag = "1")]
    pub document: ::core::option::Option<Document>,
    #[prost(message, optional, tag = "2")]
    pub rule_engine_output: ::core::option::Option<RuleEngineOutput>,
    #[prost(message, optional, tag = "3")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QaResult {
    #[prost(message, repeated, tag = "1")]
    pub highlights: ::prost::alloc::vec::Vec<qa_result::Highlight>,
    #[prost(float, tag = "2")]
    pub confidence_score: f32,
}
/// Nested message and enum types in `QAResult`.
pub mod qa_result {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Highlight {
        #[prost(int32, tag = "1")]
        pub start_index: i32,
        #[prost(int32, tag = "2")]
        pub end_index: i32,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchDocumentsResponse {
    #[prost(message, repeated, tag = "1")]
    pub matching_documents: ::prost::alloc::vec::Vec<
        search_documents_response::MatchingDocument,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub total_size: i32,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
    #[prost(message, repeated, tag = "6")]
    pub histogram_query_results: ::prost::alloc::vec::Vec<HistogramQueryResult>,
    #[prost(string, tag = "7")]
    pub question_answer: ::prost::alloc::string::String,
}
/// Nested message and enum types in `SearchDocumentsResponse`.
pub mod search_documents_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MatchingDocument {
        #[prost(message, optional, tag = "1")]
        pub document: ::core::option::Option<super::Document>,
        #[prost(string, tag = "2")]
        pub search_text_snippet: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub qa_result: ::core::option::Option<super::QaResult>,
        #[prost(int64, repeated, tag = "4")]
        pub matched_token_page_indices: ::prost::alloc::vec::Vec<i64>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchAclResponse {
    #[prost(message, optional, tag = "1")]
    pub policy: ::core::option::Option<super::super::super::iam::v1::Policy>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAclResponse {
    #[prost(message, optional, tag = "1")]
    pub policy: ::core::option::Option<super::super::super::iam::v1::Policy>,
    #[prost(message, optional, tag = "2")]
    pub metadata: ::core::option::Option<ResponseMetadata>,
}
/// Generated client implementations.
pub mod document_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service lets you manage document.
    #[derive(Debug, Clone)]
    pub struct DocumentServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DocumentServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DocumentServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a document.
        pub async fn create_document(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/CreateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "CreateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a document. Returns NOT_FOUND if the document does not exist.
        pub async fn get_document(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/GetDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "GetDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a document. Returns INVALID_ARGUMENT if the name of the document
        /// is non-empty and does not equal the existing name.
        pub async fn update_document(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDocumentRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateDocumentResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/UpdateDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "UpdateDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a document. Returns NOT_FOUND if the document does not exist.
        pub async fn delete_document(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/DeleteDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "DeleteDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for documents using provided
        /// \[SearchDocumentsRequest\]\[google.cloud.contentwarehouse.v1.SearchDocumentsRequest\].
        /// This call only returns documents that the caller has permission to search
        /// against.
        pub async fn search_documents(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchDocumentsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchDocumentsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/SearchDocuments",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "SearchDocuments",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lock the document so the document cannot be updated by other users.
        pub async fn lock_document(
            &mut self,
            request: impl tonic::IntoRequest<super::LockDocumentRequest>,
        ) -> std::result::Result<tonic::Response<super::Document>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/LockDocument",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "LockDocument",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for a resource. Returns NOT_FOUND error if
        /// the resource does not exist. Returns an empty policy if the resource exists
        /// but does not have a policy set.
        pub async fn fetch_acl(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchAclRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchAclResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/FetchAcl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "FetchAcl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy for a resource. Replaces any existing
        /// policy.
        pub async fn set_acl(
            &mut self,
            request: impl tonic::IntoRequest<super::SetAclRequest>,
        ) -> std::result::Result<tonic::Response<super::SetAclResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentService/SetAcl",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentService",
                        "SetAcl",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RunPipelineResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunPipelineMetadata {
    #[prost(int32, tag = "1")]
    pub total_file_count: i32,
    #[prost(int32, tag = "2")]
    pub failed_file_count: i32,
    #[prost(message, optional, tag = "3")]
    pub user_info: ::core::option::Option<UserInfo>,
    #[prost(message, repeated, tag = "5")]
    pub individual_document_statuses: ::prost::alloc::vec::Vec<
        run_pipeline_metadata::IndividualDocumentStatus,
    >,
    #[prost(oneof = "run_pipeline_metadata::PipelineMetadata", tags = "4, 6, 7")]
    pub pipeline_metadata: ::core::option::Option<
        run_pipeline_metadata::PipelineMetadata,
    >,
}
/// Nested message and enum types in `RunPipelineMetadata`.
pub mod run_pipeline_metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct GcsIngestPipelineMetadata {
        #[prost(string, tag = "1")]
        pub input_path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExportToCdwPipelineMetadata {
        #[prost(string, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(string, tag = "2")]
        pub doc_ai_dataset: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub output_path: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ProcessWithDocAiPipelineMetadata {
        #[prost(string, repeated, tag = "1")]
        pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, optional, tag = "2")]
        pub processor_info: ::core::option::Option<super::ProcessorInfo>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IndividualDocumentStatus {
        #[prost(string, tag = "1")]
        pub document_id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub status: ::core::option::Option<super::super::super::super::rpc::Status>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum PipelineMetadata {
        #[prost(message, tag = "4")]
        GcsIngestPipelineMetadata(GcsIngestPipelineMetadata),
        #[prost(message, tag = "6")]
        ExportToCdwPipelineMetadata(ExportToCdwPipelineMetadata),
        #[prost(message, tag = "7")]
        ProcessWithDocAiPipelineMetadata(ProcessWithDocAiPipelineMetadata),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessorInfo {
    #[prost(string, tag = "1")]
    pub processor_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub document_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub schema_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IngestPipelineConfig {
    #[prost(message, optional, tag = "1")]
    pub document_acl_policy: ::core::option::Option<
        super::super::super::iam::v1::Policy,
    >,
    #[prost(bool, tag = "2")]
    pub enable_document_text_extraction: bool,
    #[prost(string, tag = "3")]
    pub folder: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub cloud_function: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsIngestPipeline {
    #[prost(string, tag = "1")]
    pub input_path: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub schema_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub processor_type: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub skip_ingested_documents: bool,
    #[prost(message, optional, tag = "5")]
    pub pipeline_config: ::core::option::Option<IngestPipelineConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GcsIngestWithDocAiProcessorsPipeline {
    #[prost(string, tag = "1")]
    pub input_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub split_classify_processor_info: ::core::option::Option<ProcessorInfo>,
    #[prost(message, repeated, tag = "3")]
    pub extract_processor_infos: ::prost::alloc::vec::Vec<ProcessorInfo>,
    #[prost(string, tag = "4")]
    pub processor_results_folder_path: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub skip_ingested_documents: bool,
    #[prost(message, optional, tag = "6")]
    pub pipeline_config: ::core::option::Option<IngestPipelineConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportToCdwPipeline {
    #[prost(string, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub export_folder_path: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub doc_ai_dataset: ::prost::alloc::string::String,
    #[prost(float, tag = "4")]
    pub training_split_ratio: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProcessWithDocAiPipeline {
    #[prost(string, repeated, tag = "1")]
    pub documents: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub export_folder_path: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub processor_info: ::core::option::Option<ProcessorInfo>,
    #[prost(string, tag = "4")]
    pub processor_results_folder_path: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunPipelineRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
    #[prost(oneof = "run_pipeline_request::Pipeline", tags = "2, 3, 4, 5")]
    pub pipeline: ::core::option::Option<run_pipeline_request::Pipeline>,
}
/// Nested message and enum types in `RunPipelineRequest`.
pub mod run_pipeline_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Pipeline {
        #[prost(message, tag = "2")]
        GcsIngestPipeline(super::GcsIngestPipeline),
        #[prost(message, tag = "3")]
        GcsIngestWithDocAiProcessorsPipeline(
            super::GcsIngestWithDocAiProcessorsPipeline,
        ),
        #[prost(message, tag = "4")]
        ExportCdwPipeline(super::ExportToCdwPipeline),
        #[prost(message, tag = "5")]
        ProcessWithDocAiPipeline(super::ProcessWithDocAiPipeline),
    }
}
/// Generated client implementations.
pub mod pipeline_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service lets you manage pipelines.
    #[derive(Debug, Clone)]
    pub struct PipelineServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> PipelineServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> PipelineServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            PipelineServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Run a predefined pipeline.
        pub async fn run_pipeline(
            &mut self,
            request: impl tonic::IntoRequest<super::RunPipelineRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.PipelineService/RunPipeline",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.PipelineService",
                        "RunPipeline",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateDocumentMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateDocumentMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuleSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rule_set: ::core::option::Option<RuleSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRuleSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRuleSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rule_set: ::core::option::Option<RuleSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRuleSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub rule_sets: ::prost::alloc::vec::Vec<RuleSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLinkedTargetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub document_links: ::prost::alloc::vec::Vec<DocumentLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLinkedTargetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLinkedSourcesResponse {
    #[prost(message, repeated, tag = "1")]
    pub document_links: ::prost::alloc::vec::Vec<DocumentLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListLinkedSourcesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DocumentLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub source_document_reference: ::core::option::Option<DocumentReference>,
    #[prost(message, optional, tag = "3")]
    pub target_document_reference: ::core::option::Option<DocumentReference>,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "6")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "document_link::State", tag = "7")]
    pub state: i32,
}
/// Nested message and enum types in `DocumentLink`.
pub mod document_link {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Active = 1,
        SoftDeleted = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Active => "ACTIVE",
                State::SoftDeleted => "SOFT_DELETED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ACTIVE" => Some(Self::Active),
                "SOFT_DELETED" => Some(Self::SoftDeleted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDocumentLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub document_link: ::core::option::Option<DocumentLink>,
    #[prost(message, optional, tag = "3")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDocumentLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub request_metadata: ::core::option::Option<RequestMetadata>,
}
/// Generated client implementations.
pub mod document_link_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service lets you manage document-links.
    /// Document-Links are treated as sub-resources under source documents.
    #[derive(Debug, Clone)]
    pub struct DocumentLinkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DocumentLinkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DocumentLinkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DocumentLinkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Return all target document-links from the document.
        pub async fn list_linked_targets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLinkedTargetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLinkedTargetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentLinkService/ListLinkedTargets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentLinkService",
                        "ListLinkedTargets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Return all source document-links from the document.
        pub async fn list_linked_sources(
            &mut self,
            request: impl tonic::IntoRequest<super::ListLinkedSourcesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListLinkedSourcesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentLinkService/ListLinkedSources",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentLinkService",
                        "ListLinkedSources",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a link between a source document and a target document.
        pub async fn create_document_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDocumentLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::DocumentLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentLinkService/CreateDocumentLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentLinkService",
                        "CreateDocumentLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Remove the link between the source and target documents.
        pub async fn delete_document_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDocumentLinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.DocumentLinkService/DeleteDocumentLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.DocumentLinkService",
                        "DeleteDocumentLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod rule_set_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service to manage customer specific RuleSets.
    #[derive(Debug, Clone)]
    pub struct RuleSetServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> RuleSetServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> RuleSetServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            RuleSetServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a ruleset.
        pub async fn create_rule_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRuleSetRequest>,
        ) -> std::result::Result<tonic::Response<super::RuleSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.RuleSetService/CreateRuleSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.RuleSetService",
                        "CreateRuleSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a ruleset. Returns NOT_FOUND if the ruleset does not exist.
        pub async fn get_rule_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRuleSetRequest>,
        ) -> std::result::Result<tonic::Response<super::RuleSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.RuleSetService/GetRuleSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.RuleSetService",
                        "GetRuleSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a ruleset. Returns INVALID_ARGUMENT if the name of the ruleset
        /// is non-empty and does not equal the existing name.
        pub async fn update_rule_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateRuleSetRequest>,
        ) -> std::result::Result<tonic::Response<super::RuleSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.RuleSetService/UpdateRuleSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.RuleSetService",
                        "UpdateRuleSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ruleset. Returns NOT_FOUND if the document does not exist.
        pub async fn delete_rule_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteRuleSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.RuleSetService/DeleteRuleSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.RuleSetService",
                        "DeleteRuleSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists rulesets.
        pub async fn list_rule_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuleSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuleSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.contentwarehouse.v1.RuleSetService/ListRuleSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.contentwarehouse.v1.RuleSetService",
                        "ListRuleSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
