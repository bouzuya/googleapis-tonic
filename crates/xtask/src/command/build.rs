use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::PathBuf,
    str::FromStr as _,
};

use anyhow::Context;

use crate::bytes_type::BytesType;
use crate::feature_name::FeatureName;
use crate::map_type::MapType;
use crate::modules::Modules;
use crate::proto_dir::ProtoDir;

pub fn execute() -> anyhow::Result<()> {
    let proto_dir = "crates/xtask/googleapis";
    let src_dir = "crates/googleapis-tonic/src";

    let proto_dir = ProtoDir::load(proto_dir)?;

    for (bytes_type, map_type) in BytesType::values().iter().flat_map(|bytes_type| {
        MapType::values()
            .iter()
            .map(|map_type| (*bytes_type, *map_type))
            .collect::<Vec<(BytesType, MapType)>>()
    }) {
        // // FIXME: crates.io size limit
        // if !((bytes_type == BytesType::Bytes && map_type == MapType::BTreeMap)
        //     || (bytes_type == BytesType::VecU8 && map_type == MapType::HashMap))
        // {
        //     continue;
        // }

        let root_mod_name = format!("{}_{}", bytes_type.as_path_part(), map_type.as_path_part());
        let out_dir = format!("{}/{}", src_dir, root_mod_name);

        let mut prost_config = prost_build::Config::new();
        let packages = proto_dir
            .dependencies()
            .keys()
            .map(ToString::to_string)
            .map(|it| format!(".{}", it))
            .collect::<Vec<String>>();
        prost_config.disable_comments(packages.clone());
        tonic_build::configure()
            .btree_map(match map_type {
                MapType::BTreeMap => vec!["."],
                MapType::HashMap => vec![],
            })
            .build_client(true)
            .build_server(false)
            .build_transport(false)
            .bytes(match bytes_type {
                BytesType::Bytes => vec!["."],
                BytesType::VecU8 => vec![],
            })
            .disable_comments(".")
            .emit_rerun_if_changed(false)
            .out_dir(out_dir.as_str())
            .protoc_arg("--experimental_allow_proto3_optional")
            .compile_with_config(
                prost_config,
                proto_dir.proto_paths(),
                &[proto_dir.dir_path()],
            )?;

        let mut file_names = vec![];
        for dir_entry in fs::read_dir(out_dir.as_str())? {
            let dir_entry = dir_entry?;
            let path = dir_entry.path();
            let file_name = path
                .file_name()
                .with_context(|| format!("file_name is None {}", path.display()))?
                .to_str()
                .with_context(|| format!("file_name is not utf-8 {}", path.display()))?;
            file_names.push(file_name.to_owned());
        }

        let modules = Modules::from_file_names(&file_names);
        let output = modules.to_rs_file_content(&format!("{}/", root_mod_name));
        fs::write(format!("{}/{}.rs", src_dir, root_mod_name), output)?;
    }

    update_cargo_toml(src_dir, proto_dir)?;

    // FIXME: generate googleapis-tonic-xxx crates
    let mut file_names = vec![];
    let out_dir = format!("{}/vec_u8_hash_map", src_dir);
    for dir_entry in fs::read_dir(out_dir.as_str())? {
        let dir_entry = dir_entry?;
        let path = dir_entry.path();
        let file_name = path
            .file_name()
            .with_context(|| format!("file_name is None {}", path.display()))?
            .to_str()
            .with_context(|| format!("file_name is not utf-8 {}", path.display()))?;
        file_names.push(file_name.to_owned());
    }
    file_names.sort();
    // println!("{:#?}", file_names);

    let file_name = &file_names[0];

    let crate_name = format!(
        "googleapis-tonic-{}",
        file_name
            .split('.')
            .filter(|s| s != &"rs")
            .collect::<Vec<&str>>()
            .join("-")
    );
    // println!("{}", crate_name);

    let crate_dir = PathBuf::from(&format!("crates/{}", crate_name));
    fs::create_dir_all(&crate_dir)?;
    fs::write(
        crate_dir.join("Cargo.toml"),
        r#"[package]
name = "{CRATE_NAME}"
version = "{VERSION}"
authors = ["bouzuya <m@bouzuya.net>"]
description = "A Google APIs client library generated by tonic-build"
edition = "2021"
keywords = ["api", "gcloud", "gcp", "google", "tonic"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bouzuya/googleapis-tonic"

[dependencies]
prost = "0.13.1"
prost-types = "0.13.1"
tonic = { version = "0.12.1", default-features = false, features = [
  "codegen",
  "prost",
] }

[lints.clippy]
non_minimal_cfg = "allow"

[lints.rust]
unused_imports = "allow"

[features]
btree-map = []
bytes = []
default = ["hash-map", "vec-u8"]
hash-map = []
vec-u8 = []
"#
        .replace("{CRATE_NAME}", &crate_name)
        .replace("{VERSION}", "0.0.0"),
    )?;
    for variant in [
        "bytes_btree_map",
        "bytes_hash_map",
        "vec_u8_btree_map",
        "vec_u8_hash_map",
    ] {
        fs::create_dir_all(format!("crates/{}/src/{}", crate_name, variant))?;
        fs::copy(
            format!("crates/googleapis-tonic/src/{}/{}", variant, file_name),
            format!("crates/{}/src/{}/{}", crate_name, variant, file_name),
        )?;
        fs::write(
            format!("crates/{}/src/{}.rs", crate_name, variant),
            r#"pub mod cloud {
    pub mod kubernetes {
        pub mod security {
            pub mod containersecurity_logging {
                include!("{VARIANT}/cloud.kubernetes.security.containersecurity_logging.rs");
            }
        }
    }
}
"#
            .replace("{VARIANT}", variant),
        )?;
    }
    fs::copy(
        "crates/googleapis-tonic/src/lib.rs",
        format!("crates/{}/src/lib.rs", crate_name),
    )?;

    Ok(())
}

fn build_features(proto_dir: ProtoDir) -> BTreeMap<FeatureName, BTreeSet<FeatureName>> {
    let mut features = BTreeMap::new();
    features.insert(
        FeatureName::default(),
        [
            FeatureName::from(MapType::HashMap),
            FeatureName::from(BytesType::VecU8),
        ]
        .into_iter()
        .collect::<BTreeSet<FeatureName>>(),
    );
    for bytes_type in BytesType::values() {
        features.insert(FeatureName::from(*bytes_type), BTreeSet::default());
    }
    for map_type in MapType::values() {
        features.insert(FeatureName::from(*map_type), BTreeSet::default());
    }
    for (pkg, deps) in proto_dir.dependencies() {
        let feature_name = FeatureName::from(pkg);
        let deps = deps
            .iter()
            .map(FeatureName::from)
            .filter(|it| it != &feature_name)
            .collect::<BTreeSet<FeatureName>>();
        features.insert(feature_name, deps);
    }
    features
}

fn update_cargo_toml(src_dir: &str, proto_dir: ProtoDir) -> anyhow::Result<()> {
    let cargo_toml_path = PathBuf::from(src_dir)
        .join("../Cargo.toml")
        .canonicalize()?;
    let cargo_toml = fs::read_to_string(&cargo_toml_path)?;
    let mut document = toml_edit::DocumentMut::from_str(&cargo_toml)?;
    let table = document["features"]
        .as_table_mut()
        .context("features is not a table")?;
    table.clear();
    for (feature_name, deps) in build_features(proto_dir) {
        table.insert(
            &feature_name.to_string(),
            toml_edit::Item::Value(toml_edit::Value::Array(
                deps.iter()
                    .map(ToString::to_string)
                    .collect::<toml_edit::Array>(),
            )),
        );
    }
    table.sort_values();
    fs::write(cargo_toml_path, document.to_string())?;
    Ok(())
}
