use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::{Path, PathBuf},
};

use crate::{proto_dir::ProtoDir, protobuf_package_name::ProtobufPackageName};

struct M {
    include: bool,
    modules: BTreeMap<String, M>,
}

pub fn build_crates(googleapis_tonic_src_dir: &str, proto_dir: &ProtoDir) -> anyhow::Result<()> {
    let googleapis_tonic_src_dir = PathBuf::from(googleapis_tonic_src_dir);

    for (package_name, deps) in proto_dir.dependencies() {
        let crate_name = package_name_to_crate_name(package_name);
        let file_name = format!("{}.rs", package_name_to_module_name(package_name));

        let mut modules = BTreeMap::new();
        for dep in deps.iter().chain(std::iter::once(package_name)) {
            let idents = dep
                .to_string()
                .split('.')
                .map(ToString::to_string)
                .collect::<Vec<String>>();
            let idents_len = idents.len();
            idents
                .into_iter()
                .enumerate()
                .fold(&mut modules, |m, (i, s)| {
                    &mut m
                        .entry(s.to_owned())
                        .or_insert(M {
                            include: i == idents_len - 1,
                            modules: BTreeMap::new(),
                        })
                        .modules
                });
        }

        // crates/googleapis-tonic-{crate_name}/
        //   src/
        //     bytes_btree_map/    ... variant directory
        //       {file_name}
        //     bytes_hash_map/
        //     vec_u8_btree_map/
        //     vec_u8_hash_map/
        //     bytes_btree_map.rs  ... variant file
        //     bytes_hash_map.rs
        //     lib.rs
        //     vec_u8_btree_map.rs
        //     vec_u8_hash_map.rs
        //   Cargo.toml
        let crate_dir = PathBuf::from("crates").join(&crate_name);
        fs::create_dir_all(&crate_dir)?;
        write_cargo_toml(&crate_dir, &crate_name, package_name, deps)?;
        let src_dir = crate_dir.join("src");
        for variant in [
            "bytes_btree_map",
            "bytes_hash_map",
            "vec_u8_btree_map",
            "vec_u8_hash_map",
        ] {
            write_variant_dir(&googleapis_tonic_src_dir, &src_dir, variant, &file_name)?;
            write_variant_file(&src_dir, variant, &file_name, package_name, &modules)?;
        }
        fs::copy(
            googleapis_tonic_src_dir.join("lib.rs"),
            src_dir.join("lib.rs"),
        )?;
    }
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/Cargo.toml
fn write_cargo_toml(
    crate_dir: &Path,
    crate_name: &str,
    package_name: &ProtobufPackageName,
    deps: &BTreeSet<ProtobufPackageName>,
) -> anyhow::Result<()> {
    let cargo_toml_path = crate_dir.join("Cargo.toml");
    let cargo_toml_content = r#"[package]
name = "{CRATE_NAME}"
version = "{VERSION}"
authors = ["bouzuya <m@bouzuya.net>"]
description = "A Google APIs client library generated by tonic-build"
edition = "2021"
keywords = ["api", "gcloud", "gcp", "google", "tonic"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bouzuya/googleapis-tonic"

[dependencies]
prost = "0.13.1"
prost-types = "0.13.1"
tonic = { version = "0.12.1", default-features = false, features = [
  "codegen",
  "prost",
] }
{DEPENDENCIES}

[lints.clippy]
non_minimal_cfg = "allow"

[lints.rust]
unused_imports = "allow"

[features]
default = ["hash-map", "vec-u8"]
{FEATURES}
"#
    .replace("{CRATE_NAME}", crate_name)
    .replace("{VERSION}", "0.0.0")
    .replace(
        "{DEPENDENCIES}",
        &deps
            .iter()
            .filter(|it| it != &package_name)
            .map(|dep| {
                // FIXME: `path = "../{crate_name}"` => `version = "{version}"`
                format!(
                    "{} = {{ path = \"../{}\", default-features = false }}",
                    package_name_to_crate_name(dep),
                    package_name_to_crate_name(dep),
                )
            })
            .collect::<Vec<String>>()
            .join("\n"),
    )
    .replace("{FEATURES}", &{
        ["btree-map", "bytes", "hash-map", "vec-u8"]
            .into_iter()
            .map(|feature| {
                format!(
                    r#"{} = [{}]"#,
                    feature,
                    deps.iter()
                        .map(|dep| format!(r#""{}/{}""#, package_name_to_crate_name(dep), feature))
                        .collect::<Vec<String>>()
                        .join(", ")
                )
            })
            .collect::<Vec<String>>()
            .join("\n")
    });
    fs::write(cargo_toml_path, cargo_toml_content)?;
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/src/{variant}/{file_name}.rs
fn write_variant_dir(
    googleapis_tonic_src_dir: &Path,
    src_dir: &Path,
    variant: &str,
    file_name: &str,
) -> anyhow::Result<()> {
    let variant_dir = src_dir.join(variant);
    fs::create_dir_all(&variant_dir)?;
    fs::copy(
        googleapis_tonic_src_dir.join(variant).join(file_name),
        variant_dir.join(file_name),
    )?;
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/src/{variant}.rs
fn write_variant_file(
    src_dir: &Path,
    variant: &str,
    file_name: &str,
    package_name: &ProtobufPackageName,
    modules: &BTreeMap<String, M>,
) -> anyhow::Result<()> {
    let variant_file = src_dir.join(format!("{}.rs", variant));
    let variant_file_content = {
        fn dfs(
            modules: &BTreeMap<String, M>,
            c: &mut Vec<String>,
            s: &mut String,
            variant: &str,
            package_name: &ProtobufPackageName,
            file_name: &str,
        ) {
            let indent = "    ";
            for (k, m) in modules {
                s.push_str(&format!(
                    "{}pub mod {} {{\n",
                    indent.repeat(c.len()),
                    // FIXME: other keywords
                    if k == "type" {
                        format!("r#{}", k)
                    } else {
                        k.to_owned()
                    }
                ));
                c.push(k.to_owned());
                if m.include {
                    if c.join(".") == package_name.to_string() {
                        s.push_str(&format!(
                            "{}include!(\"{}/{}\");\n",
                            indent.repeat(c.len()),
                            variant,
                            file_name
                        ));
                    } else {
                        s.push_str(&format!(
                            "{}pub(crate) use googleapis_tonic_{}::{}::*;\n",
                            indent.repeat(c.len()),
                            c.join("_"),
                            c.iter()
                                .map(|it| if it == "type" {
                                    format!("r#{}", it)
                                } else {
                                    it.to_owned()
                                })
                                .collect::<Vec<String>>()
                                .join("::"),
                        ));
                    }
                }
                dfs(&m.modules, c, s, variant, package_name, file_name);
                c.pop();
                s.push_str(&format!("{}}}\n", indent.repeat(c.len())));
            }
        }

        let mut s = String::new();
        let mut c = vec![];
        dfs(modules, &mut c, &mut s, variant, package_name, file_name);
        s
    };
    fs::write(variant_file, variant_file_content)?;
    Ok(())
}

fn package_name_to_crate_name(package_name: &ProtobufPackageName) -> String {
    format!(
        "googleapis-tonic-{}",
        package_name
            .to_string()
            .split('.')
            .collect::<Vec<&str>>()
            .join("-")
    )
}

fn package_name_to_module_name(package_name: &ProtobufPackageName) -> String {
    package_name
        .to_string()
        .split('.')
        .map(|s| {
            // FIXME: other keywords
            if s == "type" {
                format!("r#{}", s)
            } else {
                s.to_owned()
            }
        })
        .collect::<Vec<String>>()
        .join(".")
}
