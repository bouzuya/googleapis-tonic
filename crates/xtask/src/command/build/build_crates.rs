use std::{
    collections::{BTreeMap, BTreeSet},
    fmt::Display,
    fs,
    path::{Path, PathBuf},
    str::FromStr as _,
};

use crate::{proto_dir::ProtoDir, protobuf_package_name::ProtobufPackageName};

struct M {
    include: bool,
    modules: BTreeMap<String, M>,
}

pub fn build_crates(googleapis_tonic_src_dir: &Path, proto_dir: &ProtoDir) -> anyhow::Result<()> {
    let emit_package_names = proto_dir.emit_package_names();
    for package_name in emit_package_names {
        let deps = proto_dir
            .dependencies()
            .get(package_name)
            .cloned()
            .unwrap_or_default();
        let crate_name = CrateName::from_package_name(package_name);
        let dep_crate_names = deps
            .iter()
            .filter(|it| emit_package_names.contains(it))
            .map(CrateName::from_package_name)
            .collect::<BTreeSet<CrateName>>();
        let include_package_names = deps
            .iter()
            .filter(|it| !emit_package_names.contains(it))
            .chain(std::iter::once(package_name))
            .cloned()
            .collect::<BTreeSet<ProtobufPackageName>>();

        let mut modules = BTreeMap::new();
        for dep in deps.iter().chain(std::iter::once(package_name)) {
            let idents = dep
                .to_string()
                .split('.')
                .map(ToString::to_string)
                .collect::<Vec<String>>();
            let idents_len = idents.len();
            idents
                .into_iter()
                .enumerate()
                .fold(&mut modules, |m, (i, s)| {
                    &mut m
                        .entry(s.to_owned())
                        .or_insert(M {
                            include: i == idents_len - 1,
                            modules: BTreeMap::new(),
                        })
                        .modules
                });
        }

        // crates/googleapis-tonic-{crate_name}/
        //   src/
        //     bytes_btree_map/    ... variant directory
        //       {file_name}
        //     bytes_hash_map/
        //     vec_u8_btree_map/
        //     vec_u8_hash_map/
        //     bytes_btree_map.rs  ... variant file
        //     bytes_hash_map.rs
        //     lib.rs
        //     vec_u8_btree_map.rs
        //     vec_u8_hash_map.rs
        //   Cargo.toml
        let crate_dir = PathBuf::from("crates").join(crate_name.as_ref());
        fs::create_dir_all(&crate_dir)?;
        write_cargo_toml(&crate_dir, &crate_name, &dep_crate_names)?;
        let src_dir = crate_dir.join("src");
        for variant in [
            "bytes_btree_map",
            "bytes_hash_map",
            "vec_u8_btree_map",
            "vec_u8_hash_map",
        ] {
            write_variant_dir(
                googleapis_tonic_src_dir,
                &src_dir,
                variant,
                &include_package_names,
            )?;
            write_variant_file(&src_dir, variant, &modules, &include_package_names)?;
        }
        fs::copy(
            googleapis_tonic_src_dir.join("lib.rs"),
            src_dir.join("lib.rs"),
        )?;
    }
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/Cargo.toml
fn write_cargo_toml(
    crate_dir: &Path,
    crate_name: &CrateName,
    dep_crate_names: &BTreeSet<CrateName>,
) -> anyhow::Result<()> {
    let cargo_toml_path = crate_dir.join("Cargo.toml");
    let cargo_toml_content = r#"[package]
name = "{CRATE_NAME}"
version = "{VERSION}"
authors = ["bouzuya <m@bouzuya.net>"]
description = "A Google APIs client library generated by tonic-build"
edition = "2021"
keywords = ["api", "gcloud", "gcp", "google", "tonic"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bouzuya/googleapis-tonic"

[dependencies]
prost = "0.13.1"
prost-types = "0.13.1"
tonic = { version = "0.12.1", default-features = false, features = [
  "codegen",
  "prost",
] }
{DEPENDENCIES}

[lints.clippy]
doc_lazy_continuation = "allow"
large_enum_variant = "allow"
module_inception = "allow"
non_minimal_cfg = "allow"

[lints.rust]
unused_imports = "allow"

[features]
default = ["hash-map", "vec-u8"]
{FEATURES}
"#
    .replace("{CRATE_NAME}", crate_name.as_ref())
    .replace("{VERSION}", "0.0.0")
    .replace(
        "{DEPENDENCIES}",
        &dep_crate_names
            .iter()
            .map(|dep| {
                // FIXME: `path = "../{crate_name}"` => `version = "{version}"`
                format!(
                    "{} = {{ path = \"../{}\", default-features = false }}",
                    dep, dep,
                )
            })
            .collect::<Vec<String>>()
            .join("\n"),
    )
    .replace("{FEATURES}", &{
        ["btree-map", "bytes", "hash-map", "vec-u8"]
            .into_iter()
            .map(|feature| {
                format!(
                    r#"{} = [{}]"#,
                    feature,
                    dep_crate_names
                        .iter()
                        .map(|dep| format!(r#""{}/{}""#, dep, feature))
                        .collect::<Vec<String>>()
                        .join(", ")
                )
            })
            .collect::<Vec<String>>()
            .join("\n")
    });
    fs::write(cargo_toml_path, cargo_toml_content)?;
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/src/{variant}/{file_name}.rs
fn write_variant_dir(
    googleapis_tonic_src_dir: &Path,
    src_dir: &Path,
    variant: &str,
    include_package_names: &BTreeSet<ProtobufPackageName>,
) -> anyhow::Result<()> {
    let variant_dir = src_dir.join(variant);
    fs::create_dir_all(&variant_dir)?;
    for include in include_package_names {
        let include_file_name = format!("{}.rs", package_name_to_module_name(include));
        fs::copy(
            googleapis_tonic_src_dir
                .join(variant)
                .join(&include_file_name),
            variant_dir.join(&include_file_name),
        )?;
    }
    Ok(())
}

// crates/googleapis-tonic-{crate_name}/src/{variant}.rs
fn write_variant_file(
    src_dir: &Path,
    variant: &str,
    modules: &BTreeMap<String, M>,
    include_package_names: &BTreeSet<ProtobufPackageName>,
) -> anyhow::Result<()> {
    let variant_file = src_dir.join(format!("{}.rs", variant));
    let variant_file_content = {
        fn dfs(
            modules: &BTreeMap<String, M>,
            c: &mut Vec<String>,
            s: &mut String,
            variant: &str,
            include_package_names: &BTreeSet<ProtobufPackageName>,
        ) {
            let indent = "    ";
            for (k, m) in modules {
                s.push_str(&format!(
                    "{}pub mod {} {{\n",
                    indent.repeat(c.len()),
                    // FIXME: other keywords
                    if k == "type" {
                        format!("r#{}", k)
                    } else {
                        k.to_owned()
                    }
                ));
                c.push(k.to_owned());
                if m.include {
                    let current_package_name =
                        ProtobufPackageName::from_str(&c.join(".")).expect("valid package name");
                    if include_package_names.contains(&current_package_name) {
                        let include_file_name =
                            format!("{}.rs", package_name_to_module_name(&current_package_name));
                        s.push_str(&format!(
                            "{}include!(\"{}/{}\");\n",
                            indent.repeat(c.len()),
                            variant,
                            include_file_name
                        ));
                    } else {
                        s.push_str(&format!(
                            "{}pub(crate) use googleapis_tonic_{}::{}::*;\n",
                            indent.repeat(c.len()),
                            c.join("_"),
                            c.iter()
                                .map(|it| if it == "type" {
                                    format!("r#{}", it)
                                } else {
                                    it.to_owned()
                                })
                                .collect::<Vec<String>>()
                                .join("::"),
                        ));
                    }
                }
                dfs(&m.modules, c, s, variant, include_package_names);
                c.pop();
                s.push_str(&format!("{}}}\n", indent.repeat(c.len())));
            }
        }

        let mut s = String::new();
        let mut c = vec![];
        dfs(modules, &mut c, &mut s, variant, include_package_names);
        s
    };
    fs::write(variant_file, variant_file_content)?;
    Ok(())
}

fn package_name_to_module_name(package_name: &ProtobufPackageName) -> String {
    package_name
        .to_string()
        .split('.')
        .map(|s| {
            // FIXME: other keywords
            if s == "type" {
                format!("r#{}", s)
            } else {
                s.to_owned()
            }
        })
        .collect::<Vec<String>>()
        .join(".")
}

/// A crate name.
///
/// e.g. `googleapis-tonic-foo-bar-baz`
#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
struct CrateName(String);

impl CrateName {
    fn from_package_name(package_name: &ProtobufPackageName) -> Self {
        CrateName(format!(
            "googleapis-tonic-{}",
            package_name
                .to_string()
                .split('.')
                .collect::<Vec<&str>>()
                .join("-")
        ))
    }
}

impl AsRef<str> for CrateName {
    fn as_ref(&self) -> &str {
        &self.0
    }
}

impl Display for CrateName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.0.fmt(f)
    }
}
