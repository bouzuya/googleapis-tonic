use std::{
    collections::{BTreeMap, BTreeSet},
    fs,
    path::Path,
    str::FromStr as _,
};

use anyhow::Context;

use crate::crate_name::CrateName;
use crate::crate_version::CrateVersion;
use crate::feature_name::FeatureName;
use crate::map_type::MapType;
use crate::modules::Modules;
use crate::protobuf_package_name::ProtobufPackageName;
use crate::sha1hash::Sha1Hash;
use crate::{bytes_type::BytesType, googleapis::Googleapis};

pub fn build_crate(
    generated_dir: &Path,
    googleapis: &Googleapis,
    old_crate_version: &CrateVersion,
    old_package_hashes: &BTreeMap<ProtobufPackageName, Sha1Hash>,
    force_update: bool,
) -> anyhow::Result<CrateVersion> {
    let crate_name = CrateName::from_str("googleapis-tonic")?;
    let crate_dir = generated_dir.join(crate_name.to_string());
    let src_dir = crate_dir.join("src");
    let new_crate_version = if force_update
        || googleapis
            .package_hashes()
            .iter()
            .any(|(package_name, hash)| Some(hash) != old_package_hashes.get(package_name))
    {
        old_crate_version.increment_minor()
    } else {
        old_crate_version.to_owned()
    };

    fs::create_dir_all(&src_dir)?;
    for (bytes_type, map_type) in BytesType::values().iter().flat_map(|bytes_type| {
        MapType::values()
            .iter()
            .map(|map_type| (*bytes_type, *map_type))
            .collect::<Vec<(BytesType, MapType)>>()
    }) {
        let root_mod_name = format!("{}_{}", bytes_type.as_path_part(), map_type.as_path_part());
        let out_dir = src_dir.join(&root_mod_name);
        fs::create_dir_all(&out_dir)?;

        tonic_build::configure()
            .btree_map(match map_type {
                MapType::BTreeMap => vec!["."],
                MapType::HashMap => vec![],
            })
            .build_client(true)
            .build_server(false)
            .build_transport(false)
            .bytes(match bytes_type {
                BytesType::Bytes => vec!["."],
                BytesType::VecU8 => vec![],
            })
            .emit_rerun_if_changed(false)
            .out_dir(&out_dir)
            .protoc_arg("--experimental_allow_proto3_optional")
            .compile_protos(&googleapis.proto_paths(), &[googleapis.dir_path()])?;

        let mut file_names = vec![];
        for dir_entry in fs::read_dir(&out_dir)? {
            let dir_entry = dir_entry?;
            let path = dir_entry.path();
            let file_name = path
                .file_name()
                .with_context(|| format!("file_name is None {}", path.display()))?
                .to_str()
                .with_context(|| format!("file_name is not utf-8 {}", path.display()))?;
            file_names.push(file_name.to_owned());
        }

        let modules = Modules::from_file_names(&file_names);
        let output = modules.to_rs_file_content(&format!("{}/", root_mod_name));
        fs::write(src_dir.join(format!("{}.rs", root_mod_name)), output)?;
    }
    create_lib_rs(&crate_dir)?;

    create_cargo_toml(&crate_dir, &crate_name, googleapis, &new_crate_version)?;
    Ok(new_crate_version)
}

fn build_features(googleapis: &Googleapis) -> BTreeMap<FeatureName, BTreeSet<FeatureName>> {
    let mut features = BTreeMap::new();
    features.insert(
        FeatureName::default(),
        [
            FeatureName::from(MapType::HashMap),
            FeatureName::from(BytesType::VecU8),
        ]
        .into_iter()
        .collect::<BTreeSet<FeatureName>>(),
    );
    for bytes_type in BytesType::values() {
        features.insert(FeatureName::from(*bytes_type), BTreeSet::default());
    }
    for map_type in MapType::values() {
        features.insert(FeatureName::from(*map_type), BTreeSet::default());
    }
    for (pkg, deps) in googleapis.package_dependencies() {
        let feature_name = FeatureName::from(pkg);
        let deps = deps
            .iter()
            .map(FeatureName::from)
            .filter(|it| it != &feature_name)
            .collect::<BTreeSet<FeatureName>>();
        features.insert(feature_name, deps);
    }
    features
}

// create crates/googleapis-tonic/Cargo.toml
fn create_cargo_toml(
    crate_dir: &Path,
    crate_name: &CrateName,
    googleapis: &Googleapis,
    version: &CrateVersion,
) -> anyhow::Result<()> {
    let cargo_toml_path = crate_dir.join("Cargo.toml");
    let cargo_toml_content = r#"[package]
name = "{CRATE_NAME}"
version = "{VERSION}"
authors = ["bouzuya <m@bouzuya.net>"]
description = "A Google APIs client library generated by tonic-build"
edition = "2021"
keywords = ["api", "gcloud", "gcp", "google", "tonic"]
license = "MIT OR Apache-2.0"
repository = "https://github.com/bouzuya/googleapis-tonic"

[dependencies]
prost = "0.13.5"
prost-types = "0.13.5"
tonic = { version = "0.12.3", default-features = false, features = [
  "codegen",
  "prost",
] }

[lints.clippy]
doc_lazy_continuation = "allow"
large_enum_variant = "allow"
module_inception = "allow"
non_minimal_cfg = "allow"

[lints.rust]
unused_imports = "allow"

[features]
{FEATURES}
"#
    .replace("{CRATE_NAME}", crate_name.as_ref())
    .replace("{VERSION}", &version.to_string())
    .replace("{FEATURES}", &{
        build_features(googleapis)
            .into_iter()
            .map(|(feature_name, deps)| {
                format!(
                    r#"{} = [{}]"#,
                    feature_name,
                    deps.iter()
                        .map(ToString::to_string)
                        .collect::<Vec<String>>()
                        .join(", ")
                )
            })
            .collect::<Vec<String>>()
            .join("\n")
    });
    fs::write(cargo_toml_path, cargo_toml_content)?;
    Ok(())
}

// create crates/googleapis-tonic/src/lib.rs
fn create_lib_rs(crate_dir: &Path) -> anyhow::Result<()> {
    let src_dir = crate_dir.join("src");
    fs::create_dir_all(&src_dir)?;
    let lib_rs_path = src_dir.join("lib.rs");
    let lib_rs_content = r#"#[cfg(not(any(feature = "btree-map", feature = "hash-map")))]
compile_error!("feature \"btree-map\" or feature \"hash-map\" must be enabled");
#[cfg(all(feature = "btree-map", feature = "hash-map"))]
compile_error!("feature \"btree-map\" and feature \"hash-map\" cannot be enabled at the same time");

#[cfg(not(any(feature = "bytes", feature = "vec-u8")))]
compile_error!("feature \"bytes\" or feature \"vec-u8\" must be enabled");
#[cfg(all(feature = "bytes", feature = "vec-u8"))]
compile_error!("feature \"bytes\" and feature \"vec-u8\" cannot be enabled at the same time");

#[cfg(all(feature = "bytes", feature = "btree-map"))]
mod bytes_btree_map;
#[cfg(all(feature = "bytes", feature = "hash-map"))]
mod bytes_hash_map;
#[cfg(all(feature = "vec-u8", feature = "btree-map"))]
mod vec_u8_btree_map;
#[cfg(all(feature = "vec-u8", feature = "hash-map"))]
mod vec_u8_hash_map;

#[cfg(all(feature = "bytes", feature = "btree-map"))]
pub use self::bytes_btree_map::*;
#[cfg(all(feature = "bytes", feature = "hash-map"))]
pub use self::bytes_hash_map::*;
#[cfg(all(feature = "vec-u8", feature = "btree-map"))]
pub use self::vec_u8_btree_map::*;
#[cfg(all(feature = "vec-u8", feature = "hash-map"))]
pub use self::vec_u8_hash_map::*;
"#;
    fs::write(lib_rs_path, lib_rs_content)?;
    Ok(())
}
