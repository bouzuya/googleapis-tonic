// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountReference {
    #[prost(string, tag = "1")]
    pub ifsc: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub account_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub account_number: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SettlementParticipant {
    #[prost(message, optional, tag = "1")]
    pub participant: ::core::option::Option<Participant>,
    #[prost(message, optional, tag = "2")]
    pub merchant_info: ::core::option::Option<MerchantInfo>,
    #[deprecated]
    #[prost(string, tag = "3")]
    pub mobile: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<settlement_participant::SettlementDetails>,
}
/// Nested message and enum types in `SettlementParticipant`.
pub mod settlement_participant {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SettlementDetails {
        #[prost(string, tag = "1")]
        pub backend_settlement_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub code: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub reversal_code: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "4")]
        pub settled_amount: ::core::option::Option<
            super::super::super::super::super::r#type::Money,
        >,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeviceDetails {
    #[prost(string, tag = "1")]
    pub payment_app: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub capability: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub geo_code: ::core::option::Option<super::super::super::super::r#type::LatLng>,
    #[prost(string, tag = "4")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub operating_system: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub telecom_provider: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub r#type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Participant {
    #[prost(string, tag = "1")]
    pub payment_address: ::prost::alloc::string::String,
    #[prost(enumeration = "participant::Persona", tag = "2")]
    pub persona: i32,
    #[prost(string, tag = "3")]
    pub user: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub account: ::core::option::Option<AccountReference>,
    #[prost(message, optional, tag = "5")]
    pub device_details: ::core::option::Option<DeviceDetails>,
    #[prost(string, tag = "6")]
    pub mobile_number: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Participant`.
pub mod participant {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Persona {
        Unspecified = 0,
        Entity = 1,
        Person = 2,
    }
    impl Persona {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Persona::Unspecified => "PERSONA_UNSPECIFIED",
                Persona::Entity => "ENTITY",
                Persona::Person => "PERSON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PERSONA_UNSPECIFIED" => Some(Self::Unspecified),
                "ENTITY" => Some(Self::Entity),
                "PERSON" => Some(Self::Person),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub merchant: ::core::option::Option<MerchantName>,
    #[prost(message, optional, tag = "3")]
    pub additional_info: ::core::option::Option<MerchantAdditionalInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantName {
    #[prost(string, tag = "1")]
    pub brand: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub legal: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub franchise: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerchantAdditionalInfo {
    #[prost(string, tag = "1")]
    pub category_code: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub store_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub terminal_id: ::prost::alloc::string::String,
    #[prost(enumeration = "merchant_additional_info::Type", tag = "4")]
    pub r#type: i32,
    #[prost(enumeration = "merchant_additional_info::Genre", tag = "5")]
    pub genre: i32,
    #[prost(enumeration = "merchant_additional_info::OnboardingType", tag = "6")]
    pub onboarding_type: i32,
    #[prost(enumeration = "merchant_additional_info::OwnershipType", tag = "7")]
    pub ownership_type: i32,
}
/// Nested message and enum types in `MerchantAdditionalInfo`.
pub mod merchant_additional_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Large = 1,
        Small = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Large => "LARGE",
                Type::Small => "SMALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LARGE" => Some(Self::Large),
                "SMALL" => Some(Self::Small),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Genre {
        Unspecified = 0,
        Offline = 1,
        Online = 2,
    }
    impl Genre {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Genre::Unspecified => "GENRE_UNSPECIFIED",
                Genre::Offline => "OFFLINE",
                Genre::Online => "ONLINE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GENRE_UNSPECIFIED" => Some(Self::Unspecified),
                "OFFLINE" => Some(Self::Offline),
                "ONLINE" => Some(Self::Online),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OnboardingType {
        Unspecified = 0,
        Aggregator = 1,
        Bank = 2,
        Network = 3,
        Tpap = 4,
    }
    impl OnboardingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OnboardingType::Unspecified => "ONBOARDING_TYPE_UNSPECIFIED",
                OnboardingType::Aggregator => "AGGREGATOR",
                OnboardingType::Bank => "BANK",
                OnboardingType::Network => "NETWORK",
                OnboardingType::Tpap => "TPAP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ONBOARDING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AGGREGATOR" => Some(Self::Aggregator),
                "BANK" => Some(Self::Bank),
                "NETWORK" => Some(Self::Network),
                "TPAP" => Some(Self::Tpap),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OwnershipType {
        Unspecified = 0,
        Proprietary = 1,
        Partnership = 2,
        Public = 3,
        Private = 4,
        Others = 5,
    }
    impl OwnershipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OwnershipType::Unspecified => "OWNERSHIP_TYPE_UNSPECIFIED",
                OwnershipType::Proprietary => "PROPRIETARY",
                OwnershipType::Partnership => "PARTNERSHIP",
                OwnershipType::Public => "PUBLIC",
                OwnershipType::Private => "PRIVATE",
                OwnershipType::Others => "OTHERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OWNERSHIP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "PROPRIETARY" => Some(Self::Proprietary),
                "PARTNERSHIP" => Some(Self::Partnership),
                "PUBLIC" => Some(Self::Public),
                "PRIVATE" => Some(Self::Private),
                "OTHERS" => Some(Self::Others),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApiType {
    Unspecified = 0,
    Balance = 1,
    CheckStatus = 2,
    Complaint = 3,
    HeartBeat = 4,
    InitiateRegistration = 5,
    ListAccounts = 6,
    Mandate = 7,
    MandateConfirmation = 8,
    SettlePayment = 9,
    UpdateCredentials = 10,
    ValidateRegistration = 11,
    ValidateCustomer = 12,
    Voucher = 13,
    VoucherConfirmation = 14,
    Activation = 15,
}
impl ApiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ApiType::Unspecified => "API_TYPE_UNSPECIFIED",
            ApiType::Balance => "BALANCE",
            ApiType::CheckStatus => "CHECK_STATUS",
            ApiType::Complaint => "COMPLAINT",
            ApiType::HeartBeat => "HEART_BEAT",
            ApiType::InitiateRegistration => "INITIATE_REGISTRATION",
            ApiType::ListAccounts => "LIST_ACCOUNTS",
            ApiType::Mandate => "MANDATE",
            ApiType::MandateConfirmation => "MANDATE_CONFIRMATION",
            ApiType::SettlePayment => "SETTLE_PAYMENT",
            ApiType::UpdateCredentials => "UPDATE_CREDENTIALS",
            ApiType::ValidateRegistration => "VALIDATE_REGISTRATION",
            ApiType::ValidateCustomer => "VALIDATE_CUSTOMER",
            ApiType::Voucher => "VOUCHER",
            ApiType::VoucherConfirmation => "VOUCHER_CONFIRMATION",
            ApiType::Activation => "ACTIVATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "API_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "BALANCE" => Some(Self::Balance),
            "CHECK_STATUS" => Some(Self::CheckStatus),
            "COMPLAINT" => Some(Self::Complaint),
            "HEART_BEAT" => Some(Self::HeartBeat),
            "INITIATE_REGISTRATION" => Some(Self::InitiateRegistration),
            "LIST_ACCOUNTS" => Some(Self::ListAccounts),
            "MANDATE" => Some(Self::Mandate),
            "MANDATE_CONFIRMATION" => Some(Self::MandateConfirmation),
            "SETTLE_PAYMENT" => Some(Self::SettlePayment),
            "UPDATE_CREDENTIALS" => Some(Self::UpdateCredentials),
            "VALIDATE_REGISTRATION" => Some(Self::ValidateRegistration),
            "VALIDATE_CUSTOMER" => Some(Self::ValidateCustomer),
            "VOUCHER" => Some(Self::Voucher),
            "VOUCHER_CONFIRMATION" => Some(Self::VoucherConfirmation),
            "ACTIVATION" => Some(Self::Activation),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionType {
    Unspecified = 0,
    Autoupdate = 1,
    BalanceCheck = 2,
    BalanceEnquiry = 3,
    CheckStatus = 4,
    CheckTransaction = 5,
    Complaint = 6,
    Create = 7,
    Credit = 8,
    Debit = 9,
    Dispute = 10,
    HeartBeat = 11,
    ListAccounts = 12,
    MandateNotification = 13,
    Otp = 14,
    Pause = 15,
    Redeem = 16,
    Refund = 17,
    RegisterMobile = 18,
    Reversal = 19,
    Revoke = 20,
    StatusUpdate = 21,
    Unpause = 22,
    Update = 23,
    UpdateCredentials = 24,
    ValidateCustomer = 25,
    ActivationInternational = 26,
    ActivationUpiServices = 27,
}
impl TransactionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionType::Unspecified => "TRANSACTION_TYPE_UNSPECIFIED",
            TransactionType::Autoupdate => "TRANSACTION_TYPE_AUTOUPDATE",
            TransactionType::BalanceCheck => "TRANSACTION_TYPE_BALANCE_CHECK",
            TransactionType::BalanceEnquiry => "TRANSACTION_TYPE_BALANCE_ENQUIRY",
            TransactionType::CheckStatus => "TRANSACTION_TYPE_CHECK_STATUS",
            TransactionType::CheckTransaction => "TRANSACTION_TYPE_CHECK_TRANSACTION",
            TransactionType::Complaint => "TRANSACTION_TYPE_COMPLAINT",
            TransactionType::Create => "TRANSACTION_TYPE_CREATE",
            TransactionType::Credit => "TRANSACTION_TYPE_CREDIT",
            TransactionType::Debit => "TRANSACTION_TYPE_DEBIT",
            TransactionType::Dispute => "TRANSACTION_TYPE_DISPUTE",
            TransactionType::HeartBeat => "TRANSACTION_TYPE_HEART_BEAT",
            TransactionType::ListAccounts => "TRANSACTION_TYPE_LIST_ACCOUNTS",
            TransactionType::MandateNotification => {
                "TRANSACTION_TYPE_MANDATE_NOTIFICATION"
            }
            TransactionType::Otp => "TRANSACTION_TYPE_OTP",
            TransactionType::Pause => "TRANSACTION_TYPE_PAUSE",
            TransactionType::Redeem => "TRANSACTION_TYPE_REDEEM",
            TransactionType::Refund => "TRANSACTION_TYPE_REFUND",
            TransactionType::RegisterMobile => "TRANSACTION_TYPE_REGISTER_MOBILE",
            TransactionType::Reversal => "TRANSACTION_TYPE_REVERSAL",
            TransactionType::Revoke => "TRANSACTION_TYPE_REVOKE",
            TransactionType::StatusUpdate => "TRANSACTION_TYPE_STATUS_UPDATE",
            TransactionType::Unpause => "TRANSACTION_TYPE_UNPAUSE",
            TransactionType::Update => "TRANSACTION_TYPE_UPDATE",
            TransactionType::UpdateCredentials => "TRANSACTION_TYPE_UPDATE_CREDENTIALS",
            TransactionType::ValidateCustomer => "TRANSACTION_TYPE_VALIDATE_CUSTOMER",
            TransactionType::ActivationInternational => {
                "TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL"
            }
            TransactionType::ActivationUpiServices => {
                "TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_TYPE_AUTOUPDATE" => Some(Self::Autoupdate),
            "TRANSACTION_TYPE_BALANCE_CHECK" => Some(Self::BalanceCheck),
            "TRANSACTION_TYPE_BALANCE_ENQUIRY" => Some(Self::BalanceEnquiry),
            "TRANSACTION_TYPE_CHECK_STATUS" => Some(Self::CheckStatus),
            "TRANSACTION_TYPE_CHECK_TRANSACTION" => Some(Self::CheckTransaction),
            "TRANSACTION_TYPE_COMPLAINT" => Some(Self::Complaint),
            "TRANSACTION_TYPE_CREATE" => Some(Self::Create),
            "TRANSACTION_TYPE_CREDIT" => Some(Self::Credit),
            "TRANSACTION_TYPE_DEBIT" => Some(Self::Debit),
            "TRANSACTION_TYPE_DISPUTE" => Some(Self::Dispute),
            "TRANSACTION_TYPE_HEART_BEAT" => Some(Self::HeartBeat),
            "TRANSACTION_TYPE_LIST_ACCOUNTS" => Some(Self::ListAccounts),
            "TRANSACTION_TYPE_MANDATE_NOTIFICATION" => Some(Self::MandateNotification),
            "TRANSACTION_TYPE_OTP" => Some(Self::Otp),
            "TRANSACTION_TYPE_PAUSE" => Some(Self::Pause),
            "TRANSACTION_TYPE_REDEEM" => Some(Self::Redeem),
            "TRANSACTION_TYPE_REFUND" => Some(Self::Refund),
            "TRANSACTION_TYPE_REGISTER_MOBILE" => Some(Self::RegisterMobile),
            "TRANSACTION_TYPE_REVERSAL" => Some(Self::Reversal),
            "TRANSACTION_TYPE_REVOKE" => Some(Self::Revoke),
            "TRANSACTION_TYPE_STATUS_UPDATE" => Some(Self::StatusUpdate),
            "TRANSACTION_TYPE_UNPAUSE" => Some(Self::Unpause),
            "TRANSACTION_TYPE_UPDATE" => Some(Self::Update),
            "TRANSACTION_TYPE_UPDATE_CREDENTIALS" => Some(Self::UpdateCredentials),
            "TRANSACTION_TYPE_VALIDATE_CUSTOMER" => Some(Self::ValidateCustomer),
            "TRANSACTION_TYPE_ACTIVATION_INTERNATIONAL" => {
                Some(Self::ActivationInternational)
            }
            "TRANSACTION_TYPE_ACTIVATION_UPI_SERVICES" => {
                Some(Self::ActivationUpiServices)
            }
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum XmlApiType {
    Unspecified = 0,
    ReqBalEnq = 1,
    ReqChkTxn = 2,
    ReqComplaint = 3,
    ReqHbt = 4,
    ReqListAccount = 5,
    ReqMandate = 6,
    ReqMandateConfirmation = 7,
    ReqOtp = 8,
    ReqPay = 9,
    ReqRegMob = 10,
    ReqSetCre = 11,
    ReqValCust = 12,
    ReqVoucher = 13,
    ReqVoucherConfirmation = 14,
    ReqTxnConfirmation = 15,
    RespBalEnq = 16,
    RespChkTxn = 17,
    RespComplaint = 18,
    RespHbt = 19,
    RespListAccount = 20,
    RespMandate = 21,
    RespMandateConfirmation = 22,
    RespOtp = 23,
    RespPay = 24,
    RespRegMob = 25,
    RespSetCre = 26,
    RespValCust = 27,
    RespVoucher = 28,
    RespVoucherConfirmation = 29,
    RespTxnConfirmation = 30,
    ReqActivation = 31,
    RespActivation = 32,
}
impl XmlApiType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            XmlApiType::Unspecified => "XML_API_TYPE_UNSPECIFIED",
            XmlApiType::ReqBalEnq => "REQ_BAL_ENQ",
            XmlApiType::ReqChkTxn => "REQ_CHK_TXN",
            XmlApiType::ReqComplaint => "REQ_COMPLAINT",
            XmlApiType::ReqHbt => "REQ_HBT",
            XmlApiType::ReqListAccount => "REQ_LIST_ACCOUNT",
            XmlApiType::ReqMandate => "REQ_MANDATE",
            XmlApiType::ReqMandateConfirmation => "REQ_MANDATE_CONFIRMATION",
            XmlApiType::ReqOtp => "REQ_OTP",
            XmlApiType::ReqPay => "REQ_PAY",
            XmlApiType::ReqRegMob => "REQ_REG_MOB",
            XmlApiType::ReqSetCre => "REQ_SET_CRE",
            XmlApiType::ReqValCust => "REQ_VAL_CUST",
            XmlApiType::ReqVoucher => "REQ_VOUCHER",
            XmlApiType::ReqVoucherConfirmation => "REQ_VOUCHER_CONFIRMATION",
            XmlApiType::ReqTxnConfirmation => "REQ_TXN_CONFIRMATION",
            XmlApiType::RespBalEnq => "RESP_BAL_ENQ",
            XmlApiType::RespChkTxn => "RESP_CHK_TXN",
            XmlApiType::RespComplaint => "RESP_COMPLAINT",
            XmlApiType::RespHbt => "RESP_HBT",
            XmlApiType::RespListAccount => "RESP_LIST_ACCOUNT",
            XmlApiType::RespMandate => "RESP_MANDATE",
            XmlApiType::RespMandateConfirmation => "RESP_MANDATE_CONFIRMATION",
            XmlApiType::RespOtp => "RESP_OTP",
            XmlApiType::RespPay => "RESP_PAY",
            XmlApiType::RespRegMob => "RESP_REG_MOB",
            XmlApiType::RespSetCre => "RESP_SET_CRE",
            XmlApiType::RespValCust => "RESP_VAL_CUST",
            XmlApiType::RespVoucher => "RESP_VOUCHER",
            XmlApiType::RespVoucherConfirmation => "RESP_VOUCHER_CONFIRMATION",
            XmlApiType::RespTxnConfirmation => "RESP_TXN_CONFIRMATION",
            XmlApiType::ReqActivation => "REQ_ACTIVATION",
            XmlApiType::RespActivation => "RESP_ACTIVATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "XML_API_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "REQ_BAL_ENQ" => Some(Self::ReqBalEnq),
            "REQ_CHK_TXN" => Some(Self::ReqChkTxn),
            "REQ_COMPLAINT" => Some(Self::ReqComplaint),
            "REQ_HBT" => Some(Self::ReqHbt),
            "REQ_LIST_ACCOUNT" => Some(Self::ReqListAccount),
            "REQ_MANDATE" => Some(Self::ReqMandate),
            "REQ_MANDATE_CONFIRMATION" => Some(Self::ReqMandateConfirmation),
            "REQ_OTP" => Some(Self::ReqOtp),
            "REQ_PAY" => Some(Self::ReqPay),
            "REQ_REG_MOB" => Some(Self::ReqRegMob),
            "REQ_SET_CRE" => Some(Self::ReqSetCre),
            "REQ_VAL_CUST" => Some(Self::ReqValCust),
            "REQ_VOUCHER" => Some(Self::ReqVoucher),
            "REQ_VOUCHER_CONFIRMATION" => Some(Self::ReqVoucherConfirmation),
            "REQ_TXN_CONFIRMATION" => Some(Self::ReqTxnConfirmation),
            "RESP_BAL_ENQ" => Some(Self::RespBalEnq),
            "RESP_CHK_TXN" => Some(Self::RespChkTxn),
            "RESP_COMPLAINT" => Some(Self::RespComplaint),
            "RESP_HBT" => Some(Self::RespHbt),
            "RESP_LIST_ACCOUNT" => Some(Self::RespListAccount),
            "RESP_MANDATE" => Some(Self::RespMandate),
            "RESP_MANDATE_CONFIRMATION" => Some(Self::RespMandateConfirmation),
            "RESP_OTP" => Some(Self::RespOtp),
            "RESP_PAY" => Some(Self::RespPay),
            "RESP_REG_MOB" => Some(Self::RespRegMob),
            "RESP_SET_CRE" => Some(Self::RespSetCre),
            "RESP_VAL_CUST" => Some(Self::RespValCust),
            "RESP_VOUCHER" => Some(Self::RespVoucher),
            "RESP_VOUCHER_CONFIRMATION" => Some(Self::RespVoucherConfirmation),
            "RESP_TXN_CONFIRMATION" => Some(Self::RespTxnConfirmation),
            "REQ_ACTIVATION" => Some(Self::ReqActivation),
            "RESP_ACTIVATION" => Some(Self::RespActivation),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Rule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub rule_description: ::prost::alloc::string::String,
    #[prost(enumeration = "ApiType", tag = "3")]
    pub api_type: i32,
    #[prost(enumeration = "TransactionType", tag = "4")]
    pub transaction_type: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleMetadata {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "rule_metadata::Type", tag = "3")]
    pub r#type: i32,
}
/// Nested message and enum types in `RuleMetadata`.
pub mod rule_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        List = 1,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::List => "LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "LIST" => Some(Self::List),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RuleMetadataValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "rule_metadata_value::Value", tags = "2, 3")]
    pub value: ::core::option::Option<rule_metadata_value::Value>,
}
/// Nested message and enum types in `RuleMetadataValue`.
pub mod rule_metadata_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(string, tag = "2")]
        Id(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        AccountReference(super::AccountReference),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rules: ::prost::alloc::vec::Vec<Rule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub total_size: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleMetadataRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleMetadataResponse {
    #[prost(message, repeated, tag = "1")]
    pub rule_metadata: ::prost::alloc::vec::Vec<RuleMetadata>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub total_size: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleMetadataValuesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRuleMetadataValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rule_metadata_values: ::prost::alloc::vec::Vec<RuleMetadataValue>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateRuleMetadataValuesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<CreateRuleMetadataValueRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateRuleMetadataValuesResponse {
    #[prost(message, repeated, tag = "1")]
    pub rule_metadata_value: ::prost::alloc::vec::Vec<RuleMetadataValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRuleMetadataValueRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rule_metadata_value: ::core::option::Option<RuleMetadataValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteRuleMetadataValuesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Generated client implementations.
pub mod issuer_switch_rules_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Manages rules used by the issuer switch's rules engine.
    #[derive(Debug, Clone)]
    pub struct IssuerSwitchRulesClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IssuerSwitchRulesClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IssuerSwitchRulesClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            IssuerSwitchRulesClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List all rules that are applied on transactions by the issuer switch. Rules
        /// can be filtered on API type and transaction type.
        pub async fn list_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules/ListRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
                        "ListRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all rule metadata for a given rule identifier.
        pub async fn list_rule_metadata(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuleMetadataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuleMetadataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules/ListRuleMetadata",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
                        "ListRuleMetadata",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all metadata values for a rule metadata identifier.
        pub async fn list_rule_metadata_values(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRuleMetadataValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRuleMetadataValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules/ListRuleMetadataValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
                        "ListRuleMetadataValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create (add) multiple values to the list of values under the specified rule
        /// metadata resource.
        pub async fn batch_create_rule_metadata_values(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateRuleMetadataValuesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateRuleMetadataValuesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules/BatchCreateRuleMetadataValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
                        "BatchCreateRuleMetadataValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Delete (remove) multiple values from the list of values under the specified
        /// rules metadata resource.
        pub async fn batch_delete_rule_metadata_values(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteRuleMetadataValuesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules/BatchDeleteRuleMetadataValues",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchRules",
                        "BatchDeleteRuleMetadataValues",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchParticipantRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub account_reference: ::core::option::Option<AccountReference>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssuerParticipant {
    #[prost(message, optional, tag = "1")]
    pub account_reference: ::core::option::Option<AccountReference>,
    #[prost(string, tag = "2")]
    pub mobile_number: ::prost::alloc::string::String,
    #[prost(enumeration = "issuer_participant::State", tag = "3")]
    pub state: i32,
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<issuer_participant::Metadata>,
    #[prost(int32, tag = "5")]
    pub mpin_failure_count: i32,
    #[prost(message, optional, tag = "6")]
    pub mpin_locked_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `IssuerParticipant`.
pub mod issuer_participant {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Metadata {
        #[prost(btree_map = "string, string", tag = "1")]
        pub values: ::prost::alloc::collections::BTreeMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Inactive = 1,
        Active = 2,
        MpinLocked = 3,
        MobileNumberChanged = 4,
        NewRegistrationInitiated = 5,
        ReRegistrationInitiated = 6,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Inactive => "INACTIVE",
                State::Active => "ACTIVE",
                State::MpinLocked => "MPIN_LOCKED",
                State::MobileNumberChanged => "MOBILE_NUMBER_CHANGED",
                State::NewRegistrationInitiated => "NEW_REGISTRATION_INITIATED",
                State::ReRegistrationInitiated => "RE_REGISTRATION_INITIATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "INACTIVE" => Some(Self::Inactive),
                "ACTIVE" => Some(Self::Active),
                "MPIN_LOCKED" => Some(Self::MpinLocked),
                "MOBILE_NUMBER_CHANGED" => Some(Self::MobileNumberChanged),
                "NEW_REGISTRATION_INITIATED" => Some(Self::NewRegistrationInitiated),
                "RE_REGISTRATION_INITIATED" => Some(Self::ReRegistrationInitiated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateIssuerParticipantRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub issuer_participant: ::core::option::Option<IssuerParticipant>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParticipantStateChangeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(oneof = "participant_state_change_request::Id", tags = "2, 3")]
    pub id: ::core::option::Option<participant_state_change_request::Id>,
}
/// Nested message and enum types in `ParticipantStateChangeRequest`.
pub mod participant_state_change_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Id {
        #[prost(message, tag = "2")]
        AccountReference(super::AccountReference),
        #[prost(string, tag = "3")]
        MobileNumber(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IssuerParticipants {
    #[prost(message, repeated, tag = "1")]
    pub participants: ::prost::alloc::vec::Vec<IssuerParticipant>,
}
/// Generated client implementations.
pub mod issuer_switch_participants_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// A service that allows for the management of participants in the issuer
    /// switch.
    #[derive(Debug, Clone)]
    pub struct IssuerSwitchParticipantsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IssuerSwitchParticipantsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IssuerSwitchParticipantsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            IssuerSwitchParticipantsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Fetch the issuer switch participant. This method can be used to retrieve
        /// all details of a participant in the issuer switch.
        ///
        /// In UPI, the participant is identified by their account's IFSC and their
        /// account number.
        pub async fn fetch_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchParticipantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssuerParticipant>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants/FetchParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants",
                        "FetchParticipant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Update the issuer switch participant. Currently, this API only allows for
        /// the
        /// \[metadata\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.metadata\]
        /// field to be updated.
        ///
        /// The `number` of key-value pairs in the `metadata` field, the length of each
        /// `key` and the length of each `value` should be within the thresholds
        /// defined for them in the issuer switch configuration. Any violation of these
        /// thresholds will cause this API to return an error. The default values for
        /// these thresholds are:
        ///
        /// * `Maximum number` of key-value pairs - `5`
        /// * `Maximum length` of a key - `100`
        /// * `Maximum length` of a value - `500`
        ///
        /// **Note** that this method replaces any existing `metadata` field value in
        /// the participant with the new value. Specifically, it does not do a merge.
        /// If key-value pairs are to be added/removed from the metadata, then
        /// callers must follow the following steps:
        ///
        /// 1. Invoke the
        ///   \[FetchParticipant\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants.FetchParticipant\]
        ///   API to get the current value of the `metadata` field.
        /// 1. Update the `metadata` map to add/remove key-value pairs from it.
        /// 1. Update the `metadata` in the issuer switch using this method.
        pub async fn update_issuer_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateIssuerParticipantRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssuerParticipant>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants/UpdateIssuerParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants",
                        "UpdateIssuerParticipant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Activate the issuer switch participant for UPI transactions. This API
        /// sets the state of the participant to
        /// \[ACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.ACTIVE\].
        /// A participant in the `ACTIVE` state can perform all UPI operations
        /// normally.
        ///
        /// The behavior of this API varies based on the current state of the
        /// participant.
        ///
        /// * Current state is
        ///  \[ACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.ACTIVE\]
        ///  : This API will make no change to the participant's state and returns a
        ///  successful response.
        /// * Current state is
        ///  \[INACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.INACTIVE\]
        ///  : If an *MPIN* has already been provisioned for the participant, then
        ///  this API will change the state of the participant to `ACTIVE`. Else,
        ///  this API will return an error.
        /// * Current state is
        ///  \[MOBILE_NUMBER_CHANGED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.MOBILE_NUMBER_CHANGED\]
        ///  : The state cannot be changed to `ACTIVE`. This API will return an
        ///  error.
        /// * Current state is
        ///  \[NEW_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.NEW_REGISTRATION_INITIATED\]
        ///  : The state cannot be changed to `ACTIVE`. This API will return an
        ///  error.
        /// * Current state is
        ///  \[RE_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.RE_REGISTRATION_INITIATED\]
        ///  : The state cannot be changed to `ACTIVE`. This API will return an
        ///  error.
        pub async fn activate_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::ParticipantStateChangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssuerParticipants>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants/ActivateParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants",
                        "ActivateParticipant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deactivate the issuer switch participant for UPI transactions. This API
        /// sets the state of the participant to
        /// \[INACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.INACTIVE\].
        /// An `INACTIVE` participant cannot perform any UPI operation which involves
        /// MPIN verification.
        ///
        /// The behavior of this API varies based on the current state of the
        /// participant.
        ///
        /// * Current state is
        ///  \[ACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.ACTIVE\]
        ///  : The state will change to `INACTIVE`. The user will be forced to
        ///  re-register with UPI and reset their MPIN  to perform any UPI
        ///  operations.
        /// * Current state is
        ///  \[INACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.INACTIVE\]
        ///  : This API will make no change to the participant's state and returns a
        ///  successful response.
        /// * Current state is
        ///  \[MOBILE_NUMBER_CHANGED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.MOBILE_NUMBER_CHANGED\]
        ///  : The state cannot be changed to `INACTIVE`. This API will return an
        ///  error.
        /// * Current state is
        ///  \[NEW_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.NEW_REGISTRATION_INITIATED\]
        ///  : The state cannot be changed to `INACTIVE`. This API will return an
        ///  error.
        /// * Current state is
        ///  \[RE_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.RE_REGISTRATION_INITIATED\]
        ///  : The state cannot be changed to `INACTIVE`. This API will return an
        ///  error.
        pub async fn deactivate_participant(
            &mut self,
            request: impl tonic::IntoRequest<super::ParticipantStateChangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssuerParticipants>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants/DeactivateParticipant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants",
                        "DeactivateParticipant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Mark the state of the issuer switch participant as *mobile number changed*
        /// to prevent UPI transactions by the user. This API sets the state of the
        /// participant to
        /// \[MOBILE_NUMBER_CHANGED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.MOBILE_NUMBER_CHANGED\].
        ///
        /// Any UPI operation for a participant in the `MOBILE_NUMBER_CHANGED` state
        /// will cause the issuer switch to return a `B1` error to the UPI payments
        /// orchestrator which would force the user to re-register with UPI.
        ///
        /// The behavior of this API varies based on the current state of the
        /// participant.
        ///
        /// * Current state is
        ///  \[ACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.ACTIVE\]
        ///  : The state will change to `MOBILE_NUMBER_CHANGED`. Any operation
        ///  involving MPIN verification of the participant will return a `B1` error
        ///  to the UPI payments orchestrator. The user will be forced to
        ///  re-register with their changed mobile number.
        /// * Current state is
        ///  \[INACTIVE\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.INACTIVE\]
        ///  : The state will change to `MOBILE_NUMBER_CHANGED`. Any operation
        ///  involving MPIN verification of the participant will return a `B1` error
        ///  to the UPI payments orchestrator. The user will be forced to
        ///  re-register with their changed mobile number.
        /// * Current state is
        ///  \[MOBILE_NUMBER_CHANGED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.MOBILE_NUMBER_CHANGED\]
        ///  : This API will make no change to the participant's state and returns a
        ///  successful response.
        /// * Current state is
        ///  \[NEW_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.NEW_REGISTRATION_INITIATED\]
        ///  : The state cannot be changed to `MOBILE_NUMBER_CHANGED`. This API will
        ///  return an error.
        /// * Current state is
        ///  \[RE_REGISTRATION_INITIATED\]\[google.cloud.paymentgateway.issuerswitch.v1.IssuerParticipant.State.RE_REGISTRATION_INITIATED\]
        ///  : The state will change to `MOBILE_NUMBER_CHANGED`. Any operation
        ///  involving MPIN verification of the participant will return a `B1` error
        ///  to the UPI payments orchestrator. The user will be forced to
        ///  re-register with their changed mobile number.
        pub async fn mobile_number_changed(
            &mut self,
            request: impl tonic::IntoRequest<super::ParticipantStateChangeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::IssuerParticipants>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants/MobileNumberChanged",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchParticipants",
                        "MobileNumberChanged",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Complaint {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub raise_complaint_adjustment: ::core::option::Option<RaiseComplaintAdjustment>,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<CaseDetails>,
    #[prost(message, optional, tag = "5")]
    pub response: ::core::option::Option<CaseResponse>,
    #[prost(message, optional, tag = "6")]
    pub resolve_complaint_adjustment: ::core::option::Option<ResolveComplaintAdjustment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateComplaintRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub complaint: ::core::option::Option<Complaint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolveComplaintRequest {
    #[prost(message, optional, tag = "1")]
    pub complaint: ::core::option::Option<Complaint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dispute {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub raise_dispute_adjustment: ::core::option::Option<RaiseDisputeAdjustment>,
    #[prost(message, optional, tag = "4")]
    pub details: ::core::option::Option<CaseDetails>,
    #[prost(message, optional, tag = "5")]
    pub response: ::core::option::Option<CaseResponse>,
    #[prost(message, optional, tag = "6")]
    pub resolve_dispute_adjustment: ::core::option::Option<ResolveDisputeAdjustment>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDisputeRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dispute: ::core::option::Option<Dispute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolveDisputeRequest {
    #[prost(message, optional, tag = "1")]
    pub dispute: ::core::option::Option<Dispute>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OriginalTransaction {
    #[prost(string, tag = "1")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub retrieval_reference_number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub request_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseDetails {
    #[prost(message, optional, tag = "1")]
    pub original_transaction: ::core::option::Option<OriginalTransaction>,
    #[prost(enumeration = "TransactionSubType", tag = "2")]
    pub transaction_sub_type: i32,
    #[prost(message, optional, tag = "3")]
    pub amount: ::core::option::Option<super::super::super::super::r#type::Money>,
    #[prost(string, tag = "4")]
    pub original_settlement_response_code: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub current_cycle: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CaseResponse {
    #[prost(string, tag = "1")]
    pub complaint_reference_number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub amount: ::core::option::Option<super::super::super::super::r#type::Money>,
    #[prost(string, tag = "3")]
    pub adjustment_flag: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub adjustment_code: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub adjustment_reference_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub adjustment_remarks: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub approval_number: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub process_status: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub adjustment_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "case_response::Result", tag = "12")]
    pub result: i32,
    #[prost(oneof = "case_response::Participant", tags = "10, 11")]
    pub participant: ::core::option::Option<case_response::Participant>,
}
/// Nested message and enum types in `CaseResponse`.
pub mod case_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Unspecified = 0,
        Success = 1,
        Failure = 2,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unspecified => "RESULT_UNSPECIFIED",
                Result::Success => "SUCCESS",
                Result::Failure => "FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCESS" => Some(Self::Success),
                "FAILURE" => Some(Self::Failure),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Participant {
        #[prost(message, tag = "10")]
        Payer(super::Participant),
        #[prost(message, tag = "11")]
        Payee(super::Participant),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RaiseComplaintAdjustment {
    #[prost(enumeration = "raise_complaint_adjustment::AdjustmentFlag", tag = "1")]
    pub adjustment_flag: i32,
    #[prost(enumeration = "raise_complaint_adjustment::ReasonCode", tag = "2")]
    pub adjustment_code: i32,
}
/// Nested message and enum types in `RaiseComplaintAdjustment`.
pub mod raise_complaint_adjustment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdjustmentFlag {
        Unspecified = 0,
        Raise = 1,
    }
    impl AdjustmentFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdjustmentFlag::Unspecified => "ADJUSTMENT_FLAG_UNSPECIFIED",
                AdjustmentFlag::Raise => "RAISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADJUSTMENT_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "RAISE" => Some(Self::Raise),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReasonCode {
        Unspecified = 0,
        CustomerAccountNotReversed = 1,
        GoodsServicesNotProvided = 2,
        CustomerAccountNotCreditedBack = 3,
        BeneficiaryAccountNotCredited = 4,
        GoodsServicesCreditNotProcessed = 5,
        MerchantNotReceivedConfirmation = 6,
        PaidByAlternateMeans = 7,
    }
    impl ReasonCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReasonCode::Unspecified => "REASON_CODE_UNSPECIFIED",
                ReasonCode::CustomerAccountNotReversed => "CUSTOMER_ACCOUNT_NOT_REVERSED",
                ReasonCode::GoodsServicesNotProvided => "GOODS_SERVICES_NOT_PROVIDED",
                ReasonCode::CustomerAccountNotCreditedBack => {
                    "CUSTOMER_ACCOUNT_NOT_CREDITED_BACK"
                }
                ReasonCode::BeneficiaryAccountNotCredited => {
                    "BENEFICIARY_ACCOUNT_NOT_CREDITED"
                }
                ReasonCode::GoodsServicesCreditNotProcessed => {
                    "GOODS_SERVICES_CREDIT_NOT_PROCESSED"
                }
                ReasonCode::MerchantNotReceivedConfirmation => {
                    "MERCHANT_NOT_RECEIVED_CONFIRMATION"
                }
                ReasonCode::PaidByAlternateMeans => "PAID_BY_ALTERNATE_MEANS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CUSTOMER_ACCOUNT_NOT_REVERSED" => Some(Self::CustomerAccountNotReversed),
                "GOODS_SERVICES_NOT_PROVIDED" => Some(Self::GoodsServicesNotProvided),
                "CUSTOMER_ACCOUNT_NOT_CREDITED_BACK" => {
                    Some(Self::CustomerAccountNotCreditedBack)
                }
                "BENEFICIARY_ACCOUNT_NOT_CREDITED" => {
                    Some(Self::BeneficiaryAccountNotCredited)
                }
                "GOODS_SERVICES_CREDIT_NOT_PROCESSED" => {
                    Some(Self::GoodsServicesCreditNotProcessed)
                }
                "MERCHANT_NOT_RECEIVED_CONFIRMATION" => {
                    Some(Self::MerchantNotReceivedConfirmation)
                }
                "PAID_BY_ALTERNATE_MEANS" => Some(Self::PaidByAlternateMeans),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResolveComplaintAdjustment {
    #[prost(enumeration = "resolve_complaint_adjustment::AdjustmentFlag", tag = "1")]
    pub adjustment_flag: i32,
    #[prost(enumeration = "resolve_complaint_adjustment::ReasonCode", tag = "2")]
    pub adjustment_code: i32,
}
/// Nested message and enum types in `ResolveComplaintAdjustment`.
pub mod resolve_complaint_adjustment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdjustmentFlag {
        Unspecified = 0,
        DebitReversalConfirmation = 1,
        Return = 2,
        RefundReversalConfirmation = 3,
        TransactionCreditConfirmation = 4,
    }
    impl AdjustmentFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdjustmentFlag::Unspecified => "ADJUSTMENT_FLAG_UNSPECIFIED",
                AdjustmentFlag::DebitReversalConfirmation => {
                    "DEBIT_REVERSAL_CONFIRMATION"
                }
                AdjustmentFlag::Return => "RETURN",
                AdjustmentFlag::RefundReversalConfirmation => {
                    "REFUND_REVERSAL_CONFIRMATION"
                }
                AdjustmentFlag::TransactionCreditConfirmation => {
                    "TRANSACTION_CREDIT_CONFIRMATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADJUSTMENT_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "DEBIT_REVERSAL_CONFIRMATION" => Some(Self::DebitReversalConfirmation),
                "RETURN" => Some(Self::Return),
                "REFUND_REVERSAL_CONFIRMATION" => Some(Self::RefundReversalConfirmation),
                "TRANSACTION_CREDIT_CONFIRMATION" => {
                    Some(Self::TransactionCreditConfirmation)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReasonCode {
        Unspecified = 0,
        ComplaintResolvedOnline = 1,
        ComplaintResolvedNowOrManually = 2,
        OriginalTransactionNotDone = 3,
        RetAccountClosed = 4,
        RetAccountDoesNotExist = 5,
        RetPartyInstructions = 6,
        RetNriAccount = 7,
        RetCreditFreezed = 8,
        RetInvalidBeneficiaryDetails = 9,
        RetAnyOtherReason = 10,
        RetBeneficiaryCannotCredit = 11,
        RetMerchantNotReceivedConfirmation = 12,
        RrcCustomerAccountCredited = 13,
    }
    impl ReasonCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReasonCode::Unspecified => "REASON_CODE_UNSPECIFIED",
                ReasonCode::ComplaintResolvedOnline => "COMPLAINT_RESOLVED_ONLINE",
                ReasonCode::ComplaintResolvedNowOrManually => {
                    "COMPLAINT_RESOLVED_NOW_OR_MANUALLY"
                }
                ReasonCode::OriginalTransactionNotDone => "ORIGINAL_TRANSACTION_NOT_DONE",
                ReasonCode::RetAccountClosed => "RET_ACCOUNT_CLOSED",
                ReasonCode::RetAccountDoesNotExist => "RET_ACCOUNT_DOES_NOT_EXIST",
                ReasonCode::RetPartyInstructions => "RET_PARTY_INSTRUCTIONS",
                ReasonCode::RetNriAccount => "RET_NRI_ACCOUNT",
                ReasonCode::RetCreditFreezed => "RET_CREDIT_FREEZED",
                ReasonCode::RetInvalidBeneficiaryDetails => {
                    "RET_INVALID_BENEFICIARY_DETAILS"
                }
                ReasonCode::RetAnyOtherReason => "RET_ANY_OTHER_REASON",
                ReasonCode::RetBeneficiaryCannotCredit => "RET_BENEFICIARY_CANNOT_CREDIT",
                ReasonCode::RetMerchantNotReceivedConfirmation => {
                    "RET_MERCHANT_NOT_RECEIVED_CONFIRMATION"
                }
                ReasonCode::RrcCustomerAccountCredited => "RRC_CUSTOMER_ACCOUNT_CREDITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "COMPLAINT_RESOLVED_ONLINE" => Some(Self::ComplaintResolvedOnline),
                "COMPLAINT_RESOLVED_NOW_OR_MANUALLY" => {
                    Some(Self::ComplaintResolvedNowOrManually)
                }
                "ORIGINAL_TRANSACTION_NOT_DONE" => Some(Self::OriginalTransactionNotDone),
                "RET_ACCOUNT_CLOSED" => Some(Self::RetAccountClosed),
                "RET_ACCOUNT_DOES_NOT_EXIST" => Some(Self::RetAccountDoesNotExist),
                "RET_PARTY_INSTRUCTIONS" => Some(Self::RetPartyInstructions),
                "RET_NRI_ACCOUNT" => Some(Self::RetNriAccount),
                "RET_CREDIT_FREEZED" => Some(Self::RetCreditFreezed),
                "RET_INVALID_BENEFICIARY_DETAILS" => {
                    Some(Self::RetInvalidBeneficiaryDetails)
                }
                "RET_ANY_OTHER_REASON" => Some(Self::RetAnyOtherReason),
                "RET_BENEFICIARY_CANNOT_CREDIT" => Some(Self::RetBeneficiaryCannotCredit),
                "RET_MERCHANT_NOT_RECEIVED_CONFIRMATION" => {
                    Some(Self::RetMerchantNotReceivedConfirmation)
                }
                "RRC_CUSTOMER_ACCOUNT_CREDITED" => Some(Self::RrcCustomerAccountCredited),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RaiseDisputeAdjustment {
    #[prost(enumeration = "raise_dispute_adjustment::AdjustmentFlag", tag = "1")]
    pub adjustment_flag: i32,
    #[prost(enumeration = "raise_dispute_adjustment::ReasonCode", tag = "2")]
    pub adjustment_code: i32,
}
/// Nested message and enum types in `RaiseDisputeAdjustment`.
pub mod raise_dispute_adjustment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdjustmentFlag {
        Unspecified = 0,
        ChargebackRaise = 1,
        FraudChargebackRaise = 2,
        WrongCreditChargebackRaise = 3,
        DeferredChargebackRaise = 4,
        PreArbitrationRaise = 5,
        DeferredPreArbitrationRaise = 6,
        ArbitrationRaise = 7,
        DeferredArbitrationRaise = 8,
    }
    impl AdjustmentFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdjustmentFlag::Unspecified => "ADJUSTMENT_FLAG_UNSPECIFIED",
                AdjustmentFlag::ChargebackRaise => "CHARGEBACK_RAISE",
                AdjustmentFlag::FraudChargebackRaise => "FRAUD_CHARGEBACK_RAISE",
                AdjustmentFlag::WrongCreditChargebackRaise => {
                    "WRONG_CREDIT_CHARGEBACK_RAISE"
                }
                AdjustmentFlag::DeferredChargebackRaise => "DEFERRED_CHARGEBACK_RAISE",
                AdjustmentFlag::PreArbitrationRaise => "PRE_ARBITRATION_RAISE",
                AdjustmentFlag::DeferredPreArbitrationRaise => {
                    "DEFERRED_PRE_ARBITRATION_RAISE"
                }
                AdjustmentFlag::ArbitrationRaise => "ARBITRATION_RAISE",
                AdjustmentFlag::DeferredArbitrationRaise => "DEFERRED_ARBITRATION_RAISE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADJUSTMENT_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "CHARGEBACK_RAISE" => Some(Self::ChargebackRaise),
                "FRAUD_CHARGEBACK_RAISE" => Some(Self::FraudChargebackRaise),
                "WRONG_CREDIT_CHARGEBACK_RAISE" => Some(Self::WrongCreditChargebackRaise),
                "DEFERRED_CHARGEBACK_RAISE" => Some(Self::DeferredChargebackRaise),
                "PRE_ARBITRATION_RAISE" => Some(Self::PreArbitrationRaise),
                "DEFERRED_PRE_ARBITRATION_RAISE" => {
                    Some(Self::DeferredPreArbitrationRaise)
                }
                "ARBITRATION_RAISE" => Some(Self::ArbitrationRaise),
                "DEFERRED_ARBITRATION_RAISE" => Some(Self::DeferredArbitrationRaise),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReasonCode {
        Unspecified = 0,
        ChargebackRaiseRemitterDebitedBeneficiaryNotCredited = 1,
        PreArbitrationRaiseBeneficiaryNotCredited = 2,
        DeferredChargebackRaiseBeneficiaryNotCredited = 3,
        DeferredPreArbitrationRaiseBeneficiaryNotCredited = 4,
        DeferredArbitrationRaiseDeferredChargebackPreArbitrationRejected = 5,
        ChargebackOnFraud = 6,
        GoodsServicesCreditNotProcessed = 7,
        GoodsServicesDefective = 8,
        PaidByAlternateMeans = 9,
        GoodsServicesNotReceived = 10,
        MerchantNotReceivedConfirmation = 11,
        TransactionNotSteeled = 12,
        DuplicateTransaction = 13,
        ChargebackCardHolderChargedMore = 14,
        CustomerClaimingGoodsServicesNotDelivered = 15,
        PartiesDenied = 16,
        FundsTransferredToUnintendedBeneficiary = 17,
    }
    impl ReasonCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReasonCode::Unspecified => "REASON_CODE_UNSPECIFIED",
                ReasonCode::ChargebackRaiseRemitterDebitedBeneficiaryNotCredited => {
                    "CHARGEBACK_RAISE_REMITTER_DEBITED_BENEFICIARY_NOT_CREDITED"
                }
                ReasonCode::PreArbitrationRaiseBeneficiaryNotCredited => {
                    "PRE_ARBITRATION_RAISE_BENEFICIARY_NOT_CREDITED"
                }
                ReasonCode::DeferredChargebackRaiseBeneficiaryNotCredited => {
                    "DEFERRED_CHARGEBACK_RAISE_BENEFICIARY_NOT_CREDITED"
                }
                ReasonCode::DeferredPreArbitrationRaiseBeneficiaryNotCredited => {
                    "DEFERRED_PRE_ARBITRATION_RAISE_BENEFICIARY_NOT_CREDITED"
                }
                ReasonCode::DeferredArbitrationRaiseDeferredChargebackPreArbitrationRejected => {
                    "DEFERRED_ARBITRATION_RAISE_DEFERRED_CHARGEBACK_PRE_ARBITRATION_REJECTED"
                }
                ReasonCode::ChargebackOnFraud => "CHARGEBACK_ON_FRAUD",
                ReasonCode::GoodsServicesCreditNotProcessed => {
                    "GOODS_SERVICES_CREDIT_NOT_PROCESSED"
                }
                ReasonCode::GoodsServicesDefective => "GOODS_SERVICES_DEFECTIVE",
                ReasonCode::PaidByAlternateMeans => "PAID_BY_ALTERNATE_MEANS",
                ReasonCode::GoodsServicesNotReceived => "GOODS_SERVICES_NOT_RECEIVED",
                ReasonCode::MerchantNotReceivedConfirmation => {
                    "MERCHANT_NOT_RECEIVED_CONFIRMATION"
                }
                ReasonCode::TransactionNotSteeled => "TRANSACTION_NOT_STEELED",
                ReasonCode::DuplicateTransaction => "DUPLICATE_TRANSACTION",
                ReasonCode::ChargebackCardHolderChargedMore => {
                    "CHARGEBACK_CARD_HOLDER_CHARGED_MORE"
                }
                ReasonCode::CustomerClaimingGoodsServicesNotDelivered => {
                    "CUSTOMER_CLAIMING_GOODS_SERVICES_NOT_DELIVERED"
                }
                ReasonCode::PartiesDenied => "PARTIES_DENIED",
                ReasonCode::FundsTransferredToUnintendedBeneficiary => {
                    "FUNDS_TRANSFERRED_TO_UNINTENDED_BENEFICIARY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CHARGEBACK_RAISE_REMITTER_DEBITED_BENEFICIARY_NOT_CREDITED" => {
                    Some(Self::ChargebackRaiseRemitterDebitedBeneficiaryNotCredited)
                }
                "PRE_ARBITRATION_RAISE_BENEFICIARY_NOT_CREDITED" => {
                    Some(Self::PreArbitrationRaiseBeneficiaryNotCredited)
                }
                "DEFERRED_CHARGEBACK_RAISE_BENEFICIARY_NOT_CREDITED" => {
                    Some(Self::DeferredChargebackRaiseBeneficiaryNotCredited)
                }
                "DEFERRED_PRE_ARBITRATION_RAISE_BENEFICIARY_NOT_CREDITED" => {
                    Some(Self::DeferredPreArbitrationRaiseBeneficiaryNotCredited)
                }
                "DEFERRED_ARBITRATION_RAISE_DEFERRED_CHARGEBACK_PRE_ARBITRATION_REJECTED" => {
                    Some(
                        Self::DeferredArbitrationRaiseDeferredChargebackPreArbitrationRejected,
                    )
                }
                "CHARGEBACK_ON_FRAUD" => Some(Self::ChargebackOnFraud),
                "GOODS_SERVICES_CREDIT_NOT_PROCESSED" => {
                    Some(Self::GoodsServicesCreditNotProcessed)
                }
                "GOODS_SERVICES_DEFECTIVE" => Some(Self::GoodsServicesDefective),
                "PAID_BY_ALTERNATE_MEANS" => Some(Self::PaidByAlternateMeans),
                "GOODS_SERVICES_NOT_RECEIVED" => Some(Self::GoodsServicesNotReceived),
                "MERCHANT_NOT_RECEIVED_CONFIRMATION" => {
                    Some(Self::MerchantNotReceivedConfirmation)
                }
                "TRANSACTION_NOT_STEELED" => Some(Self::TransactionNotSteeled),
                "DUPLICATE_TRANSACTION" => Some(Self::DuplicateTransaction),
                "CHARGEBACK_CARD_HOLDER_CHARGED_MORE" => {
                    Some(Self::ChargebackCardHolderChargedMore)
                }
                "CUSTOMER_CLAIMING_GOODS_SERVICES_NOT_DELIVERED" => {
                    Some(Self::CustomerClaimingGoodsServicesNotDelivered)
                }
                "PARTIES_DENIED" => Some(Self::PartiesDenied),
                "FUNDS_TRANSFERRED_TO_UNINTENDED_BENEFICIARY" => {
                    Some(Self::FundsTransferredToUnintendedBeneficiary)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResolveDisputeAdjustment {
    #[prost(enumeration = "resolve_dispute_adjustment::AdjustmentFlag", tag = "1")]
    pub adjustment_flag: i32,
    #[prost(enumeration = "resolve_dispute_adjustment::ReasonCode", tag = "2")]
    pub adjustment_code: i32,
}
/// Nested message and enum types in `ResolveDisputeAdjustment`.
pub mod resolve_dispute_adjustment {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdjustmentFlag {
        Unspecified = 0,
        RePresentmentRaise = 1,
        DeferredRePresentmentRaise = 2,
        ChargebackAcceptance = 3,
        DeferredChargebackAcceptance = 4,
        PreArbitrationAcceptance = 5,
        DeferredPreArbitrationAcceptance = 6,
        PreArbitrationDeclined = 7,
        DeferredPreArbitrationDeclined = 8,
        ArbitrationAcceptance = 9,
        ArbitrationContinuation = 10,
        ArbitrationWithdrawn = 11,
        ArbitrationVerdict = 12,
        CreditAdjustment = 13,
        FraudChargebackRepresentment = 14,
        FraudChargebackAccept = 15,
        WrongCreditRepresentment = 16,
        WrongCreditChargebackAcceptance = 17,
        ManualAdjustment = 18,
    }
    impl AdjustmentFlag {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdjustmentFlag::Unspecified => "ADJUSTMENT_FLAG_UNSPECIFIED",
                AdjustmentFlag::RePresentmentRaise => "RE_PRESENTMENT_RAISE",
                AdjustmentFlag::DeferredRePresentmentRaise => {
                    "DEFERRED_RE_PRESENTMENT_RAISE"
                }
                AdjustmentFlag::ChargebackAcceptance => "CHARGEBACK_ACCEPTANCE",
                AdjustmentFlag::DeferredChargebackAcceptance => {
                    "DEFERRED_CHARGEBACK_ACCEPTANCE"
                }
                AdjustmentFlag::PreArbitrationAcceptance => "PRE_ARBITRATION_ACCEPTANCE",
                AdjustmentFlag::DeferredPreArbitrationAcceptance => {
                    "DEFERRED_PRE_ARBITRATION_ACCEPTANCE"
                }
                AdjustmentFlag::PreArbitrationDeclined => "PRE_ARBITRATION_DECLINED",
                AdjustmentFlag::DeferredPreArbitrationDeclined => {
                    "DEFERRED_PRE_ARBITRATION_DECLINED"
                }
                AdjustmentFlag::ArbitrationAcceptance => "ARBITRATION_ACCEPTANCE",
                AdjustmentFlag::ArbitrationContinuation => "ARBITRATION_CONTINUATION",
                AdjustmentFlag::ArbitrationWithdrawn => "ARBITRATION_WITHDRAWN",
                AdjustmentFlag::ArbitrationVerdict => "ARBITRATION_VERDICT",
                AdjustmentFlag::CreditAdjustment => "CREDIT_ADJUSTMENT",
                AdjustmentFlag::FraudChargebackRepresentment => {
                    "FRAUD_CHARGEBACK_REPRESENTMENT"
                }
                AdjustmentFlag::FraudChargebackAccept => "FRAUD_CHARGEBACK_ACCEPT",
                AdjustmentFlag::WrongCreditRepresentment => "WRONG_CREDIT_REPRESENTMENT",
                AdjustmentFlag::WrongCreditChargebackAcceptance => {
                    "WRONG_CREDIT_CHARGEBACK_ACCEPTANCE"
                }
                AdjustmentFlag::ManualAdjustment => "MANUAL_ADJUSTMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADJUSTMENT_FLAG_UNSPECIFIED" => Some(Self::Unspecified),
                "RE_PRESENTMENT_RAISE" => Some(Self::RePresentmentRaise),
                "DEFERRED_RE_PRESENTMENT_RAISE" => Some(Self::DeferredRePresentmentRaise),
                "CHARGEBACK_ACCEPTANCE" => Some(Self::ChargebackAcceptance),
                "DEFERRED_CHARGEBACK_ACCEPTANCE" => {
                    Some(Self::DeferredChargebackAcceptance)
                }
                "PRE_ARBITRATION_ACCEPTANCE" => Some(Self::PreArbitrationAcceptance),
                "DEFERRED_PRE_ARBITRATION_ACCEPTANCE" => {
                    Some(Self::DeferredPreArbitrationAcceptance)
                }
                "PRE_ARBITRATION_DECLINED" => Some(Self::PreArbitrationDeclined),
                "DEFERRED_PRE_ARBITRATION_DECLINED" => {
                    Some(Self::DeferredPreArbitrationDeclined)
                }
                "ARBITRATION_ACCEPTANCE" => Some(Self::ArbitrationAcceptance),
                "ARBITRATION_CONTINUATION" => Some(Self::ArbitrationContinuation),
                "ARBITRATION_WITHDRAWN" => Some(Self::ArbitrationWithdrawn),
                "ARBITRATION_VERDICT" => Some(Self::ArbitrationVerdict),
                "CREDIT_ADJUSTMENT" => Some(Self::CreditAdjustment),
                "FRAUD_CHARGEBACK_REPRESENTMENT" => {
                    Some(Self::FraudChargebackRepresentment)
                }
                "FRAUD_CHARGEBACK_ACCEPT" => Some(Self::FraudChargebackAccept),
                "WRONG_CREDIT_REPRESENTMENT" => Some(Self::WrongCreditRepresentment),
                "WRONG_CREDIT_CHARGEBACK_ACCEPTANCE" => {
                    Some(Self::WrongCreditChargebackAcceptance)
                }
                "MANUAL_ADJUSTMENT" => Some(Self::ManualAdjustment),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReasonCode {
        Unspecified = 0,
        ChargebackBeneficiaryCannotCreditOrPreArbitrationDuplicateProcess = 1,
        PreArbitrationDeclinedBeneficiaryCreditedOnline = 3,
        PreArbitrationDeclinedBeneficiaryCreditedManually = 4,
        DeferredChargebackAcceptanceAccountNotCreditedTccRaised = 5,
        DeferredRePresentmentRaiseAccountCreditedTccRaised = 6,
        DeferredPreArbitrationAcceptanceAccountNotCredited = 7,
        DeferredPreArbitrationDeclinedAccountCredited = 8,
        FraudChargebackAcceptAmountRecoveredFromFraudulentAccount = 9,
        FraudChargebackRepresentmentLienMarkedInsufficientBalance = 10,
        FraudChargebackRepresentmentFirNotProvided = 11,
        FraudChargebackRepresentmentReasonOthers = 12,
        RePresentmentRaiseBeneficiaryCreditedOnline = 13,
        RePresentmentRaiseBeneficiaryCreditedManually = 14,
        CreditAdjustmentGoodsServicesCreditNotProcessed = 15,
        CreditAdjustmentGoodsServicesDefective = 16,
        CreditAdjustmentPaidByAlternateMeans = 17,
        CreditAdjustmentGoodsServicesNotReceived = 18,
        CreditAdjustmentMerchantNotReceivedConfirmation = 19,
        CreditAdjustmentDuplicateTransaction = 20,
        CreditAdjustmentReasonOthers = 21,
        CreditAdjustmentNonMatchingAccountNumber = 22,
        CreditAdjustmentCardHolderChargedMore = 23,
        CreditAdjustmentCreditNotProcessed = 24,
        CreditAdjustmentBeneficiaryCannotCredit = 25,
        ChargebackAcceptanceMerchantCannotProvideService = 26,
        RePresentmentRaiseGoodsServicesProvided = 27,
        PreArbitrationDeclinedServicesProvidedLater = 28,
        PreArbitrationAcceptanceServicesNotProvidedByMerchant = 29,
        ArbitrationAcceptanceIllegibleFulfilment = 30,
        ArbitrationContinuationCustomerStillNotReceivedService = 31,
        ArbitrationWithdrawnCustomerReceivedServiceLater = 32,
        ArbitrationVerdictPanelVerdict = 33,
        ManualAdjustmentReason = 34,
        AttributingCustomer = 35,
        AttributingTechnicalIssue = 36,
        WrongCreditChargebackAcceptanceAmountRecovered = 37,
        WrongCreditRepresentmentLienMarkedInsufficientBalance = 38,
        WrongCreditRepresentmentCustomerInaccessible = 39,
        WrongCreditRepresentmentReasonOthers = 40,
    }
    impl ReasonCode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReasonCode::Unspecified => "REASON_CODE_UNSPECIFIED",
                ReasonCode::ChargebackBeneficiaryCannotCreditOrPreArbitrationDuplicateProcess => {
                    "CHARGEBACK_BENEFICIARY_CANNOT_CREDIT_OR_PRE_ARBITRATION_DUPLICATE_PROCESS"
                }
                ReasonCode::PreArbitrationDeclinedBeneficiaryCreditedOnline => {
                    "PRE_ARBITRATION_DECLINED_BENEFICIARY_CREDITED_ONLINE"
                }
                ReasonCode::PreArbitrationDeclinedBeneficiaryCreditedManually => {
                    "PRE_ARBITRATION_DECLINED_BENEFICIARY_CREDITED_MANUALLY"
                }
                ReasonCode::DeferredChargebackAcceptanceAccountNotCreditedTccRaised => {
                    "DEFERRED_CHARGEBACK_ACCEPTANCE_ACCOUNT_NOT_CREDITED_TCC_RAISED"
                }
                ReasonCode::DeferredRePresentmentRaiseAccountCreditedTccRaised => {
                    "DEFERRED_RE_PRESENTMENT_RAISE_ACCOUNT_CREDITED_TCC_RAISED"
                }
                ReasonCode::DeferredPreArbitrationAcceptanceAccountNotCredited => {
                    "DEFERRED_PRE_ARBITRATION_ACCEPTANCE_ACCOUNT_NOT_CREDITED"
                }
                ReasonCode::DeferredPreArbitrationDeclinedAccountCredited => {
                    "DEFERRED_PRE_ARBITRATION_DECLINED_ACCOUNT_CREDITED"
                }
                ReasonCode::FraudChargebackAcceptAmountRecoveredFromFraudulentAccount => {
                    "FRAUD_CHARGEBACK_ACCEPT_AMOUNT_RECOVERED_FROM_FRAUDULENT_ACCOUNT"
                }
                ReasonCode::FraudChargebackRepresentmentLienMarkedInsufficientBalance => {
                    "FRAUD_CHARGEBACK_REPRESENTMENT_LIEN_MARKED_INSUFFICIENT_BALANCE"
                }
                ReasonCode::FraudChargebackRepresentmentFirNotProvided => {
                    "FRAUD_CHARGEBACK_REPRESENTMENT_FIR_NOT_PROVIDED"
                }
                ReasonCode::FraudChargebackRepresentmentReasonOthers => {
                    "FRAUD_CHARGEBACK_REPRESENTMENT_REASON_OTHERS"
                }
                ReasonCode::RePresentmentRaiseBeneficiaryCreditedOnline => {
                    "RE_PRESENTMENT_RAISE_BENEFICIARY_CREDITED_ONLINE"
                }
                ReasonCode::RePresentmentRaiseBeneficiaryCreditedManually => {
                    "RE_PRESENTMENT_RAISE_BENEFICIARY_CREDITED_MANUALLY"
                }
                ReasonCode::CreditAdjustmentGoodsServicesCreditNotProcessed => {
                    "CREDIT_ADJUSTMENT_GOODS_SERVICES_CREDIT_NOT_PROCESSED"
                }
                ReasonCode::CreditAdjustmentGoodsServicesDefective => {
                    "CREDIT_ADJUSTMENT_GOODS_SERVICES_DEFECTIVE"
                }
                ReasonCode::CreditAdjustmentPaidByAlternateMeans => {
                    "CREDIT_ADJUSTMENT_PAID_BY_ALTERNATE_MEANS"
                }
                ReasonCode::CreditAdjustmentGoodsServicesNotReceived => {
                    "CREDIT_ADJUSTMENT_GOODS_SERVICES_NOT_RECEIVED"
                }
                ReasonCode::CreditAdjustmentMerchantNotReceivedConfirmation => {
                    "CREDIT_ADJUSTMENT_MERCHANT_NOT_RECEIVED_CONFIRMATION"
                }
                ReasonCode::CreditAdjustmentDuplicateTransaction => {
                    "CREDIT_ADJUSTMENT_DUPLICATE_TRANSACTION"
                }
                ReasonCode::CreditAdjustmentReasonOthers => {
                    "CREDIT_ADJUSTMENT_REASON_OTHERS"
                }
                ReasonCode::CreditAdjustmentNonMatchingAccountNumber => {
                    "CREDIT_ADJUSTMENT_NON_MATCHING_ACCOUNT_NUMBER"
                }
                ReasonCode::CreditAdjustmentCardHolderChargedMore => {
                    "CREDIT_ADJUSTMENT_CARD_HOLDER_CHARGED_MORE"
                }
                ReasonCode::CreditAdjustmentCreditNotProcessed => {
                    "CREDIT_ADJUSTMENT_CREDIT_NOT_PROCESSED"
                }
                ReasonCode::CreditAdjustmentBeneficiaryCannotCredit => {
                    "CREDIT_ADJUSTMENT_BENEFICIARY_CANNOT_CREDIT"
                }
                ReasonCode::ChargebackAcceptanceMerchantCannotProvideService => {
                    "CHARGEBACK_ACCEPTANCE_MERCHANT_CANNOT_PROVIDE_SERVICE"
                }
                ReasonCode::RePresentmentRaiseGoodsServicesProvided => {
                    "RE_PRESENTMENT_RAISE_GOODS_SERVICES_PROVIDED"
                }
                ReasonCode::PreArbitrationDeclinedServicesProvidedLater => {
                    "PRE_ARBITRATION_DECLINED_SERVICES_PROVIDED_LATER"
                }
                ReasonCode::PreArbitrationAcceptanceServicesNotProvidedByMerchant => {
                    "PRE_ARBITRATION_ACCEPTANCE_SERVICES_NOT_PROVIDED_BY_MERCHANT"
                }
                ReasonCode::ArbitrationAcceptanceIllegibleFulfilment => {
                    "ARBITRATION_ACCEPTANCE_ILLEGIBLE_FULFILMENT"
                }
                ReasonCode::ArbitrationContinuationCustomerStillNotReceivedService => {
                    "ARBITRATION_CONTINUATION_CUSTOMER_STILL_NOT_RECEIVED_SERVICE"
                }
                ReasonCode::ArbitrationWithdrawnCustomerReceivedServiceLater => {
                    "ARBITRATION_WITHDRAWN_CUSTOMER_RECEIVED_SERVICE_LATER"
                }
                ReasonCode::ArbitrationVerdictPanelVerdict => {
                    "ARBITRATION_VERDICT_PANEL_VERDICT"
                }
                ReasonCode::ManualAdjustmentReason => "MANUAL_ADJUSTMENT_REASON",
                ReasonCode::AttributingCustomer => "ATTRIBUTING_CUSTOMER",
                ReasonCode::AttributingTechnicalIssue => "ATTRIBUTING_TECHNICAL_ISSUE",
                ReasonCode::WrongCreditChargebackAcceptanceAmountRecovered => {
                    "WRONG_CREDIT_CHARGEBACK_ACCEPTANCE_AMOUNT_RECOVERED"
                }
                ReasonCode::WrongCreditRepresentmentLienMarkedInsufficientBalance => {
                    "WRONG_CREDIT_REPRESENTMENT_LIEN_MARKED_INSUFFICIENT_BALANCE"
                }
                ReasonCode::WrongCreditRepresentmentCustomerInaccessible => {
                    "WRONG_CREDIT_REPRESENTMENT_CUSTOMER_INACCESSIBLE"
                }
                ReasonCode::WrongCreditRepresentmentReasonOthers => {
                    "WRONG_CREDIT_REPRESENTMENT_REASON_OTHERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REASON_CODE_UNSPECIFIED" => Some(Self::Unspecified),
                "CHARGEBACK_BENEFICIARY_CANNOT_CREDIT_OR_PRE_ARBITRATION_DUPLICATE_PROCESS" => {
                    Some(
                        Self::ChargebackBeneficiaryCannotCreditOrPreArbitrationDuplicateProcess,
                    )
                }
                "PRE_ARBITRATION_DECLINED_BENEFICIARY_CREDITED_ONLINE" => {
                    Some(Self::PreArbitrationDeclinedBeneficiaryCreditedOnline)
                }
                "PRE_ARBITRATION_DECLINED_BENEFICIARY_CREDITED_MANUALLY" => {
                    Some(Self::PreArbitrationDeclinedBeneficiaryCreditedManually)
                }
                "DEFERRED_CHARGEBACK_ACCEPTANCE_ACCOUNT_NOT_CREDITED_TCC_RAISED" => {
                    Some(Self::DeferredChargebackAcceptanceAccountNotCreditedTccRaised)
                }
                "DEFERRED_RE_PRESENTMENT_RAISE_ACCOUNT_CREDITED_TCC_RAISED" => {
                    Some(Self::DeferredRePresentmentRaiseAccountCreditedTccRaised)
                }
                "DEFERRED_PRE_ARBITRATION_ACCEPTANCE_ACCOUNT_NOT_CREDITED" => {
                    Some(Self::DeferredPreArbitrationAcceptanceAccountNotCredited)
                }
                "DEFERRED_PRE_ARBITRATION_DECLINED_ACCOUNT_CREDITED" => {
                    Some(Self::DeferredPreArbitrationDeclinedAccountCredited)
                }
                "FRAUD_CHARGEBACK_ACCEPT_AMOUNT_RECOVERED_FROM_FRAUDULENT_ACCOUNT" => {
                    Some(Self::FraudChargebackAcceptAmountRecoveredFromFraudulentAccount)
                }
                "FRAUD_CHARGEBACK_REPRESENTMENT_LIEN_MARKED_INSUFFICIENT_BALANCE" => {
                    Some(Self::FraudChargebackRepresentmentLienMarkedInsufficientBalance)
                }
                "FRAUD_CHARGEBACK_REPRESENTMENT_FIR_NOT_PROVIDED" => {
                    Some(Self::FraudChargebackRepresentmentFirNotProvided)
                }
                "FRAUD_CHARGEBACK_REPRESENTMENT_REASON_OTHERS" => {
                    Some(Self::FraudChargebackRepresentmentReasonOthers)
                }
                "RE_PRESENTMENT_RAISE_BENEFICIARY_CREDITED_ONLINE" => {
                    Some(Self::RePresentmentRaiseBeneficiaryCreditedOnline)
                }
                "RE_PRESENTMENT_RAISE_BENEFICIARY_CREDITED_MANUALLY" => {
                    Some(Self::RePresentmentRaiseBeneficiaryCreditedManually)
                }
                "CREDIT_ADJUSTMENT_GOODS_SERVICES_CREDIT_NOT_PROCESSED" => {
                    Some(Self::CreditAdjustmentGoodsServicesCreditNotProcessed)
                }
                "CREDIT_ADJUSTMENT_GOODS_SERVICES_DEFECTIVE" => {
                    Some(Self::CreditAdjustmentGoodsServicesDefective)
                }
                "CREDIT_ADJUSTMENT_PAID_BY_ALTERNATE_MEANS" => {
                    Some(Self::CreditAdjustmentPaidByAlternateMeans)
                }
                "CREDIT_ADJUSTMENT_GOODS_SERVICES_NOT_RECEIVED" => {
                    Some(Self::CreditAdjustmentGoodsServicesNotReceived)
                }
                "CREDIT_ADJUSTMENT_MERCHANT_NOT_RECEIVED_CONFIRMATION" => {
                    Some(Self::CreditAdjustmentMerchantNotReceivedConfirmation)
                }
                "CREDIT_ADJUSTMENT_DUPLICATE_TRANSACTION" => {
                    Some(Self::CreditAdjustmentDuplicateTransaction)
                }
                "CREDIT_ADJUSTMENT_REASON_OTHERS" => {
                    Some(Self::CreditAdjustmentReasonOthers)
                }
                "CREDIT_ADJUSTMENT_NON_MATCHING_ACCOUNT_NUMBER" => {
                    Some(Self::CreditAdjustmentNonMatchingAccountNumber)
                }
                "CREDIT_ADJUSTMENT_CARD_HOLDER_CHARGED_MORE" => {
                    Some(Self::CreditAdjustmentCardHolderChargedMore)
                }
                "CREDIT_ADJUSTMENT_CREDIT_NOT_PROCESSED" => {
                    Some(Self::CreditAdjustmentCreditNotProcessed)
                }
                "CREDIT_ADJUSTMENT_BENEFICIARY_CANNOT_CREDIT" => {
                    Some(Self::CreditAdjustmentBeneficiaryCannotCredit)
                }
                "CHARGEBACK_ACCEPTANCE_MERCHANT_CANNOT_PROVIDE_SERVICE" => {
                    Some(Self::ChargebackAcceptanceMerchantCannotProvideService)
                }
                "RE_PRESENTMENT_RAISE_GOODS_SERVICES_PROVIDED" => {
                    Some(Self::RePresentmentRaiseGoodsServicesProvided)
                }
                "PRE_ARBITRATION_DECLINED_SERVICES_PROVIDED_LATER" => {
                    Some(Self::PreArbitrationDeclinedServicesProvidedLater)
                }
                "PRE_ARBITRATION_ACCEPTANCE_SERVICES_NOT_PROVIDED_BY_MERCHANT" => {
                    Some(Self::PreArbitrationAcceptanceServicesNotProvidedByMerchant)
                }
                "ARBITRATION_ACCEPTANCE_ILLEGIBLE_FULFILMENT" => {
                    Some(Self::ArbitrationAcceptanceIllegibleFulfilment)
                }
                "ARBITRATION_CONTINUATION_CUSTOMER_STILL_NOT_RECEIVED_SERVICE" => {
                    Some(Self::ArbitrationContinuationCustomerStillNotReceivedService)
                }
                "ARBITRATION_WITHDRAWN_CUSTOMER_RECEIVED_SERVICE_LATER" => {
                    Some(Self::ArbitrationWithdrawnCustomerReceivedServiceLater)
                }
                "ARBITRATION_VERDICT_PANEL_VERDICT" => {
                    Some(Self::ArbitrationVerdictPanelVerdict)
                }
                "MANUAL_ADJUSTMENT_REASON" => Some(Self::ManualAdjustmentReason),
                "ATTRIBUTING_CUSTOMER" => Some(Self::AttributingCustomer),
                "ATTRIBUTING_TECHNICAL_ISSUE" => Some(Self::AttributingTechnicalIssue),
                "WRONG_CREDIT_CHARGEBACK_ACCEPTANCE_AMOUNT_RECOVERED" => {
                    Some(Self::WrongCreditChargebackAcceptanceAmountRecovered)
                }
                "WRONG_CREDIT_REPRESENTMENT_LIEN_MARKED_INSUFFICIENT_BALANCE" => {
                    Some(Self::WrongCreditRepresentmentLienMarkedInsufficientBalance)
                }
                "WRONG_CREDIT_REPRESENTMENT_CUSTOMER_INACCESSIBLE" => {
                    Some(Self::WrongCreditRepresentmentCustomerInaccessible)
                }
                "WRONG_CREDIT_REPRESENTMENT_REASON_OTHERS" => {
                    Some(Self::WrongCreditRepresentmentReasonOthers)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateComplaintMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResolveComplaintMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateDisputeMetadata {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResolveDisputeMetadata {}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransactionSubType {
    Unspecified = 0,
    Beneficiary = 1,
    Remitter = 2,
}
impl TransactionSubType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransactionSubType::Unspecified => "TRANSACTION_SUB_TYPE_UNSPECIFIED",
            TransactionSubType::Beneficiary => "TRANSACTION_SUB_TYPE_BENEFICIARY",
            TransactionSubType::Remitter => "TRANSACTION_SUB_TYPE_REMITTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "TRANSACTION_SUB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TRANSACTION_SUB_TYPE_BENEFICIARY" => Some(Self::Beneficiary),
            "TRANSACTION_SUB_TYPE_REMITTER" => Some(Self::Remitter),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod issuer_switch_resolutions_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Creates and resolves UPI complaints and disputes.
    #[derive(Debug, Clone)]
    pub struct IssuerSwitchResolutionsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IssuerSwitchResolutionsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IssuerSwitchResolutionsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            IssuerSwitchResolutionsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Create a complaint. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[CreateComplaintMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.CreateComplaintMetadata\]
        /// * `response`:
        ///  \[Complaint\]\[google.cloud.paymentgateway.issuerswitch.v1.Complaint\]
        pub async fn create_complaint(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateComplaintRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions/CreateComplaint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions",
                        "CreateComplaint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resolve a complaint. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ResolveComplaintMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ResolveComplaintMetadata\]
        /// * `response`:
        ///  \[Complaint\]\[google.cloud.paymentgateway.issuerswitch.v1.Complaint\]
        pub async fn resolve_complaint(
            &mut self,
            request: impl tonic::IntoRequest<super::ResolveComplaintRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions/ResolveComplaint",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions",
                        "ResolveComplaint",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a dispute. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[CreateDisputeMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.CreateDisputeMetadata\]
        /// * `response`:
        ///  \[Dispute\]\[google.cloud.paymentgateway.issuerswitch.v1.Dispute\]
        pub async fn create_dispute(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDisputeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions/CreateDispute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions",
                        "CreateDispute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Resolve a dispute. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ResolveDisputeMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ResolveDisputeMetadata\]
        /// * `response`:
        ///  \[Dispute\]\[google.cloud.paymentgateway.issuerswitch.v1.Dispute\]
        pub async fn resolve_dispute(
            &mut self,
            request: impl tonic::IntoRequest<super::ResolveDisputeRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions/ResolveDispute",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchResolutions",
                        "ResolveDispute",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransactionInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "ApiType", tag = "2")]
    pub api_type: i32,
    #[prost(enumeration = "TransactionType", tag = "3")]
    pub transaction_type: i32,
    #[prost(enumeration = "transaction_info::TransactionSubType", tag = "4")]
    pub transaction_sub_type: i32,
    #[prost(enumeration = "transaction_info::State", tag = "5")]
    pub state: i32,
    #[prost(message, optional, tag = "6")]
    pub metadata: ::core::option::Option<transaction_info::TransactionMetadata>,
    #[prost(message, optional, tag = "7")]
    pub error_details: ::core::option::Option<transaction_info::TransactionErrorDetails>,
    #[prost(message, optional, tag = "8")]
    pub adapter_info: ::core::option::Option<transaction_info::AdapterInfo>,
    #[prost(message, repeated, tag = "9")]
    pub risk_info: ::prost::alloc::vec::Vec<transaction_info::TransactionRiskInfo>,
}
/// Nested message and enum types in `TransactionInfo`.
pub mod transaction_info {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionMetadata {
        #[prost(message, optional, tag = "1")]
        pub create_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(message, optional, tag = "2")]
        pub update_time: ::core::option::Option<::prost_types::Timestamp>,
        #[prost(string, tag = "3")]
        pub reference_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub reference_uri: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub description: ::prost::alloc::string::String,
        #[prost(string, tag = "6")]
        pub initiation_mode: ::prost::alloc::string::String,
        #[prost(string, tag = "7")]
        pub purpose_code: ::prost::alloc::string::String,
        #[prost(string, tag = "8")]
        pub reference_category: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionErrorDetails {
        #[prost(string, tag = "1")]
        pub error_code: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub error_message: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub upi_error_code: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AdapterInfo {
        #[prost(string, tag = "1")]
        pub request_ids: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub response_metadata: ::core::option::Option<adapter_info::ResponseMetadata>,
    }
    /// Nested message and enum types in `AdapterInfo`.
    pub mod adapter_info {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct ResponseMetadata {
            #[prost(btree_map = "string, string", tag = "1")]
            pub values: ::prost::alloc::collections::BTreeMap<
                ::prost::alloc::string::String,
                ::prost::alloc::string::String,
            >,
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct TransactionRiskInfo {
        #[prost(string, tag = "1")]
        pub provider: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub r#type: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub value: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Succeeded = 1,
        Failed = 2,
        TimedOut = 3,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Succeeded => "SUCCEEDED",
                State::Failed => "FAILED",
                State::TimedOut => "TIMED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUCCEEDED" => Some(Self::Succeeded),
                "FAILED" => Some(Self::Failed),
                "TIMED_OUT" => Some(Self::TimedOut),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TransactionSubType {
        Unspecified = 0,
        Collect = 1,
        Debit = 2,
        Pay = 3,
        Beneficiary = 4,
        Remitter = 5,
        Refund = 6,
        Credit = 7,
    }
    impl TransactionSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TransactionSubType::Unspecified => "TRANSACTION_SUB_TYPE_UNSPECIFIED",
                TransactionSubType::Collect => "COLLECT",
                TransactionSubType::Debit => "DEBIT",
                TransactionSubType::Pay => "PAY",
                TransactionSubType::Beneficiary => "BENEFICIARY",
                TransactionSubType::Remitter => "REMITTER",
                TransactionSubType::Refund => "REFUND",
                TransactionSubType::Credit => "CREDIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TRANSACTION_SUB_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "COLLECT" => Some(Self::Collect),
                "DEBIT" => Some(Self::Debit),
                "PAY" => Some(Self::Pay),
                "BENEFICIARY" => Some(Self::Beneficiary),
                "REMITTER" => Some(Self::Remitter),
                "REFUND" => Some(Self::Refund),
                "CREDIT" => Some(Self::Credit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MetadataTransaction {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<TransactionInfo>,
    #[prost(message, optional, tag = "3")]
    pub initiator: ::core::option::Option<Participant>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinancialTransaction {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<TransactionInfo>,
    #[prost(string, tag = "3")]
    pub retrieval_reference_number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub payer: ::core::option::Option<SettlementParticipant>,
    #[prost(message, optional, tag = "5")]
    pub payee: ::core::option::Option<SettlementParticipant>,
    #[prost(message, optional, tag = "6")]
    pub amount: ::core::option::Option<super::super::super::super::r#type::Money>,
    #[prost(message, repeated, tag = "7")]
    pub payment_rules: ::prost::alloc::vec::Vec<financial_transaction::PaymentRule>,
}
/// Nested message and enum types in `FinancialTransaction`.
pub mod financial_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct PaymentRule {
        #[prost(enumeration = "payment_rule::PaymentRuleName", tag = "1")]
        pub payment_rule: i32,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `PaymentRule`.
    pub mod payment_rule {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum PaymentRuleName {
            Unspecified = 0,
            ExpireAfter = 1,
            MinAmount = 2,
        }
        impl PaymentRuleName {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    PaymentRuleName::Unspecified => "PAYMENT_RULE_NAME_UNSPECIFIED",
                    PaymentRuleName::ExpireAfter => "EXPIRE_AFTER",
                    PaymentRuleName::MinAmount => "MIN_AMOUNT",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "PAYMENT_RULE_NAME_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXPIRE_AFTER" => Some(Self::ExpireAfter),
                    "MIN_AMOUNT" => Some(Self::MinAmount),
                    _ => None,
                }
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MandateTransaction {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub transaction_info: ::core::option::Option<TransactionInfo>,
    #[prost(string, tag = "3")]
    pub unique_mandate_number: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub payer: ::core::option::Option<SettlementParticipant>,
    #[prost(message, optional, tag = "5")]
    pub payee: ::core::option::Option<SettlementParticipant>,
    #[prost(enumeration = "mandate_transaction::RecurrencePatternType", tag = "6")]
    pub recurrence_pattern: i32,
    #[prost(enumeration = "mandate_transaction::RecurrenceRuleType", tag = "7")]
    pub recurrence_rule_type: i32,
    #[prost(int32, tag = "8")]
    pub recurrence_rule_value: i32,
    #[prost(message, optional, tag = "9")]
    pub start_date: ::core::option::Option<super::super::super::super::r#type::Date>,
    #[prost(message, optional, tag = "10")]
    pub end_date: ::core::option::Option<super::super::super::super::r#type::Date>,
    #[prost(bool, tag = "11")]
    pub revokable: bool,
    #[prost(double, tag = "12")]
    pub amount: f64,
    #[prost(enumeration = "mandate_transaction::AmountRuleType", tag = "13")]
    pub amount_rule: i32,
    #[prost(string, tag = "14")]
    pub approval_reference: ::prost::alloc::string::String,
    #[prost(bool, tag = "15")]
    pub block_funds: bool,
    #[prost(string, tag = "16")]
    pub mandate_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `MandateTransaction`.
pub mod mandate_transaction {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecurrencePatternType {
        Unspecified = 0,
        AsPresented = 1,
        Bimonthly = 2,
        Daily = 3,
        Fortnightly = 4,
        HalfYearly = 5,
        Monthly = 6,
        OneTime = 7,
        Quarterly = 8,
        Weekly = 9,
        Yearly = 10,
    }
    impl RecurrencePatternType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecurrencePatternType::Unspecified => {
                    "RECURRENCE_PATTERN_TYPE_UNSPECIFIED"
                }
                RecurrencePatternType::AsPresented => "AS_PRESENTED",
                RecurrencePatternType::Bimonthly => "BIMONTHLY",
                RecurrencePatternType::Daily => "DAILY",
                RecurrencePatternType::Fortnightly => "FORTNIGHTLY",
                RecurrencePatternType::HalfYearly => "HALF_YEARLY",
                RecurrencePatternType::Monthly => "MONTHLY",
                RecurrencePatternType::OneTime => "ONE_TIME",
                RecurrencePatternType::Quarterly => "QUARTERLY",
                RecurrencePatternType::Weekly => "WEEKLY",
                RecurrencePatternType::Yearly => "YEARLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECURRENCE_PATTERN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AS_PRESENTED" => Some(Self::AsPresented),
                "BIMONTHLY" => Some(Self::Bimonthly),
                "DAILY" => Some(Self::Daily),
                "FORTNIGHTLY" => Some(Self::Fortnightly),
                "HALF_YEARLY" => Some(Self::HalfYearly),
                "MONTHLY" => Some(Self::Monthly),
                "ONE_TIME" => Some(Self::OneTime),
                "QUARTERLY" => Some(Self::Quarterly),
                "WEEKLY" => Some(Self::Weekly),
                "YEARLY" => Some(Self::Yearly),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecurrenceRuleType {
        Unspecified = 0,
        After = 1,
        Before = 2,
        On = 3,
    }
    impl RecurrenceRuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecurrenceRuleType::Unspecified => "RECURRENCE_RULE_TYPE_UNSPECIFIED",
                RecurrenceRuleType::After => "AFTER",
                RecurrenceRuleType::Before => "BEFORE",
                RecurrenceRuleType::On => "ON",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RECURRENCE_RULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "AFTER" => Some(Self::After),
                "BEFORE" => Some(Self::Before),
                "ON" => Some(Self::On),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AmountRuleType {
        Unspecified = 0,
        Exact = 1,
        Max = 2,
    }
    impl AmountRuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AmountRuleType::Unspecified => "AMOUNT_RULE_TYPE_UNSPECIFIED",
                AmountRuleType::Exact => "EXACT",
                AmountRuleType::Max => "MAX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AMOUNT_RULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXACT" => Some(Self::Exact),
                "MAX" => Some(Self::Max),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ComplaintTransaction {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub info: ::core::option::Option<TransactionInfo>,
    #[prost(oneof = "complaint_transaction::Case", tags = "3, 4")]
    pub case: ::core::option::Option<complaint_transaction::Case>,
}
/// Nested message and enum types in `ComplaintTransaction`.
pub mod complaint_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Case {
        #[prost(message, tag = "3")]
        Complaint(super::Complaint),
        #[prost(message, tag = "4")]
        Dispute(super::Dispute),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFinancialTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMandateTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListComplaintTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMetadataTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub metadata_transactions: ::prost::alloc::vec::Vec<MetadataTransaction>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFinancialTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub financial_transactions: ::prost::alloc::vec::Vec<FinancialTransaction>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMandateTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub mandate_transactions: ::prost::alloc::vec::Vec<MandateTransaction>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListComplaintTransactionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub complaint_transactions: ::prost::alloc::vec::Vec<ComplaintTransaction>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFinancialTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "TransactionType", tag = "2")]
    pub transaction_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMetadataTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "ApiType", tag = "2")]
    pub api_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMandateTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "TransactionType", tag = "2")]
    pub transaction_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportComplaintTransactionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(enumeration = "TransactionType", tag = "2")]
    pub transaction_type: i32,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportFinancialTransactionsResponse {
    #[prost(string, tag = "1")]
    pub target_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMetadataTransactionsResponse {
    #[prost(string, tag = "1")]
    pub target_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportMandateTransactionsResponse {
    #[prost(string, tag = "1")]
    pub target_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportComplaintTransactionsResponse {
    #[prost(string, tag = "1")]
    pub target_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportFinancialTransactionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportMandateTransactionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportMetadataTransactionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExportComplaintTransactionsMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Generated client implementations.
pub mod issuer_switch_transactions_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Fetch the issuer switch participant.
    /// Lists and exports transactions processed by the issuer switch.
    #[derive(Debug, Clone)]
    pub struct IssuerSwitchTransactionsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> IssuerSwitchTransactionsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IssuerSwitchTransactionsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            IssuerSwitchTransactionsClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// List metadata transactions that satisfy the specified filter criteria.
        pub async fn list_metadata_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMetadataTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMetadataTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ListMetadataTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ListMetadataTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List financial transactions that satisfy specified filter criteria.
        pub async fn list_financial_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFinancialTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFinancialTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ListFinancialTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ListFinancialTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List mandate transactions that satisfy specified filter criteria.
        pub async fn list_mandate_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListMandateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListMandateTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ListMandateTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ListMandateTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List complaint transactions that satisfy specified filter criteria.
        pub async fn list_complaint_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListComplaintTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListComplaintTransactionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ListComplaintTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ListComplaintTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export financial transactions received within the specified time range as a
        /// file into a configured target location. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ExportFinancialTransactionsMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsMetadata\]
        /// * `response`:
        ///  \[ExportFinancialTransactionsResponse\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportFinancialTransactionsResponse\]
        ///
        /// The exported file will be in the standard CSV format where each row in the
        /// file represents a transaction. The file has the following fields in order:
        ///
        /// 1. `TransactionID`
        ///   * **Min Length** - 35 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - UPI transaction ID.
        /// 1. `TransactionType`
        ///   * **Min Length** - 22 characters
        ///   * **Max Length** - 25 characters
        ///   * **Description** - Type of the transaction. This will be one of
        ///     `TRANSACTION_TYPE_CREDIT`, `TRANSACTION_TYPE_DEBIT` or
        ///     `TRANSACTION_TYPE_REVERSAL`.
        /// 1. `TransactionSubType`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 7 characters
        ///   * **Description** - Subtype of the transaction. This will be one of
        ///     `COLLECT`, or `PAY`.
        /// 1. `CreationTime`
        ///   * **Min Length** - 20 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Timestamp (in UTC) indicating when the issuer
        ///     switch created the transaction resource for processing the transaction.
        ///     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
        /// 1. `State`
        ///   * **Min Length** - 6 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - State of the transaction. This will be one of
        ///     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
        /// 1. `RRN`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Retrieval reference number associated with the
        ///     transaction.
        /// 1. `PayerVPA`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Virtual Payment Address (VPA) of the payer.
        /// 1. `PayerMobileNumber`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Mobile number of the payer.
        /// 1. `PayerIFSC`
        ///   * **Min Length** - 11 characters
        ///   * **Max Length** - 11 characters
        ///   * **Description** - IFSC of the payer's bank account.
        /// 1. `PayerAccountNumber`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Payer's bank account number.
        /// 1. `PayerAccountType`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 7 characters
        ///   * **Description** - Payer's bank account type. This will be one of
        ///     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
        ///     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
        /// 1. `PayeeVPA`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Virtual Payment Address (VPA) of the payee.
        /// 1. `PayeeMobileNumber`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Payee's mobile number.
        /// 1. `PayeeIFSC`
        ///   * **Min Length** - 11 characters
        ///   * **Max Length** - 11 characters
        ///   * **Description** - IFSC of the payee's bank account.
        /// 1. `PayeeAccountNumber`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Payee's bank account number.
        /// 1. `PayeeAccountType`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 10 characters
        ///   * **Description** - Payee's bank account type. This will be one of
        ///     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
        ///     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
        /// 1. `PayeeMerchantID`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Payee's merchant ID, only if the payee is a
        ///     merchant.
        /// 1. `PayeeMerchantName`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Payee's merchant name, only if the payee is a
        ///     merchant.
        /// 1. `PayeeMCC`
        ///   * **Min Length** - 4 characters
        ///   * **Max Length** - 4 characters
        ///   * **Description** - Payee's Merchant Category Code (MCC), only if the
        ///     payee is a merchant.
        /// 1. `Currency`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 3 characters
        ///   * **Description** - Currency of the amount involved in the transaction.
        ///     The currency codes are defined in ISO 4217.
        /// 1. `Amount`
        ///   * **Description** - Amount involved in the transaction.
        /// 1. `AdapterRequestIDs`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 2,000 characters
        ///   * **Description** - List of adapter request IDs (colon separated) used
        ///     when invoking the Adapter APIs for fulfilling a transaction request.
        /// 1. `ErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Error code of a failed transaction.
        /// 1. `ErrorMessage`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 10,000 characters
        ///   * **Description** - Error description for a failed transaction.
        /// 1. `UPIErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 3 characters
        ///   * **Description** - Error code as per the UPI specification. The issuer
        ///     switch maps the ErrorCode to an appropriate error code that complies
        ///     with the UPI specification.
        /// 1. `PayerDeviceInfoTypeAppName`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Payment application name on the payer's device.
        /// 1. `PayerDeviceInfoTypeCapability`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Capability of the payer's device.
        /// 1. `PayerDeviceInfoTypeGeoCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 15 characters
        ///   * **Description** - Geo code of the payer's device. This will include
        ///     floating point values for latitude and longitude (separated by colon).
        /// 1. `PayerDeviceInfoTypeID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Device ID of the payer's device.
        /// 1. `PayerDeviceInfoTypeIP`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 39 characters
        ///   * **Description** - IP address of the payer's device.
        /// 1. `PayerDeviceInfoTypeLocation`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 40 characters
        ///   * **Description** - Coarse location of the payer's device.
        /// 1. `PayerDeviceInfoTypeOS`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Operating system on the payer's device.
        /// 1. `PayerDeviceInfoTypeTelecomProvider`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Telecom provider for the payer's device.
        /// 1. `PayerDeviceInfoTypeDeviceType`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - Type of the payer's device. This will be one of
        ///     'MOB', 'INET', 'USDC/USDB', 'POS'.
        /// 1. `PayeeDeviceInfoTypeAppName`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Payment application name on the payee's device.
        /// 1. `PayeeDeviceInfoTypeCapability`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Capability of the payee's device.
        /// 1. `PayeeDeviceInfoTypeGeoCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 15 characters
        ///   * **Description** - Geo code of the payee's device. This will include
        ///     floating point values for latitude and longitude (separated by colon).
        /// 1. `PayeeDeviceInfoTypeID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Device ID of the payee's device.
        /// 1. `PayeeDeviceInfoTypeIP`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 39 characters
        ///   * **Description** - IP address of the payee's device.
        /// 1. `PayeeDeviceInfoTypeLocation`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 40 characters
        ///   * **Description** - Coarse location of the payee's device.
        /// 1. `PayeeDeviceInfoTypeOS`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Operating system on the payee's device.
        /// 1. `PayeeDeviceInfoTypeTelecomProvider`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Telecom provider for the payee's device.
        /// 1. `PayeeDeviceInfoTypeDeviceType`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - Type of the payee's device. This will be one of
        ///     'MOB', 'INET', 'USDC/USDB', 'POS'.
        /// 1. `ReferenceID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Consumer reference number to identify loan number,
        ///     order id etc.
        /// 1. `ReferenceURI`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - URL for the  transaction.
        /// 1. `ReferenceCategory`
        ///   * **Min Length** - 2 characters
        ///   * **Max Length** - 2 characters
        ///   * **Description** - Reference category.
        pub async fn export_financial_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportFinancialTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ExportFinancialTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ExportFinancialTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export metadata transactions received within the specified time range as a
        /// file into a configured target location. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ExportMetadataTransactionsMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsMetadata\]
        /// * `response`:
        ///  \[ExportMetadataTransactionsResponse\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportMetadataTransactionsResponse\]
        ///
        /// The exported file will be in the standard CSV format where each row in the
        /// file represents a transaction. The file has the following fields in order:
        ///
        /// 1. `TransactionID`
        ///   * **Min Length** - 35 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - UPI transaction ID.
        /// 1. `APIType`
        ///   * **Description** - The transaction's API type. The value will be of
        ///     the \[ApiType\]\[google.cloud.paymentgateway.issuerswitch.v1.ApiType\]
        ///     enum.
        /// 1. `TransactionType`
        ///   * **Description** - Type of the transaction. The value will be of the
        ///     \[TransactionType\]\[google.cloud.paymentgateway.issuerswitch.v1.TransactionType\]
        ///     enum.
        /// 1. `CreationTime`
        ///   * **Min Length** - 20 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Timestamp (in UTC) indicating when the issuer
        ///     switch created the transaction resource for processing the transaction.
        ///     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
        /// 1. `State`
        ///   * **Min Length** - 6 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - State of the transaction. This will be one of
        ///     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
        /// 1. `OriginVPA`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Virtual Payment Address (VPA) of the originator of
        ///     the transaction.
        /// 1. `AdapterRequestIDs`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 2,000 characters
        ///   * **Description** - List of adapter request IDs (colon separated) used
        ///     when invoking the Adapter APIs for fulfilling a transaction request.
        /// 1. `ErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Error code of the failed transaction.
        /// 1. `ErrorMessage`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 10,000 characters
        ///   * **Description** - Error description for the failed transaction.
        /// 1. `UPIErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 3 characters
        ///   * **Description** - Error code as per the UPI specification. The issuer
        ///     switch maps the ErrorCode to an appropriate error code that complies
        ///     with the UPI specification.
        pub async fn export_metadata_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportMetadataTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ExportMetadataTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ExportMetadataTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export mandate transactions received within the specified time range as a
        /// file into a configured target location. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ExportMandateTransactionsMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsMetadata\]
        /// * `response`:
        ///  \[ExportMandateTransactionsResponse\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportMandateTransactionsResponse\]
        ///
        /// The exported file will be in the standard CSV format where each row in the
        /// file represents a transaction. The file has the following fields in order:
        ///
        /// 1. `TransactionID`
        ///   * **Min Length** - 35 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - UPI transaction ID.
        /// 1. `UniqueMandateNumber`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 70 characters
        ///   * **Description** - UPI Unique Mandate Number.
        /// 1. `TransactionType`
        ///   * **Min Length** - 23 characters
        ///   * **Max Length** - 23 characters
        ///   * **Description** - Type of the transaction. This will be one of
        ///     `TRANSACTION_TYPE_CREATE`, `TRANSACTION_TYPE_REVOKE`,
        ///     `TRANSACTION_TYPE_UPDATE`, `TRANSACTION_TYPE_PAUSE` or
        ///     `TRANSACTION_TYPE_UNPAUSE`.
        /// 1. `CreationTime`
        ///   * **Min Length** - 20 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Timestamp (in UTC) indicating when the issuer
        ///     switch created the transaction resource for processing the transaction.
        ///     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
        /// 1. `State`
        ///   * **Min Length** - 6 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - State of the transaction. This will be one of
        ///     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
        /// 1. `PayerVPA`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Virtual Payment Address (VPA) of the payer.
        /// 1. `PayerMobileNumber`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Mobile number of the payer.
        /// 1. `PayerIFSC`
        ///   * **Min Length** - 11 characters
        ///   * **Max Length** - 11 characters
        ///   * **Description** - IFSC of the payer's bank account.
        /// 1. `PayerAccountNumber`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Payer's bank account number.
        /// 1. `PayerAccountType`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 7 characters
        ///   * **Description** - Payer's bank account type. This will be one of
        ///     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
        ///     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
        /// 1. `PayeeVPA`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Virtual Payment Address (VPA) of the payee.
        /// 1. `PayeeMobileNumber`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Mobile number of the payee.
        /// 1. `PayeeIFSC`
        ///   * **Min Length** - 11 characters
        ///   * **Max Length** - 11 characters
        ///   * **Description** - IFSC of the payee's bank account.
        /// 1. `PayeeAccountNumber`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Payee's bank account number.
        /// 1. `PayeeAccountType`
        ///   * **Min Length** - 3 characters
        ///   * **Max Length** - 10 characters
        ///   * **Description** - Payee's bank account type. This will be one of
        ///     `SAVINGS`, `DEFAULT`, `CURRENT`, `NRE`, `NRO`, `PPIWALLET`,
        ///     `BANKWALLET`, `CREDIT`, `SOD`, or `UOD`.
        /// 1. `PayeeMerchantID`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Payee's merchant ID, only if the payee is a
        ///     merchant
        /// 1. `PayeeMerchantName`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Payee's merchant name, only if the payee is a
        ///     merchant.
        /// 1. `PayeeMCC`
        ///   * **Min Length** - 4 characters
        ///   * **Max Length** - 4 characters
        ///   * **Description** - Payee's Merchant Category Code (MCC), only if the
        ///     payee is a merchant.
        /// 1. `Amount`
        ///   * **Description** - Amount specified in the mandate.
        /// 1. `RecurrencePattern`
        ///   * **Description** - Reccurence pattern of the mandate. The value will
        ///     be of the
        ///     \[MandateTransaction.RecurrencePatternType\]\[google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrencePatternType\]
        ///     enum.
        /// 1. `RecurrenceRuleType`
        ///   * **Description** - Reccurrence rule type of the mandate. The value
        ///     will be of the
        ///     \[MandateTransaction.RecurrenceRuleType\]\[google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.RecurrenceRuleType\]
        ///     enum.
        /// 1. `RecurrenceRuleValue`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 2 characters
        ///   * **Description** - Recurrence rule value of the mandate. This will be
        ///     an integer between 1 and 31.
        /// 1. `Revokeable`
        ///   * **Min Length** - 4 characters
        ///   * **Max Length** - 5 characters
        ///   * **Description** - Boolean value specifying if the mandate is
        ///     revokable.
        /// 1. `StartDate`
        ///   * **Min Length** - 10 characters
        ///   * **Max Length** - 10 characters
        ///   * **Description** - The start date of the mandate in `DD-MM-YYYY`
        ///     format.
        /// 1. `EndDate`
        ///   * **Min Length** - 10 characters
        ///   * **Max Length** - 10 characters
        ///   * **Description** - The end date of the mandate in `DD-MM-YYYY` format.
        /// 1. `AmountRuleType`
        ///   * **Description** - The amount rule of the mandate. The value will be
        ///     of the
        ///     \[MandateTransaction.AmountRuleType\]\[google.cloud.paymentgateway.issuerswitch.v1.MandateTransaction.AmountRuleType\]
        ///     enum.
        /// 1. `ApprovalReference`
        ///   * **Min Length** - 6 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - The block funds reference generated by the bank, if
        ///     funds have been blocked for the mandate. This column will have a value
        ///     only when the RecurrencePattern is ONETIME.
        /// 1. `BlockFunds`
        ///   * **Min Length** - 4 characters
        ///   * **Max Length** - 5 characters
        ///   * **Description** - Boolean value specifying if the mandate transaction
        ///     requested to block funds.
        /// 1. `LastUpdateTime`
        ///   * **Min Length** - 20 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Timestamp (in UTC) indicating when was the last
        ///     modification made to the mandate. The format will be as per RFC-3339.
        ///     Example : 2022-11-22T23:00:05Z
        /// 1. `AdapterRequestIDs`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 2,000 characters
        ///   * **Description** - List of adapter request IDs (colon separated) used
        ///     when invoking the Adapter APIs for fulfilling a transaction request.
        /// 1. `ErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Error code of the failed transaction.
        /// 1. `ErrorMessage`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 10,000 characters
        ///   * **Description** - Error description for the failed transaction.
        /// 1. `UPIErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 3 characters
        ///   * **Description** - Error code as per the UPI specification. The issuer
        ///     switch maps the ErrorCode to an appropriate error code that complies
        ///     with the UPI specification.
        /// 1. `PayerDeviceInfoTypeAppName`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Payment application name on the payer's device.
        /// 1. `PayerDeviceInfoTypeCapability`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Capability of the payer's device.
        /// 1. `PayerDeviceInfoTypeGeoCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 15 characters
        ///   * **Description** - Geo code of the payer's device. This will include
        ///     floating point values for latitude and longitude (separated by colon).
        /// 1. `PayerDeviceInfoTypeID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Device ID of the payer's device.
        /// 1. `PayerDeviceInfoTypeIP`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 39 characters
        ///   * **Description** - IP address of the payer's device.
        /// 1. `PayerDeviceInfoTypeLocation`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 40 characters
        ///   * **Description** - Coarse location of the payer's device.
        /// 1. `PayerDeviceInfoTypeOS`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Operating system on the payer's device.
        /// 1. `PayerDeviceInfoTypeTelecomProvider`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Telecom provider for the payer's device.
        /// 1. `PayerDeviceInfoTypeDeviceType`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - Type of the payer's device. This will be one of
        ///     'MOB', 'INET', 'USDC/USDB', 'POS'.
        /// 1. `PayeeDeviceInfoTypeAppName`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Payment application name on the payee's device.
        /// 1. `PayeeDeviceInfoTypeCapability`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Capability of the payee's device.
        /// 1. `PayeeDeviceInfoTypeGeoCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 15 characters
        ///   * **Description** - Geo code of the payee's device. This will include
        ///     floating point values for latitude and longitude (separated by colon).
        /// 1. `PayeeDeviceInfoTypeID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Device ID of the payee's device.
        /// 1. `PayeeDeviceInfoTypeIP`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 39 characters
        ///   * **Description** - IP address of the payee's device.
        /// 1. `PayeeDeviceInfoTypeLocation`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 40 characters
        ///   * **Description** - Coarse location of the payee's device.
        /// 1. `PayeeDeviceInfoTypeOS`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Operating system on the payee's device.
        /// 1. `PayeeDeviceInfoTypeTelecomProvider`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 99 characters
        ///   * **Description** - Telecom provider for the payee's device.
        /// 1. `PayeeDeviceInfoTypeDeviceType`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - Type of the payee's device. This will be one of
        ///     `MOB`, `INET`, `USDC/USDB`, `POS`.
        /// 1. `ReferenceID`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Consumer reference number to identify loan number,
        ///     order id etc.
        /// 1. `ReferenceURI`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - URL for the  transaction.
        /// 1. `ReferenceCategory`
        ///   * **Min Length** - 2 characters
        ///   * **Max Length** - 2 characters
        ///   * **Description** - Reference category.
        /// 1. `MandateName`
        ///   * **Min Length** - 1 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - The mandate's name.
        pub async fn export_mandate_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportMandateTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ExportMandateTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ExportMandateTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Export complaint transactions received within the specified time range as a
        /// file into a configured target location. The returned `Operation` type has
        /// the following method-specific fields:
        ///
        /// * `metadata`:
        ///  \[ExportComplaintTransactionsMetadata\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsMetadata\]
        /// * `response`:
        ///  \[ExportComplaintTransactionsResponse\]\[google.cloud.paymentgateway.issuerswitch.v1.ExportComplaintTransactionsResponse\]
        ///
        /// The exported file will be in the standard CSV format where each row in the
        /// file represents a transaction. The file has the following fields in order:
        ///
        /// 1. `TransactionID`
        ///   * **Min Length** - 35 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - UPI transaction ID.
        /// 1. `TransactionType`
        ///   * **Min Length** - 23 characters
        ///   * **Max Length** - 30 characters
        ///   * **Description** - Type of the transaction. This will be one of
        ///     `TRANSACTION_TYPE_CHECK_STATUS`, `TRANSACTION_TYPE_COMPLAINT`,
        ///     `TRANSACTION_TYPE_REVERSAL`, `TRANSACTION_TYPE_DISPUTE`,
        ///     `TRANSACTION_TYPE_REFUND`, or `TRANSACTION_TYPE_STATUS_UPDATE`.
        /// 1. `CreationTime`
        ///   * **Min Length** - 20 characters
        ///   * **Max Length** - 20 characters
        ///   * **Description** - Timestamp (in UTC) indicating when the issuer
        ///     switch created the transaction resource for processing the transaction.
        ///     The format will be as per RFC-3339. Example : 2022-11-22T23:00:05Z
        ///     1: `State`
        ///   * **Min Length** - 6 characters
        ///   * **Max Length** - 9 characters
        ///   * **Description** - State of the transaction. This will be one of
        ///     `FAILED`, `SUCCEEDED`, or `TIMED_OUT`.
        /// 1. `OriginalRRN`
        ///   * **Min Length** - 12 characters
        ///   * **Max Length** - 12 characters
        ///   * **Description** - Retrieval reference number of the original payment
        ///     transaction.
        /// 1. `BankType`
        ///   * **Min Length** - 8 characters
        ///   * **Max Length** - 11 characters
        ///   * **Description** - The subtype of the transaction based on the bank
        ///     involved. This will be one of `BENEFICIARY`, or `REMITTER`.
        /// 1. `OriginalTransactionID`
        ///   * **Min Length** - 35 characters
        ///   * **Max Length** - 35 characters
        ///   * **Description** - Transaction ID of the original unresolved
        ///     transaction.
        /// 1. `RaiseComplaintAdjFlag`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the type of action to raise the
        ///     complaint.
        /// 1. `RaiseComplaintAdjCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the reason of action to raise the
        ///     complaint.
        /// 1. `ResolveComplaintAdjFlag`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the type of action to resolve the
        ///     complaint.
        /// 1. `ResolveComplaintAdjCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the reason of action to resolve the
        ///     complaint.
        /// 1. `RaiseDisputeAdjFlag`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the type of action to raise the dispute.
        /// 1. `RaiseDisputeAdjCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the reason of action to raise the
        ///     dispute.
        /// 1. `ResolveDisputeAdjFlag`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the type of action to resolve the
        ///     dispute.
        /// 1. `ResolveDisputeAdjCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the reason of action to resolve the
        ///     dispute.
        /// 1. `Amount`
        ///   * **Description** - Amount to be resolved.
        /// 1. `CurrentCycle`
        ///   * **Min Length** - 4 characters
        ///   * **Max Length** - 5 characters
        ///   * **Description** - Boolean value specifying if the complaint / dispute
        ///     belongs to current settlement cycle or not.
        /// 1. `CRN`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Defines the Complaint Reference number.
        /// 1. `AdjTime`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the time when the resolution was done.
        /// 1. `RespAdjFlag`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the response category type.
        /// 1. `RespAdjCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the response reason used.
        /// 1. `AdjRemarks`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Indicates the additional remarks for the complaint
        ///     / dispute.
        /// 1. `AdapterRequestIDs`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 2,000 characters
        ///   * **Description** - List of adapter request IDs (colon separated) used
        ///     when invoking the Adapter APIs for fulfilling a transaction request.
        /// 1. `ErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 255 characters
        ///   * **Description** - Error code of the failed transaction.
        /// 1. `ErrorMessage`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 10,000 characters
        ///   * **Description** - Error description for the failed transaction.
        /// 1. `UPIErrorCode`
        ///   * **Min Length** - 0 characters
        ///   * **Max Length** - 3 characters
        ///   * **Description** - Error code as per the UPI specification. The issuer
        ///     switch service maps the ErrorCode to an appropriate error code that
        ///     complies with the UPI specification.
        pub async fn export_complaint_transactions(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportComplaintTransactionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions/ExportComplaintTransactions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.paymentgateway.issuerswitch.v1.IssuerSwitchTransactions",
                        "ExportComplaintTransactions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpiTransaction {
    #[prost(string, tag = "1")]
    pub message: ::prost::alloc::string::String,
    #[prost(
        enumeration = "super::super::super::super::logging::r#type::LogSeverity",
        tag = "2"
    )]
    pub severity: i32,
    #[prost(enumeration = "ApiType", tag = "3")]
    pub api_type: i32,
    #[prost(enumeration = "XmlApiType", tag = "4")]
    pub xml_api_type: i32,
    #[prost(enumeration = "TransactionType", tag = "5")]
    pub transaction_type: i32,
    #[prost(string, tag = "6")]
    pub transaction_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub message_id: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub rrn: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "9")]
    pub payload_receipt_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub payload_sent_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "transaction_info::State", tag = "11")]
    pub status: i32,
    #[prost(string, tag = "12")]
    pub error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub upi_error_code: ::prost::alloc::string::String,
    #[prost(string, tag = "14")]
    pub error_message: ::prost::alloc::string::String,
    #[prost(oneof = "upi_transaction::Payload", tags = "15, 16")]
    pub payload: ::core::option::Option<upi_transaction::Payload>,
}
/// Nested message and enum types in `UpiTransaction`.
pub mod upi_transaction {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(string, tag = "15")]
        Sent(::prost::alloc::string::String),
        #[prost(string, tag = "16")]
        Received(::prost::alloc::string::String),
    }
}
