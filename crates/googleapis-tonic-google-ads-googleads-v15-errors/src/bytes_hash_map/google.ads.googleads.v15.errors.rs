// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemValidationErrorEnum {}
/// Nested message and enum types in `FeedItemValidationErrorEnum`.
pub mod feed_item_validation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemValidationError {
        Unspecified = 0,
        Unknown = 1,
        StringTooShort = 2,
        StringTooLong = 3,
        ValueNotSpecified = 4,
        InvalidDomesticPhoneNumberFormat = 5,
        InvalidPhoneNumber = 6,
        PhoneNumberNotSupportedForCountry = 7,
        PremiumRateNumberNotAllowed = 8,
        DisallowedNumberType = 9,
        ValueOutOfRange = 10,
        CalltrackingNotSupportedForCountry = 11,
        CustomerNotInAllowlistForCalltracking = 99,
        InvalidCountryCode = 13,
        InvalidAppId = 14,
        MissingAttributesForFields = 15,
        InvalidTypeId = 16,
        InvalidEmailAddress = 17,
        InvalidHttpsUrl = 18,
        MissingDeliveryAddress = 19,
        StartDateAfterEndDate = 20,
        MissingFeedItemStartTime = 21,
        MissingFeedItemEndTime = 22,
        MissingFeedItemId = 23,
        VanityPhoneNumberNotAllowed = 24,
        InvalidReviewExtensionSnippet = 25,
        InvalidNumberFormat = 26,
        InvalidDateFormat = 27,
        InvalidPriceFormat = 28,
        UnknownPlaceholderField = 29,
        MissingEnhancedSitelinkDescriptionLine = 30,
        ReviewExtensionSourceIneligible = 31,
        HyphensInReviewExtensionSnippet = 32,
        DoubleQuotesInReviewExtensionSnippet = 33,
        QuotesInReviewExtensionSnippet = 34,
        InvalidFormEncodedParams = 35,
        InvalidUrlParameterName = 36,
        NoGeocodingResult = 37,
        SourceNameInReviewExtensionText = 38,
        CarrierSpecificShortNumberNotAllowed = 39,
        InvalidPlaceholderFieldId = 40,
        InvalidUrlTag = 41,
        ListTooLong = 42,
        InvalidAttributesCombination = 43,
        DuplicateValues = 44,
        InvalidCallConversionActionId = 45,
        CannotSetWithoutFinalUrls = 46,
        AppIdDoesntExistInAppStore = 47,
        InvalidFinalUrl = 48,
        InvalidTrackingUrl = 49,
        InvalidFinalUrlForAppDownloadUrl = 50,
        ListTooShort = 51,
        InvalidUserAction = 52,
        InvalidTypeName = 53,
        InvalidEventChangeStatus = 54,
        InvalidSnippetsHeader = 55,
        InvalidAndroidAppLink = 56,
        NumberTypeWithCalltrackingNotSupportedForCountry = 57,
        ReservedKeywordOther = 58,
        DuplicateOptionLabels = 59,
        DuplicateOptionPrefills = 60,
        UnequalListLengths = 61,
        InconsistentCurrencyCodes = 62,
        PriceExtensionHasDuplicatedHeaders = 63,
        ItemHasDuplicatedHeaderAndDescription = 64,
        PriceExtensionHasTooFewItems = 65,
        UnsupportedValue = 66,
        InvalidFinalMobileUrl = 67,
        InvalidKeywordlessAdRuleLabel = 68,
        ValueTrackParameterNotSupported = 69,
        UnsupportedValueInSelectedLanguage = 70,
        InvalidIosAppLink = 71,
        MissingIosAppLinkOrIosAppStoreId = 72,
        PromotionInvalidTime = 73,
        PromotionCannotSetPercentOffAndMoneyAmountOff = 74,
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 75,
        TooManyDecimalPlacesSpecified = 76,
        AdCustomizersNotAllowed = 77,
        InvalidLanguageCode = 78,
        UnsupportedLanguage = 79,
        IfFunctionNotAllowed = 80,
        InvalidFinalUrlSuffix = 81,
        InvalidTagInFinalUrlSuffix = 82,
        InvalidFinalUrlSuffixFormat = 83,
        CustomerConsentForCallRecordingRequired = 84,
        OnlyOneDeliveryOptionIsAllowed = 85,
        NoDeliveryOptionIsSet = 86,
        InvalidConversionReportingState = 87,
        ImageSizeWrong = 88,
        EmailDeliveryNotAvailableInCountry = 89,
        AutoReplyNotAvailableInCountry = 90,
        InvalidLatitudeValue = 91,
        InvalidLongitudeValue = 92,
        TooManyLabels = 93,
        InvalidImageUrl = 94,
        MissingLatitudeValue = 95,
        MissingLongitudeValue = 96,
        AddressNotFound = 97,
        AddressNotTargetable = 98,
        InvalidAssetId = 100,
        IncompatibleAssetType = 101,
        ImageErrorUnexpectedSize = 102,
        ImageErrorAspectRatioNotAllowed = 103,
        ImageErrorFileTooLarge = 104,
        ImageErrorFormatNotAllowed = 105,
        ImageErrorConstraintsViolated = 106,
        ImageErrorServerError = 107,
    }
    impl FeedItemValidationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemValidationError::Unspecified => "UNSPECIFIED",
                FeedItemValidationError::Unknown => "UNKNOWN",
                FeedItemValidationError::StringTooShort => "STRING_TOO_SHORT",
                FeedItemValidationError::StringTooLong => "STRING_TOO_LONG",
                FeedItemValidationError::ValueNotSpecified => "VALUE_NOT_SPECIFIED",
                FeedItemValidationError::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                FeedItemValidationError::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                FeedItemValidationError::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                FeedItemValidationError::PremiumRateNumberNotAllowed => {
                    "PREMIUM_RATE_NUMBER_NOT_ALLOWED"
                }
                FeedItemValidationError::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                FeedItemValidationError::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                FeedItemValidationError::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                FeedItemValidationError::CustomerNotInAllowlistForCalltracking => {
                    "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING"
                }
                FeedItemValidationError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                FeedItemValidationError::InvalidAppId => "INVALID_APP_ID",
                FeedItemValidationError::MissingAttributesForFields => {
                    "MISSING_ATTRIBUTES_FOR_FIELDS"
                }
                FeedItemValidationError::InvalidTypeId => "INVALID_TYPE_ID",
                FeedItemValidationError::InvalidEmailAddress => "INVALID_EMAIL_ADDRESS",
                FeedItemValidationError::InvalidHttpsUrl => "INVALID_HTTPS_URL",
                FeedItemValidationError::MissingDeliveryAddress => {
                    "MISSING_DELIVERY_ADDRESS"
                }
                FeedItemValidationError::StartDateAfterEndDate => {
                    "START_DATE_AFTER_END_DATE"
                }
                FeedItemValidationError::MissingFeedItemStartTime => {
                    "MISSING_FEED_ITEM_START_TIME"
                }
                FeedItemValidationError::MissingFeedItemEndTime => {
                    "MISSING_FEED_ITEM_END_TIME"
                }
                FeedItemValidationError::MissingFeedItemId => "MISSING_FEED_ITEM_ID",
                FeedItemValidationError::VanityPhoneNumberNotAllowed => {
                    "VANITY_PHONE_NUMBER_NOT_ALLOWED"
                }
                FeedItemValidationError::InvalidReviewExtensionSnippet => {
                    "INVALID_REVIEW_EXTENSION_SNIPPET"
                }
                FeedItemValidationError::InvalidNumberFormat => "INVALID_NUMBER_FORMAT",
                FeedItemValidationError::InvalidDateFormat => "INVALID_DATE_FORMAT",
                FeedItemValidationError::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                FeedItemValidationError::UnknownPlaceholderField => {
                    "UNKNOWN_PLACEHOLDER_FIELD"
                }
                FeedItemValidationError::MissingEnhancedSitelinkDescriptionLine => {
                    "MISSING_ENHANCED_SITELINK_DESCRIPTION_LINE"
                }
                FeedItemValidationError::ReviewExtensionSourceIneligible => {
                    "REVIEW_EXTENSION_SOURCE_INELIGIBLE"
                }
                FeedItemValidationError::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                FeedItemValidationError::DoubleQuotesInReviewExtensionSnippet => {
                    "DOUBLE_QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                FeedItemValidationError::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                FeedItemValidationError::InvalidFormEncodedParams => {
                    "INVALID_FORM_ENCODED_PARAMS"
                }
                FeedItemValidationError::InvalidUrlParameterName => {
                    "INVALID_URL_PARAMETER_NAME"
                }
                FeedItemValidationError::NoGeocodingResult => "NO_GEOCODING_RESULT",
                FeedItemValidationError::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                FeedItemValidationError::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                FeedItemValidationError::InvalidPlaceholderFieldId => {
                    "INVALID_PLACEHOLDER_FIELD_ID"
                }
                FeedItemValidationError::InvalidUrlTag => "INVALID_URL_TAG",
                FeedItemValidationError::ListTooLong => "LIST_TOO_LONG",
                FeedItemValidationError::InvalidAttributesCombination => {
                    "INVALID_ATTRIBUTES_COMBINATION"
                }
                FeedItemValidationError::DuplicateValues => "DUPLICATE_VALUES",
                FeedItemValidationError::InvalidCallConversionActionId => {
                    "INVALID_CALL_CONVERSION_ACTION_ID"
                }
                FeedItemValidationError::CannotSetWithoutFinalUrls => {
                    "CANNOT_SET_WITHOUT_FINAL_URLS"
                }
                FeedItemValidationError::AppIdDoesntExistInAppStore => {
                    "APP_ID_DOESNT_EXIST_IN_APP_STORE"
                }
                FeedItemValidationError::InvalidFinalUrl => "INVALID_FINAL_URL",
                FeedItemValidationError::InvalidTrackingUrl => "INVALID_TRACKING_URL",
                FeedItemValidationError::InvalidFinalUrlForAppDownloadUrl => {
                    "INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL"
                }
                FeedItemValidationError::ListTooShort => "LIST_TOO_SHORT",
                FeedItemValidationError::InvalidUserAction => "INVALID_USER_ACTION",
                FeedItemValidationError::InvalidTypeName => "INVALID_TYPE_NAME",
                FeedItemValidationError::InvalidEventChangeStatus => {
                    "INVALID_EVENT_CHANGE_STATUS"
                }
                FeedItemValidationError::InvalidSnippetsHeader => {
                    "INVALID_SNIPPETS_HEADER"
                }
                FeedItemValidationError::InvalidAndroidAppLink => {
                    "INVALID_ANDROID_APP_LINK"
                }
                FeedItemValidationError::NumberTypeWithCalltrackingNotSupportedForCountry => {
                    "NUMBER_TYPE_WITH_CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                FeedItemValidationError::ReservedKeywordOther => "RESERVED_KEYWORD_OTHER",
                FeedItemValidationError::DuplicateOptionLabels => {
                    "DUPLICATE_OPTION_LABELS"
                }
                FeedItemValidationError::DuplicateOptionPrefills => {
                    "DUPLICATE_OPTION_PREFILLS"
                }
                FeedItemValidationError::UnequalListLengths => "UNEQUAL_LIST_LENGTHS",
                FeedItemValidationError::InconsistentCurrencyCodes => {
                    "INCONSISTENT_CURRENCY_CODES"
                }
                FeedItemValidationError::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                FeedItemValidationError::ItemHasDuplicatedHeaderAndDescription => {
                    "ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                FeedItemValidationError::PriceExtensionHasTooFewItems => {
                    "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS"
                }
                FeedItemValidationError::UnsupportedValue => "UNSUPPORTED_VALUE",
                FeedItemValidationError::InvalidFinalMobileUrl => {
                    "INVALID_FINAL_MOBILE_URL"
                }
                FeedItemValidationError::InvalidKeywordlessAdRuleLabel => {
                    "INVALID_KEYWORDLESS_AD_RULE_LABEL"
                }
                FeedItemValidationError::ValueTrackParameterNotSupported => {
                    "VALUE_TRACK_PARAMETER_NOT_SUPPORTED"
                }
                FeedItemValidationError::UnsupportedValueInSelectedLanguage => {
                    "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE"
                }
                FeedItemValidationError::InvalidIosAppLink => "INVALID_IOS_APP_LINK",
                FeedItemValidationError::MissingIosAppLinkOrIosAppStoreId => {
                    "MISSING_IOS_APP_LINK_OR_IOS_APP_STORE_ID"
                }
                FeedItemValidationError::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                FeedItemValidationError::PromotionCannotSetPercentOffAndMoneyAmountOff => {
                    "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF"
                }
                FeedItemValidationError::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                FeedItemValidationError::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                FeedItemValidationError::AdCustomizersNotAllowed => {
                    "AD_CUSTOMIZERS_NOT_ALLOWED"
                }
                FeedItemValidationError::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
                FeedItemValidationError::UnsupportedLanguage => "UNSUPPORTED_LANGUAGE",
                FeedItemValidationError::IfFunctionNotAllowed => {
                    "IF_FUNCTION_NOT_ALLOWED"
                }
                FeedItemValidationError::InvalidFinalUrlSuffix => {
                    "INVALID_FINAL_URL_SUFFIX"
                }
                FeedItemValidationError::InvalidTagInFinalUrlSuffix => {
                    "INVALID_TAG_IN_FINAL_URL_SUFFIX"
                }
                FeedItemValidationError::InvalidFinalUrlSuffixFormat => {
                    "INVALID_FINAL_URL_SUFFIX_FORMAT"
                }
                FeedItemValidationError::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                FeedItemValidationError::OnlyOneDeliveryOptionIsAllowed => {
                    "ONLY_ONE_DELIVERY_OPTION_IS_ALLOWED"
                }
                FeedItemValidationError::NoDeliveryOptionIsSet => {
                    "NO_DELIVERY_OPTION_IS_SET"
                }
                FeedItemValidationError::InvalidConversionReportingState => {
                    "INVALID_CONVERSION_REPORTING_STATE"
                }
                FeedItemValidationError::ImageSizeWrong => "IMAGE_SIZE_WRONG",
                FeedItemValidationError::EmailDeliveryNotAvailableInCountry => {
                    "EMAIL_DELIVERY_NOT_AVAILABLE_IN_COUNTRY"
                }
                FeedItemValidationError::AutoReplyNotAvailableInCountry => {
                    "AUTO_REPLY_NOT_AVAILABLE_IN_COUNTRY"
                }
                FeedItemValidationError::InvalidLatitudeValue => "INVALID_LATITUDE_VALUE",
                FeedItemValidationError::InvalidLongitudeValue => {
                    "INVALID_LONGITUDE_VALUE"
                }
                FeedItemValidationError::TooManyLabels => "TOO_MANY_LABELS",
                FeedItemValidationError::InvalidImageUrl => "INVALID_IMAGE_URL",
                FeedItemValidationError::MissingLatitudeValue => "MISSING_LATITUDE_VALUE",
                FeedItemValidationError::MissingLongitudeValue => {
                    "MISSING_LONGITUDE_VALUE"
                }
                FeedItemValidationError::AddressNotFound => "ADDRESS_NOT_FOUND",
                FeedItemValidationError::AddressNotTargetable => "ADDRESS_NOT_TARGETABLE",
                FeedItemValidationError::InvalidAssetId => "INVALID_ASSET_ID",
                FeedItemValidationError::IncompatibleAssetType => {
                    "INCOMPATIBLE_ASSET_TYPE"
                }
                FeedItemValidationError::ImageErrorUnexpectedSize => {
                    "IMAGE_ERROR_UNEXPECTED_SIZE"
                }
                FeedItemValidationError::ImageErrorAspectRatioNotAllowed => {
                    "IMAGE_ERROR_ASPECT_RATIO_NOT_ALLOWED"
                }
                FeedItemValidationError::ImageErrorFileTooLarge => {
                    "IMAGE_ERROR_FILE_TOO_LARGE"
                }
                FeedItemValidationError::ImageErrorFormatNotAllowed => {
                    "IMAGE_ERROR_FORMAT_NOT_ALLOWED"
                }
                FeedItemValidationError::ImageErrorConstraintsViolated => {
                    "IMAGE_ERROR_CONSTRAINTS_VIOLATED"
                }
                FeedItemValidationError::ImageErrorServerError => {
                    "IMAGE_ERROR_SERVER_ERROR"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STRING_TOO_SHORT" => Some(Self::StringTooShort),
                "STRING_TOO_LONG" => Some(Self::StringTooLong),
                "VALUE_NOT_SPECIFIED" => Some(Self::ValueNotSpecified),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotInAllowlistForCalltracking)
                }
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "MISSING_ATTRIBUTES_FOR_FIELDS" => Some(Self::MissingAttributesForFields),
                "INVALID_TYPE_ID" => Some(Self::InvalidTypeId),
                "INVALID_EMAIL_ADDRESS" => Some(Self::InvalidEmailAddress),
                "INVALID_HTTPS_URL" => Some(Self::InvalidHttpsUrl),
                "MISSING_DELIVERY_ADDRESS" => Some(Self::MissingDeliveryAddress),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "MISSING_FEED_ITEM_START_TIME" => Some(Self::MissingFeedItemStartTime),
                "MISSING_FEED_ITEM_END_TIME" => Some(Self::MissingFeedItemEndTime),
                "MISSING_FEED_ITEM_ID" => Some(Self::MissingFeedItemId),
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::InvalidReviewExtensionSnippet)
                }
                "INVALID_NUMBER_FORMAT" => Some(Self::InvalidNumberFormat),
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "UNKNOWN_PLACEHOLDER_FIELD" => Some(Self::UnknownPlaceholderField),
                "MISSING_ENHANCED_SITELINK_DESCRIPTION_LINE" => {
                    Some(Self::MissingEnhancedSitelinkDescriptionLine)
                }
                "REVIEW_EXTENSION_SOURCE_INELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceIneligible)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "DOUBLE_QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::DoubleQuotesInReviewExtensionSnippet)
                }
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "INVALID_FORM_ENCODED_PARAMS" => Some(Self::InvalidFormEncodedParams),
                "INVALID_URL_PARAMETER_NAME" => Some(Self::InvalidUrlParameterName),
                "NO_GEOCODING_RESULT" => Some(Self::NoGeocodingResult),
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "INVALID_PLACEHOLDER_FIELD_ID" => Some(Self::InvalidPlaceholderFieldId),
                "INVALID_URL_TAG" => Some(Self::InvalidUrlTag),
                "LIST_TOO_LONG" => Some(Self::ListTooLong),
                "INVALID_ATTRIBUTES_COMBINATION" => {
                    Some(Self::InvalidAttributesCombination)
                }
                "DUPLICATE_VALUES" => Some(Self::DuplicateValues),
                "INVALID_CALL_CONVERSION_ACTION_ID" => {
                    Some(Self::InvalidCallConversionActionId)
                }
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "APP_ID_DOESNT_EXIST_IN_APP_STORE" => {
                    Some(Self::AppIdDoesntExistInAppStore)
                }
                "INVALID_FINAL_URL" => Some(Self::InvalidFinalUrl),
                "INVALID_TRACKING_URL" => Some(Self::InvalidTrackingUrl),
                "INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL" => {
                    Some(Self::InvalidFinalUrlForAppDownloadUrl)
                }
                "LIST_TOO_SHORT" => Some(Self::ListTooShort),
                "INVALID_USER_ACTION" => Some(Self::InvalidUserAction),
                "INVALID_TYPE_NAME" => Some(Self::InvalidTypeName),
                "INVALID_EVENT_CHANGE_STATUS" => Some(Self::InvalidEventChangeStatus),
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "INVALID_ANDROID_APP_LINK" => Some(Self::InvalidAndroidAppLink),
                "NUMBER_TYPE_WITH_CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::NumberTypeWithCalltrackingNotSupportedForCountry)
                }
                "RESERVED_KEYWORD_OTHER" => Some(Self::ReservedKeywordOther),
                "DUPLICATE_OPTION_LABELS" => Some(Self::DuplicateOptionLabels),
                "DUPLICATE_OPTION_PREFILLS" => Some(Self::DuplicateOptionPrefills),
                "UNEQUAL_LIST_LENGTHS" => Some(Self::UnequalListLengths),
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::ItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "INVALID_FINAL_MOBILE_URL" => Some(Self::InvalidFinalMobileUrl),
                "INVALID_KEYWORDLESS_AD_RULE_LABEL" => {
                    Some(Self::InvalidKeywordlessAdRuleLabel)
                }
                "VALUE_TRACK_PARAMETER_NOT_SUPPORTED" => {
                    Some(Self::ValueTrackParameterNotSupported)
                }
                "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE" => {
                    Some(Self::UnsupportedValueInSelectedLanguage)
                }
                "INVALID_IOS_APP_LINK" => Some(Self::InvalidIosAppLink),
                "MISSING_IOS_APP_LINK_OR_IOS_APP_STORE_ID" => {
                    Some(Self::MissingIosAppLinkOrIosAppStoreId)
                }
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF" => {
                    Some(Self::PromotionCannotSetPercentOffAndMoneyAmountOff)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "AD_CUSTOMIZERS_NOT_ALLOWED" => Some(Self::AdCustomizersNotAllowed),
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                "UNSUPPORTED_LANGUAGE" => Some(Self::UnsupportedLanguage),
                "IF_FUNCTION_NOT_ALLOWED" => Some(Self::IfFunctionNotAllowed),
                "INVALID_FINAL_URL_SUFFIX" => Some(Self::InvalidFinalUrlSuffix),
                "INVALID_TAG_IN_FINAL_URL_SUFFIX" => {
                    Some(Self::InvalidTagInFinalUrlSuffix)
                }
                "INVALID_FINAL_URL_SUFFIX_FORMAT" => {
                    Some(Self::InvalidFinalUrlSuffixFormat)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "ONLY_ONE_DELIVERY_OPTION_IS_ALLOWED" => {
                    Some(Self::OnlyOneDeliveryOptionIsAllowed)
                }
                "NO_DELIVERY_OPTION_IS_SET" => Some(Self::NoDeliveryOptionIsSet),
                "INVALID_CONVERSION_REPORTING_STATE" => {
                    Some(Self::InvalidConversionReportingState)
                }
                "IMAGE_SIZE_WRONG" => Some(Self::ImageSizeWrong),
                "EMAIL_DELIVERY_NOT_AVAILABLE_IN_COUNTRY" => {
                    Some(Self::EmailDeliveryNotAvailableInCountry)
                }
                "AUTO_REPLY_NOT_AVAILABLE_IN_COUNTRY" => {
                    Some(Self::AutoReplyNotAvailableInCountry)
                }
                "INVALID_LATITUDE_VALUE" => Some(Self::InvalidLatitudeValue),
                "INVALID_LONGITUDE_VALUE" => Some(Self::InvalidLongitudeValue),
                "TOO_MANY_LABELS" => Some(Self::TooManyLabels),
                "INVALID_IMAGE_URL" => Some(Self::InvalidImageUrl),
                "MISSING_LATITUDE_VALUE" => Some(Self::MissingLatitudeValue),
                "MISSING_LONGITUDE_VALUE" => Some(Self::MissingLongitudeValue),
                "ADDRESS_NOT_FOUND" => Some(Self::AddressNotFound),
                "ADDRESS_NOT_TARGETABLE" => Some(Self::AddressNotTargetable),
                "INVALID_ASSET_ID" => Some(Self::InvalidAssetId),
                "INCOMPATIBLE_ASSET_TYPE" => Some(Self::IncompatibleAssetType),
                "IMAGE_ERROR_UNEXPECTED_SIZE" => Some(Self::ImageErrorUnexpectedSize),
                "IMAGE_ERROR_ASPECT_RATIO_NOT_ALLOWED" => {
                    Some(Self::ImageErrorAspectRatioNotAllowed)
                }
                "IMAGE_ERROR_FILE_TOO_LARGE" => Some(Self::ImageErrorFileTooLarge),
                "IMAGE_ERROR_FORMAT_NOT_ALLOWED" => {
                    Some(Self::ImageErrorFormatNotAllowed)
                }
                "IMAGE_ERROR_CONSTRAINTS_VIOLATED" => {
                    Some(Self::ImageErrorConstraintsViolated)
                }
                "IMAGE_ERROR_SERVER_ERROR" => Some(Self::ImageErrorServerError),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CollectionSizeErrorEnum {}
/// Nested message and enum types in `CollectionSizeErrorEnum`.
pub mod collection_size_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CollectionSizeError {
        Unspecified = 0,
        Unknown = 1,
        TooFew = 2,
        TooMany = 3,
    }
    impl CollectionSizeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CollectionSizeError::Unspecified => "UNSPECIFIED",
                CollectionSizeError::Unknown => "UNKNOWN",
                CollectionSizeError::TooFew => "TOO_FEW",
                CollectionSizeError::TooMany => "TOO_MANY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_FEW" => Some(Self::TooFew),
                "TOO_MANY" => Some(Self::TooMany),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentUploadErrorEnum {}
/// Nested message and enum types in `ConversionAdjustmentUploadErrorEnum`.
pub mod conversion_adjustment_upload_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAdjustmentUploadError {
        Unspecified = 0,
        Unknown = 1,
        TooRecentConversionAction = 2,
        ConversionAlreadyRetracted = 4,
        ConversionNotFound = 5,
        ConversionExpired = 6,
        AdjustmentPrecedesConversion = 7,
        MoreRecentRestatementFound = 8,
        TooRecentConversion = 9,
        CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue = 10,
        TooManyAdjustmentsInRequest = 11,
        TooManyAdjustments = 12,
        RestatementAlreadyExists = 13,
        DuplicateAdjustmentInRequest = 14,
        CustomerNotAcceptedCustomerDataTerms = 15,
        ConversionActionNotEligibleForEnhancement = 16,
        InvalidUserIdentifier = 17,
        UnsupportedUserIdentifier = 18,
        GclidDateTimePairAndOrderIdBothSet = 20,
        ConversionAlreadyEnhanced = 21,
        DuplicateEnhancementInRequest = 22,
        CustomerDataPolicyProhibitsEnhancement = 23,
        MissingOrderIdForWebpage = 24,
        OrderIdContainsPii = 25,
        InvalidJobId = 26,
        NoConversionActionFound = 27,
        InvalidConversionActionType = 28,
    }
    impl ConversionAdjustmentUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionAdjustmentUploadError::Unspecified => "UNSPECIFIED",
                ConversionAdjustmentUploadError::Unknown => "UNKNOWN",
                ConversionAdjustmentUploadError::TooRecentConversionAction => {
                    "TOO_RECENT_CONVERSION_ACTION"
                }
                ConversionAdjustmentUploadError::ConversionAlreadyRetracted => {
                    "CONVERSION_ALREADY_RETRACTED"
                }
                ConversionAdjustmentUploadError::ConversionNotFound => {
                    "CONVERSION_NOT_FOUND"
                }
                ConversionAdjustmentUploadError::ConversionExpired => {
                    "CONVERSION_EXPIRED"
                }
                ConversionAdjustmentUploadError::AdjustmentPrecedesConversion => {
                    "ADJUSTMENT_PRECEDES_CONVERSION"
                }
                ConversionAdjustmentUploadError::MoreRecentRestatementFound => {
                    "MORE_RECENT_RESTATEMENT_FOUND"
                }
                ConversionAdjustmentUploadError::TooRecentConversion => {
                    "TOO_RECENT_CONVERSION"
                }
                ConversionAdjustmentUploadError::CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue => {
                    "CANNOT_RESTATE_CONVERSION_ACTION_THAT_ALWAYS_USES_DEFAULT_CONVERSION_VALUE"
                }
                ConversionAdjustmentUploadError::TooManyAdjustmentsInRequest => {
                    "TOO_MANY_ADJUSTMENTS_IN_REQUEST"
                }
                ConversionAdjustmentUploadError::TooManyAdjustments => {
                    "TOO_MANY_ADJUSTMENTS"
                }
                ConversionAdjustmentUploadError::RestatementAlreadyExists => {
                    "RESTATEMENT_ALREADY_EXISTS"
                }
                ConversionAdjustmentUploadError::DuplicateAdjustmentInRequest => {
                    "DUPLICATE_ADJUSTMENT_IN_REQUEST"
                }
                ConversionAdjustmentUploadError::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                ConversionAdjustmentUploadError::ConversionActionNotEligibleForEnhancement => {
                    "CONVERSION_ACTION_NOT_ELIGIBLE_FOR_ENHANCEMENT"
                }
                ConversionAdjustmentUploadError::InvalidUserIdentifier => {
                    "INVALID_USER_IDENTIFIER"
                }
                ConversionAdjustmentUploadError::UnsupportedUserIdentifier => {
                    "UNSUPPORTED_USER_IDENTIFIER"
                }
                ConversionAdjustmentUploadError::GclidDateTimePairAndOrderIdBothSet => {
                    "GCLID_DATE_TIME_PAIR_AND_ORDER_ID_BOTH_SET"
                }
                ConversionAdjustmentUploadError::ConversionAlreadyEnhanced => {
                    "CONVERSION_ALREADY_ENHANCED"
                }
                ConversionAdjustmentUploadError::DuplicateEnhancementInRequest => {
                    "DUPLICATE_ENHANCEMENT_IN_REQUEST"
                }
                ConversionAdjustmentUploadError::CustomerDataPolicyProhibitsEnhancement => {
                    "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCEMENT"
                }
                ConversionAdjustmentUploadError::MissingOrderIdForWebpage => {
                    "MISSING_ORDER_ID_FOR_WEBPAGE"
                }
                ConversionAdjustmentUploadError::OrderIdContainsPii => {
                    "ORDER_ID_CONTAINS_PII"
                }
                ConversionAdjustmentUploadError::InvalidJobId => "INVALID_JOB_ID",
                ConversionAdjustmentUploadError::NoConversionActionFound => {
                    "NO_CONVERSION_ACTION_FOUND"
                }
                ConversionAdjustmentUploadError::InvalidConversionActionType => {
                    "INVALID_CONVERSION_ACTION_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_RECENT_CONVERSION_ACTION" => Some(Self::TooRecentConversionAction),
                "CONVERSION_ALREADY_RETRACTED" => Some(Self::ConversionAlreadyRetracted),
                "CONVERSION_NOT_FOUND" => Some(Self::ConversionNotFound),
                "CONVERSION_EXPIRED" => Some(Self::ConversionExpired),
                "ADJUSTMENT_PRECEDES_CONVERSION" => {
                    Some(Self::AdjustmentPrecedesConversion)
                }
                "MORE_RECENT_RESTATEMENT_FOUND" => Some(Self::MoreRecentRestatementFound),
                "TOO_RECENT_CONVERSION" => Some(Self::TooRecentConversion),
                "CANNOT_RESTATE_CONVERSION_ACTION_THAT_ALWAYS_USES_DEFAULT_CONVERSION_VALUE" => {
                    Some(
                        Self::CannotRestateConversionActionThatAlwaysUsesDefaultConversionValue,
                    )
                }
                "TOO_MANY_ADJUSTMENTS_IN_REQUEST" => {
                    Some(Self::TooManyAdjustmentsInRequest)
                }
                "TOO_MANY_ADJUSTMENTS" => Some(Self::TooManyAdjustments),
                "RESTATEMENT_ALREADY_EXISTS" => Some(Self::RestatementAlreadyExists),
                "DUPLICATE_ADJUSTMENT_IN_REQUEST" => {
                    Some(Self::DuplicateAdjustmentInRequest)
                }
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "CONVERSION_ACTION_NOT_ELIGIBLE_FOR_ENHANCEMENT" => {
                    Some(Self::ConversionActionNotEligibleForEnhancement)
                }
                "INVALID_USER_IDENTIFIER" => Some(Self::InvalidUserIdentifier),
                "UNSUPPORTED_USER_IDENTIFIER" => Some(Self::UnsupportedUserIdentifier),
                "GCLID_DATE_TIME_PAIR_AND_ORDER_ID_BOTH_SET" => {
                    Some(Self::GclidDateTimePairAndOrderIdBothSet)
                }
                "CONVERSION_ALREADY_ENHANCED" => Some(Self::ConversionAlreadyEnhanced),
                "DUPLICATE_ENHANCEMENT_IN_REQUEST" => {
                    Some(Self::DuplicateEnhancementInRequest)
                }
                "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCEMENT" => {
                    Some(Self::CustomerDataPolicyProhibitsEnhancement)
                }
                "MISSING_ORDER_ID_FOR_WEBPAGE" => Some(Self::MissingOrderIdForWebpage),
                "ORDER_ID_CONTAINS_PII" => Some(Self::OrderIdContainsPii),
                "INVALID_JOB_ID" => Some(Self::InvalidJobId),
                "NO_CONVERSION_ACTION_FOUND" => Some(Self::NoConversionActionFound),
                "INVALID_CONVERSION_ACTION_TYPE" => {
                    Some(Self::InvalidConversionActionType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionUploadErrorEnum {}
/// Nested message and enum types in `ConversionUploadErrorEnum`.
pub mod conversion_upload_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionUploadError {
        Unspecified = 0,
        Unknown = 1,
        TooManyConversionsInRequest = 2,
        UnparseableGclid = 3,
        ConversionPrecedesEvent = 42,
        ExpiredEvent = 43,
        TooRecentEvent = 44,
        EventNotFound = 45,
        UnauthorizedCustomer = 8,
        TooRecentConversionAction = 10,
        ConversionTrackingNotEnabledAtImpressionTime = 11,
        ExternalAttributionDataSetForNonExternallyAttributedConversionAction = 12,
        ExternalAttributionDataNotSetForExternallyAttributedConversionAction = 13,
        OrderIdNotPermittedForExternallyAttributedConversionAction = 14,
        OrderIdAlreadyInUse = 15,
        DuplicateOrderId = 16,
        TooRecentCall = 17,
        ExpiredCall = 18,
        CallNotFound = 19,
        ConversionPrecedesCall = 20,
        ConversionTrackingNotEnabledAtCallTime = 21,
        UnparseableCallersPhoneNumber = 22,
        ClickConversionAlreadyExists = 23,
        CallConversionAlreadyExists = 24,
        DuplicateClickConversionInRequest = 25,
        DuplicateCallConversionInRequest = 26,
        CustomVariableNotEnabled = 28,
        CustomVariableValueContainsPii = 29,
        InvalidCustomerForClick = 30,
        InvalidCustomerForCall = 31,
        ConversionNotCompliantWithAttPolicy = 32,
        ClickNotFound = 33,
        InvalidUserIdentifier = 34,
        ExternallyAttributedConversionActionNotPermittedWithUserIdentifier = 35,
        UnsupportedUserIdentifier = 36,
        GbraidWbraidBothSet = 38,
        UnparseableWbraid = 39,
        UnparseableGbraid = 40,
        OnePerClickConversionActionNotPermittedWithBraid = 46,
        CustomerDataPolicyProhibitsEnhancedConversions = 47,
        CustomerNotAcceptedCustomerDataTerms = 48,
        OrderIdContainsPii = 49,
        CustomerNotEnabledEnhancedConversionsForLeads = 50,
        InvalidJobId = 52,
        NoConversionActionFound = 53,
        InvalidConversionActionType = 54,
    }
    impl ConversionUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionUploadError::Unspecified => "UNSPECIFIED",
                ConversionUploadError::Unknown => "UNKNOWN",
                ConversionUploadError::TooManyConversionsInRequest => {
                    "TOO_MANY_CONVERSIONS_IN_REQUEST"
                }
                ConversionUploadError::UnparseableGclid => "UNPARSEABLE_GCLID",
                ConversionUploadError::ConversionPrecedesEvent => {
                    "CONVERSION_PRECEDES_EVENT"
                }
                ConversionUploadError::ExpiredEvent => "EXPIRED_EVENT",
                ConversionUploadError::TooRecentEvent => "TOO_RECENT_EVENT",
                ConversionUploadError::EventNotFound => "EVENT_NOT_FOUND",
                ConversionUploadError::UnauthorizedCustomer => "UNAUTHORIZED_CUSTOMER",
                ConversionUploadError::TooRecentConversionAction => {
                    "TOO_RECENT_CONVERSION_ACTION"
                }
                ConversionUploadError::ConversionTrackingNotEnabledAtImpressionTime => {
                    "CONVERSION_TRACKING_NOT_ENABLED_AT_IMPRESSION_TIME"
                }
                ConversionUploadError::ExternalAttributionDataSetForNonExternallyAttributedConversionAction => {
                    "EXTERNAL_ATTRIBUTION_DATA_SET_FOR_NON_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                ConversionUploadError::ExternalAttributionDataNotSetForExternallyAttributedConversionAction => {
                    "EXTERNAL_ATTRIBUTION_DATA_NOT_SET_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                ConversionUploadError::OrderIdNotPermittedForExternallyAttributedConversionAction => {
                    "ORDER_ID_NOT_PERMITTED_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION"
                }
                ConversionUploadError::OrderIdAlreadyInUse => "ORDER_ID_ALREADY_IN_USE",
                ConversionUploadError::DuplicateOrderId => "DUPLICATE_ORDER_ID",
                ConversionUploadError::TooRecentCall => "TOO_RECENT_CALL",
                ConversionUploadError::ExpiredCall => "EXPIRED_CALL",
                ConversionUploadError::CallNotFound => "CALL_NOT_FOUND",
                ConversionUploadError::ConversionPrecedesCall => {
                    "CONVERSION_PRECEDES_CALL"
                }
                ConversionUploadError::ConversionTrackingNotEnabledAtCallTime => {
                    "CONVERSION_TRACKING_NOT_ENABLED_AT_CALL_TIME"
                }
                ConversionUploadError::UnparseableCallersPhoneNumber => {
                    "UNPARSEABLE_CALLERS_PHONE_NUMBER"
                }
                ConversionUploadError::ClickConversionAlreadyExists => {
                    "CLICK_CONVERSION_ALREADY_EXISTS"
                }
                ConversionUploadError::CallConversionAlreadyExists => {
                    "CALL_CONVERSION_ALREADY_EXISTS"
                }
                ConversionUploadError::DuplicateClickConversionInRequest => {
                    "DUPLICATE_CLICK_CONVERSION_IN_REQUEST"
                }
                ConversionUploadError::DuplicateCallConversionInRequest => {
                    "DUPLICATE_CALL_CONVERSION_IN_REQUEST"
                }
                ConversionUploadError::CustomVariableNotEnabled => {
                    "CUSTOM_VARIABLE_NOT_ENABLED"
                }
                ConversionUploadError::CustomVariableValueContainsPii => {
                    "CUSTOM_VARIABLE_VALUE_CONTAINS_PII"
                }
                ConversionUploadError::InvalidCustomerForClick => {
                    "INVALID_CUSTOMER_FOR_CLICK"
                }
                ConversionUploadError::InvalidCustomerForCall => {
                    "INVALID_CUSTOMER_FOR_CALL"
                }
                ConversionUploadError::ConversionNotCompliantWithAttPolicy => {
                    "CONVERSION_NOT_COMPLIANT_WITH_ATT_POLICY"
                }
                ConversionUploadError::ClickNotFound => "CLICK_NOT_FOUND",
                ConversionUploadError::InvalidUserIdentifier => "INVALID_USER_IDENTIFIER",
                ConversionUploadError::ExternallyAttributedConversionActionNotPermittedWithUserIdentifier => {
                    "EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION_NOT_PERMITTED_WITH_USER_IDENTIFIER"
                }
                ConversionUploadError::UnsupportedUserIdentifier => {
                    "UNSUPPORTED_USER_IDENTIFIER"
                }
                ConversionUploadError::GbraidWbraidBothSet => "GBRAID_WBRAID_BOTH_SET",
                ConversionUploadError::UnparseableWbraid => "UNPARSEABLE_WBRAID",
                ConversionUploadError::UnparseableGbraid => "UNPARSEABLE_GBRAID",
                ConversionUploadError::OnePerClickConversionActionNotPermittedWithBraid => {
                    "ONE_PER_CLICK_CONVERSION_ACTION_NOT_PERMITTED_WITH_BRAID"
                }
                ConversionUploadError::CustomerDataPolicyProhibitsEnhancedConversions => {
                    "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS"
                }
                ConversionUploadError::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                ConversionUploadError::OrderIdContainsPii => "ORDER_ID_CONTAINS_PII",
                ConversionUploadError::CustomerNotEnabledEnhancedConversionsForLeads => {
                    "CUSTOMER_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS"
                }
                ConversionUploadError::InvalidJobId => "INVALID_JOB_ID",
                ConversionUploadError::NoConversionActionFound => {
                    "NO_CONVERSION_ACTION_FOUND"
                }
                ConversionUploadError::InvalidConversionActionType => {
                    "INVALID_CONVERSION_ACTION_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_MANY_CONVERSIONS_IN_REQUEST" => {
                    Some(Self::TooManyConversionsInRequest)
                }
                "UNPARSEABLE_GCLID" => Some(Self::UnparseableGclid),
                "CONVERSION_PRECEDES_EVENT" => Some(Self::ConversionPrecedesEvent),
                "EXPIRED_EVENT" => Some(Self::ExpiredEvent),
                "TOO_RECENT_EVENT" => Some(Self::TooRecentEvent),
                "EVENT_NOT_FOUND" => Some(Self::EventNotFound),
                "UNAUTHORIZED_CUSTOMER" => Some(Self::UnauthorizedCustomer),
                "TOO_RECENT_CONVERSION_ACTION" => Some(Self::TooRecentConversionAction),
                "CONVERSION_TRACKING_NOT_ENABLED_AT_IMPRESSION_TIME" => {
                    Some(Self::ConversionTrackingNotEnabledAtImpressionTime)
                }
                "EXTERNAL_ATTRIBUTION_DATA_SET_FOR_NON_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::ExternalAttributionDataSetForNonExternallyAttributedConversionAction,
                    )
                }
                "EXTERNAL_ATTRIBUTION_DATA_NOT_SET_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::ExternalAttributionDataNotSetForExternallyAttributedConversionAction,
                    )
                }
                "ORDER_ID_NOT_PERMITTED_FOR_EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION" => {
                    Some(
                        Self::OrderIdNotPermittedForExternallyAttributedConversionAction,
                    )
                }
                "ORDER_ID_ALREADY_IN_USE" => Some(Self::OrderIdAlreadyInUse),
                "DUPLICATE_ORDER_ID" => Some(Self::DuplicateOrderId),
                "TOO_RECENT_CALL" => Some(Self::TooRecentCall),
                "EXPIRED_CALL" => Some(Self::ExpiredCall),
                "CALL_NOT_FOUND" => Some(Self::CallNotFound),
                "CONVERSION_PRECEDES_CALL" => Some(Self::ConversionPrecedesCall),
                "CONVERSION_TRACKING_NOT_ENABLED_AT_CALL_TIME" => {
                    Some(Self::ConversionTrackingNotEnabledAtCallTime)
                }
                "UNPARSEABLE_CALLERS_PHONE_NUMBER" => {
                    Some(Self::UnparseableCallersPhoneNumber)
                }
                "CLICK_CONVERSION_ALREADY_EXISTS" => {
                    Some(Self::ClickConversionAlreadyExists)
                }
                "CALL_CONVERSION_ALREADY_EXISTS" => {
                    Some(Self::CallConversionAlreadyExists)
                }
                "DUPLICATE_CLICK_CONVERSION_IN_REQUEST" => {
                    Some(Self::DuplicateClickConversionInRequest)
                }
                "DUPLICATE_CALL_CONVERSION_IN_REQUEST" => {
                    Some(Self::DuplicateCallConversionInRequest)
                }
                "CUSTOM_VARIABLE_NOT_ENABLED" => Some(Self::CustomVariableNotEnabled),
                "CUSTOM_VARIABLE_VALUE_CONTAINS_PII" => {
                    Some(Self::CustomVariableValueContainsPii)
                }
                "INVALID_CUSTOMER_FOR_CLICK" => Some(Self::InvalidCustomerForClick),
                "INVALID_CUSTOMER_FOR_CALL" => Some(Self::InvalidCustomerForCall),
                "CONVERSION_NOT_COMPLIANT_WITH_ATT_POLICY" => {
                    Some(Self::ConversionNotCompliantWithAttPolicy)
                }
                "CLICK_NOT_FOUND" => Some(Self::ClickNotFound),
                "INVALID_USER_IDENTIFIER" => Some(Self::InvalidUserIdentifier),
                "EXTERNALLY_ATTRIBUTED_CONVERSION_ACTION_NOT_PERMITTED_WITH_USER_IDENTIFIER" => {
                    Some(
                        Self::ExternallyAttributedConversionActionNotPermittedWithUserIdentifier,
                    )
                }
                "UNSUPPORTED_USER_IDENTIFIER" => Some(Self::UnsupportedUserIdentifier),
                "GBRAID_WBRAID_BOTH_SET" => Some(Self::GbraidWbraidBothSet),
                "UNPARSEABLE_WBRAID" => Some(Self::UnparseableWbraid),
                "UNPARSEABLE_GBRAID" => Some(Self::UnparseableGbraid),
                "ONE_PER_CLICK_CONVERSION_ACTION_NOT_PERMITTED_WITH_BRAID" => {
                    Some(Self::OnePerClickConversionActionNotPermittedWithBraid)
                }
                "CUSTOMER_DATA_POLICY_PROHIBITS_ENHANCED_CONVERSIONS" => {
                    Some(Self::CustomerDataPolicyProhibitsEnhancedConversions)
                }
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "ORDER_ID_CONTAINS_PII" => Some(Self::OrderIdContainsPii),
                "CUSTOMER_NOT_ENABLED_ENHANCED_CONVERSIONS_FOR_LEADS" => {
                    Some(Self::CustomerNotEnabledEnhancedConversionsForLeads)
                }
                "INVALID_JOB_ID" => Some(Self::InvalidJobId),
                "NO_CONVERSION_ACTION_FOUND" => Some(Self::NoConversionActionFound),
                "INVALID_CONVERSION_ACTION_TYPE" => {
                    Some(Self::InvalidConversionActionType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateErrorEnum {}
/// Nested message and enum types in `DateErrorEnum`.
pub mod date_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateError {
        Unspecified = 0,
        Unknown = 1,
        InvalidFieldValuesInDate = 2,
        InvalidFieldValuesInDateTime = 3,
        InvalidStringDate = 4,
        InvalidStringDateTimeMicros = 6,
        InvalidStringDateTimeSeconds = 11,
        InvalidStringDateTimeSecondsWithOffset = 12,
        EarlierThanMinimumDate = 7,
        LaterThanMaximumDate = 8,
        DateRangeMinimumDateLaterThanMaximumDate = 9,
        DateRangeMinimumAndMaximumDatesBothNull = 10,
    }
    impl DateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DateError::Unspecified => "UNSPECIFIED",
                DateError::Unknown => "UNKNOWN",
                DateError::InvalidFieldValuesInDate => "INVALID_FIELD_VALUES_IN_DATE",
                DateError::InvalidFieldValuesInDateTime => {
                    "INVALID_FIELD_VALUES_IN_DATE_TIME"
                }
                DateError::InvalidStringDate => "INVALID_STRING_DATE",
                DateError::InvalidStringDateTimeMicros => {
                    "INVALID_STRING_DATE_TIME_MICROS"
                }
                DateError::InvalidStringDateTimeSeconds => {
                    "INVALID_STRING_DATE_TIME_SECONDS"
                }
                DateError::InvalidStringDateTimeSecondsWithOffset => {
                    "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET"
                }
                DateError::EarlierThanMinimumDate => "EARLIER_THAN_MINIMUM_DATE",
                DateError::LaterThanMaximumDate => "LATER_THAN_MAXIMUM_DATE",
                DateError::DateRangeMinimumDateLaterThanMaximumDate => {
                    "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE"
                }
                DateError::DateRangeMinimumAndMaximumDatesBothNull => {
                    "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FIELD_VALUES_IN_DATE" => Some(Self::InvalidFieldValuesInDate),
                "INVALID_FIELD_VALUES_IN_DATE_TIME" => {
                    Some(Self::InvalidFieldValuesInDateTime)
                }
                "INVALID_STRING_DATE" => Some(Self::InvalidStringDate),
                "INVALID_STRING_DATE_TIME_MICROS" => {
                    Some(Self::InvalidStringDateTimeMicros)
                }
                "INVALID_STRING_DATE_TIME_SECONDS" => {
                    Some(Self::InvalidStringDateTimeSeconds)
                }
                "INVALID_STRING_DATE_TIME_SECONDS_WITH_OFFSET" => {
                    Some(Self::InvalidStringDateTimeSecondsWithOffset)
                }
                "EARLIER_THAN_MINIMUM_DATE" => Some(Self::EarlierThanMinimumDate),
                "LATER_THAN_MAXIMUM_DATE" => Some(Self::LaterThanMaximumDate),
                "DATE_RANGE_MINIMUM_DATE_LATER_THAN_MAXIMUM_DATE" => {
                    Some(Self::DateRangeMinimumDateLaterThanMaximumDate)
                }
                "DATE_RANGE_MINIMUM_AND_MAXIMUM_DATES_BOTH_NULL" => {
                    Some(Self::DateRangeMinimumAndMaximumDatesBothNull)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistinctErrorEnum {}
/// Nested message and enum types in `DistinctErrorEnum`.
pub mod distinct_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistinctError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateElement = 2,
        DuplicateType = 3,
    }
    impl DistinctError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DistinctError::Unspecified => "UNSPECIFIED",
                DistinctError::Unknown => "UNKNOWN",
                DistinctError::DuplicateElement => "DUPLICATE_ELEMENT",
                DistinctError::DuplicateType => "DUPLICATE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ELEMENT" => Some(Self::DuplicateElement),
                "DUPLICATE_TYPE" => Some(Self::DuplicateType),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FieldErrorEnum {}
/// Nested message and enum types in `FieldErrorEnum`.
pub mod field_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldError {
        Unspecified = 0,
        Unknown = 1,
        Required = 2,
        ImmutableField = 3,
        InvalidValue = 4,
        ValueMustBeUnset = 5,
        RequiredNonemptyList = 6,
        FieldCannotBeCleared = 7,
        BlockedValue = 9,
        FieldCanOnlyBeCleared = 10,
    }
    impl FieldError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FieldError::Unspecified => "UNSPECIFIED",
                FieldError::Unknown => "UNKNOWN",
                FieldError::Required => "REQUIRED",
                FieldError::ImmutableField => "IMMUTABLE_FIELD",
                FieldError::InvalidValue => "INVALID_VALUE",
                FieldError::ValueMustBeUnset => "VALUE_MUST_BE_UNSET",
                FieldError::RequiredNonemptyList => "REQUIRED_NONEMPTY_LIST",
                FieldError::FieldCannotBeCleared => "FIELD_CANNOT_BE_CLEARED",
                FieldError::BlockedValue => "BLOCKED_VALUE",
                FieldError::FieldCanOnlyBeCleared => "FIELD_CAN_ONLY_BE_CLEARED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUIRED" => Some(Self::Required),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "INVALID_VALUE" => Some(Self::InvalidValue),
                "VALUE_MUST_BE_UNSET" => Some(Self::ValueMustBeUnset),
                "REQUIRED_NONEMPTY_LIST" => Some(Self::RequiredNonemptyList),
                "FIELD_CANNOT_BE_CLEARED" => Some(Self::FieldCannotBeCleared),
                "BLOCKED_VALUE" => Some(Self::BlockedValue),
                "FIELD_CAN_ONLY_BE_CLEARED" => Some(Self::FieldCanOnlyBeCleared),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MutateErrorEnum {}
/// Nested message and enum types in `MutateErrorEnum`.
pub mod mutate_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MutateError {
        Unspecified = 0,
        Unknown = 1,
        ResourceNotFound = 3,
        IdExistsInMultipleMutates = 7,
        InconsistentFieldValues = 8,
        MutateNotAllowed = 9,
        ResourceNotInGoogleAds = 10,
        ResourceAlreadyExists = 11,
        ResourceDoesNotSupportValidateOnly = 12,
        OperationDoesNotSupportPartialFailure = 16,
        ResourceReadOnly = 13,
    }
    impl MutateError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MutateError::Unspecified => "UNSPECIFIED",
                MutateError::Unknown => "UNKNOWN",
                MutateError::ResourceNotFound => "RESOURCE_NOT_FOUND",
                MutateError::IdExistsInMultipleMutates => "ID_EXISTS_IN_MULTIPLE_MUTATES",
                MutateError::InconsistentFieldValues => "INCONSISTENT_FIELD_VALUES",
                MutateError::MutateNotAllowed => "MUTATE_NOT_ALLOWED",
                MutateError::ResourceNotInGoogleAds => "RESOURCE_NOT_IN_GOOGLE_ADS",
                MutateError::ResourceAlreadyExists => "RESOURCE_ALREADY_EXISTS",
                MutateError::ResourceDoesNotSupportValidateOnly => {
                    "RESOURCE_DOES_NOT_SUPPORT_VALIDATE_ONLY"
                }
                MutateError::OperationDoesNotSupportPartialFailure => {
                    "OPERATION_DOES_NOT_SUPPORT_PARTIAL_FAILURE"
                }
                MutateError::ResourceReadOnly => "RESOURCE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "ID_EXISTS_IN_MULTIPLE_MUTATES" => Some(Self::IdExistsInMultipleMutates),
                "INCONSISTENT_FIELD_VALUES" => Some(Self::InconsistentFieldValues),
                "MUTATE_NOT_ALLOWED" => Some(Self::MutateNotAllowed),
                "RESOURCE_NOT_IN_GOOGLE_ADS" => Some(Self::ResourceNotInGoogleAds),
                "RESOURCE_ALREADY_EXISTS" => Some(Self::ResourceAlreadyExists),
                "RESOURCE_DOES_NOT_SUPPORT_VALIDATE_ONLY" => {
                    Some(Self::ResourceDoesNotSupportValidateOnly)
                }
                "OPERATION_DOES_NOT_SUPPORT_PARTIAL_FAILURE" => {
                    Some(Self::OperationDoesNotSupportPartialFailure)
                }
                "RESOURCE_READ_ONLY" => Some(Self::ResourceReadOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotAllowlistedErrorEnum {}
/// Nested message and enum types in `NotAllowlistedErrorEnum`.
pub mod not_allowlisted_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotAllowlistedError {
        Unspecified = 0,
        Unknown = 1,
        CustomerNotAllowlistedForThisFeature = 2,
    }
    impl NotAllowlistedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NotAllowlistedError::Unspecified => "UNSPECIFIED",
                NotAllowlistedError::Unknown => "UNKNOWN",
                NotAllowlistedError::CustomerNotAllowlistedForThisFeature => {
                    "CUSTOMER_NOT_ALLOWLISTED_FOR_THIS_FEATURE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_NOT_ALLOWLISTED_FOR_THIS_FEATURE" => {
                    Some(Self::CustomerNotAllowlistedForThisFeature)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StringFormatErrorEnum {}
/// Nested message and enum types in `StringFormatErrorEnum`.
pub mod string_format_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StringFormatError {
        Unspecified = 0,
        Unknown = 1,
        IllegalChars = 2,
        InvalidFormat = 3,
    }
    impl StringFormatError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StringFormatError::Unspecified => "UNSPECIFIED",
                StringFormatError::Unknown => "UNKNOWN",
                StringFormatError::IllegalChars => "ILLEGAL_CHARS",
                StringFormatError::InvalidFormat => "INVALID_FORMAT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ILLEGAL_CHARS" => Some(Self::IllegalChars),
                "INVALID_FORMAT" => Some(Self::InvalidFormat),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StringLengthErrorEnum {}
/// Nested message and enum types in `StringLengthErrorEnum`.
pub mod string_length_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StringLengthError {
        Unspecified = 0,
        Unknown = 1,
        Empty = 4,
        TooShort = 2,
        TooLong = 3,
    }
    impl StringLengthError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StringLengthError::Unspecified => "UNSPECIFIED",
                StringLengthError::Unknown => "UNKNOWN",
                StringLengthError::Empty => "EMPTY",
                StringLengthError::TooShort => "TOO_SHORT",
                StringLengthError::TooLong => "TOO_LONG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMPTY" => Some(Self::Empty),
                "TOO_SHORT" => Some(Self::TooShort),
                "TOO_LONG" => Some(Self::TooLong),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MerchantCenterErrorEnum {}
/// Nested message and enum types in `MerchantCenterErrorEnum`.
pub mod merchant_center_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MerchantCenterError {
        Unspecified = 0,
        Unknown = 1,
        MerchantIdCannotBeAccessed = 2,
        CustomerNotAllowedForShoppingPerformanceMax = 3,
    }
    impl MerchantCenterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MerchantCenterError::Unspecified => "UNSPECIFIED",
                MerchantCenterError::Unknown => "UNKNOWN",
                MerchantCenterError::MerchantIdCannotBeAccessed => {
                    "MERCHANT_ID_CANNOT_BE_ACCESSED"
                }
                MerchantCenterError::CustomerNotAllowedForShoppingPerformanceMax => {
                    "CUSTOMER_NOT_ALLOWED_FOR_SHOPPING_PERFORMANCE_MAX"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MERCHANT_ID_CANNOT_BE_ACCESSED" => {
                    Some(Self::MerchantIdCannotBeAccessed)
                }
                "CUSTOMER_NOT_ALLOWED_FOR_SHOPPING_PERFORMANCE_MAX" => {
                    Some(Self::CustomerNotAllowedForShoppingPerformanceMax)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PartialFailureErrorEnum {}
/// Nested message and enum types in `PartialFailureErrorEnum`.
pub mod partial_failure_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartialFailureError {
        Unspecified = 0,
        Unknown = 1,
        PartialFailureModeRequired = 2,
    }
    impl PartialFailureError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PartialFailureError::Unspecified => "UNSPECIFIED",
                PartialFailureError::Unknown => "UNKNOWN",
                PartialFailureError::PartialFailureModeRequired => {
                    "PARTIAL_FAILURE_MODE_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PARTIAL_FAILURE_MODE_REQUIRED" => Some(Self::PartialFailureModeRequired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupFeedErrorEnum {}
/// Nested message and enum types in `AdGroupFeedErrorEnum`.
pub mod ad_group_feed_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupFeedError {
        Unspecified = 0,
        Unknown = 1,
        FeedAlreadyExistsForPlaceholderType = 2,
        CannotCreateForRemovedFeed = 3,
        AdgroupFeedAlreadyExists = 4,
        CannotOperateOnRemovedAdgroupFeed = 5,
        InvalidPlaceholderType = 6,
        MissingFeedmappingForPlaceholderType = 7,
        NoExistingLocationCustomerFeed = 8,
    }
    impl AdGroupFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupFeedError::Unspecified => "UNSPECIFIED",
                AdGroupFeedError::Unknown => "UNKNOWN",
                AdGroupFeedError::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                AdGroupFeedError::CannotCreateForRemovedFeed => {
                    "CANNOT_CREATE_FOR_REMOVED_FEED"
                }
                AdGroupFeedError::AdgroupFeedAlreadyExists => {
                    "ADGROUP_FEED_ALREADY_EXISTS"
                }
                AdGroupFeedError::CannotOperateOnRemovedAdgroupFeed => {
                    "CANNOT_OPERATE_ON_REMOVED_ADGROUP_FEED"
                }
                AdGroupFeedError::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                AdGroupFeedError::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                AdGroupFeedError::NoExistingLocationCustomerFeed => {
                    "NO_EXISTING_LOCATION_CUSTOMER_FEED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "ADGROUP_FEED_ALREADY_EXISTS" => Some(Self::AdgroupFeedAlreadyExists),
                "CANNOT_OPERATE_ON_REMOVED_ADGROUP_FEED" => {
                    Some(Self::CannotOperateOnRemovedAdgroupFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "NO_EXISTING_LOCATION_CUSTOMER_FEED" => {
                    Some(Self::NoExistingLocationCustomerFeed)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedAttributeReferenceErrorEnum {}
/// Nested message and enum types in `FeedAttributeReferenceErrorEnum`.
pub mod feed_attribute_reference_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedAttributeReferenceError {
        Unspecified = 0,
        Unknown = 1,
        CannotReferenceRemovedFeed = 2,
        InvalidFeedName = 3,
        InvalidFeedAttributeName = 4,
    }
    impl FeedAttributeReferenceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedAttributeReferenceError::Unspecified => "UNSPECIFIED",
                FeedAttributeReferenceError::Unknown => "UNKNOWN",
                FeedAttributeReferenceError::CannotReferenceRemovedFeed => {
                    "CANNOT_REFERENCE_REMOVED_FEED"
                }
                FeedAttributeReferenceError::InvalidFeedName => "INVALID_FEED_NAME",
                FeedAttributeReferenceError::InvalidFeedAttributeName => {
                    "INVALID_FEED_ATTRIBUTE_NAME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_REFERENCE_REMOVED_FEED" => Some(Self::CannotReferenceRemovedFeed),
                "INVALID_FEED_NAME" => Some(Self::InvalidFeedName),
                "INVALID_FEED_ATTRIBUTE_NAME" => Some(Self::InvalidFeedAttributeName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeZoneErrorEnum {}
/// Nested message and enum types in `TimeZoneErrorEnum`.
pub mod time_zone_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeZoneError {
        Unspecified = 0,
        Unknown = 1,
        InvalidTimeZone = 5,
    }
    impl TimeZoneError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeZoneError::Unspecified => "UNSPECIFIED",
                TimeZoneError::Unknown => "UNKNOWN",
                TimeZoneError::InvalidTimeZone => "INVALID_TIME_ZONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_TIME_ZONE" => Some(Self::InvalidTimeZone),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerClientLinkErrorEnum {}
/// Nested message and enum types in `CustomerClientLinkErrorEnum`.
pub mod customer_client_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerClientLinkError {
        Unspecified = 0,
        Unknown = 1,
        ClientAlreadyInvitedByThisManager = 2,
        ClientAlreadyManagedInHierarchy = 3,
        CyclicLinkNotAllowed = 4,
        CustomerHasTooManyAccounts = 5,
        ClientHasTooManyInvitations = 6,
        CannotHideOrUnhideManagerAccounts = 7,
        CustomerHasTooManyAccountsAtManager = 8,
        ClientHasTooManyManagers = 9,
    }
    impl CustomerClientLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerClientLinkError::Unspecified => "UNSPECIFIED",
                CustomerClientLinkError::Unknown => "UNKNOWN",
                CustomerClientLinkError::ClientAlreadyInvitedByThisManager => {
                    "CLIENT_ALREADY_INVITED_BY_THIS_MANAGER"
                }
                CustomerClientLinkError::ClientAlreadyManagedInHierarchy => {
                    "CLIENT_ALREADY_MANAGED_IN_HIERARCHY"
                }
                CustomerClientLinkError::CyclicLinkNotAllowed => {
                    "CYCLIC_LINK_NOT_ALLOWED"
                }
                CustomerClientLinkError::CustomerHasTooManyAccounts => {
                    "CUSTOMER_HAS_TOO_MANY_ACCOUNTS"
                }
                CustomerClientLinkError::ClientHasTooManyInvitations => {
                    "CLIENT_HAS_TOO_MANY_INVITATIONS"
                }
                CustomerClientLinkError::CannotHideOrUnhideManagerAccounts => {
                    "CANNOT_HIDE_OR_UNHIDE_MANAGER_ACCOUNTS"
                }
                CustomerClientLinkError::CustomerHasTooManyAccountsAtManager => {
                    "CUSTOMER_HAS_TOO_MANY_ACCOUNTS_AT_MANAGER"
                }
                CustomerClientLinkError::ClientHasTooManyManagers => {
                    "CLIENT_HAS_TOO_MANY_MANAGERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLIENT_ALREADY_INVITED_BY_THIS_MANAGER" => {
                    Some(Self::ClientAlreadyInvitedByThisManager)
                }
                "CLIENT_ALREADY_MANAGED_IN_HIERARCHY" => {
                    Some(Self::ClientAlreadyManagedInHierarchy)
                }
                "CYCLIC_LINK_NOT_ALLOWED" => Some(Self::CyclicLinkNotAllowed),
                "CUSTOMER_HAS_TOO_MANY_ACCOUNTS" => {
                    Some(Self::CustomerHasTooManyAccounts)
                }
                "CLIENT_HAS_TOO_MANY_INVITATIONS" => {
                    Some(Self::ClientHasTooManyInvitations)
                }
                "CANNOT_HIDE_OR_UNHIDE_MANAGER_ACCOUNTS" => {
                    Some(Self::CannotHideOrUnhideManagerAccounts)
                }
                "CUSTOMER_HAS_TOO_MANY_ACCOUNTS_AT_MANAGER" => {
                    Some(Self::CustomerHasTooManyAccountsAtManager)
                }
                "CLIENT_HAS_TOO_MANY_MANAGERS" => Some(Self::ClientHasTooManyManagers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SettingErrorEnum {}
/// Nested message and enum types in `SettingErrorEnum`.
pub mod setting_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SettingError {
        Unspecified = 0,
        Unknown = 1,
        SettingTypeIsNotAvailable = 3,
        SettingTypeIsNotCompatibleWithCampaign = 4,
        TargetingSettingContainsInvalidCriterionTypeGroup = 5,
        TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll = 6,
        TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup = 7,
        DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent = 8,
        DynamicSearchAdsSettingContainsInvalidDomainName = 9,
        DynamicSearchAdsSettingContainsSubdomainName = 10,
        DynamicSearchAdsSettingContainsInvalidLanguageCode = 11,
        TargetAllIsNotAllowedForPlacementInSearchCampaign = 12,
        SettingValueNotCompatibleWithCampaign = 20,
        BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting = 21,
    }
    impl SettingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SettingError::Unspecified => "UNSPECIFIED",
                SettingError::Unknown => "UNKNOWN",
                SettingError::SettingTypeIsNotAvailable => {
                    "SETTING_TYPE_IS_NOT_AVAILABLE"
                }
                SettingError::SettingTypeIsNotCompatibleWithCampaign => {
                    "SETTING_TYPE_IS_NOT_COMPATIBLE_WITH_CAMPAIGN"
                }
                SettingError::TargetingSettingContainsInvalidCriterionTypeGroup => {
                    "TARGETING_SETTING_CONTAINS_INVALID_CRITERION_TYPE_GROUP"
                }
                SettingError::TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll => {
                    "TARGETING_SETTING_DEMOGRAPHIC_CRITERION_TYPE_GROUPS_MUST_BE_SET_TO_TARGET_ALL"
                }
                SettingError::TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup => {
                    "TARGETING_SETTING_CANNOT_CHANGE_TARGET_ALL_TO_FALSE_FOR_DEMOGRAPHIC_CRITERION_TYPE_GROUP"
                }
                SettingError::DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent => {
                    "DYNAMIC_SEARCH_ADS_SETTING_AT_LEAST_ONE_FEED_ID_MUST_BE_PRESENT"
                }
                SettingError::DynamicSearchAdsSettingContainsInvalidDomainName => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_DOMAIN_NAME"
                }
                SettingError::DynamicSearchAdsSettingContainsSubdomainName => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_SUBDOMAIN_NAME"
                }
                SettingError::DynamicSearchAdsSettingContainsInvalidLanguageCode => {
                    "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_LANGUAGE_CODE"
                }
                SettingError::TargetAllIsNotAllowedForPlacementInSearchCampaign => {
                    "TARGET_ALL_IS_NOT_ALLOWED_FOR_PLACEMENT_IN_SEARCH_CAMPAIGN"
                }
                SettingError::SettingValueNotCompatibleWithCampaign => {
                    "SETTING_VALUE_NOT_COMPATIBLE_WITH_CAMPAIGN"
                }
                SettingError::BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting => {
                    "BID_ONLY_IS_NOT_ALLOWED_TO_BE_MODIFIED_WITH_CUSTOMER_MATCH_TARGETING"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SETTING_TYPE_IS_NOT_AVAILABLE" => Some(Self::SettingTypeIsNotAvailable),
                "SETTING_TYPE_IS_NOT_COMPATIBLE_WITH_CAMPAIGN" => {
                    Some(Self::SettingTypeIsNotCompatibleWithCampaign)
                }
                "TARGETING_SETTING_CONTAINS_INVALID_CRITERION_TYPE_GROUP" => {
                    Some(Self::TargetingSettingContainsInvalidCriterionTypeGroup)
                }
                "TARGETING_SETTING_DEMOGRAPHIC_CRITERION_TYPE_GROUPS_MUST_BE_SET_TO_TARGET_ALL" => {
                    Some(
                        Self::TargetingSettingDemographicCriterionTypeGroupsMustBeSetToTargetAll,
                    )
                }
                "TARGETING_SETTING_CANNOT_CHANGE_TARGET_ALL_TO_FALSE_FOR_DEMOGRAPHIC_CRITERION_TYPE_GROUP" => {
                    Some(
                        Self::TargetingSettingCannotChangeTargetAllToFalseForDemographicCriterionTypeGroup,
                    )
                }
                "DYNAMIC_SEARCH_ADS_SETTING_AT_LEAST_ONE_FEED_ID_MUST_BE_PRESENT" => {
                    Some(Self::DynamicSearchAdsSettingAtLeastOneFeedIdMustBePresent)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_DOMAIN_NAME" => {
                    Some(Self::DynamicSearchAdsSettingContainsInvalidDomainName)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_SUBDOMAIN_NAME" => {
                    Some(Self::DynamicSearchAdsSettingContainsSubdomainName)
                }
                "DYNAMIC_SEARCH_ADS_SETTING_CONTAINS_INVALID_LANGUAGE_CODE" => {
                    Some(Self::DynamicSearchAdsSettingContainsInvalidLanguageCode)
                }
                "TARGET_ALL_IS_NOT_ALLOWED_FOR_PLACEMENT_IN_SEARCH_CAMPAIGN" => {
                    Some(Self::TargetAllIsNotAllowedForPlacementInSearchCampaign)
                }
                "SETTING_VALUE_NOT_COMPATIBLE_WITH_CAMPAIGN" => {
                    Some(Self::SettingValueNotCompatibleWithCampaign)
                }
                "BID_ONLY_IS_NOT_ALLOWED_TO_BE_MODIFIED_WITH_CUSTOMER_MATCH_TARGETING" => {
                    Some(Self::BidOnlyIsNotAllowedToBeModifiedWithCustomerMatchTargeting)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchJobErrorEnum {}
/// Nested message and enum types in `BatchJobErrorEnum`.
pub mod batch_job_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BatchJobError {
        Unspecified = 0,
        Unknown = 1,
        CannotModifyJobAfterJobStartsRunning = 2,
        EmptyOperations = 3,
        InvalidSequenceToken = 4,
        ResultsNotReady = 5,
        InvalidPageSize = 6,
        CanOnlyRemovePendingJob = 7,
        CannotListResults = 8,
    }
    impl BatchJobError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BatchJobError::Unspecified => "UNSPECIFIED",
                BatchJobError::Unknown => "UNKNOWN",
                BatchJobError::CannotModifyJobAfterJobStartsRunning => {
                    "CANNOT_MODIFY_JOB_AFTER_JOB_STARTS_RUNNING"
                }
                BatchJobError::EmptyOperations => "EMPTY_OPERATIONS",
                BatchJobError::InvalidSequenceToken => "INVALID_SEQUENCE_TOKEN",
                BatchJobError::ResultsNotReady => "RESULTS_NOT_READY",
                BatchJobError::InvalidPageSize => "INVALID_PAGE_SIZE",
                BatchJobError::CanOnlyRemovePendingJob => "CAN_ONLY_REMOVE_PENDING_JOB",
                BatchJobError::CannotListResults => "CANNOT_LIST_RESULTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_MODIFY_JOB_AFTER_JOB_STARTS_RUNNING" => {
                    Some(Self::CannotModifyJobAfterJobStartsRunning)
                }
                "EMPTY_OPERATIONS" => Some(Self::EmptyOperations),
                "INVALID_SEQUENCE_TOKEN" => Some(Self::InvalidSequenceToken),
                "RESULTS_NOT_READY" => Some(Self::ResultsNotReady),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "CAN_ONLY_REMOVE_PENDING_JOB" => Some(Self::CanOnlyRemovePendingJob),
                "CANNOT_LIST_RESULTS" => Some(Self::CannotListResults),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountLinkErrorEnum {}
/// Nested message and enum types in `AccountLinkErrorEnum`.
pub mod account_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountLinkError {
        Unspecified = 0,
        Unknown = 1,
        InvalidStatus = 2,
        PermissionDenied = 3,
    }
    impl AccountLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountLinkError::Unspecified => "UNSPECIFIED",
                AccountLinkError::Unknown => "UNKNOWN",
                AccountLinkError::InvalidStatus => "INVALID_STATUS",
                AccountLinkError::PermissionDenied => "PERMISSION_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NewResourceCreationErrorEnum {}
/// Nested message and enum types in `NewResourceCreationErrorEnum`.
pub mod new_resource_creation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NewResourceCreationError {
        Unspecified = 0,
        Unknown = 1,
        CannotSetIdForCreate = 2,
        DuplicateTempIds = 3,
        TempIdResourceHadErrors = 4,
    }
    impl NewResourceCreationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NewResourceCreationError::Unspecified => "UNSPECIFIED",
                NewResourceCreationError::Unknown => "UNKNOWN",
                NewResourceCreationError::CannotSetIdForCreate => {
                    "CANNOT_SET_ID_FOR_CREATE"
                }
                NewResourceCreationError::DuplicateTempIds => "DUPLICATE_TEMP_IDS",
                NewResourceCreationError::TempIdResourceHadErrors => {
                    "TEMP_ID_RESOURCE_HAD_ERRORS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_SET_ID_FOR_CREATE" => Some(Self::CannotSetIdForCreate),
                "DUPLICATE_TEMP_IDS" => Some(Self::DuplicateTempIds),
                "TEMP_ID_RESOURCE_HAD_ERRORS" => Some(Self::TempIdResourceHadErrors),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupAssetErrorEnum {}
/// Nested message and enum types in `AssetGroupAssetErrorEnum`.
pub mod asset_group_asset_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupAssetError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateResource = 2,
        ExpandableTagsNotAllowedInDescription = 3,
        AdCustomizerNotSupported = 4,
        HotelPropertyAssetNotLinkedToCampaign = 5,
    }
    impl AssetGroupAssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupAssetError::Unspecified => "UNSPECIFIED",
                AssetGroupAssetError::Unknown => "UNKNOWN",
                AssetGroupAssetError::DuplicateResource => "DUPLICATE_RESOURCE",
                AssetGroupAssetError::ExpandableTagsNotAllowedInDescription => {
                    "EXPANDABLE_TAGS_NOT_ALLOWED_IN_DESCRIPTION"
                }
                AssetGroupAssetError::AdCustomizerNotSupported => {
                    "AD_CUSTOMIZER_NOT_SUPPORTED"
                }
                AssetGroupAssetError::HotelPropertyAssetNotLinkedToCampaign => {
                    "HOTEL_PROPERTY_ASSET_NOT_LINKED_TO_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_RESOURCE" => Some(Self::DuplicateResource),
                "EXPANDABLE_TAGS_NOT_ALLOWED_IN_DESCRIPTION" => {
                    Some(Self::ExpandableTagsNotAllowedInDescription)
                }
                "AD_CUSTOMIZER_NOT_SUPPORTED" => Some(Self::AdCustomizerNotSupported),
                "HOTEL_PROPERTY_ASSET_NOT_LINKED_TO_CAMPAIGN" => {
                    Some(Self::HotelPropertyAssetNotLinkedToCampaign)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignFeedErrorEnum {}
/// Nested message and enum types in `CampaignFeedErrorEnum`.
pub mod campaign_feed_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignFeedError {
        Unspecified = 0,
        Unknown = 1,
        FeedAlreadyExistsForPlaceholderType = 2,
        CannotCreateForRemovedFeed = 4,
        CannotCreateAlreadyExistingCampaignFeed = 5,
        CannotModifyRemovedCampaignFeed = 6,
        InvalidPlaceholderType = 7,
        MissingFeedmappingForPlaceholderType = 8,
        NoExistingLocationCustomerFeed = 9,
        LegacyFeedTypeReadOnly = 10,
    }
    impl CampaignFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignFeedError::Unspecified => "UNSPECIFIED",
                CampaignFeedError::Unknown => "UNKNOWN",
                CampaignFeedError::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                CampaignFeedError::CannotCreateForRemovedFeed => {
                    "CANNOT_CREATE_FOR_REMOVED_FEED"
                }
                CampaignFeedError::CannotCreateAlreadyExistingCampaignFeed => {
                    "CANNOT_CREATE_ALREADY_EXISTING_CAMPAIGN_FEED"
                }
                CampaignFeedError::CannotModifyRemovedCampaignFeed => {
                    "CANNOT_MODIFY_REMOVED_CAMPAIGN_FEED"
                }
                CampaignFeedError::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                CampaignFeedError::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                CampaignFeedError::NoExistingLocationCustomerFeed => {
                    "NO_EXISTING_LOCATION_CUSTOMER_FEED"
                }
                CampaignFeedError::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "CANNOT_CREATE_ALREADY_EXISTING_CAMPAIGN_FEED" => {
                    Some(Self::CannotCreateAlreadyExistingCampaignFeed)
                }
                "CANNOT_MODIFY_REMOVED_CAMPAIGN_FEED" => {
                    Some(Self::CannotModifyRemovedCampaignFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "NO_EXISTING_LOCATION_CUSTOMER_FEED" => {
                    Some(Self::NoExistingLocationCustomerFeed)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkErrorEnum {}
/// Nested message and enum types in `AssetLinkErrorEnum`.
pub mod asset_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkError {
        Unspecified = 0,
        Unknown = 1,
        PinningUnsupported = 2,
        UnsupportedFieldType = 3,
        FieldTypeIncompatibleWithAssetType = 4,
        FieldTypeIncompatibleWithCampaignType = 5,
        IncompatibleAdvertisingChannelType = 6,
        ImageNotWithinSpecifiedDimensionRange = 7,
        InvalidPinnedField = 8,
        MediaBundleAssetFileSizeTooLarge = 9,
        NotEnoughAvailableAssetLinksForValidCombination = 10,
        NotEnoughAvailableAssetLinksWithFallback = 11,
        NotEnoughAvailableAssetLinksWithFallbackForValidCombination = 12,
        YoutubeVideoRemoved = 13,
        YoutubeVideoTooLong = 14,
        YoutubeVideoTooShort = 15,
        ExcludedParentFieldType = 16,
        InvalidStatus = 17,
        YoutubeVideoDurationNotDefined = 18,
        CannotCreateAutomaticallyCreatedLinks = 19,
        CannotLinkToAutomaticallyCreatedAsset = 20,
        CannotModifyAssetLinkSource = 21,
        CannotLinkLocationLeadFormWithoutLocationAsset = 22,
        CustomerNotVerified = 23,
        UnsupportedCallToAction = 24,
    }
    impl AssetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetLinkError::Unspecified => "UNSPECIFIED",
                AssetLinkError::Unknown => "UNKNOWN",
                AssetLinkError::PinningUnsupported => "PINNING_UNSUPPORTED",
                AssetLinkError::UnsupportedFieldType => "UNSUPPORTED_FIELD_TYPE",
                AssetLinkError::FieldTypeIncompatibleWithAssetType => {
                    "FIELD_TYPE_INCOMPATIBLE_WITH_ASSET_TYPE"
                }
                AssetLinkError::FieldTypeIncompatibleWithCampaignType => {
                    "FIELD_TYPE_INCOMPATIBLE_WITH_CAMPAIGN_TYPE"
                }
                AssetLinkError::IncompatibleAdvertisingChannelType => {
                    "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE"
                }
                AssetLinkError::ImageNotWithinSpecifiedDimensionRange => {
                    "IMAGE_NOT_WITHIN_SPECIFIED_DIMENSION_RANGE"
                }
                AssetLinkError::InvalidPinnedField => "INVALID_PINNED_FIELD",
                AssetLinkError::MediaBundleAssetFileSizeTooLarge => {
                    "MEDIA_BUNDLE_ASSET_FILE_SIZE_TOO_LARGE"
                }
                AssetLinkError::NotEnoughAvailableAssetLinksForValidCombination => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_FOR_VALID_COMBINATION"
                }
                AssetLinkError::NotEnoughAvailableAssetLinksWithFallback => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK"
                }
                AssetLinkError::NotEnoughAvailableAssetLinksWithFallbackForValidCombination => {
                    "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK_FOR_VALID_COMBINATION"
                }
                AssetLinkError::YoutubeVideoRemoved => "YOUTUBE_VIDEO_REMOVED",
                AssetLinkError::YoutubeVideoTooLong => "YOUTUBE_VIDEO_TOO_LONG",
                AssetLinkError::YoutubeVideoTooShort => "YOUTUBE_VIDEO_TOO_SHORT",
                AssetLinkError::ExcludedParentFieldType => "EXCLUDED_PARENT_FIELD_TYPE",
                AssetLinkError::InvalidStatus => "INVALID_STATUS",
                AssetLinkError::YoutubeVideoDurationNotDefined => {
                    "YOUTUBE_VIDEO_DURATION_NOT_DEFINED"
                }
                AssetLinkError::CannotCreateAutomaticallyCreatedLinks => {
                    "CANNOT_CREATE_AUTOMATICALLY_CREATED_LINKS"
                }
                AssetLinkError::CannotLinkToAutomaticallyCreatedAsset => {
                    "CANNOT_LINK_TO_AUTOMATICALLY_CREATED_ASSET"
                }
                AssetLinkError::CannotModifyAssetLinkSource => {
                    "CANNOT_MODIFY_ASSET_LINK_SOURCE"
                }
                AssetLinkError::CannotLinkLocationLeadFormWithoutLocationAsset => {
                    "CANNOT_LINK_LOCATION_LEAD_FORM_WITHOUT_LOCATION_ASSET"
                }
                AssetLinkError::CustomerNotVerified => "CUSTOMER_NOT_VERIFIED",
                AssetLinkError::UnsupportedCallToAction => "UNSUPPORTED_CALL_TO_ACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PINNING_UNSUPPORTED" => Some(Self::PinningUnsupported),
                "UNSUPPORTED_FIELD_TYPE" => Some(Self::UnsupportedFieldType),
                "FIELD_TYPE_INCOMPATIBLE_WITH_ASSET_TYPE" => {
                    Some(Self::FieldTypeIncompatibleWithAssetType)
                }
                "FIELD_TYPE_INCOMPATIBLE_WITH_CAMPAIGN_TYPE" => {
                    Some(Self::FieldTypeIncompatibleWithCampaignType)
                }
                "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::IncompatibleAdvertisingChannelType)
                }
                "IMAGE_NOT_WITHIN_SPECIFIED_DIMENSION_RANGE" => {
                    Some(Self::ImageNotWithinSpecifiedDimensionRange)
                }
                "INVALID_PINNED_FIELD" => Some(Self::InvalidPinnedField),
                "MEDIA_BUNDLE_ASSET_FILE_SIZE_TOO_LARGE" => {
                    Some(Self::MediaBundleAssetFileSizeTooLarge)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_FOR_VALID_COMBINATION" => {
                    Some(Self::NotEnoughAvailableAssetLinksForValidCombination)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK" => {
                    Some(Self::NotEnoughAvailableAssetLinksWithFallback)
                }
                "NOT_ENOUGH_AVAILABLE_ASSET_LINKS_WITH_FALLBACK_FOR_VALID_COMBINATION" => {
                    Some(
                        Self::NotEnoughAvailableAssetLinksWithFallbackForValidCombination,
                    )
                }
                "YOUTUBE_VIDEO_REMOVED" => Some(Self::YoutubeVideoRemoved),
                "YOUTUBE_VIDEO_TOO_LONG" => Some(Self::YoutubeVideoTooLong),
                "YOUTUBE_VIDEO_TOO_SHORT" => Some(Self::YoutubeVideoTooShort),
                "EXCLUDED_PARENT_FIELD_TYPE" => Some(Self::ExcludedParentFieldType),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "YOUTUBE_VIDEO_DURATION_NOT_DEFINED" => {
                    Some(Self::YoutubeVideoDurationNotDefined)
                }
                "CANNOT_CREATE_AUTOMATICALLY_CREATED_LINKS" => {
                    Some(Self::CannotCreateAutomaticallyCreatedLinks)
                }
                "CANNOT_LINK_TO_AUTOMATICALLY_CREATED_ASSET" => {
                    Some(Self::CannotLinkToAutomaticallyCreatedAsset)
                }
                "CANNOT_MODIFY_ASSET_LINK_SOURCE" => {
                    Some(Self::CannotModifyAssetLinkSource)
                }
                "CANNOT_LINK_LOCATION_LEAD_FORM_WITHOUT_LOCATION_ASSET" => {
                    Some(Self::CannotLinkLocationLeadFormWithoutLocationAsset)
                }
                "CUSTOMER_NOT_VERIFIED" => Some(Self::CustomerNotVerified),
                "UNSUPPORTED_CALL_TO_ACTION" => Some(Self::UnsupportedCallToAction),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupKeywordErrorEnum {}
/// Nested message and enum types in `KeywordPlanAdGroupKeywordErrorEnum`.
pub mod keyword_plan_ad_group_keyword_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAdGroupKeywordError {
        Unspecified = 0,
        Unknown = 1,
        InvalidKeywordMatchType = 2,
        DuplicateKeyword = 3,
        KeywordTextTooLong = 4,
        KeywordHasInvalidChars = 5,
        KeywordHasTooManyWords = 6,
        InvalidKeywordText = 7,
        NegativeKeywordHasCpcBid = 8,
        NewBmmKeywordsNotAllowed = 9,
    }
    impl KeywordPlanAdGroupKeywordError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanAdGroupKeywordError::Unspecified => "UNSPECIFIED",
                KeywordPlanAdGroupKeywordError::Unknown => "UNKNOWN",
                KeywordPlanAdGroupKeywordError::InvalidKeywordMatchType => {
                    "INVALID_KEYWORD_MATCH_TYPE"
                }
                KeywordPlanAdGroupKeywordError::DuplicateKeyword => "DUPLICATE_KEYWORD",
                KeywordPlanAdGroupKeywordError::KeywordTextTooLong => {
                    "KEYWORD_TEXT_TOO_LONG"
                }
                KeywordPlanAdGroupKeywordError::KeywordHasInvalidChars => {
                    "KEYWORD_HAS_INVALID_CHARS"
                }
                KeywordPlanAdGroupKeywordError::KeywordHasTooManyWords => {
                    "KEYWORD_HAS_TOO_MANY_WORDS"
                }
                KeywordPlanAdGroupKeywordError::InvalidKeywordText => {
                    "INVALID_KEYWORD_TEXT"
                }
                KeywordPlanAdGroupKeywordError::NegativeKeywordHasCpcBid => {
                    "NEGATIVE_KEYWORD_HAS_CPC_BID"
                }
                KeywordPlanAdGroupKeywordError::NewBmmKeywordsNotAllowed => {
                    "NEW_BMM_KEYWORDS_NOT_ALLOWED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_KEYWORD_MATCH_TYPE" => Some(Self::InvalidKeywordMatchType),
                "DUPLICATE_KEYWORD" => Some(Self::DuplicateKeyword),
                "KEYWORD_TEXT_TOO_LONG" => Some(Self::KeywordTextTooLong),
                "KEYWORD_HAS_INVALID_CHARS" => Some(Self::KeywordHasInvalidChars),
                "KEYWORD_HAS_TOO_MANY_WORDS" => Some(Self::KeywordHasTooManyWords),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "NEGATIVE_KEYWORD_HAS_CPC_BID" => Some(Self::NegativeKeywordHasCpcBid),
                "NEW_BMM_KEYWORDS_NOT_ALLOWED" => Some(Self::NewBmmKeywordsNotAllowed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignConversionGoalErrorEnum {}
/// Nested message and enum types in `CampaignConversionGoalErrorEnum`.
pub mod campaign_conversion_goal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignConversionGoalError {
        Unspecified = 0,
        Unknown = 1,
        CannotUseCampaignGoalForSearchAds360ManagedCampaign = 2,
        CannotUseStoreSaleGoalForPerformanceMaxCampaign = 3,
    }
    impl CampaignConversionGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignConversionGoalError::Unspecified => "UNSPECIFIED",
                CampaignConversionGoalError::Unknown => "UNKNOWN",
                CampaignConversionGoalError::CannotUseCampaignGoalForSearchAds360ManagedCampaign => {
                    "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN"
                }
                CampaignConversionGoalError::CannotUseStoreSaleGoalForPerformanceMaxCampaign => {
                    "CANNOT_USE_STORE_SALE_GOAL_FOR_PERFORMANCE_MAX_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN" => {
                    Some(Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign)
                }
                "CANNOT_USE_STORE_SALE_GOAL_FOR_PERFORMANCE_MAX_CAMPAIGN" => {
                    Some(Self::CannotUseStoreSaleGoalForPerformanceMaxCampaign)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemErrorEnum {}
/// Nested message and enum types in `FeedItemErrorEnum`.
pub mod feed_item_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemError {
        Unspecified = 0,
        Unknown = 1,
        CannotConvertAttributeValueFromString = 2,
        CannotOperateOnRemovedFeedItem = 3,
        DateTimeMustBeInAccountTimeZone = 4,
        KeyAttributesNotFound = 5,
        InvalidUrl = 6,
        MissingKeyAttributes = 7,
        KeyAttributesNotUnique = 8,
        CannotModifyKeyAttributeValue = 9,
        SizeTooLargeForMultiValueAttribute = 10,
        LegacyFeedTypeReadOnly = 11,
    }
    impl FeedItemError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemError::Unspecified => "UNSPECIFIED",
                FeedItemError::Unknown => "UNKNOWN",
                FeedItemError::CannotConvertAttributeValueFromString => {
                    "CANNOT_CONVERT_ATTRIBUTE_VALUE_FROM_STRING"
                }
                FeedItemError::CannotOperateOnRemovedFeedItem => {
                    "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM"
                }
                FeedItemError::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                FeedItemError::KeyAttributesNotFound => "KEY_ATTRIBUTES_NOT_FOUND",
                FeedItemError::InvalidUrl => "INVALID_URL",
                FeedItemError::MissingKeyAttributes => "MISSING_KEY_ATTRIBUTES",
                FeedItemError::KeyAttributesNotUnique => "KEY_ATTRIBUTES_NOT_UNIQUE",
                FeedItemError::CannotModifyKeyAttributeValue => {
                    "CANNOT_MODIFY_KEY_ATTRIBUTE_VALUE"
                }
                FeedItemError::SizeTooLargeForMultiValueAttribute => {
                    "SIZE_TOO_LARGE_FOR_MULTI_VALUE_ATTRIBUTE"
                }
                FeedItemError::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_CONVERT_ATTRIBUTE_VALUE_FROM_STRING" => {
                    Some(Self::CannotConvertAttributeValueFromString)
                }
                "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM" => {
                    Some(Self::CannotOperateOnRemovedFeedItem)
                }
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "KEY_ATTRIBUTES_NOT_FOUND" => Some(Self::KeyAttributesNotFound),
                "INVALID_URL" => Some(Self::InvalidUrl),
                "MISSING_KEY_ATTRIBUTES" => Some(Self::MissingKeyAttributes),
                "KEY_ATTRIBUTES_NOT_UNIQUE" => Some(Self::KeyAttributesNotUnique),
                "CANNOT_MODIFY_KEY_ATTRIBUTE_VALUE" => {
                    Some(Self::CannotModifyKeyAttributeValue)
                }
                "SIZE_TOO_LARGE_FOR_MULTI_VALUE_ATTRIBUTE" => {
                    Some(Self::SizeTooLargeForMultiValueAttribute)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionErrorEnum {}
/// Nested message and enum types in `ConversionActionErrorEnum`.
pub mod conversion_action_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateName = 2,
        DuplicateAppId = 3,
        TwoConversionActionsBiddingOnSameAppDownload = 4,
        BiddingOnSameAppDownloadAsGlobalAction = 5,
        DataDrivenModelWasNeverGenerated = 6,
        DataDrivenModelExpired = 7,
        DataDrivenModelStale = 8,
        DataDrivenModelUnknown = 9,
        CreationNotSupported = 10,
        UpdateNotSupported = 11,
        CannotSetRuleBasedAttributionModels = 12,
    }
    impl ConversionActionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionError::Unspecified => "UNSPECIFIED",
                ConversionActionError::Unknown => "UNKNOWN",
                ConversionActionError::DuplicateName => "DUPLICATE_NAME",
                ConversionActionError::DuplicateAppId => "DUPLICATE_APP_ID",
                ConversionActionError::TwoConversionActionsBiddingOnSameAppDownload => {
                    "TWO_CONVERSION_ACTIONS_BIDDING_ON_SAME_APP_DOWNLOAD"
                }
                ConversionActionError::BiddingOnSameAppDownloadAsGlobalAction => {
                    "BIDDING_ON_SAME_APP_DOWNLOAD_AS_GLOBAL_ACTION"
                }
                ConversionActionError::DataDrivenModelWasNeverGenerated => {
                    "DATA_DRIVEN_MODEL_WAS_NEVER_GENERATED"
                }
                ConversionActionError::DataDrivenModelExpired => {
                    "DATA_DRIVEN_MODEL_EXPIRED"
                }
                ConversionActionError::DataDrivenModelStale => "DATA_DRIVEN_MODEL_STALE",
                ConversionActionError::DataDrivenModelUnknown => {
                    "DATA_DRIVEN_MODEL_UNKNOWN"
                }
                ConversionActionError::CreationNotSupported => "CREATION_NOT_SUPPORTED",
                ConversionActionError::UpdateNotSupported => "UPDATE_NOT_SUPPORTED",
                ConversionActionError::CannotSetRuleBasedAttributionModels => {
                    "CANNOT_SET_RULE_BASED_ATTRIBUTION_MODELS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "DUPLICATE_APP_ID" => Some(Self::DuplicateAppId),
                "TWO_CONVERSION_ACTIONS_BIDDING_ON_SAME_APP_DOWNLOAD" => {
                    Some(Self::TwoConversionActionsBiddingOnSameAppDownload)
                }
                "BIDDING_ON_SAME_APP_DOWNLOAD_AS_GLOBAL_ACTION" => {
                    Some(Self::BiddingOnSameAppDownloadAsGlobalAction)
                }
                "DATA_DRIVEN_MODEL_WAS_NEVER_GENERATED" => {
                    Some(Self::DataDrivenModelWasNeverGenerated)
                }
                "DATA_DRIVEN_MODEL_EXPIRED" => Some(Self::DataDrivenModelExpired),
                "DATA_DRIVEN_MODEL_STALE" => Some(Self::DataDrivenModelStale),
                "DATA_DRIVEN_MODEL_UNKNOWN" => Some(Self::DataDrivenModelUnknown),
                "CREATION_NOT_SUPPORTED" => Some(Self::CreationNotSupported),
                "UPDATE_NOT_SUPPORTED" => Some(Self::UpdateNotSupported),
                "CANNOT_SET_RULE_BASED_ATTRIBUTION_MODELS" => {
                    Some(Self::CannotSetRuleBasedAttributionModels)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignExperimentErrorEnum {}
/// Nested message and enum types in `CampaignExperimentErrorEnum`.
pub mod campaign_experiment_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignExperimentError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateName = 2,
        InvalidTransition = 3,
        CannotCreateExperimentWithSharedBudget = 4,
        CannotCreateExperimentForRemovedBaseCampaign = 5,
        CannotCreateExperimentForNonProposedDraft = 6,
        CustomerCannotCreateExperiment = 7,
        CampaignCannotCreateExperiment = 8,
        ExperimentDurationsMustNotOverlap = 9,
        ExperimentDurationMustBeWithinCampaignDuration = 10,
        CannotMutateExperimentDueToStatus = 11,
    }
    impl CampaignExperimentError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignExperimentError::Unspecified => "UNSPECIFIED",
                CampaignExperimentError::Unknown => "UNKNOWN",
                CampaignExperimentError::DuplicateName => "DUPLICATE_NAME",
                CampaignExperimentError::InvalidTransition => "INVALID_TRANSITION",
                CampaignExperimentError::CannotCreateExperimentWithSharedBudget => {
                    "CANNOT_CREATE_EXPERIMENT_WITH_SHARED_BUDGET"
                }
                CampaignExperimentError::CannotCreateExperimentForRemovedBaseCampaign => {
                    "CANNOT_CREATE_EXPERIMENT_FOR_REMOVED_BASE_CAMPAIGN"
                }
                CampaignExperimentError::CannotCreateExperimentForNonProposedDraft => {
                    "CANNOT_CREATE_EXPERIMENT_FOR_NON_PROPOSED_DRAFT"
                }
                CampaignExperimentError::CustomerCannotCreateExperiment => {
                    "CUSTOMER_CANNOT_CREATE_EXPERIMENT"
                }
                CampaignExperimentError::CampaignCannotCreateExperiment => {
                    "CAMPAIGN_CANNOT_CREATE_EXPERIMENT"
                }
                CampaignExperimentError::ExperimentDurationsMustNotOverlap => {
                    "EXPERIMENT_DURATIONS_MUST_NOT_OVERLAP"
                }
                CampaignExperimentError::ExperimentDurationMustBeWithinCampaignDuration => {
                    "EXPERIMENT_DURATION_MUST_BE_WITHIN_CAMPAIGN_DURATION"
                }
                CampaignExperimentError::CannotMutateExperimentDueToStatus => {
                    "CANNOT_MUTATE_EXPERIMENT_DUE_TO_STATUS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "INVALID_TRANSITION" => Some(Self::InvalidTransition),
                "CANNOT_CREATE_EXPERIMENT_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotCreateExperimentWithSharedBudget)
                }
                "CANNOT_CREATE_EXPERIMENT_FOR_REMOVED_BASE_CAMPAIGN" => {
                    Some(Self::CannotCreateExperimentForRemovedBaseCampaign)
                }
                "CANNOT_CREATE_EXPERIMENT_FOR_NON_PROPOSED_DRAFT" => {
                    Some(Self::CannotCreateExperimentForNonProposedDraft)
                }
                "CUSTOMER_CANNOT_CREATE_EXPERIMENT" => {
                    Some(Self::CustomerCannotCreateExperiment)
                }
                "CAMPAIGN_CANNOT_CREATE_EXPERIMENT" => {
                    Some(Self::CampaignCannotCreateExperiment)
                }
                "EXPERIMENT_DURATIONS_MUST_NOT_OVERLAP" => {
                    Some(Self::ExperimentDurationsMustNotOverlap)
                }
                "EXPERIMENT_DURATION_MUST_BE_WITHIN_CAMPAIGN_DURATION" => {
                    Some(Self::ExperimentDurationMustBeWithinCampaignDuration)
                }
                "CANNOT_MUTATE_EXPERIMENT_DUE_TO_STATUS" => {
                    Some(Self::CannotMutateExperimentDueToStatus)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaFileErrorEnum {}
/// Nested message and enum types in `MediaFileErrorEnum`.
pub mod media_file_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaFileError {
        Unspecified = 0,
        Unknown = 1,
        CannotCreateStandardIcon = 2,
        CannotSelectStandardIconWithOtherTypes = 3,
        CannotSpecifyMediaFileIdAndData = 4,
        DuplicateMedia = 5,
        EmptyField = 6,
        ResourceReferencedInMultipleOps = 7,
        FieldNotSupportedForMediaSubType = 8,
        InvalidMediaFileId = 9,
        InvalidMediaSubType = 10,
        InvalidMediaFileType = 11,
        InvalidMimeType = 12,
        InvalidReferenceId = 13,
        InvalidYouTubeId = 14,
        MediaFileFailedTranscoding = 15,
        MediaNotTranscoded = 16,
        MediaTypeDoesNotMatchMediaFileType = 17,
        NoFieldsSpecified = 18,
        NullReferenceIdAndMediaId = 19,
        TooLong = 20,
        UnsupportedType = 21,
        YouTubeServiceUnavailable = 22,
        YouTubeVideoHasNonPositiveDuration = 23,
        YouTubeVideoNotFound = 24,
    }
    impl MediaFileError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaFileError::Unspecified => "UNSPECIFIED",
                MediaFileError::Unknown => "UNKNOWN",
                MediaFileError::CannotCreateStandardIcon => "CANNOT_CREATE_STANDARD_ICON",
                MediaFileError::CannotSelectStandardIconWithOtherTypes => {
                    "CANNOT_SELECT_STANDARD_ICON_WITH_OTHER_TYPES"
                }
                MediaFileError::CannotSpecifyMediaFileIdAndData => {
                    "CANNOT_SPECIFY_MEDIA_FILE_ID_AND_DATA"
                }
                MediaFileError::DuplicateMedia => "DUPLICATE_MEDIA",
                MediaFileError::EmptyField => "EMPTY_FIELD",
                MediaFileError::ResourceReferencedInMultipleOps => {
                    "RESOURCE_REFERENCED_IN_MULTIPLE_OPS"
                }
                MediaFileError::FieldNotSupportedForMediaSubType => {
                    "FIELD_NOT_SUPPORTED_FOR_MEDIA_SUB_TYPE"
                }
                MediaFileError::InvalidMediaFileId => "INVALID_MEDIA_FILE_ID",
                MediaFileError::InvalidMediaSubType => "INVALID_MEDIA_SUB_TYPE",
                MediaFileError::InvalidMediaFileType => "INVALID_MEDIA_FILE_TYPE",
                MediaFileError::InvalidMimeType => "INVALID_MIME_TYPE",
                MediaFileError::InvalidReferenceId => "INVALID_REFERENCE_ID",
                MediaFileError::InvalidYouTubeId => "INVALID_YOU_TUBE_ID",
                MediaFileError::MediaFileFailedTranscoding => {
                    "MEDIA_FILE_FAILED_TRANSCODING"
                }
                MediaFileError::MediaNotTranscoded => "MEDIA_NOT_TRANSCODED",
                MediaFileError::MediaTypeDoesNotMatchMediaFileType => {
                    "MEDIA_TYPE_DOES_NOT_MATCH_MEDIA_FILE_TYPE"
                }
                MediaFileError::NoFieldsSpecified => "NO_FIELDS_SPECIFIED",
                MediaFileError::NullReferenceIdAndMediaId => {
                    "NULL_REFERENCE_ID_AND_MEDIA_ID"
                }
                MediaFileError::TooLong => "TOO_LONG",
                MediaFileError::UnsupportedType => "UNSUPPORTED_TYPE",
                MediaFileError::YouTubeServiceUnavailable => {
                    "YOU_TUBE_SERVICE_UNAVAILABLE"
                }
                MediaFileError::YouTubeVideoHasNonPositiveDuration => {
                    "YOU_TUBE_VIDEO_HAS_NON_POSITIVE_DURATION"
                }
                MediaFileError::YouTubeVideoNotFound => "YOU_TUBE_VIDEO_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_CREATE_STANDARD_ICON" => Some(Self::CannotCreateStandardIcon),
                "CANNOT_SELECT_STANDARD_ICON_WITH_OTHER_TYPES" => {
                    Some(Self::CannotSelectStandardIconWithOtherTypes)
                }
                "CANNOT_SPECIFY_MEDIA_FILE_ID_AND_DATA" => {
                    Some(Self::CannotSpecifyMediaFileIdAndData)
                }
                "DUPLICATE_MEDIA" => Some(Self::DuplicateMedia),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "RESOURCE_REFERENCED_IN_MULTIPLE_OPS" => {
                    Some(Self::ResourceReferencedInMultipleOps)
                }
                "FIELD_NOT_SUPPORTED_FOR_MEDIA_SUB_TYPE" => {
                    Some(Self::FieldNotSupportedForMediaSubType)
                }
                "INVALID_MEDIA_FILE_ID" => Some(Self::InvalidMediaFileId),
                "INVALID_MEDIA_SUB_TYPE" => Some(Self::InvalidMediaSubType),
                "INVALID_MEDIA_FILE_TYPE" => Some(Self::InvalidMediaFileType),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_REFERENCE_ID" => Some(Self::InvalidReferenceId),
                "INVALID_YOU_TUBE_ID" => Some(Self::InvalidYouTubeId),
                "MEDIA_FILE_FAILED_TRANSCODING" => Some(Self::MediaFileFailedTranscoding),
                "MEDIA_NOT_TRANSCODED" => Some(Self::MediaNotTranscoded),
                "MEDIA_TYPE_DOES_NOT_MATCH_MEDIA_FILE_TYPE" => {
                    Some(Self::MediaTypeDoesNotMatchMediaFileType)
                }
                "NO_FIELDS_SPECIFIED" => Some(Self::NoFieldsSpecified),
                "NULL_REFERENCE_ID_AND_MEDIA_ID" => Some(Self::NullReferenceIdAndMediaId),
                "TOO_LONG" => Some(Self::TooLong),
                "UNSUPPORTED_TYPE" => Some(Self::UnsupportedType),
                "YOU_TUBE_SERVICE_UNAVAILABLE" => Some(Self::YouTubeServiceUnavailable),
                "YOU_TUBE_VIDEO_HAS_NON_POSITIVE_DURATION" => {
                    Some(Self::YouTubeVideoHasNonPositiveDuration)
                }
                "YOU_TUBE_VIDEO_NOT_FOUND" => Some(Self::YouTubeVideoNotFound),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetErrorEnum {}
/// Nested message and enum types in `SharedSetErrorEnum`.
pub mod shared_set_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetError {
        Unspecified = 0,
        Unknown = 1,
        CustomerCannotCreateSharedSetOfThisType = 2,
        DuplicateName = 3,
        SharedSetRemoved = 4,
        SharedSetInUse = 5,
    }
    impl SharedSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SharedSetError::Unspecified => "UNSPECIFIED",
                SharedSetError::Unknown => "UNKNOWN",
                SharedSetError::CustomerCannotCreateSharedSetOfThisType => {
                    "CUSTOMER_CANNOT_CREATE_SHARED_SET_OF_THIS_TYPE"
                }
                SharedSetError::DuplicateName => "DUPLICATE_NAME",
                SharedSetError::SharedSetRemoved => "SHARED_SET_REMOVED",
                SharedSetError::SharedSetInUse => "SHARED_SET_IN_USE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_CANNOT_CREATE_SHARED_SET_OF_THIS_TYPE" => {
                    Some(Self::CustomerCannotCreateSharedSetOfThisType)
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "SHARED_SET_REMOVED" => Some(Self::SharedSetRemoved),
                "SHARED_SET_IN_USE" => Some(Self::SharedSetInUse),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdErrorEnum {}
/// Nested message and enum types in `AdErrorEnum`.
pub mod ad_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdError {
        Unspecified = 0,
        Unknown = 1,
        AdCustomizersNotSupportedForAdType = 2,
        ApproximatelyTooLong = 3,
        ApproximatelyTooShort = 4,
        BadSnippet = 5,
        CannotModifyAd = 6,
        CannotSetBusinessNameIfUrlSet = 7,
        CannotSetField = 8,
        CannotSetFieldWithOriginAdIdSet = 9,
        CannotSetFieldWithAdIdSetForSharing = 10,
        CannotSetAllowFlexibleColorFalse = 11,
        CannotSetColorControlWhenNativeFormatSetting = 12,
        CannotSetUrl = 13,
        CannotSetWithoutFinalUrls = 14,
        CannotSetWithFinalUrls = 15,
        CannotSetWithUrlData = 17,
        CannotUseAdSubclassForOperator = 18,
        CustomerNotApprovedMobileads = 19,
        CustomerNotApprovedThirdpartyAds = 20,
        CustomerNotApprovedThirdpartyRedirectAds = 21,
        CustomerNotEligible = 22,
        CustomerNotEligibleForUpdatingBeaconUrl = 23,
        DimensionAlreadyInUnion = 24,
        DimensionMustBeSet = 25,
        DimensionNotInUnion = 26,
        DisplayUrlCannotBeSpecified = 27,
        DomesticPhoneNumberFormat = 28,
        EmergencyPhoneNumber = 29,
        EmptyField = 30,
        FeedAttributeMustHaveMappingForTypeId = 31,
        FeedAttributeMappingTypeMismatch = 32,
        IllegalAdCustomizerTagUse = 33,
        IllegalTagUse = 34,
        InconsistentDimensions = 35,
        InconsistentStatusInTemplateUnion = 36,
        IncorrectLength = 37,
        IneligibleForUpgrade = 38,
        InvalidAdAddressCampaignTarget = 39,
        InvalidAdType = 40,
        InvalidAttributesForMobileImage = 41,
        InvalidAttributesForMobileText = 42,
        InvalidCallToActionText = 43,
        InvalidCharacterForUrl = 44,
        InvalidCountryCode = 45,
        InvalidExpandedDynamicSearchAdTag = 47,
        InvalidInput = 48,
        InvalidMarkupLanguage = 49,
        InvalidMobileCarrier = 50,
        InvalidMobileCarrierTarget = 51,
        InvalidNumberOfElements = 52,
        InvalidPhoneNumberFormat = 53,
        InvalidRichMediaCertifiedVendorFormatId = 54,
        InvalidTemplateData = 55,
        InvalidTemplateElementFieldType = 56,
        InvalidTemplateId = 57,
        LineTooWide = 58,
        MissingAdCustomizerMapping = 59,
        MissingAddressComponent = 60,
        MissingAdvertisementName = 61,
        MissingBusinessName = 62,
        MissingDescription1 = 63,
        MissingDescription2 = 64,
        MissingDestinationUrlTag = 65,
        MissingLandingPageUrlTag = 66,
        MissingDimension = 67,
        MissingDisplayUrl = 68,
        MissingHeadline = 69,
        MissingHeight = 70,
        MissingImage = 71,
        MissingMarketingImageOrProductVideos = 72,
        MissingMarkupLanguages = 73,
        MissingMobileCarrier = 74,
        MissingPhone = 75,
        MissingRequiredTemplateFields = 76,
        MissingTemplateFieldValue = 77,
        MissingText = 78,
        MissingVisibleUrl = 79,
        MissingWidth = 80,
        MultipleDistinctFeedsUnsupported = 81,
        MustUseTempAdUnionIdOnAdd = 82,
        TooLong = 83,
        TooShort = 84,
        UnionDimensionsCannotChange = 85,
        UnknownAddressComponent = 86,
        UnknownFieldName = 87,
        UnknownUniqueName = 88,
        UnsupportedDimensions = 89,
        UrlInvalidScheme = 90,
        UrlInvalidTopLevelDomain = 91,
        UrlMalformed = 92,
        UrlNoHost = 93,
        UrlNotEquivalent = 94,
        UrlHostNameTooLong = 95,
        UrlNoScheme = 96,
        UrlNoTopLevelDomain = 97,
        UrlPathNotAllowed = 98,
        UrlPortNotAllowed = 99,
        UrlQueryNotAllowed = 100,
        UrlSchemeBeforeExpandedDynamicSearchAdTag = 102,
        UserDoesNotHaveAccessToTemplate = 103,
        InconsistentExpandableSettings = 104,
        InvalidFormat = 105,
        InvalidFieldText = 106,
        ElementNotPresent = 107,
        ImageError = 108,
        ValueNotInRange = 109,
        FieldNotPresent = 110,
        AddressNotComplete = 111,
        AddressInvalid = 112,
        VideoRetrievalError = 113,
        AudioError = 114,
        InvalidYoutubeDisplayUrl = 115,
        TooManyProductImages = 116,
        TooManyProductVideos = 117,
        IncompatibleAdTypeAndDevicePreference = 118,
        CalltrackingNotSupportedForCountry = 119,
        CarrierSpecificShortNumberNotAllowed = 120,
        DisallowedNumberType = 121,
        PhoneNumberNotSupportedForCountry = 122,
        PhoneNumberNotSupportedWithCalltrackingForCountry = 123,
        PremiumRateNumberNotAllowed = 124,
        VanityPhoneNumberNotAllowed = 125,
        InvalidCallConversionTypeId = 126,
        CannotDisableCallConversionAndSetConversionTypeId = 127,
        CannotSetPath2WithoutPath1 = 128,
        MissingDynamicSearchAdsSettingDomainName = 129,
        IncompatibleWithRestrictionType = 130,
        CustomerConsentForCallRecordingRequired = 131,
        MissingImageOrMediaBundle = 132,
        ProductTypeNotSupportedInThisCampaign = 133,
        PlaceholderCannotHaveEmptyDefaultValue = 134,
        PlaceholderCountdownFunctionCannotHaveDefaultValue = 135,
        PlaceholderDefaultValueMissing = 136,
        UnexpectedPlaceholderDefaultValue = 137,
        AdCustomizersMayNotBeAdjacent = 138,
        UpdatingAdWithNoEnabledAssociation = 139,
        CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain = 140,
        CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty = 154,
        TooManyAdCustomizers = 141,
        InvalidAdCustomizerFormat = 142,
        NestedAdCustomizerSyntax = 143,
        UnsupportedAdCustomizerSyntax = 144,
        UnpairedBraceInAdCustomizerTag = 145,
        MoreThanOneCountdownTagTypeExists = 146,
        DateTimeInCountdownTagIsInvalid = 147,
        DateTimeInCountdownTagIsPast = 148,
        UnrecognizedAdCustomizerTagFound = 149,
        CustomizerTypeForbiddenForField = 150,
        InvalidCustomizerAttributeName = 151,
        StoreMismatch = 152,
        MissingRequiredImageAspectRatio = 153,
        MismatchedAspectRatios = 155,
        DuplicateImageAcrossCarouselCards = 156,
    }
    impl AdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdError::Unspecified => "UNSPECIFIED",
                AdError::Unknown => "UNKNOWN",
                AdError::AdCustomizersNotSupportedForAdType => {
                    "AD_CUSTOMIZERS_NOT_SUPPORTED_FOR_AD_TYPE"
                }
                AdError::ApproximatelyTooLong => "APPROXIMATELY_TOO_LONG",
                AdError::ApproximatelyTooShort => "APPROXIMATELY_TOO_SHORT",
                AdError::BadSnippet => "BAD_SNIPPET",
                AdError::CannotModifyAd => "CANNOT_MODIFY_AD",
                AdError::CannotSetBusinessNameIfUrlSet => {
                    "CANNOT_SET_BUSINESS_NAME_IF_URL_SET"
                }
                AdError::CannotSetField => "CANNOT_SET_FIELD",
                AdError::CannotSetFieldWithOriginAdIdSet => {
                    "CANNOT_SET_FIELD_WITH_ORIGIN_AD_ID_SET"
                }
                AdError::CannotSetFieldWithAdIdSetForSharing => {
                    "CANNOT_SET_FIELD_WITH_AD_ID_SET_FOR_SHARING"
                }
                AdError::CannotSetAllowFlexibleColorFalse => {
                    "CANNOT_SET_ALLOW_FLEXIBLE_COLOR_FALSE"
                }
                AdError::CannotSetColorControlWhenNativeFormatSetting => {
                    "CANNOT_SET_COLOR_CONTROL_WHEN_NATIVE_FORMAT_SETTING"
                }
                AdError::CannotSetUrl => "CANNOT_SET_URL",
                AdError::CannotSetWithoutFinalUrls => "CANNOT_SET_WITHOUT_FINAL_URLS",
                AdError::CannotSetWithFinalUrls => "CANNOT_SET_WITH_FINAL_URLS",
                AdError::CannotSetWithUrlData => "CANNOT_SET_WITH_URL_DATA",
                AdError::CannotUseAdSubclassForOperator => {
                    "CANNOT_USE_AD_SUBCLASS_FOR_OPERATOR"
                }
                AdError::CustomerNotApprovedMobileads => {
                    "CUSTOMER_NOT_APPROVED_MOBILEADS"
                }
                AdError::CustomerNotApprovedThirdpartyAds => {
                    "CUSTOMER_NOT_APPROVED_THIRDPARTY_ADS"
                }
                AdError::CustomerNotApprovedThirdpartyRedirectAds => {
                    "CUSTOMER_NOT_APPROVED_THIRDPARTY_REDIRECT_ADS"
                }
                AdError::CustomerNotEligible => "CUSTOMER_NOT_ELIGIBLE",
                AdError::CustomerNotEligibleForUpdatingBeaconUrl => {
                    "CUSTOMER_NOT_ELIGIBLE_FOR_UPDATING_BEACON_URL"
                }
                AdError::DimensionAlreadyInUnion => "DIMENSION_ALREADY_IN_UNION",
                AdError::DimensionMustBeSet => "DIMENSION_MUST_BE_SET",
                AdError::DimensionNotInUnion => "DIMENSION_NOT_IN_UNION",
                AdError::DisplayUrlCannotBeSpecified => "DISPLAY_URL_CANNOT_BE_SPECIFIED",
                AdError::DomesticPhoneNumberFormat => "DOMESTIC_PHONE_NUMBER_FORMAT",
                AdError::EmergencyPhoneNumber => "EMERGENCY_PHONE_NUMBER",
                AdError::EmptyField => "EMPTY_FIELD",
                AdError::FeedAttributeMustHaveMappingForTypeId => {
                    "FEED_ATTRIBUTE_MUST_HAVE_MAPPING_FOR_TYPE_ID"
                }
                AdError::FeedAttributeMappingTypeMismatch => {
                    "FEED_ATTRIBUTE_MAPPING_TYPE_MISMATCH"
                }
                AdError::IllegalAdCustomizerTagUse => "ILLEGAL_AD_CUSTOMIZER_TAG_USE",
                AdError::IllegalTagUse => "ILLEGAL_TAG_USE",
                AdError::InconsistentDimensions => "INCONSISTENT_DIMENSIONS",
                AdError::InconsistentStatusInTemplateUnion => {
                    "INCONSISTENT_STATUS_IN_TEMPLATE_UNION"
                }
                AdError::IncorrectLength => "INCORRECT_LENGTH",
                AdError::IneligibleForUpgrade => "INELIGIBLE_FOR_UPGRADE",
                AdError::InvalidAdAddressCampaignTarget => {
                    "INVALID_AD_ADDRESS_CAMPAIGN_TARGET"
                }
                AdError::InvalidAdType => "INVALID_AD_TYPE",
                AdError::InvalidAttributesForMobileImage => {
                    "INVALID_ATTRIBUTES_FOR_MOBILE_IMAGE"
                }
                AdError::InvalidAttributesForMobileText => {
                    "INVALID_ATTRIBUTES_FOR_MOBILE_TEXT"
                }
                AdError::InvalidCallToActionText => "INVALID_CALL_TO_ACTION_TEXT",
                AdError::InvalidCharacterForUrl => "INVALID_CHARACTER_FOR_URL",
                AdError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                AdError::InvalidExpandedDynamicSearchAdTag => {
                    "INVALID_EXPANDED_DYNAMIC_SEARCH_AD_TAG"
                }
                AdError::InvalidInput => "INVALID_INPUT",
                AdError::InvalidMarkupLanguage => "INVALID_MARKUP_LANGUAGE",
                AdError::InvalidMobileCarrier => "INVALID_MOBILE_CARRIER",
                AdError::InvalidMobileCarrierTarget => "INVALID_MOBILE_CARRIER_TARGET",
                AdError::InvalidNumberOfElements => "INVALID_NUMBER_OF_ELEMENTS",
                AdError::InvalidPhoneNumberFormat => "INVALID_PHONE_NUMBER_FORMAT",
                AdError::InvalidRichMediaCertifiedVendorFormatId => {
                    "INVALID_RICH_MEDIA_CERTIFIED_VENDOR_FORMAT_ID"
                }
                AdError::InvalidTemplateData => "INVALID_TEMPLATE_DATA",
                AdError::InvalidTemplateElementFieldType => {
                    "INVALID_TEMPLATE_ELEMENT_FIELD_TYPE"
                }
                AdError::InvalidTemplateId => "INVALID_TEMPLATE_ID",
                AdError::LineTooWide => "LINE_TOO_WIDE",
                AdError::MissingAdCustomizerMapping => "MISSING_AD_CUSTOMIZER_MAPPING",
                AdError::MissingAddressComponent => "MISSING_ADDRESS_COMPONENT",
                AdError::MissingAdvertisementName => "MISSING_ADVERTISEMENT_NAME",
                AdError::MissingBusinessName => "MISSING_BUSINESS_NAME",
                AdError::MissingDescription1 => "MISSING_DESCRIPTION1",
                AdError::MissingDescription2 => "MISSING_DESCRIPTION2",
                AdError::MissingDestinationUrlTag => "MISSING_DESTINATION_URL_TAG",
                AdError::MissingLandingPageUrlTag => "MISSING_LANDING_PAGE_URL_TAG",
                AdError::MissingDimension => "MISSING_DIMENSION",
                AdError::MissingDisplayUrl => "MISSING_DISPLAY_URL",
                AdError::MissingHeadline => "MISSING_HEADLINE",
                AdError::MissingHeight => "MISSING_HEIGHT",
                AdError::MissingImage => "MISSING_IMAGE",
                AdError::MissingMarketingImageOrProductVideos => {
                    "MISSING_MARKETING_IMAGE_OR_PRODUCT_VIDEOS"
                }
                AdError::MissingMarkupLanguages => "MISSING_MARKUP_LANGUAGES",
                AdError::MissingMobileCarrier => "MISSING_MOBILE_CARRIER",
                AdError::MissingPhone => "MISSING_PHONE",
                AdError::MissingRequiredTemplateFields => {
                    "MISSING_REQUIRED_TEMPLATE_FIELDS"
                }
                AdError::MissingTemplateFieldValue => "MISSING_TEMPLATE_FIELD_VALUE",
                AdError::MissingText => "MISSING_TEXT",
                AdError::MissingVisibleUrl => "MISSING_VISIBLE_URL",
                AdError::MissingWidth => "MISSING_WIDTH",
                AdError::MultipleDistinctFeedsUnsupported => {
                    "MULTIPLE_DISTINCT_FEEDS_UNSUPPORTED"
                }
                AdError::MustUseTempAdUnionIdOnAdd => "MUST_USE_TEMP_AD_UNION_ID_ON_ADD",
                AdError::TooLong => "TOO_LONG",
                AdError::TooShort => "TOO_SHORT",
                AdError::UnionDimensionsCannotChange => "UNION_DIMENSIONS_CANNOT_CHANGE",
                AdError::UnknownAddressComponent => "UNKNOWN_ADDRESS_COMPONENT",
                AdError::UnknownFieldName => "UNKNOWN_FIELD_NAME",
                AdError::UnknownUniqueName => "UNKNOWN_UNIQUE_NAME",
                AdError::UnsupportedDimensions => "UNSUPPORTED_DIMENSIONS",
                AdError::UrlInvalidScheme => "URL_INVALID_SCHEME",
                AdError::UrlInvalidTopLevelDomain => "URL_INVALID_TOP_LEVEL_DOMAIN",
                AdError::UrlMalformed => "URL_MALFORMED",
                AdError::UrlNoHost => "URL_NO_HOST",
                AdError::UrlNotEquivalent => "URL_NOT_EQUIVALENT",
                AdError::UrlHostNameTooLong => "URL_HOST_NAME_TOO_LONG",
                AdError::UrlNoScheme => "URL_NO_SCHEME",
                AdError::UrlNoTopLevelDomain => "URL_NO_TOP_LEVEL_DOMAIN",
                AdError::UrlPathNotAllowed => "URL_PATH_NOT_ALLOWED",
                AdError::UrlPortNotAllowed => "URL_PORT_NOT_ALLOWED",
                AdError::UrlQueryNotAllowed => "URL_QUERY_NOT_ALLOWED",
                AdError::UrlSchemeBeforeExpandedDynamicSearchAdTag => {
                    "URL_SCHEME_BEFORE_EXPANDED_DYNAMIC_SEARCH_AD_TAG"
                }
                AdError::UserDoesNotHaveAccessToTemplate => {
                    "USER_DOES_NOT_HAVE_ACCESS_TO_TEMPLATE"
                }
                AdError::InconsistentExpandableSettings => {
                    "INCONSISTENT_EXPANDABLE_SETTINGS"
                }
                AdError::InvalidFormat => "INVALID_FORMAT",
                AdError::InvalidFieldText => "INVALID_FIELD_TEXT",
                AdError::ElementNotPresent => "ELEMENT_NOT_PRESENT",
                AdError::ImageError => "IMAGE_ERROR",
                AdError::ValueNotInRange => "VALUE_NOT_IN_RANGE",
                AdError::FieldNotPresent => "FIELD_NOT_PRESENT",
                AdError::AddressNotComplete => "ADDRESS_NOT_COMPLETE",
                AdError::AddressInvalid => "ADDRESS_INVALID",
                AdError::VideoRetrievalError => "VIDEO_RETRIEVAL_ERROR",
                AdError::AudioError => "AUDIO_ERROR",
                AdError::InvalidYoutubeDisplayUrl => "INVALID_YOUTUBE_DISPLAY_URL",
                AdError::TooManyProductImages => "TOO_MANY_PRODUCT_IMAGES",
                AdError::TooManyProductVideos => "TOO_MANY_PRODUCT_VIDEOS",
                AdError::IncompatibleAdTypeAndDevicePreference => {
                    "INCOMPATIBLE_AD_TYPE_AND_DEVICE_PREFERENCE"
                }
                AdError::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                AdError::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                AdError::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                AdError::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                AdError::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                AdError::PremiumRateNumberNotAllowed => "PREMIUM_RATE_NUMBER_NOT_ALLOWED",
                AdError::VanityPhoneNumberNotAllowed => "VANITY_PHONE_NUMBER_NOT_ALLOWED",
                AdError::InvalidCallConversionTypeId => "INVALID_CALL_CONVERSION_TYPE_ID",
                AdError::CannotDisableCallConversionAndSetConversionTypeId => {
                    "CANNOT_DISABLE_CALL_CONVERSION_AND_SET_CONVERSION_TYPE_ID"
                }
                AdError::CannotSetPath2WithoutPath1 => "CANNOT_SET_PATH2_WITHOUT_PATH1",
                AdError::MissingDynamicSearchAdsSettingDomainName => {
                    "MISSING_DYNAMIC_SEARCH_ADS_SETTING_DOMAIN_NAME"
                }
                AdError::IncompatibleWithRestrictionType => {
                    "INCOMPATIBLE_WITH_RESTRICTION_TYPE"
                }
                AdError::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                AdError::MissingImageOrMediaBundle => "MISSING_IMAGE_OR_MEDIA_BUNDLE",
                AdError::ProductTypeNotSupportedInThisCampaign => {
                    "PRODUCT_TYPE_NOT_SUPPORTED_IN_THIS_CAMPAIGN"
                }
                AdError::PlaceholderCannotHaveEmptyDefaultValue => {
                    "PLACEHOLDER_CANNOT_HAVE_EMPTY_DEFAULT_VALUE"
                }
                AdError::PlaceholderCountdownFunctionCannotHaveDefaultValue => {
                    "PLACEHOLDER_COUNTDOWN_FUNCTION_CANNOT_HAVE_DEFAULT_VALUE"
                }
                AdError::PlaceholderDefaultValueMissing => {
                    "PLACEHOLDER_DEFAULT_VALUE_MISSING"
                }
                AdError::UnexpectedPlaceholderDefaultValue => {
                    "UNEXPECTED_PLACEHOLDER_DEFAULT_VALUE"
                }
                AdError::AdCustomizersMayNotBeAdjacent => {
                    "AD_CUSTOMIZERS_MAY_NOT_BE_ADJACENT"
                }
                AdError::UpdatingAdWithNoEnabledAssociation => {
                    "UPDATING_AD_WITH_NO_ENABLED_ASSOCIATION"
                }
                AdError::CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain => {
                    "CALL_AD_VERIFICATION_URL_FINAL_URL_DOES_NOT_HAVE_SAME_DOMAIN"
                }
                AdError::CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty => {
                    "CALL_AD_FINAL_URL_AND_VERIFICATION_URL_CANNOT_BOTH_BE_EMPTY"
                }
                AdError::TooManyAdCustomizers => "TOO_MANY_AD_CUSTOMIZERS",
                AdError::InvalidAdCustomizerFormat => "INVALID_AD_CUSTOMIZER_FORMAT",
                AdError::NestedAdCustomizerSyntax => "NESTED_AD_CUSTOMIZER_SYNTAX",
                AdError::UnsupportedAdCustomizerSyntax => {
                    "UNSUPPORTED_AD_CUSTOMIZER_SYNTAX"
                }
                AdError::UnpairedBraceInAdCustomizerTag => {
                    "UNPAIRED_BRACE_IN_AD_CUSTOMIZER_TAG"
                }
                AdError::MoreThanOneCountdownTagTypeExists => {
                    "MORE_THAN_ONE_COUNTDOWN_TAG_TYPE_EXISTS"
                }
                AdError::DateTimeInCountdownTagIsInvalid => {
                    "DATE_TIME_IN_COUNTDOWN_TAG_IS_INVALID"
                }
                AdError::DateTimeInCountdownTagIsPast => {
                    "DATE_TIME_IN_COUNTDOWN_TAG_IS_PAST"
                }
                AdError::UnrecognizedAdCustomizerTagFound => {
                    "UNRECOGNIZED_AD_CUSTOMIZER_TAG_FOUND"
                }
                AdError::CustomizerTypeForbiddenForField => {
                    "CUSTOMIZER_TYPE_FORBIDDEN_FOR_FIELD"
                }
                AdError::InvalidCustomizerAttributeName => {
                    "INVALID_CUSTOMIZER_ATTRIBUTE_NAME"
                }
                AdError::StoreMismatch => "STORE_MISMATCH",
                AdError::MissingRequiredImageAspectRatio => {
                    "MISSING_REQUIRED_IMAGE_ASPECT_RATIO"
                }
                AdError::MismatchedAspectRatios => "MISMATCHED_ASPECT_RATIOS",
                AdError::DuplicateImageAcrossCarouselCards => {
                    "DUPLICATE_IMAGE_ACROSS_CAROUSEL_CARDS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_CUSTOMIZERS_NOT_SUPPORTED_FOR_AD_TYPE" => {
                    Some(Self::AdCustomizersNotSupportedForAdType)
                }
                "APPROXIMATELY_TOO_LONG" => Some(Self::ApproximatelyTooLong),
                "APPROXIMATELY_TOO_SHORT" => Some(Self::ApproximatelyTooShort),
                "BAD_SNIPPET" => Some(Self::BadSnippet),
                "CANNOT_MODIFY_AD" => Some(Self::CannotModifyAd),
                "CANNOT_SET_BUSINESS_NAME_IF_URL_SET" => {
                    Some(Self::CannotSetBusinessNameIfUrlSet)
                }
                "CANNOT_SET_FIELD" => Some(Self::CannotSetField),
                "CANNOT_SET_FIELD_WITH_ORIGIN_AD_ID_SET" => {
                    Some(Self::CannotSetFieldWithOriginAdIdSet)
                }
                "CANNOT_SET_FIELD_WITH_AD_ID_SET_FOR_SHARING" => {
                    Some(Self::CannotSetFieldWithAdIdSetForSharing)
                }
                "CANNOT_SET_ALLOW_FLEXIBLE_COLOR_FALSE" => {
                    Some(Self::CannotSetAllowFlexibleColorFalse)
                }
                "CANNOT_SET_COLOR_CONTROL_WHEN_NATIVE_FORMAT_SETTING" => {
                    Some(Self::CannotSetColorControlWhenNativeFormatSetting)
                }
                "CANNOT_SET_URL" => Some(Self::CannotSetUrl),
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "CANNOT_SET_WITH_FINAL_URLS" => Some(Self::CannotSetWithFinalUrls),
                "CANNOT_SET_WITH_URL_DATA" => Some(Self::CannotSetWithUrlData),
                "CANNOT_USE_AD_SUBCLASS_FOR_OPERATOR" => {
                    Some(Self::CannotUseAdSubclassForOperator)
                }
                "CUSTOMER_NOT_APPROVED_MOBILEADS" => {
                    Some(Self::CustomerNotApprovedMobileads)
                }
                "CUSTOMER_NOT_APPROVED_THIRDPARTY_ADS" => {
                    Some(Self::CustomerNotApprovedThirdpartyAds)
                }
                "CUSTOMER_NOT_APPROVED_THIRDPARTY_REDIRECT_ADS" => {
                    Some(Self::CustomerNotApprovedThirdpartyRedirectAds)
                }
                "CUSTOMER_NOT_ELIGIBLE" => Some(Self::CustomerNotEligible),
                "CUSTOMER_NOT_ELIGIBLE_FOR_UPDATING_BEACON_URL" => {
                    Some(Self::CustomerNotEligibleForUpdatingBeaconUrl)
                }
                "DIMENSION_ALREADY_IN_UNION" => Some(Self::DimensionAlreadyInUnion),
                "DIMENSION_MUST_BE_SET" => Some(Self::DimensionMustBeSet),
                "DIMENSION_NOT_IN_UNION" => Some(Self::DimensionNotInUnion),
                "DISPLAY_URL_CANNOT_BE_SPECIFIED" => {
                    Some(Self::DisplayUrlCannotBeSpecified)
                }
                "DOMESTIC_PHONE_NUMBER_FORMAT" => Some(Self::DomesticPhoneNumberFormat),
                "EMERGENCY_PHONE_NUMBER" => Some(Self::EmergencyPhoneNumber),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "FEED_ATTRIBUTE_MUST_HAVE_MAPPING_FOR_TYPE_ID" => {
                    Some(Self::FeedAttributeMustHaveMappingForTypeId)
                }
                "FEED_ATTRIBUTE_MAPPING_TYPE_MISMATCH" => {
                    Some(Self::FeedAttributeMappingTypeMismatch)
                }
                "ILLEGAL_AD_CUSTOMIZER_TAG_USE" => Some(Self::IllegalAdCustomizerTagUse),
                "ILLEGAL_TAG_USE" => Some(Self::IllegalTagUse),
                "INCONSISTENT_DIMENSIONS" => Some(Self::InconsistentDimensions),
                "INCONSISTENT_STATUS_IN_TEMPLATE_UNION" => {
                    Some(Self::InconsistentStatusInTemplateUnion)
                }
                "INCORRECT_LENGTH" => Some(Self::IncorrectLength),
                "INELIGIBLE_FOR_UPGRADE" => Some(Self::IneligibleForUpgrade),
                "INVALID_AD_ADDRESS_CAMPAIGN_TARGET" => {
                    Some(Self::InvalidAdAddressCampaignTarget)
                }
                "INVALID_AD_TYPE" => Some(Self::InvalidAdType),
                "INVALID_ATTRIBUTES_FOR_MOBILE_IMAGE" => {
                    Some(Self::InvalidAttributesForMobileImage)
                }
                "INVALID_ATTRIBUTES_FOR_MOBILE_TEXT" => {
                    Some(Self::InvalidAttributesForMobileText)
                }
                "INVALID_CALL_TO_ACTION_TEXT" => Some(Self::InvalidCallToActionText),
                "INVALID_CHARACTER_FOR_URL" => Some(Self::InvalidCharacterForUrl),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_EXPANDED_DYNAMIC_SEARCH_AD_TAG" => {
                    Some(Self::InvalidExpandedDynamicSearchAdTag)
                }
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "INVALID_MARKUP_LANGUAGE" => Some(Self::InvalidMarkupLanguage),
                "INVALID_MOBILE_CARRIER" => Some(Self::InvalidMobileCarrier),
                "INVALID_MOBILE_CARRIER_TARGET" => Some(Self::InvalidMobileCarrierTarget),
                "INVALID_NUMBER_OF_ELEMENTS" => Some(Self::InvalidNumberOfElements),
                "INVALID_PHONE_NUMBER_FORMAT" => Some(Self::InvalidPhoneNumberFormat),
                "INVALID_RICH_MEDIA_CERTIFIED_VENDOR_FORMAT_ID" => {
                    Some(Self::InvalidRichMediaCertifiedVendorFormatId)
                }
                "INVALID_TEMPLATE_DATA" => Some(Self::InvalidTemplateData),
                "INVALID_TEMPLATE_ELEMENT_FIELD_TYPE" => {
                    Some(Self::InvalidTemplateElementFieldType)
                }
                "INVALID_TEMPLATE_ID" => Some(Self::InvalidTemplateId),
                "LINE_TOO_WIDE" => Some(Self::LineTooWide),
                "MISSING_AD_CUSTOMIZER_MAPPING" => Some(Self::MissingAdCustomizerMapping),
                "MISSING_ADDRESS_COMPONENT" => Some(Self::MissingAddressComponent),
                "MISSING_ADVERTISEMENT_NAME" => Some(Self::MissingAdvertisementName),
                "MISSING_BUSINESS_NAME" => Some(Self::MissingBusinessName),
                "MISSING_DESCRIPTION1" => Some(Self::MissingDescription1),
                "MISSING_DESCRIPTION2" => Some(Self::MissingDescription2),
                "MISSING_DESTINATION_URL_TAG" => Some(Self::MissingDestinationUrlTag),
                "MISSING_LANDING_PAGE_URL_TAG" => Some(Self::MissingLandingPageUrlTag),
                "MISSING_DIMENSION" => Some(Self::MissingDimension),
                "MISSING_DISPLAY_URL" => Some(Self::MissingDisplayUrl),
                "MISSING_HEADLINE" => Some(Self::MissingHeadline),
                "MISSING_HEIGHT" => Some(Self::MissingHeight),
                "MISSING_IMAGE" => Some(Self::MissingImage),
                "MISSING_MARKETING_IMAGE_OR_PRODUCT_VIDEOS" => {
                    Some(Self::MissingMarketingImageOrProductVideos)
                }
                "MISSING_MARKUP_LANGUAGES" => Some(Self::MissingMarkupLanguages),
                "MISSING_MOBILE_CARRIER" => Some(Self::MissingMobileCarrier),
                "MISSING_PHONE" => Some(Self::MissingPhone),
                "MISSING_REQUIRED_TEMPLATE_FIELDS" => {
                    Some(Self::MissingRequiredTemplateFields)
                }
                "MISSING_TEMPLATE_FIELD_VALUE" => Some(Self::MissingTemplateFieldValue),
                "MISSING_TEXT" => Some(Self::MissingText),
                "MISSING_VISIBLE_URL" => Some(Self::MissingVisibleUrl),
                "MISSING_WIDTH" => Some(Self::MissingWidth),
                "MULTIPLE_DISTINCT_FEEDS_UNSUPPORTED" => {
                    Some(Self::MultipleDistinctFeedsUnsupported)
                }
                "MUST_USE_TEMP_AD_UNION_ID_ON_ADD" => {
                    Some(Self::MustUseTempAdUnionIdOnAdd)
                }
                "TOO_LONG" => Some(Self::TooLong),
                "TOO_SHORT" => Some(Self::TooShort),
                "UNION_DIMENSIONS_CANNOT_CHANGE" => {
                    Some(Self::UnionDimensionsCannotChange)
                }
                "UNKNOWN_ADDRESS_COMPONENT" => Some(Self::UnknownAddressComponent),
                "UNKNOWN_FIELD_NAME" => Some(Self::UnknownFieldName),
                "UNKNOWN_UNIQUE_NAME" => Some(Self::UnknownUniqueName),
                "UNSUPPORTED_DIMENSIONS" => Some(Self::UnsupportedDimensions),
                "URL_INVALID_SCHEME" => Some(Self::UrlInvalidScheme),
                "URL_INVALID_TOP_LEVEL_DOMAIN" => Some(Self::UrlInvalidTopLevelDomain),
                "URL_MALFORMED" => Some(Self::UrlMalformed),
                "URL_NO_HOST" => Some(Self::UrlNoHost),
                "URL_NOT_EQUIVALENT" => Some(Self::UrlNotEquivalent),
                "URL_HOST_NAME_TOO_LONG" => Some(Self::UrlHostNameTooLong),
                "URL_NO_SCHEME" => Some(Self::UrlNoScheme),
                "URL_NO_TOP_LEVEL_DOMAIN" => Some(Self::UrlNoTopLevelDomain),
                "URL_PATH_NOT_ALLOWED" => Some(Self::UrlPathNotAllowed),
                "URL_PORT_NOT_ALLOWED" => Some(Self::UrlPortNotAllowed),
                "URL_QUERY_NOT_ALLOWED" => Some(Self::UrlQueryNotAllowed),
                "URL_SCHEME_BEFORE_EXPANDED_DYNAMIC_SEARCH_AD_TAG" => {
                    Some(Self::UrlSchemeBeforeExpandedDynamicSearchAdTag)
                }
                "USER_DOES_NOT_HAVE_ACCESS_TO_TEMPLATE" => {
                    Some(Self::UserDoesNotHaveAccessToTemplate)
                }
                "INCONSISTENT_EXPANDABLE_SETTINGS" => {
                    Some(Self::InconsistentExpandableSettings)
                }
                "INVALID_FORMAT" => Some(Self::InvalidFormat),
                "INVALID_FIELD_TEXT" => Some(Self::InvalidFieldText),
                "ELEMENT_NOT_PRESENT" => Some(Self::ElementNotPresent),
                "IMAGE_ERROR" => Some(Self::ImageError),
                "VALUE_NOT_IN_RANGE" => Some(Self::ValueNotInRange),
                "FIELD_NOT_PRESENT" => Some(Self::FieldNotPresent),
                "ADDRESS_NOT_COMPLETE" => Some(Self::AddressNotComplete),
                "ADDRESS_INVALID" => Some(Self::AddressInvalid),
                "VIDEO_RETRIEVAL_ERROR" => Some(Self::VideoRetrievalError),
                "AUDIO_ERROR" => Some(Self::AudioError),
                "INVALID_YOUTUBE_DISPLAY_URL" => Some(Self::InvalidYoutubeDisplayUrl),
                "TOO_MANY_PRODUCT_IMAGES" => Some(Self::TooManyProductImages),
                "TOO_MANY_PRODUCT_VIDEOS" => Some(Self::TooManyProductVideos),
                "INCOMPATIBLE_AD_TYPE_AND_DEVICE_PREFERENCE" => {
                    Some(Self::IncompatibleAdTypeAndDevicePreference)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_CALL_CONVERSION_TYPE_ID" => {
                    Some(Self::InvalidCallConversionTypeId)
                }
                "CANNOT_DISABLE_CALL_CONVERSION_AND_SET_CONVERSION_TYPE_ID" => {
                    Some(Self::CannotDisableCallConversionAndSetConversionTypeId)
                }
                "CANNOT_SET_PATH2_WITHOUT_PATH1" => {
                    Some(Self::CannotSetPath2WithoutPath1)
                }
                "MISSING_DYNAMIC_SEARCH_ADS_SETTING_DOMAIN_NAME" => {
                    Some(Self::MissingDynamicSearchAdsSettingDomainName)
                }
                "INCOMPATIBLE_WITH_RESTRICTION_TYPE" => {
                    Some(Self::IncompatibleWithRestrictionType)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "MISSING_IMAGE_OR_MEDIA_BUNDLE" => Some(Self::MissingImageOrMediaBundle),
                "PRODUCT_TYPE_NOT_SUPPORTED_IN_THIS_CAMPAIGN" => {
                    Some(Self::ProductTypeNotSupportedInThisCampaign)
                }
                "PLACEHOLDER_CANNOT_HAVE_EMPTY_DEFAULT_VALUE" => {
                    Some(Self::PlaceholderCannotHaveEmptyDefaultValue)
                }
                "PLACEHOLDER_COUNTDOWN_FUNCTION_CANNOT_HAVE_DEFAULT_VALUE" => {
                    Some(Self::PlaceholderCountdownFunctionCannotHaveDefaultValue)
                }
                "PLACEHOLDER_DEFAULT_VALUE_MISSING" => {
                    Some(Self::PlaceholderDefaultValueMissing)
                }
                "UNEXPECTED_PLACEHOLDER_DEFAULT_VALUE" => {
                    Some(Self::UnexpectedPlaceholderDefaultValue)
                }
                "AD_CUSTOMIZERS_MAY_NOT_BE_ADJACENT" => {
                    Some(Self::AdCustomizersMayNotBeAdjacent)
                }
                "UPDATING_AD_WITH_NO_ENABLED_ASSOCIATION" => {
                    Some(Self::UpdatingAdWithNoEnabledAssociation)
                }
                "CALL_AD_VERIFICATION_URL_FINAL_URL_DOES_NOT_HAVE_SAME_DOMAIN" => {
                    Some(Self::CallAdVerificationUrlFinalUrlDoesNotHaveSameDomain)
                }
                "CALL_AD_FINAL_URL_AND_VERIFICATION_URL_CANNOT_BOTH_BE_EMPTY" => {
                    Some(Self::CallAdFinalUrlAndVerificationUrlCannotBothBeEmpty)
                }
                "TOO_MANY_AD_CUSTOMIZERS" => Some(Self::TooManyAdCustomizers),
                "INVALID_AD_CUSTOMIZER_FORMAT" => Some(Self::InvalidAdCustomizerFormat),
                "NESTED_AD_CUSTOMIZER_SYNTAX" => Some(Self::NestedAdCustomizerSyntax),
                "UNSUPPORTED_AD_CUSTOMIZER_SYNTAX" => {
                    Some(Self::UnsupportedAdCustomizerSyntax)
                }
                "UNPAIRED_BRACE_IN_AD_CUSTOMIZER_TAG" => {
                    Some(Self::UnpairedBraceInAdCustomizerTag)
                }
                "MORE_THAN_ONE_COUNTDOWN_TAG_TYPE_EXISTS" => {
                    Some(Self::MoreThanOneCountdownTagTypeExists)
                }
                "DATE_TIME_IN_COUNTDOWN_TAG_IS_INVALID" => {
                    Some(Self::DateTimeInCountdownTagIsInvalid)
                }
                "DATE_TIME_IN_COUNTDOWN_TAG_IS_PAST" => {
                    Some(Self::DateTimeInCountdownTagIsPast)
                }
                "UNRECOGNIZED_AD_CUSTOMIZER_TAG_FOUND" => {
                    Some(Self::UnrecognizedAdCustomizerTagFound)
                }
                "CUSTOMIZER_TYPE_FORBIDDEN_FOR_FIELD" => {
                    Some(Self::CustomizerTypeForbiddenForField)
                }
                "INVALID_CUSTOMIZER_ATTRIBUTE_NAME" => {
                    Some(Self::InvalidCustomizerAttributeName)
                }
                "STORE_MISMATCH" => Some(Self::StoreMismatch),
                "MISSING_REQUIRED_IMAGE_ASPECT_RATIO" => {
                    Some(Self::MissingRequiredImageAspectRatio)
                }
                "MISMATCHED_ASPECT_RATIOS" => Some(Self::MismatchedAspectRatios),
                "DUPLICATE_IMAGE_ACROSS_CAROUSEL_CARDS" => {
                    Some(Self::DuplicateImageAcrossCarouselCards)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCustomizerErrorEnum {}
/// Nested message and enum types in `CampaignCustomizerErrorEnum`.
pub mod campaign_customizer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCustomizerError {
        Unspecified = 0,
        Unknown = 1,
    }
    impl CampaignCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignCustomizerError::Unspecified => "UNSPECIFIED",
                CampaignCustomizerError::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupErrorEnum {}
/// Nested message and enum types in `AssetGroupErrorEnum`.
pub mod asset_group_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateName = 2,
        CannotAddAssetGroupForCampaignType = 3,
        NotEnoughHeadlineAsset = 4,
        NotEnoughLongHeadlineAsset = 5,
        NotEnoughDescriptionAsset = 6,
        NotEnoughBusinessNameAsset = 7,
        NotEnoughMarketingImageAsset = 8,
        NotEnoughSquareMarketingImageAsset = 9,
        NotEnoughLogoAsset = 10,
        FinalUrlShoppingMerchantHomePageUrlDomainsDiffer = 11,
        Path1RequiredWhenPath2IsSet = 12,
        ShortDescriptionRequired = 13,
        FinalUrlRequired = 14,
        FinalUrlContainsInvalidDomainName = 15,
        AdCustomizerNotSupported = 16,
        CannotMutateAssetGroupForRemovedCampaign = 17,
    }
    impl AssetGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupError::Unspecified => "UNSPECIFIED",
                AssetGroupError::Unknown => "UNKNOWN",
                AssetGroupError::DuplicateName => "DUPLICATE_NAME",
                AssetGroupError::CannotAddAssetGroupForCampaignType => {
                    "CANNOT_ADD_ASSET_GROUP_FOR_CAMPAIGN_TYPE"
                }
                AssetGroupError::NotEnoughHeadlineAsset => "NOT_ENOUGH_HEADLINE_ASSET",
                AssetGroupError::NotEnoughLongHeadlineAsset => {
                    "NOT_ENOUGH_LONG_HEADLINE_ASSET"
                }
                AssetGroupError::NotEnoughDescriptionAsset => {
                    "NOT_ENOUGH_DESCRIPTION_ASSET"
                }
                AssetGroupError::NotEnoughBusinessNameAsset => {
                    "NOT_ENOUGH_BUSINESS_NAME_ASSET"
                }
                AssetGroupError::NotEnoughMarketingImageAsset => {
                    "NOT_ENOUGH_MARKETING_IMAGE_ASSET"
                }
                AssetGroupError::NotEnoughSquareMarketingImageAsset => {
                    "NOT_ENOUGH_SQUARE_MARKETING_IMAGE_ASSET"
                }
                AssetGroupError::NotEnoughLogoAsset => "NOT_ENOUGH_LOGO_ASSET",
                AssetGroupError::FinalUrlShoppingMerchantHomePageUrlDomainsDiffer => {
                    "FINAL_URL_SHOPPING_MERCHANT_HOME_PAGE_URL_DOMAINS_DIFFER"
                }
                AssetGroupError::Path1RequiredWhenPath2IsSet => {
                    "PATH1_REQUIRED_WHEN_PATH2_IS_SET"
                }
                AssetGroupError::ShortDescriptionRequired => "SHORT_DESCRIPTION_REQUIRED",
                AssetGroupError::FinalUrlRequired => "FINAL_URL_REQUIRED",
                AssetGroupError::FinalUrlContainsInvalidDomainName => {
                    "FINAL_URL_CONTAINS_INVALID_DOMAIN_NAME"
                }
                AssetGroupError::AdCustomizerNotSupported => {
                    "AD_CUSTOMIZER_NOT_SUPPORTED"
                }
                AssetGroupError::CannotMutateAssetGroupForRemovedCampaign => {
                    "CANNOT_MUTATE_ASSET_GROUP_FOR_REMOVED_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "CANNOT_ADD_ASSET_GROUP_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::CannotAddAssetGroupForCampaignType)
                }
                "NOT_ENOUGH_HEADLINE_ASSET" => Some(Self::NotEnoughHeadlineAsset),
                "NOT_ENOUGH_LONG_HEADLINE_ASSET" => {
                    Some(Self::NotEnoughLongHeadlineAsset)
                }
                "NOT_ENOUGH_DESCRIPTION_ASSET" => Some(Self::NotEnoughDescriptionAsset),
                "NOT_ENOUGH_BUSINESS_NAME_ASSET" => {
                    Some(Self::NotEnoughBusinessNameAsset)
                }
                "NOT_ENOUGH_MARKETING_IMAGE_ASSET" => {
                    Some(Self::NotEnoughMarketingImageAsset)
                }
                "NOT_ENOUGH_SQUARE_MARKETING_IMAGE_ASSET" => {
                    Some(Self::NotEnoughSquareMarketingImageAsset)
                }
                "NOT_ENOUGH_LOGO_ASSET" => Some(Self::NotEnoughLogoAsset),
                "FINAL_URL_SHOPPING_MERCHANT_HOME_PAGE_URL_DOMAINS_DIFFER" => {
                    Some(Self::FinalUrlShoppingMerchantHomePageUrlDomainsDiffer)
                }
                "PATH1_REQUIRED_WHEN_PATH2_IS_SET" => {
                    Some(Self::Path1RequiredWhenPath2IsSet)
                }
                "SHORT_DESCRIPTION_REQUIRED" => Some(Self::ShortDescriptionRequired),
                "FINAL_URL_REQUIRED" => Some(Self::FinalUrlRequired),
                "FINAL_URL_CONTAINS_INVALID_DOMAIN_NAME" => {
                    Some(Self::FinalUrlContainsInvalidDomainName)
                }
                "AD_CUSTOMIZER_NOT_SUPPORTED" => Some(Self::AdCustomizerNotSupported),
                "CANNOT_MUTATE_ASSET_GROUP_FOR_REMOVED_CAMPAIGN" => {
                    Some(Self::CannotMutateAssetGroupForRemovedCampaign)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListOperationErrorEnum {}
/// Nested message and enum types in `ListOperationErrorEnum`.
pub mod list_operation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListOperationError {
        Unspecified = 0,
        Unknown = 1,
        RequiredFieldMissing = 7,
        DuplicateValues = 8,
    }
    impl ListOperationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListOperationError::Unspecified => "UNSPECIFIED",
                ListOperationError::Unknown => "UNKNOWN",
                ListOperationError::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                ListOperationError::DuplicateValues => "DUPLICATE_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "DUPLICATE_VALUES" => Some(Self::DuplicateValues),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NullErrorEnum {}
/// Nested message and enum types in `NullErrorEnum`.
pub mod null_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NullError {
        Unspecified = 0,
        Unknown = 1,
        NullContent = 2,
    }
    impl NullError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NullError::Unspecified => "UNSPECIFIED",
                NullError::Unknown => "UNKNOWN",
                NullError::NullContent => "NULL_CONTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NULL_CONTENT" => Some(Self::NullContent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurrencyErrorEnum {}
/// Nested message and enum types in `CurrencyErrorEnum`.
pub mod currency_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrencyError {
        Unspecified = 0,
        Unknown = 1,
        ValueNotMultipleOfBillableUnit = 2,
    }
    impl CurrencyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CurrencyError::Unspecified => "UNSPECIFIED",
                CurrencyError::Unknown => "UNKNOWN",
                CurrencyError::ValueNotMultipleOfBillableUnit => {
                    "VALUE_NOT_MULTIPLE_OF_BILLABLE_UNIT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VALUE_NOT_MULTIPLE_OF_BILLABLE_UNIT" => {
                    Some(Self::ValueNotMultipleOfBillableUnit)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingErrorEnum {}
/// Nested message and enum types in `BiddingErrorEnum`.
pub mod bidding_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingError {
        Unspecified = 0,
        Unknown = 1,
        BiddingStrategyTransitionNotAllowed = 2,
        CannotAttachBiddingStrategyToCampaign = 7,
        InvalidAnonymousBiddingStrategyType = 10,
        InvalidBiddingStrategyType = 14,
        InvalidBid = 17,
        BiddingStrategyNotAvailableForAccountType = 18,
        CannotCreateCampaignWithBiddingStrategy = 21,
        CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy = 23,
        BiddingStrategyNotSupportedWithAdSchedule = 24,
        PayPerConversionNotAvailableForCustomer = 25,
        PayPerConversionNotAllowedWithTargetCpa = 26,
        BiddingStrategyNotAllowedForSearchOnlyCampaigns = 27,
        BiddingStrategyNotSupportedInDraftsOrExperiments = 28,
        BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion = 29,
        BidTooSmall = 30,
        BidTooBig = 31,
        BidTooManyFractionalDigits = 32,
        InvalidDomainName = 33,
        NotCompatibleWithPaymentMode = 34,
        BiddingStrategyTypeIncompatibleWithSharedBudget = 37,
        BiddingStrategyAndBudgetMustBeAligned = 38,
        BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign = 39,
        BiddingStrategyAndBudgetMustBeRemovedTogether = 40,
        CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros = 41,
    }
    impl BiddingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingError::Unspecified => "UNSPECIFIED",
                BiddingError::Unknown => "UNKNOWN",
                BiddingError::BiddingStrategyTransitionNotAllowed => {
                    "BIDDING_STRATEGY_TRANSITION_NOT_ALLOWED"
                }
                BiddingError::CannotAttachBiddingStrategyToCampaign => {
                    "CANNOT_ATTACH_BIDDING_STRATEGY_TO_CAMPAIGN"
                }
                BiddingError::InvalidAnonymousBiddingStrategyType => {
                    "INVALID_ANONYMOUS_BIDDING_STRATEGY_TYPE"
                }
                BiddingError::InvalidBiddingStrategyType => {
                    "INVALID_BIDDING_STRATEGY_TYPE"
                }
                BiddingError::InvalidBid => "INVALID_BID",
                BiddingError::BiddingStrategyNotAvailableForAccountType => {
                    "BIDDING_STRATEGY_NOT_AVAILABLE_FOR_ACCOUNT_TYPE"
                }
                BiddingError::CannotCreateCampaignWithBiddingStrategy => {
                    "CANNOT_CREATE_CAMPAIGN_WITH_BIDDING_STRATEGY"
                }
                BiddingError::CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy => {
                    "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CAMPAIGN_LEVEL_POP_BIDDING_STRATEGY"
                }
                BiddingError::BiddingStrategyNotSupportedWithAdSchedule => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_WITH_AD_SCHEDULE"
                }
                BiddingError::PayPerConversionNotAvailableForCustomer => {
                    "PAY_PER_CONVERSION_NOT_AVAILABLE_FOR_CUSTOMER"
                }
                BiddingError::PayPerConversionNotAllowedWithTargetCpa => {
                    "PAY_PER_CONVERSION_NOT_ALLOWED_WITH_TARGET_CPA"
                }
                BiddingError::BiddingStrategyNotAllowedForSearchOnlyCampaigns => {
                    "BIDDING_STRATEGY_NOT_ALLOWED_FOR_SEARCH_ONLY_CAMPAIGNS"
                }
                BiddingError::BiddingStrategyNotSupportedInDraftsOrExperiments => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_IN_DRAFTS_OR_EXPERIMENTS"
                }
                BiddingError::BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion => {
                    "BIDDING_STRATEGY_TYPE_DOES_NOT_SUPPORT_PRODUCT_TYPE_ADGROUP_CRITERION"
                }
                BiddingError::BidTooSmall => "BID_TOO_SMALL",
                BiddingError::BidTooBig => "BID_TOO_BIG",
                BiddingError::BidTooManyFractionalDigits => {
                    "BID_TOO_MANY_FRACTIONAL_DIGITS"
                }
                BiddingError::InvalidDomainName => "INVALID_DOMAIN_NAME",
                BiddingError::NotCompatibleWithPaymentMode => {
                    "NOT_COMPATIBLE_WITH_PAYMENT_MODE"
                }
                BiddingError::BiddingStrategyTypeIncompatibleWithSharedBudget => {
                    "BIDDING_STRATEGY_TYPE_INCOMPATIBLE_WITH_SHARED_BUDGET"
                }
                BiddingError::BiddingStrategyAndBudgetMustBeAligned => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ALIGNED"
                }
                BiddingError::BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ATTACHED_TO_THE_SAME_CAMPAIGNS_TO_ALIGN"
                }
                BiddingError::BiddingStrategyAndBudgetMustBeRemovedTogether => {
                    "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_REMOVED_TOGETHER"
                }
                BiddingError::CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros => {
                    "CPC_BID_FLOOR_MICROS_GREATER_THAN_CPC_BID_CEILING_MICROS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BIDDING_STRATEGY_TRANSITION_NOT_ALLOWED" => {
                    Some(Self::BiddingStrategyTransitionNotAllowed)
                }
                "CANNOT_ATTACH_BIDDING_STRATEGY_TO_CAMPAIGN" => {
                    Some(Self::CannotAttachBiddingStrategyToCampaign)
                }
                "INVALID_ANONYMOUS_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::InvalidAnonymousBiddingStrategyType)
                }
                "INVALID_BIDDING_STRATEGY_TYPE" => Some(Self::InvalidBiddingStrategyType),
                "INVALID_BID" => Some(Self::InvalidBid),
                "BIDDING_STRATEGY_NOT_AVAILABLE_FOR_ACCOUNT_TYPE" => {
                    Some(Self::BiddingStrategyNotAvailableForAccountType)
                }
                "CANNOT_CREATE_CAMPAIGN_WITH_BIDDING_STRATEGY" => {
                    Some(Self::CannotCreateCampaignWithBiddingStrategy)
                }
                "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CAMPAIGN_LEVEL_POP_BIDDING_STRATEGY" => {
                    Some(
                        Self::CannotTargetContentNetworkOnlyWithCampaignLevelPopBiddingStrategy,
                    )
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_WITH_AD_SCHEDULE" => {
                    Some(Self::BiddingStrategyNotSupportedWithAdSchedule)
                }
                "PAY_PER_CONVERSION_NOT_AVAILABLE_FOR_CUSTOMER" => {
                    Some(Self::PayPerConversionNotAvailableForCustomer)
                }
                "PAY_PER_CONVERSION_NOT_ALLOWED_WITH_TARGET_CPA" => {
                    Some(Self::PayPerConversionNotAllowedWithTargetCpa)
                }
                "BIDDING_STRATEGY_NOT_ALLOWED_FOR_SEARCH_ONLY_CAMPAIGNS" => {
                    Some(Self::BiddingStrategyNotAllowedForSearchOnlyCampaigns)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_IN_DRAFTS_OR_EXPERIMENTS" => {
                    Some(Self::BiddingStrategyNotSupportedInDraftsOrExperiments)
                }
                "BIDDING_STRATEGY_TYPE_DOES_NOT_SUPPORT_PRODUCT_TYPE_ADGROUP_CRITERION" => {
                    Some(
                        Self::BiddingStrategyTypeDoesNotSupportProductTypeAdgroupCriterion,
                    )
                }
                "BID_TOO_SMALL" => Some(Self::BidTooSmall),
                "BID_TOO_BIG" => Some(Self::BidTooBig),
                "BID_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::BidTooManyFractionalDigits)
                }
                "INVALID_DOMAIN_NAME" => Some(Self::InvalidDomainName),
                "NOT_COMPATIBLE_WITH_PAYMENT_MODE" => {
                    Some(Self::NotCompatibleWithPaymentMode)
                }
                "BIDDING_STRATEGY_TYPE_INCOMPATIBLE_WITH_SHARED_BUDGET" => {
                    Some(Self::BiddingStrategyTypeIncompatibleWithSharedBudget)
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ALIGNED" => {
                    Some(Self::BiddingStrategyAndBudgetMustBeAligned)
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_ATTACHED_TO_THE_SAME_CAMPAIGNS_TO_ALIGN" => {
                    Some(
                        Self::BiddingStrategyAndBudgetMustBeAttachedToTheSameCampaignsToAlign,
                    )
                }
                "BIDDING_STRATEGY_AND_BUDGET_MUST_BE_REMOVED_TOGETHER" => {
                    Some(Self::BiddingStrategyAndBudgetMustBeRemovedTogether)
                }
                "CPC_BID_FLOOR_MICROS_GREATER_THAN_CPC_BID_CEILING_MICROS" => {
                    Some(Self::CpcBidFloorMicrosGreaterThanCpcBidCeilingMicros)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegionCodeErrorEnum {}
/// Nested message and enum types in `RegionCodeErrorEnum`.
pub mod region_code_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RegionCodeError {
        Unspecified = 0,
        Unknown = 1,
        InvalidRegionCode = 2,
    }
    impl RegionCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RegionCodeError::Unspecified => "UNSPECIFIED",
                RegionCodeError::Unknown => "UNKNOWN",
                RegionCodeError::InvalidRegionCode => "INVALID_REGION_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_REGION_CODE" => Some(Self::InvalidRegionCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdParameterErrorEnum {}
/// Nested message and enum types in `AdParameterErrorEnum`.
pub mod ad_parameter_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdParameterError {
        Unspecified = 0,
        Unknown = 1,
        AdGroupCriterionMustBeKeyword = 2,
        InvalidInsertionTextFormat = 3,
    }
    impl AdParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdParameterError::Unspecified => "UNSPECIFIED",
                AdParameterError::Unknown => "UNKNOWN",
                AdParameterError::AdGroupCriterionMustBeKeyword => {
                    "AD_GROUP_CRITERION_MUST_BE_KEYWORD"
                }
                AdParameterError::InvalidInsertionTextFormat => {
                    "INVALID_INSERTION_TEXT_FORMAT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_CRITERION_MUST_BE_KEYWORD" => {
                    Some(Self::AdGroupCriterionMustBeKeyword)
                }
                "INVALID_INSERTION_TEXT_FORMAT" => Some(Self::InvalidInsertionTextFormat),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerLifecycleGoalErrorEnum {}
/// Nested message and enum types in `CustomerLifecycleGoalErrorEnum`.
pub mod customer_lifecycle_goal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerLifecycleGoalError {
        Unspecified = 0,
        Unknown = 1,
        CustomerAcquisitionValueMissing = 2,
        CustomerAcquisitionInvalidValue = 3,
        CustomerAcquisitionInvalidHighLifetimeValue = 4,
        CustomerAcquisitionValueCannotBeCleared = 5,
        CustomerAcquisitionHighLifetimeValueCannotBeCleared = 6,
        InvalidExistingUserList = 7,
        InvalidHighLifetimeValueUserList = 8,
    }
    impl CustomerLifecycleGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerLifecycleGoalError::Unspecified => "UNSPECIFIED",
                CustomerLifecycleGoalError::Unknown => "UNKNOWN",
                CustomerLifecycleGoalError::CustomerAcquisitionValueMissing => {
                    "CUSTOMER_ACQUISITION_VALUE_MISSING"
                }
                CustomerLifecycleGoalError::CustomerAcquisitionInvalidValue => {
                    "CUSTOMER_ACQUISITION_INVALID_VALUE"
                }
                CustomerLifecycleGoalError::CustomerAcquisitionInvalidHighLifetimeValue => {
                    "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE"
                }
                CustomerLifecycleGoalError::CustomerAcquisitionValueCannotBeCleared => {
                    "CUSTOMER_ACQUISITION_VALUE_CANNOT_BE_CLEARED"
                }
                CustomerLifecycleGoalError::CustomerAcquisitionHighLifetimeValueCannotBeCleared => {
                    "CUSTOMER_ACQUISITION_HIGH_LIFETIME_VALUE_CANNOT_BE_CLEARED"
                }
                CustomerLifecycleGoalError::InvalidExistingUserList => {
                    "INVALID_EXISTING_USER_LIST"
                }
                CustomerLifecycleGoalError::InvalidHighLifetimeValueUserList => {
                    "INVALID_HIGH_LIFETIME_VALUE_USER_LIST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_ACQUISITION_VALUE_MISSING" => {
                    Some(Self::CustomerAcquisitionValueMissing)
                }
                "CUSTOMER_ACQUISITION_INVALID_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidValue)
                }
                "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidHighLifetimeValue)
                }
                "CUSTOMER_ACQUISITION_VALUE_CANNOT_BE_CLEARED" => {
                    Some(Self::CustomerAcquisitionValueCannotBeCleared)
                }
                "CUSTOMER_ACQUISITION_HIGH_LIFETIME_VALUE_CANNOT_BE_CLEARED" => {
                    Some(Self::CustomerAcquisitionHighLifetimeValueCannotBeCleared)
                }
                "INVALID_EXISTING_USER_LIST" => Some(Self::InvalidExistingUserList),
                "INVALID_HIGH_LIFETIME_VALUE_USER_LIST" => {
                    Some(Self::InvalidHighLifetimeValueUserList)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetErrorEnum {}
/// Nested message and enum types in `AssetSetErrorEnum`.
pub mod asset_set_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateAssetSetName = 2,
        InvalidParentAssetSetType = 3,
        AssetSetSourceIncompatibleWithParentAssetSet = 4,
        AssetSetTypeCannotBeLinkedToCustomer = 5,
        InvalidChainIds = 6,
        LocationSyncAssetSetDoesNotSupportRelationshipType = 7,
        NotUniqueEnabledLocationSyncTypedAssetSet = 8,
        InvalidPlaceIds = 9,
        OauthInfoInvalid = 11,
        OauthInfoMissing = 12,
        CannotDeleteAsEnabledLinkagesExist = 10,
    }
    impl AssetSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetError::Unspecified => "UNSPECIFIED",
                AssetSetError::Unknown => "UNKNOWN",
                AssetSetError::DuplicateAssetSetName => "DUPLICATE_ASSET_SET_NAME",
                AssetSetError::InvalidParentAssetSetType => {
                    "INVALID_PARENT_ASSET_SET_TYPE"
                }
                AssetSetError::AssetSetSourceIncompatibleWithParentAssetSet => {
                    "ASSET_SET_SOURCE_INCOMPATIBLE_WITH_PARENT_ASSET_SET"
                }
                AssetSetError::AssetSetTypeCannotBeLinkedToCustomer => {
                    "ASSET_SET_TYPE_CANNOT_BE_LINKED_TO_CUSTOMER"
                }
                AssetSetError::InvalidChainIds => "INVALID_CHAIN_IDS",
                AssetSetError::LocationSyncAssetSetDoesNotSupportRelationshipType => {
                    "LOCATION_SYNC_ASSET_SET_DOES_NOT_SUPPORT_RELATIONSHIP_TYPE"
                }
                AssetSetError::NotUniqueEnabledLocationSyncTypedAssetSet => {
                    "NOT_UNIQUE_ENABLED_LOCATION_SYNC_TYPED_ASSET_SET"
                }
                AssetSetError::InvalidPlaceIds => "INVALID_PLACE_IDS",
                AssetSetError::OauthInfoInvalid => "OAUTH_INFO_INVALID",
                AssetSetError::OauthInfoMissing => "OAUTH_INFO_MISSING",
                AssetSetError::CannotDeleteAsEnabledLinkagesExist => {
                    "CANNOT_DELETE_AS_ENABLED_LINKAGES_EXIST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ASSET_SET_NAME" => Some(Self::DuplicateAssetSetName),
                "INVALID_PARENT_ASSET_SET_TYPE" => Some(Self::InvalidParentAssetSetType),
                "ASSET_SET_SOURCE_INCOMPATIBLE_WITH_PARENT_ASSET_SET" => {
                    Some(Self::AssetSetSourceIncompatibleWithParentAssetSet)
                }
                "ASSET_SET_TYPE_CANNOT_BE_LINKED_TO_CUSTOMER" => {
                    Some(Self::AssetSetTypeCannotBeLinkedToCustomer)
                }
                "INVALID_CHAIN_IDS" => Some(Self::InvalidChainIds),
                "LOCATION_SYNC_ASSET_SET_DOES_NOT_SUPPORT_RELATIONSHIP_TYPE" => {
                    Some(Self::LocationSyncAssetSetDoesNotSupportRelationshipType)
                }
                "NOT_UNIQUE_ENABLED_LOCATION_SYNC_TYPED_ASSET_SET" => {
                    Some(Self::NotUniqueEnabledLocationSyncTypedAssetSet)
                }
                "INVALID_PLACE_IDS" => Some(Self::InvalidPlaceIds),
                "OAUTH_INFO_INVALID" => Some(Self::OauthInfoInvalid),
                "OAUTH_INFO_MISSING" => Some(Self::OauthInfoMissing),
                "CANNOT_DELETE_AS_ENABLED_LINKAGES_EXIST" => {
                    Some(Self::CannotDeleteAsEnabledLinkagesExist)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QuotaErrorEnum {}
/// Nested message and enum types in `QuotaErrorEnum`.
pub mod quota_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaError {
        Unspecified = 0,
        Unknown = 1,
        ResourceExhausted = 2,
        AccessProhibited = 3,
        ResourceTemporarilyExhausted = 4,
    }
    impl QuotaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuotaError::Unspecified => "UNSPECIFIED",
                QuotaError::Unknown => "UNKNOWN",
                QuotaError::ResourceExhausted => "RESOURCE_EXHAUSTED",
                QuotaError::AccessProhibited => "ACCESS_PROHIBITED",
                QuotaError::ResourceTemporarilyExhausted => {
                    "RESOURCE_TEMPORARILY_EXHAUSTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
                "ACCESS_PROHIBITED" => Some(Self::AccessProhibited),
                "RESOURCE_TEMPORARILY_EXHAUSTED" => {
                    Some(Self::ResourceTemporarilyExhausted)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdSharingErrorEnum {}
/// Nested message and enum types in `AdSharingErrorEnum`.
pub mod ad_sharing_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdSharingError {
        Unspecified = 0,
        Unknown = 1,
        AdGroupAlreadyContainsAd = 2,
        IncompatibleAdUnderAdGroup = 3,
        CannotShareInactiveAd = 4,
    }
    impl AdSharingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdSharingError::Unspecified => "UNSPECIFIED",
                AdSharingError::Unknown => "UNKNOWN",
                AdSharingError::AdGroupAlreadyContainsAd => {
                    "AD_GROUP_ALREADY_CONTAINS_AD"
                }
                AdSharingError::IncompatibleAdUnderAdGroup => {
                    "INCOMPATIBLE_AD_UNDER_AD_GROUP"
                }
                AdSharingError::CannotShareInactiveAd => "CANNOT_SHARE_INACTIVE_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_ALREADY_CONTAINS_AD" => Some(Self::AdGroupAlreadyContainsAd),
                "INCOMPATIBLE_AD_UNDER_AD_GROUP" => {
                    Some(Self::IncompatibleAdUnderAdGroup)
                }
                "CANNOT_SHARE_INACTIVE_AD" => Some(Self::CannotShareInactiveAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdCustomizerErrorEnum {}
/// Nested message and enum types in `AdCustomizerErrorEnum`.
pub mod ad_customizer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdCustomizerError {
        Unspecified = 0,
        Unknown = 1,
        CountdownInvalidDateFormat = 2,
        CountdownDateInPast = 3,
        CountdownInvalidLocale = 4,
        CountdownInvalidStartDaysBefore = 5,
        UnknownUserList = 6,
    }
    impl AdCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdCustomizerError::Unspecified => "UNSPECIFIED",
                AdCustomizerError::Unknown => "UNKNOWN",
                AdCustomizerError::CountdownInvalidDateFormat => {
                    "COUNTDOWN_INVALID_DATE_FORMAT"
                }
                AdCustomizerError::CountdownDateInPast => "COUNTDOWN_DATE_IN_PAST",
                AdCustomizerError::CountdownInvalidLocale => "COUNTDOWN_INVALID_LOCALE",
                AdCustomizerError::CountdownInvalidStartDaysBefore => {
                    "COUNTDOWN_INVALID_START_DAYS_BEFORE"
                }
                AdCustomizerError::UnknownUserList => "UNKNOWN_USER_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "COUNTDOWN_INVALID_DATE_FORMAT" => Some(Self::CountdownInvalidDateFormat),
                "COUNTDOWN_DATE_IN_PAST" => Some(Self::CountdownDateInPast),
                "COUNTDOWN_INVALID_LOCALE" => Some(Self::CountdownInvalidLocale),
                "COUNTDOWN_INVALID_START_DAYS_BEFORE" => {
                    Some(Self::CountdownInvalidStartDaysBefore)
                }
                "UNKNOWN_USER_LIST" => Some(Self::UnknownUserList),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthorizationErrorEnum {}
/// Nested message and enum types in `AuthorizationErrorEnum`.
pub mod authorization_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthorizationError {
        Unspecified = 0,
        Unknown = 1,
        UserPermissionDenied = 2,
        DeveloperTokenNotOnAllowlist = 13,
        DeveloperTokenProhibited = 4,
        ProjectDisabled = 5,
        AuthorizationError = 6,
        ActionNotPermitted = 7,
        IncompleteSignup = 8,
        CustomerNotEnabled = 24,
        MissingTos = 9,
        DeveloperTokenNotApproved = 10,
        InvalidLoginCustomerIdServingCustomerIdCombination = 11,
        ServiceAccessDenied = 12,
        AccessDeniedForAccountType = 25,
        MetricAccessDenied = 26,
        CloudProjectNotUnderOrganization = 27,
    }
    impl AuthorizationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AuthorizationError::Unspecified => "UNSPECIFIED",
                AuthorizationError::Unknown => "UNKNOWN",
                AuthorizationError::UserPermissionDenied => "USER_PERMISSION_DENIED",
                AuthorizationError::DeveloperTokenNotOnAllowlist => {
                    "DEVELOPER_TOKEN_NOT_ON_ALLOWLIST"
                }
                AuthorizationError::DeveloperTokenProhibited => {
                    "DEVELOPER_TOKEN_PROHIBITED"
                }
                AuthorizationError::ProjectDisabled => "PROJECT_DISABLED",
                AuthorizationError::AuthorizationError => "AUTHORIZATION_ERROR",
                AuthorizationError::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                AuthorizationError::IncompleteSignup => "INCOMPLETE_SIGNUP",
                AuthorizationError::CustomerNotEnabled => "CUSTOMER_NOT_ENABLED",
                AuthorizationError::MissingTos => "MISSING_TOS",
                AuthorizationError::DeveloperTokenNotApproved => {
                    "DEVELOPER_TOKEN_NOT_APPROVED"
                }
                AuthorizationError::InvalidLoginCustomerIdServingCustomerIdCombination => {
                    "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION"
                }
                AuthorizationError::ServiceAccessDenied => "SERVICE_ACCESS_DENIED",
                AuthorizationError::AccessDeniedForAccountType => {
                    "ACCESS_DENIED_FOR_ACCOUNT_TYPE"
                }
                AuthorizationError::MetricAccessDenied => "METRIC_ACCESS_DENIED",
                AuthorizationError::CloudProjectNotUnderOrganization => {
                    "CLOUD_PROJECT_NOT_UNDER_ORGANIZATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER_PERMISSION_DENIED" => Some(Self::UserPermissionDenied),
                "DEVELOPER_TOKEN_NOT_ON_ALLOWLIST" => {
                    Some(Self::DeveloperTokenNotOnAllowlist)
                }
                "DEVELOPER_TOKEN_PROHIBITED" => Some(Self::DeveloperTokenProhibited),
                "PROJECT_DISABLED" => Some(Self::ProjectDisabled),
                "AUTHORIZATION_ERROR" => Some(Self::AuthorizationError),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "INCOMPLETE_SIGNUP" => Some(Self::IncompleteSignup),
                "CUSTOMER_NOT_ENABLED" => Some(Self::CustomerNotEnabled),
                "MISSING_TOS" => Some(Self::MissingTos),
                "DEVELOPER_TOKEN_NOT_APPROVED" => Some(Self::DeveloperTokenNotApproved),
                "INVALID_LOGIN_CUSTOMER_ID_SERVING_CUSTOMER_ID_COMBINATION" => {
                    Some(Self::InvalidLoginCustomerIdServingCustomerIdCombination)
                }
                "SERVICE_ACCESS_DENIED" => Some(Self::ServiceAccessDenied),
                "ACCESS_DENIED_FOR_ACCOUNT_TYPE" => {
                    Some(Self::AccessDeniedForAccountType)
                }
                "METRIC_ACCESS_DENIED" => Some(Self::MetricAccessDenied),
                "CLOUD_PROJECT_NOT_UNDER_ORGANIZATION" => {
                    Some(Self::CloudProjectNotUnderOrganization)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RangeErrorEnum {}
/// Nested message and enum types in `RangeErrorEnum`.
pub mod range_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RangeError {
        Unspecified = 0,
        Unknown = 1,
        TooLow = 2,
        TooHigh = 3,
    }
    impl RangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RangeError::Unspecified => "UNSPECIFIED",
                RangeError::Unknown => "UNKNOWN",
                RangeError::TooLow => "TOO_LOW",
                RangeError::TooHigh => "TOO_HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_LOW" => Some(Self::TooLow),
                "TOO_HIGH" => Some(Self::TooHigh),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperationAccessDeniedErrorEnum {}
/// Nested message and enum types in `OperationAccessDeniedErrorEnum`.
pub mod operation_access_denied_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperationAccessDeniedError {
        Unspecified = 0,
        Unknown = 1,
        ActionNotPermitted = 2,
        CreateOperationNotPermitted = 3,
        RemoveOperationNotPermitted = 4,
        UpdateOperationNotPermitted = 5,
        MutateActionNotPermittedForClient = 6,
        OperationNotPermittedForCampaignType = 7,
        CreateAsRemovedNotPermitted = 8,
        OperationNotPermittedForRemovedResource = 9,
        OperationNotPermittedForAdGroupType = 10,
        MutateNotPermittedForCustomer = 11,
    }
    impl OperationAccessDeniedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperationAccessDeniedError::Unspecified => "UNSPECIFIED",
                OperationAccessDeniedError::Unknown => "UNKNOWN",
                OperationAccessDeniedError::ActionNotPermitted => "ACTION_NOT_PERMITTED",
                OperationAccessDeniedError::CreateOperationNotPermitted => {
                    "CREATE_OPERATION_NOT_PERMITTED"
                }
                OperationAccessDeniedError::RemoveOperationNotPermitted => {
                    "REMOVE_OPERATION_NOT_PERMITTED"
                }
                OperationAccessDeniedError::UpdateOperationNotPermitted => {
                    "UPDATE_OPERATION_NOT_PERMITTED"
                }
                OperationAccessDeniedError::MutateActionNotPermittedForClient => {
                    "MUTATE_ACTION_NOT_PERMITTED_FOR_CLIENT"
                }
                OperationAccessDeniedError::OperationNotPermittedForCampaignType => {
                    "OPERATION_NOT_PERMITTED_FOR_CAMPAIGN_TYPE"
                }
                OperationAccessDeniedError::CreateAsRemovedNotPermitted => {
                    "CREATE_AS_REMOVED_NOT_PERMITTED"
                }
                OperationAccessDeniedError::OperationNotPermittedForRemovedResource => {
                    "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE"
                }
                OperationAccessDeniedError::OperationNotPermittedForAdGroupType => {
                    "OPERATION_NOT_PERMITTED_FOR_AD_GROUP_TYPE"
                }
                OperationAccessDeniedError::MutateNotPermittedForCustomer => {
                    "MUTATE_NOT_PERMITTED_FOR_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTION_NOT_PERMITTED" => Some(Self::ActionNotPermitted),
                "CREATE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::CreateOperationNotPermitted)
                }
                "REMOVE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::RemoveOperationNotPermitted)
                }
                "UPDATE_OPERATION_NOT_PERMITTED" => {
                    Some(Self::UpdateOperationNotPermitted)
                }
                "MUTATE_ACTION_NOT_PERMITTED_FOR_CLIENT" => {
                    Some(Self::MutateActionNotPermittedForClient)
                }
                "OPERATION_NOT_PERMITTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::OperationNotPermittedForCampaignType)
                }
                "CREATE_AS_REMOVED_NOT_PERMITTED" => {
                    Some(Self::CreateAsRemovedNotPermitted)
                }
                "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE" => {
                    Some(Self::OperationNotPermittedForRemovedResource)
                }
                "OPERATION_NOT_PERMITTED_FOR_AD_GROUP_TYPE" => {
                    Some(Self::OperationNotPermittedForAdGroupType)
                }
                "MUTATE_NOT_PERMITTED_FOR_CUSTOMER" => {
                    Some(Self::MutateNotPermittedForCustomer)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListErrorEnum {}
/// Nested message and enum types in `UserListErrorEnum`.
pub mod user_list_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListError {
        Unspecified = 0,
        Unknown = 1,
        ExternalRemarketingUserListMutateNotSupported = 2,
        ConcreteTypeRequired = 3,
        ConversionTypeIdRequired = 4,
        DuplicateConversionTypes = 5,
        InvalidConversionType = 6,
        InvalidDescription = 7,
        InvalidName = 8,
        InvalidType = 9,
        CanNotAddLogicalListAsLogicalListOperand = 10,
        InvalidUserListLogicalRuleOperand = 11,
        NameAlreadyUsed = 12,
        NewConversionTypeNameRequired = 13,
        ConversionTypeNameAlreadyUsed = 14,
        OwnershipRequiredForSet = 15,
        UserListMutateNotSupported = 16,
        InvalidRule = 17,
        InvalidDateRange = 27,
        CanNotMutateSensitiveUserlist = 28,
        MaxNumRulebasedUserlists = 29,
        CannotModifyBillableRecordCount = 30,
        AppIdNotSet = 31,
        UserlistNameIsReservedForSystemList = 32,
        AdvertiserNotOnAllowlistForUsingUploadedData = 37,
        RuleTypeIsNotSupported = 34,
        CanNotAddASimilarUserlistAsLogicalListOperand = 35,
        CanNotMixCrmBasedInLogicalListWithOtherLists = 36,
        AppIdNotAllowed = 39,
        CannotMutateSystemList = 40,
        MobileAppIsSensitive = 41,
        SeedListDoesNotExist = 42,
        InvalidSeedListAccessReason = 43,
        InvalidSeedListType = 44,
        InvalidCountryCodes = 45,
    }
    impl UserListError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListError::Unspecified => "UNSPECIFIED",
                UserListError::Unknown => "UNKNOWN",
                UserListError::ExternalRemarketingUserListMutateNotSupported => {
                    "EXTERNAL_REMARKETING_USER_LIST_MUTATE_NOT_SUPPORTED"
                }
                UserListError::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                UserListError::ConversionTypeIdRequired => "CONVERSION_TYPE_ID_REQUIRED",
                UserListError::DuplicateConversionTypes => "DUPLICATE_CONVERSION_TYPES",
                UserListError::InvalidConversionType => "INVALID_CONVERSION_TYPE",
                UserListError::InvalidDescription => "INVALID_DESCRIPTION",
                UserListError::InvalidName => "INVALID_NAME",
                UserListError::InvalidType => "INVALID_TYPE",
                UserListError::CanNotAddLogicalListAsLogicalListOperand => {
                    "CAN_NOT_ADD_LOGICAL_LIST_AS_LOGICAL_LIST_OPERAND"
                }
                UserListError::InvalidUserListLogicalRuleOperand => {
                    "INVALID_USER_LIST_LOGICAL_RULE_OPERAND"
                }
                UserListError::NameAlreadyUsed => "NAME_ALREADY_USED",
                UserListError::NewConversionTypeNameRequired => {
                    "NEW_CONVERSION_TYPE_NAME_REQUIRED"
                }
                UserListError::ConversionTypeNameAlreadyUsed => {
                    "CONVERSION_TYPE_NAME_ALREADY_USED"
                }
                UserListError::OwnershipRequiredForSet => "OWNERSHIP_REQUIRED_FOR_SET",
                UserListError::UserListMutateNotSupported => {
                    "USER_LIST_MUTATE_NOT_SUPPORTED"
                }
                UserListError::InvalidRule => "INVALID_RULE",
                UserListError::InvalidDateRange => "INVALID_DATE_RANGE",
                UserListError::CanNotMutateSensitiveUserlist => {
                    "CAN_NOT_MUTATE_SENSITIVE_USERLIST"
                }
                UserListError::MaxNumRulebasedUserlists => "MAX_NUM_RULEBASED_USERLISTS",
                UserListError::CannotModifyBillableRecordCount => {
                    "CANNOT_MODIFY_BILLABLE_RECORD_COUNT"
                }
                UserListError::AppIdNotSet => "APP_ID_NOT_SET",
                UserListError::UserlistNameIsReservedForSystemList => {
                    "USERLIST_NAME_IS_RESERVED_FOR_SYSTEM_LIST"
                }
                UserListError::AdvertiserNotOnAllowlistForUsingUploadedData => {
                    "ADVERTISER_NOT_ON_ALLOWLIST_FOR_USING_UPLOADED_DATA"
                }
                UserListError::RuleTypeIsNotSupported => "RULE_TYPE_IS_NOT_SUPPORTED",
                UserListError::CanNotAddASimilarUserlistAsLogicalListOperand => {
                    "CAN_NOT_ADD_A_SIMILAR_USERLIST_AS_LOGICAL_LIST_OPERAND"
                }
                UserListError::CanNotMixCrmBasedInLogicalListWithOtherLists => {
                    "CAN_NOT_MIX_CRM_BASED_IN_LOGICAL_LIST_WITH_OTHER_LISTS"
                }
                UserListError::AppIdNotAllowed => "APP_ID_NOT_ALLOWED",
                UserListError::CannotMutateSystemList => "CANNOT_MUTATE_SYSTEM_LIST",
                UserListError::MobileAppIsSensitive => "MOBILE_APP_IS_SENSITIVE",
                UserListError::SeedListDoesNotExist => "SEED_LIST_DOES_NOT_EXIST",
                UserListError::InvalidSeedListAccessReason => {
                    "INVALID_SEED_LIST_ACCESS_REASON"
                }
                UserListError::InvalidSeedListType => "INVALID_SEED_LIST_TYPE",
                UserListError::InvalidCountryCodes => "INVALID_COUNTRY_CODES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTERNAL_REMARKETING_USER_LIST_MUTATE_NOT_SUPPORTED" => {
                    Some(Self::ExternalRemarketingUserListMutateNotSupported)
                }
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "CONVERSION_TYPE_ID_REQUIRED" => Some(Self::ConversionTypeIdRequired),
                "DUPLICATE_CONVERSION_TYPES" => Some(Self::DuplicateConversionTypes),
                "INVALID_CONVERSION_TYPE" => Some(Self::InvalidConversionType),
                "INVALID_DESCRIPTION" => Some(Self::InvalidDescription),
                "INVALID_NAME" => Some(Self::InvalidName),
                "INVALID_TYPE" => Some(Self::InvalidType),
                "CAN_NOT_ADD_LOGICAL_LIST_AS_LOGICAL_LIST_OPERAND" => {
                    Some(Self::CanNotAddLogicalListAsLogicalListOperand)
                }
                "INVALID_USER_LIST_LOGICAL_RULE_OPERAND" => {
                    Some(Self::InvalidUserListLogicalRuleOperand)
                }
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "NEW_CONVERSION_TYPE_NAME_REQUIRED" => {
                    Some(Self::NewConversionTypeNameRequired)
                }
                "CONVERSION_TYPE_NAME_ALREADY_USED" => {
                    Some(Self::ConversionTypeNameAlreadyUsed)
                }
                "OWNERSHIP_REQUIRED_FOR_SET" => Some(Self::OwnershipRequiredForSet),
                "USER_LIST_MUTATE_NOT_SUPPORTED" => {
                    Some(Self::UserListMutateNotSupported)
                }
                "INVALID_RULE" => Some(Self::InvalidRule),
                "INVALID_DATE_RANGE" => Some(Self::InvalidDateRange),
                "CAN_NOT_MUTATE_SENSITIVE_USERLIST" => {
                    Some(Self::CanNotMutateSensitiveUserlist)
                }
                "MAX_NUM_RULEBASED_USERLISTS" => Some(Self::MaxNumRulebasedUserlists),
                "CANNOT_MODIFY_BILLABLE_RECORD_COUNT" => {
                    Some(Self::CannotModifyBillableRecordCount)
                }
                "APP_ID_NOT_SET" => Some(Self::AppIdNotSet),
                "USERLIST_NAME_IS_RESERVED_FOR_SYSTEM_LIST" => {
                    Some(Self::UserlistNameIsReservedForSystemList)
                }
                "ADVERTISER_NOT_ON_ALLOWLIST_FOR_USING_UPLOADED_DATA" => {
                    Some(Self::AdvertiserNotOnAllowlistForUsingUploadedData)
                }
                "RULE_TYPE_IS_NOT_SUPPORTED" => Some(Self::RuleTypeIsNotSupported),
                "CAN_NOT_ADD_A_SIMILAR_USERLIST_AS_LOGICAL_LIST_OPERAND" => {
                    Some(Self::CanNotAddASimilarUserlistAsLogicalListOperand)
                }
                "CAN_NOT_MIX_CRM_BASED_IN_LOGICAL_LIST_WITH_OTHER_LISTS" => {
                    Some(Self::CanNotMixCrmBasedInLogicalListWithOtherLists)
                }
                "APP_ID_NOT_ALLOWED" => Some(Self::AppIdNotAllowed),
                "CANNOT_MUTATE_SYSTEM_LIST" => Some(Self::CannotMutateSystemList),
                "MOBILE_APP_IS_SENSITIVE" => Some(Self::MobileAppIsSensitive),
                "SEED_LIST_DOES_NOT_EXIST" => Some(Self::SeedListDoesNotExist),
                "INVALID_SEED_LIST_ACCESS_REASON" => {
                    Some(Self::InvalidSeedListAccessReason)
                }
                "INVALID_SEED_LIST_TYPE" => Some(Self::InvalidSeedListType),
                "INVALID_COUNTRY_CODES" => Some(Self::InvalidCountryCodes),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestErrorEnum {}
/// Nested message and enum types in `CustomInterestErrorEnum`.
pub mod custom_interest_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestError {
        Unspecified = 0,
        Unknown = 1,
        NameAlreadyUsed = 2,
        CustomInterestMemberIdAndTypeParameterNotPresentInRemove = 3,
        TypeAndParameterNotFound = 4,
        TypeAndParameterAlreadyExisted = 5,
        InvalidCustomInterestMemberType = 6,
        CannotRemoveWhileInUse = 7,
        CannotChangeType = 8,
    }
    impl CustomInterestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomInterestError::Unspecified => "UNSPECIFIED",
                CustomInterestError::Unknown => "UNKNOWN",
                CustomInterestError::NameAlreadyUsed => "NAME_ALREADY_USED",
                CustomInterestError::CustomInterestMemberIdAndTypeParameterNotPresentInRemove => {
                    "CUSTOM_INTEREST_MEMBER_ID_AND_TYPE_PARAMETER_NOT_PRESENT_IN_REMOVE"
                }
                CustomInterestError::TypeAndParameterNotFound => {
                    "TYPE_AND_PARAMETER_NOT_FOUND"
                }
                CustomInterestError::TypeAndParameterAlreadyExisted => {
                    "TYPE_AND_PARAMETER_ALREADY_EXISTED"
                }
                CustomInterestError::InvalidCustomInterestMemberType => {
                    "INVALID_CUSTOM_INTEREST_MEMBER_TYPE"
                }
                CustomInterestError::CannotRemoveWhileInUse => {
                    "CANNOT_REMOVE_WHILE_IN_USE"
                }
                CustomInterestError::CannotChangeType => "CANNOT_CHANGE_TYPE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "CUSTOM_INTEREST_MEMBER_ID_AND_TYPE_PARAMETER_NOT_PRESENT_IN_REMOVE" => {
                    Some(Self::CustomInterestMemberIdAndTypeParameterNotPresentInRemove)
                }
                "TYPE_AND_PARAMETER_NOT_FOUND" => Some(Self::TypeAndParameterNotFound),
                "TYPE_AND_PARAMETER_ALREADY_EXISTED" => {
                    Some(Self::TypeAndParameterAlreadyExisted)
                }
                "INVALID_CUSTOM_INTEREST_MEMBER_TYPE" => {
                    Some(Self::InvalidCustomInterestMemberType)
                }
                "CANNOT_REMOVE_WHILE_IN_USE" => Some(Self::CannotRemoveWhileInUse),
                "CANNOT_CHANGE_TYPE" => Some(Self::CannotChangeType),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerFeedErrorEnum {}
/// Nested message and enum types in `CustomerFeedErrorEnum`.
pub mod customer_feed_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerFeedError {
        Unspecified = 0,
        Unknown = 1,
        FeedAlreadyExistsForPlaceholderType = 2,
        CannotCreateForRemovedFeed = 3,
        CannotCreateAlreadyExistingCustomerFeed = 4,
        CannotModifyRemovedCustomerFeed = 5,
        InvalidPlaceholderType = 6,
        MissingFeedmappingForPlaceholderType = 7,
        PlaceholderTypeNotAllowedOnCustomerFeed = 8,
    }
    impl CustomerFeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerFeedError::Unspecified => "UNSPECIFIED",
                CustomerFeedError::Unknown => "UNKNOWN",
                CustomerFeedError::FeedAlreadyExistsForPlaceholderType => {
                    "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                CustomerFeedError::CannotCreateForRemovedFeed => {
                    "CANNOT_CREATE_FOR_REMOVED_FEED"
                }
                CustomerFeedError::CannotCreateAlreadyExistingCustomerFeed => {
                    "CANNOT_CREATE_ALREADY_EXISTING_CUSTOMER_FEED"
                }
                CustomerFeedError::CannotModifyRemovedCustomerFeed => {
                    "CANNOT_MODIFY_REMOVED_CUSTOMER_FEED"
                }
                CustomerFeedError::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                CustomerFeedError::MissingFeedmappingForPlaceholderType => {
                    "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE"
                }
                CustomerFeedError::PlaceholderTypeNotAllowedOnCustomerFeed => {
                    "PLACEHOLDER_TYPE_NOT_ALLOWED_ON_CUSTOMER_FEED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::FeedAlreadyExistsForPlaceholderType)
                }
                "CANNOT_CREATE_FOR_REMOVED_FEED" => {
                    Some(Self::CannotCreateForRemovedFeed)
                }
                "CANNOT_CREATE_ALREADY_EXISTING_CUSTOMER_FEED" => {
                    Some(Self::CannotCreateAlreadyExistingCustomerFeed)
                }
                "CANNOT_MODIFY_REMOVED_CUSTOMER_FEED" => {
                    Some(Self::CannotModifyRemovedCustomerFeed)
                }
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "MISSING_FEEDMAPPING_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MissingFeedmappingForPlaceholderType)
                }
                "PLACEHOLDER_TYPE_NOT_ALLOWED_ON_CUSTOMER_FEED" => {
                    Some(Self::PlaceholderTypeNotAllowedOnCustomerFeed)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEventErrorEnum {}
/// Nested message and enum types in `ChangeEventErrorEnum`.
pub mod change_event_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeEventError {
        Unspecified = 0,
        Unknown = 1,
        StartDateTooOld = 2,
        ChangeDateRangeInfinite = 3,
        ChangeDateRangeNegative = 4,
        LimitNotSpecified = 5,
        InvalidLimitClause = 6,
    }
    impl ChangeEventError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeEventError::Unspecified => "UNSPECIFIED",
                ChangeEventError::Unknown => "UNKNOWN",
                ChangeEventError::StartDateTooOld => "START_DATE_TOO_OLD",
                ChangeEventError::ChangeDateRangeInfinite => "CHANGE_DATE_RANGE_INFINITE",
                ChangeEventError::ChangeDateRangeNegative => "CHANGE_DATE_RANGE_NEGATIVE",
                ChangeEventError::LimitNotSpecified => "LIMIT_NOT_SPECIFIED",
                ChangeEventError::InvalidLimitClause => "INVALID_LIMIT_CLAUSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "START_DATE_TOO_OLD" => Some(Self::StartDateTooOld),
                "CHANGE_DATE_RANGE_INFINITE" => Some(Self::ChangeDateRangeInfinite),
                "CHANGE_DATE_RANGE_NEGATIVE" => Some(Self::ChangeDateRangeNegative),
                "LIMIT_NOT_SPECIFIED" => Some(Self::LimitNotSpecified),
                "INVALID_LIMIT_CLAUSE" => Some(Self::InvalidLimitClause),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantSuggestionErrorEnum {}
/// Nested message and enum types in `GeoTargetConstantSuggestionErrorEnum`.
pub mod geo_target_constant_suggestion_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetConstantSuggestionError {
        Unspecified = 0,
        Unknown = 1,
        LocationNameSizeLimit = 2,
        LocationNameLimit = 3,
        InvalidCountryCode = 4,
        RequestParametersUnset = 5,
    }
    impl GeoTargetConstantSuggestionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GeoTargetConstantSuggestionError::Unspecified => "UNSPECIFIED",
                GeoTargetConstantSuggestionError::Unknown => "UNKNOWN",
                GeoTargetConstantSuggestionError::LocationNameSizeLimit => {
                    "LOCATION_NAME_SIZE_LIMIT"
                }
                GeoTargetConstantSuggestionError::LocationNameLimit => {
                    "LOCATION_NAME_LIMIT"
                }
                GeoTargetConstantSuggestionError::InvalidCountryCode => {
                    "INVALID_COUNTRY_CODE"
                }
                GeoTargetConstantSuggestionError::RequestParametersUnset => {
                    "REQUEST_PARAMETERS_UNSET"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_NAME_SIZE_LIMIT" => Some(Self::LocationNameSizeLimit),
                "LOCATION_NAME_LIMIT" => Some(Self::LocationNameLimit),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "REQUEST_PARAMETERS_UNSET" => Some(Self::RequestParametersUnset),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceAccessDeniedErrorEnum {}
/// Nested message and enum types in `ResourceAccessDeniedErrorEnum`.
pub mod resource_access_denied_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceAccessDeniedError {
        Unspecified = 0,
        Unknown = 1,
        WriteAccessDenied = 3,
    }
    impl ResourceAccessDeniedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceAccessDeniedError::Unspecified => "UNSPECIFIED",
                ResourceAccessDeniedError::Unknown => "UNKNOWN",
                ResourceAccessDeniedError::WriteAccessDenied => "WRITE_ACCESS_DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WRITE_ACCESS_DENIED" => Some(Self::WriteAccessDenied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetErrorEnum {}
/// Nested message and enum types in `FeedItemSetErrorEnum`.
pub mod feed_item_set_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetError {
        Unspecified = 0,
        Unknown = 1,
        FeedItemSetRemoved = 2,
        CannotClearDynamicFilter = 3,
        CannotCreateDynamicFilter = 4,
        InvalidFeedType = 5,
        DuplicateName = 6,
        WrongDynamicFilterForFeedType = 7,
        DynamicFilterInvalidChainIds = 8,
    }
    impl FeedItemSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemSetError::Unspecified => "UNSPECIFIED",
                FeedItemSetError::Unknown => "UNKNOWN",
                FeedItemSetError::FeedItemSetRemoved => "FEED_ITEM_SET_REMOVED",
                FeedItemSetError::CannotClearDynamicFilter => {
                    "CANNOT_CLEAR_DYNAMIC_FILTER"
                }
                FeedItemSetError::CannotCreateDynamicFilter => {
                    "CANNOT_CREATE_DYNAMIC_FILTER"
                }
                FeedItemSetError::InvalidFeedType => "INVALID_FEED_TYPE",
                FeedItemSetError::DuplicateName => "DUPLICATE_NAME",
                FeedItemSetError::WrongDynamicFilterForFeedType => {
                    "WRONG_DYNAMIC_FILTER_FOR_FEED_TYPE"
                }
                FeedItemSetError::DynamicFilterInvalidChainIds => {
                    "DYNAMIC_FILTER_INVALID_CHAIN_IDS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ITEM_SET_REMOVED" => Some(Self::FeedItemSetRemoved),
                "CANNOT_CLEAR_DYNAMIC_FILTER" => Some(Self::CannotClearDynamicFilter),
                "CANNOT_CREATE_DYNAMIC_FILTER" => Some(Self::CannotCreateDynamicFilter),
                "INVALID_FEED_TYPE" => Some(Self::InvalidFeedType),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "WRONG_DYNAMIC_FILTER_FOR_FEED_TYPE" => {
                    Some(Self::WrongDynamicFilterForFeedType)
                }
                "DYNAMIC_FILTER_INVALID_CHAIN_IDS" => {
                    Some(Self::DynamicFilterInvalidChainIds)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperatorErrorEnum {}
/// Nested message and enum types in `OperatorErrorEnum`.
pub mod operator_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatorError {
        Unspecified = 0,
        Unknown = 1,
        OperatorNotSupported = 2,
    }
    impl OperatorError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperatorError::Unspecified => "UNSPECIFIED",
                OperatorError::Unknown => "UNKNOWN",
                OperatorError::OperatorNotSupported => "OPERATOR_NOT_SUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATOR_NOT_SUPPORTED" => Some(Self::OperatorNotSupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedCriterionErrorEnum {}
/// Nested message and enum types in `SharedCriterionErrorEnum`.
pub mod shared_criterion_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedCriterionError {
        Unspecified = 0,
        Unknown = 1,
        CriterionTypeNotAllowedForSharedSetType = 2,
    }
    impl SharedCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SharedCriterionError::Unspecified => "UNSPECIFIED",
                SharedCriterionError::Unknown => "UNKNOWN",
                SharedCriterionError::CriterionTypeNotAllowedForSharedSetType => {
                    "CRITERION_TYPE_NOT_ALLOWED_FOR_SHARED_SET_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_TYPE_NOT_ALLOWED_FOR_SHARED_SET_TYPE" => {
                    Some(Self::CriterionTypeNotAllowedForSharedSetType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UrlFieldErrorEnum {}
/// Nested message and enum types in `UrlFieldErrorEnum`.
pub mod url_field_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UrlFieldError {
        Unspecified = 0,
        Unknown = 1,
        InvalidTrackingUrlTemplate = 2,
        InvalidTagInTrackingUrlTemplate = 3,
        MissingTrackingUrlTemplateTag = 4,
        MissingProtocolInTrackingUrlTemplate = 5,
        InvalidProtocolInTrackingUrlTemplate = 6,
        MalformedTrackingUrlTemplate = 7,
        MissingHostInTrackingUrlTemplate = 8,
        InvalidTldInTrackingUrlTemplate = 9,
        RedundantNestedTrackingUrlTemplateTag = 10,
        InvalidFinalUrl = 11,
        InvalidTagInFinalUrl = 12,
        RedundantNestedFinalUrlTag = 13,
        MissingProtocolInFinalUrl = 14,
        InvalidProtocolInFinalUrl = 15,
        MalformedFinalUrl = 16,
        MissingHostInFinalUrl = 17,
        InvalidTldInFinalUrl = 18,
        InvalidFinalMobileUrl = 19,
        InvalidTagInFinalMobileUrl = 20,
        RedundantNestedFinalMobileUrlTag = 21,
        MissingProtocolInFinalMobileUrl = 22,
        InvalidProtocolInFinalMobileUrl = 23,
        MalformedFinalMobileUrl = 24,
        MissingHostInFinalMobileUrl = 25,
        InvalidTldInFinalMobileUrl = 26,
        InvalidFinalAppUrl = 27,
        InvalidTagInFinalAppUrl = 28,
        RedundantNestedFinalAppUrlTag = 29,
        MultipleAppUrlsForOstype = 30,
        InvalidOstype = 31,
        InvalidProtocolForAppUrl = 32,
        InvalidPackageIdForAppUrl = 33,
        UrlCustomParametersCountExceedsLimit = 34,
        InvalidCharactersInUrlCustomParameterKey = 39,
        InvalidCharactersInUrlCustomParameterValue = 40,
        InvalidTagInUrlCustomParameterValue = 41,
        RedundantNestedUrlCustomParameterTag = 42,
        MissingProtocol = 43,
        InvalidProtocol = 52,
        InvalidUrl = 44,
        DestinationUrlDeprecated = 45,
        InvalidTagInUrl = 46,
        MissingUrlTag = 47,
        DuplicateUrlId = 48,
        InvalidUrlId = 49,
        FinalUrlSuffixMalformed = 50,
        InvalidTagInFinalUrlSuffix = 51,
        InvalidTopLevelDomain = 53,
        MalformedTopLevelDomain = 54,
        MalformedUrl = 55,
        MissingHost = 56,
        NullCustomParameterValue = 57,
        ValueTrackParameterNotSupported = 58,
    }
    impl UrlFieldError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UrlFieldError::Unspecified => "UNSPECIFIED",
                UrlFieldError::Unknown => "UNKNOWN",
                UrlFieldError::InvalidTrackingUrlTemplate => {
                    "INVALID_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::InvalidTagInTrackingUrlTemplate => {
                    "INVALID_TAG_IN_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::MissingTrackingUrlTemplateTag => {
                    "MISSING_TRACKING_URL_TEMPLATE_TAG"
                }
                UrlFieldError::MissingProtocolInTrackingUrlTemplate => {
                    "MISSING_PROTOCOL_IN_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::InvalidProtocolInTrackingUrlTemplate => {
                    "INVALID_PROTOCOL_IN_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::MalformedTrackingUrlTemplate => {
                    "MALFORMED_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::MissingHostInTrackingUrlTemplate => {
                    "MISSING_HOST_IN_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::InvalidTldInTrackingUrlTemplate => {
                    "INVALID_TLD_IN_TRACKING_URL_TEMPLATE"
                }
                UrlFieldError::RedundantNestedTrackingUrlTemplateTag => {
                    "REDUNDANT_NESTED_TRACKING_URL_TEMPLATE_TAG"
                }
                UrlFieldError::InvalidFinalUrl => "INVALID_FINAL_URL",
                UrlFieldError::InvalidTagInFinalUrl => "INVALID_TAG_IN_FINAL_URL",
                UrlFieldError::RedundantNestedFinalUrlTag => {
                    "REDUNDANT_NESTED_FINAL_URL_TAG"
                }
                UrlFieldError::MissingProtocolInFinalUrl => {
                    "MISSING_PROTOCOL_IN_FINAL_URL"
                }
                UrlFieldError::InvalidProtocolInFinalUrl => {
                    "INVALID_PROTOCOL_IN_FINAL_URL"
                }
                UrlFieldError::MalformedFinalUrl => "MALFORMED_FINAL_URL",
                UrlFieldError::MissingHostInFinalUrl => "MISSING_HOST_IN_FINAL_URL",
                UrlFieldError::InvalidTldInFinalUrl => "INVALID_TLD_IN_FINAL_URL",
                UrlFieldError::InvalidFinalMobileUrl => "INVALID_FINAL_MOBILE_URL",
                UrlFieldError::InvalidTagInFinalMobileUrl => {
                    "INVALID_TAG_IN_FINAL_MOBILE_URL"
                }
                UrlFieldError::RedundantNestedFinalMobileUrlTag => {
                    "REDUNDANT_NESTED_FINAL_MOBILE_URL_TAG"
                }
                UrlFieldError::MissingProtocolInFinalMobileUrl => {
                    "MISSING_PROTOCOL_IN_FINAL_MOBILE_URL"
                }
                UrlFieldError::InvalidProtocolInFinalMobileUrl => {
                    "INVALID_PROTOCOL_IN_FINAL_MOBILE_URL"
                }
                UrlFieldError::MalformedFinalMobileUrl => "MALFORMED_FINAL_MOBILE_URL",
                UrlFieldError::MissingHostInFinalMobileUrl => {
                    "MISSING_HOST_IN_FINAL_MOBILE_URL"
                }
                UrlFieldError::InvalidTldInFinalMobileUrl => {
                    "INVALID_TLD_IN_FINAL_MOBILE_URL"
                }
                UrlFieldError::InvalidFinalAppUrl => "INVALID_FINAL_APP_URL",
                UrlFieldError::InvalidTagInFinalAppUrl => "INVALID_TAG_IN_FINAL_APP_URL",
                UrlFieldError::RedundantNestedFinalAppUrlTag => {
                    "REDUNDANT_NESTED_FINAL_APP_URL_TAG"
                }
                UrlFieldError::MultipleAppUrlsForOstype => "MULTIPLE_APP_URLS_FOR_OSTYPE",
                UrlFieldError::InvalidOstype => "INVALID_OSTYPE",
                UrlFieldError::InvalidProtocolForAppUrl => "INVALID_PROTOCOL_FOR_APP_URL",
                UrlFieldError::InvalidPackageIdForAppUrl => {
                    "INVALID_PACKAGE_ID_FOR_APP_URL"
                }
                UrlFieldError::UrlCustomParametersCountExceedsLimit => {
                    "URL_CUSTOM_PARAMETERS_COUNT_EXCEEDS_LIMIT"
                }
                UrlFieldError::InvalidCharactersInUrlCustomParameterKey => {
                    "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_KEY"
                }
                UrlFieldError::InvalidCharactersInUrlCustomParameterValue => {
                    "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_VALUE"
                }
                UrlFieldError::InvalidTagInUrlCustomParameterValue => {
                    "INVALID_TAG_IN_URL_CUSTOM_PARAMETER_VALUE"
                }
                UrlFieldError::RedundantNestedUrlCustomParameterTag => {
                    "REDUNDANT_NESTED_URL_CUSTOM_PARAMETER_TAG"
                }
                UrlFieldError::MissingProtocol => "MISSING_PROTOCOL",
                UrlFieldError::InvalidProtocol => "INVALID_PROTOCOL",
                UrlFieldError::InvalidUrl => "INVALID_URL",
                UrlFieldError::DestinationUrlDeprecated => "DESTINATION_URL_DEPRECATED",
                UrlFieldError::InvalidTagInUrl => "INVALID_TAG_IN_URL",
                UrlFieldError::MissingUrlTag => "MISSING_URL_TAG",
                UrlFieldError::DuplicateUrlId => "DUPLICATE_URL_ID",
                UrlFieldError::InvalidUrlId => "INVALID_URL_ID",
                UrlFieldError::FinalUrlSuffixMalformed => "FINAL_URL_SUFFIX_MALFORMED",
                UrlFieldError::InvalidTagInFinalUrlSuffix => {
                    "INVALID_TAG_IN_FINAL_URL_SUFFIX"
                }
                UrlFieldError::InvalidTopLevelDomain => "INVALID_TOP_LEVEL_DOMAIN",
                UrlFieldError::MalformedTopLevelDomain => "MALFORMED_TOP_LEVEL_DOMAIN",
                UrlFieldError::MalformedUrl => "MALFORMED_URL",
                UrlFieldError::MissingHost => "MISSING_HOST",
                UrlFieldError::NullCustomParameterValue => "NULL_CUSTOM_PARAMETER_VALUE",
                UrlFieldError::ValueTrackParameterNotSupported => {
                    "VALUE_TRACK_PARAMETER_NOT_SUPPORTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_TRACKING_URL_TEMPLATE" => Some(Self::InvalidTrackingUrlTemplate),
                "INVALID_TAG_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidTagInTrackingUrlTemplate)
                }
                "MISSING_TRACKING_URL_TEMPLATE_TAG" => {
                    Some(Self::MissingTrackingUrlTemplateTag)
                }
                "MISSING_PROTOCOL_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MissingProtocolInTrackingUrlTemplate)
                }
                "INVALID_PROTOCOL_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidProtocolInTrackingUrlTemplate)
                }
                "MALFORMED_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MalformedTrackingUrlTemplate)
                }
                "MISSING_HOST_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::MissingHostInTrackingUrlTemplate)
                }
                "INVALID_TLD_IN_TRACKING_URL_TEMPLATE" => {
                    Some(Self::InvalidTldInTrackingUrlTemplate)
                }
                "REDUNDANT_NESTED_TRACKING_URL_TEMPLATE_TAG" => {
                    Some(Self::RedundantNestedTrackingUrlTemplateTag)
                }
                "INVALID_FINAL_URL" => Some(Self::InvalidFinalUrl),
                "INVALID_TAG_IN_FINAL_URL" => Some(Self::InvalidTagInFinalUrl),
                "REDUNDANT_NESTED_FINAL_URL_TAG" => {
                    Some(Self::RedundantNestedFinalUrlTag)
                }
                "MISSING_PROTOCOL_IN_FINAL_URL" => Some(Self::MissingProtocolInFinalUrl),
                "INVALID_PROTOCOL_IN_FINAL_URL" => Some(Self::InvalidProtocolInFinalUrl),
                "MALFORMED_FINAL_URL" => Some(Self::MalformedFinalUrl),
                "MISSING_HOST_IN_FINAL_URL" => Some(Self::MissingHostInFinalUrl),
                "INVALID_TLD_IN_FINAL_URL" => Some(Self::InvalidTldInFinalUrl),
                "INVALID_FINAL_MOBILE_URL" => Some(Self::InvalidFinalMobileUrl),
                "INVALID_TAG_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidTagInFinalMobileUrl)
                }
                "REDUNDANT_NESTED_FINAL_MOBILE_URL_TAG" => {
                    Some(Self::RedundantNestedFinalMobileUrlTag)
                }
                "MISSING_PROTOCOL_IN_FINAL_MOBILE_URL" => {
                    Some(Self::MissingProtocolInFinalMobileUrl)
                }
                "INVALID_PROTOCOL_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidProtocolInFinalMobileUrl)
                }
                "MALFORMED_FINAL_MOBILE_URL" => Some(Self::MalformedFinalMobileUrl),
                "MISSING_HOST_IN_FINAL_MOBILE_URL" => {
                    Some(Self::MissingHostInFinalMobileUrl)
                }
                "INVALID_TLD_IN_FINAL_MOBILE_URL" => {
                    Some(Self::InvalidTldInFinalMobileUrl)
                }
                "INVALID_FINAL_APP_URL" => Some(Self::InvalidFinalAppUrl),
                "INVALID_TAG_IN_FINAL_APP_URL" => Some(Self::InvalidTagInFinalAppUrl),
                "REDUNDANT_NESTED_FINAL_APP_URL_TAG" => {
                    Some(Self::RedundantNestedFinalAppUrlTag)
                }
                "MULTIPLE_APP_URLS_FOR_OSTYPE" => Some(Self::MultipleAppUrlsForOstype),
                "INVALID_OSTYPE" => Some(Self::InvalidOstype),
                "INVALID_PROTOCOL_FOR_APP_URL" => Some(Self::InvalidProtocolForAppUrl),
                "INVALID_PACKAGE_ID_FOR_APP_URL" => Some(Self::InvalidPackageIdForAppUrl),
                "URL_CUSTOM_PARAMETERS_COUNT_EXCEEDS_LIMIT" => {
                    Some(Self::UrlCustomParametersCountExceedsLimit)
                }
                "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_KEY" => {
                    Some(Self::InvalidCharactersInUrlCustomParameterKey)
                }
                "INVALID_CHARACTERS_IN_URL_CUSTOM_PARAMETER_VALUE" => {
                    Some(Self::InvalidCharactersInUrlCustomParameterValue)
                }
                "INVALID_TAG_IN_URL_CUSTOM_PARAMETER_VALUE" => {
                    Some(Self::InvalidTagInUrlCustomParameterValue)
                }
                "REDUNDANT_NESTED_URL_CUSTOM_PARAMETER_TAG" => {
                    Some(Self::RedundantNestedUrlCustomParameterTag)
                }
                "MISSING_PROTOCOL" => Some(Self::MissingProtocol),
                "INVALID_PROTOCOL" => Some(Self::InvalidProtocol),
                "INVALID_URL" => Some(Self::InvalidUrl),
                "DESTINATION_URL_DEPRECATED" => Some(Self::DestinationUrlDeprecated),
                "INVALID_TAG_IN_URL" => Some(Self::InvalidTagInUrl),
                "MISSING_URL_TAG" => Some(Self::MissingUrlTag),
                "DUPLICATE_URL_ID" => Some(Self::DuplicateUrlId),
                "INVALID_URL_ID" => Some(Self::InvalidUrlId),
                "FINAL_URL_SUFFIX_MALFORMED" => Some(Self::FinalUrlSuffixMalformed),
                "INVALID_TAG_IN_FINAL_URL_SUFFIX" => {
                    Some(Self::InvalidTagInFinalUrlSuffix)
                }
                "INVALID_TOP_LEVEL_DOMAIN" => Some(Self::InvalidTopLevelDomain),
                "MALFORMED_TOP_LEVEL_DOMAIN" => Some(Self::MalformedTopLevelDomain),
                "MALFORMED_URL" => Some(Self::MalformedUrl),
                "MISSING_HOST" => Some(Self::MissingHost),
                "NULL_CUSTOM_PARAMETER_VALUE" => Some(Self::NullCustomParameterValue),
                "VALUE_TRACK_PARAMETER_NOT_SUPPORTED" => {
                    Some(Self::ValueTrackParameterNotSupported)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessInvitationErrorEnum {}
/// Nested message and enum types in `AccessInvitationErrorEnum`.
pub mod access_invitation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessInvitationError {
        Unspecified = 0,
        Unknown = 1,
        InvalidEmailAddress = 2,
        EmailAddressAlreadyHasAccess = 3,
        InvalidInvitationStatus = 4,
        GoogleConsumerAccountNotAllowed = 5,
        InvalidInvitationId = 6,
        EmailAddressAlreadyHasPendingInvitation = 7,
        PendingInvitationsLimitExceeded = 8,
        EmailDomainPolicyViolated = 9,
    }
    impl AccessInvitationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccessInvitationError::Unspecified => "UNSPECIFIED",
                AccessInvitationError::Unknown => "UNKNOWN",
                AccessInvitationError::InvalidEmailAddress => "INVALID_EMAIL_ADDRESS",
                AccessInvitationError::EmailAddressAlreadyHasAccess => {
                    "EMAIL_ADDRESS_ALREADY_HAS_ACCESS"
                }
                AccessInvitationError::InvalidInvitationStatus => {
                    "INVALID_INVITATION_STATUS"
                }
                AccessInvitationError::GoogleConsumerAccountNotAllowed => {
                    "GOOGLE_CONSUMER_ACCOUNT_NOT_ALLOWED"
                }
                AccessInvitationError::InvalidInvitationId => "INVALID_INVITATION_ID",
                AccessInvitationError::EmailAddressAlreadyHasPendingInvitation => {
                    "EMAIL_ADDRESS_ALREADY_HAS_PENDING_INVITATION"
                }
                AccessInvitationError::PendingInvitationsLimitExceeded => {
                    "PENDING_INVITATIONS_LIMIT_EXCEEDED"
                }
                AccessInvitationError::EmailDomainPolicyViolated => {
                    "EMAIL_DOMAIN_POLICY_VIOLATED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_EMAIL_ADDRESS" => Some(Self::InvalidEmailAddress),
                "EMAIL_ADDRESS_ALREADY_HAS_ACCESS" => {
                    Some(Self::EmailAddressAlreadyHasAccess)
                }
                "INVALID_INVITATION_STATUS" => Some(Self::InvalidInvitationStatus),
                "GOOGLE_CONSUMER_ACCOUNT_NOT_ALLOWED" => {
                    Some(Self::GoogleConsumerAccountNotAllowed)
                }
                "INVALID_INVITATION_ID" => Some(Self::InvalidInvitationId),
                "EMAIL_ADDRESS_ALREADY_HAS_PENDING_INVITATION" => {
                    Some(Self::EmailAddressAlreadyHasPendingInvitation)
                }
                "PENDING_INVITATIONS_LIMIT_EXCEEDED" => {
                    Some(Self::PendingInvitationsLimitExceeded)
                }
                "EMAIL_DOMAIN_POLICY_VIOLATED" => Some(Self::EmailDomainPolicyViolated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalErrorEnum {}
/// Nested message and enum types in `AccountBudgetProposalErrorEnum`.
pub mod account_budget_proposal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalError {
        Unspecified = 0,
        Unknown = 1,
        FieldMaskNotAllowed = 2,
        ImmutableField = 3,
        RequiredFieldMissing = 4,
        CannotCancelApprovedProposal = 5,
        CannotRemoveUnapprovedBudget = 6,
        CannotRemoveRunningBudget = 7,
        CannotEndUnapprovedBudget = 8,
        CannotEndInactiveBudget = 9,
        BudgetNameRequired = 10,
        CannotUpdateOldBudget = 11,
        CannotEndInPast = 12,
        CannotExtendEndTime = 13,
        PurchaseOrderNumberRequired = 14,
        PendingUpdateProposalExists = 15,
        MultipleBudgetsNotAllowedForUnapprovedBillingSetup = 16,
        CannotUpdateStartTimeForStartedBudget = 17,
        SpendingLimitLowerThanAccruedCostNotAllowed = 18,
        UpdateIsNoOp = 19,
        EndTimeMustFollowStartTime = 20,
        BudgetDateRangeIncompatibleWithBillingSetup = 21,
        NotAuthorized = 22,
        InvalidBillingSetup = 23,
        OverlapsExistingBudget = 24,
        CannotCreateBudgetThroughApi = 25,
        InvalidMasterServiceAgreement = 26,
        CanceledBillingSetup = 27,
    }
    impl AccountBudgetProposalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountBudgetProposalError::Unspecified => "UNSPECIFIED",
                AccountBudgetProposalError::Unknown => "UNKNOWN",
                AccountBudgetProposalError::FieldMaskNotAllowed => {
                    "FIELD_MASK_NOT_ALLOWED"
                }
                AccountBudgetProposalError::ImmutableField => "IMMUTABLE_FIELD",
                AccountBudgetProposalError::RequiredFieldMissing => {
                    "REQUIRED_FIELD_MISSING"
                }
                AccountBudgetProposalError::CannotCancelApprovedProposal => {
                    "CANNOT_CANCEL_APPROVED_PROPOSAL"
                }
                AccountBudgetProposalError::CannotRemoveUnapprovedBudget => {
                    "CANNOT_REMOVE_UNAPPROVED_BUDGET"
                }
                AccountBudgetProposalError::CannotRemoveRunningBudget => {
                    "CANNOT_REMOVE_RUNNING_BUDGET"
                }
                AccountBudgetProposalError::CannotEndUnapprovedBudget => {
                    "CANNOT_END_UNAPPROVED_BUDGET"
                }
                AccountBudgetProposalError::CannotEndInactiveBudget => {
                    "CANNOT_END_INACTIVE_BUDGET"
                }
                AccountBudgetProposalError::BudgetNameRequired => "BUDGET_NAME_REQUIRED",
                AccountBudgetProposalError::CannotUpdateOldBudget => {
                    "CANNOT_UPDATE_OLD_BUDGET"
                }
                AccountBudgetProposalError::CannotEndInPast => "CANNOT_END_IN_PAST",
                AccountBudgetProposalError::CannotExtendEndTime => {
                    "CANNOT_EXTEND_END_TIME"
                }
                AccountBudgetProposalError::PurchaseOrderNumberRequired => {
                    "PURCHASE_ORDER_NUMBER_REQUIRED"
                }
                AccountBudgetProposalError::PendingUpdateProposalExists => {
                    "PENDING_UPDATE_PROPOSAL_EXISTS"
                }
                AccountBudgetProposalError::MultipleBudgetsNotAllowedForUnapprovedBillingSetup => {
                    "MULTIPLE_BUDGETS_NOT_ALLOWED_FOR_UNAPPROVED_BILLING_SETUP"
                }
                AccountBudgetProposalError::CannotUpdateStartTimeForStartedBudget => {
                    "CANNOT_UPDATE_START_TIME_FOR_STARTED_BUDGET"
                }
                AccountBudgetProposalError::SpendingLimitLowerThanAccruedCostNotAllowed => {
                    "SPENDING_LIMIT_LOWER_THAN_ACCRUED_COST_NOT_ALLOWED"
                }
                AccountBudgetProposalError::UpdateIsNoOp => "UPDATE_IS_NO_OP",
                AccountBudgetProposalError::EndTimeMustFollowStartTime => {
                    "END_TIME_MUST_FOLLOW_START_TIME"
                }
                AccountBudgetProposalError::BudgetDateRangeIncompatibleWithBillingSetup => {
                    "BUDGET_DATE_RANGE_INCOMPATIBLE_WITH_BILLING_SETUP"
                }
                AccountBudgetProposalError::NotAuthorized => "NOT_AUTHORIZED",
                AccountBudgetProposalError::InvalidBillingSetup => {
                    "INVALID_BILLING_SETUP"
                }
                AccountBudgetProposalError::OverlapsExistingBudget => {
                    "OVERLAPS_EXISTING_BUDGET"
                }
                AccountBudgetProposalError::CannotCreateBudgetThroughApi => {
                    "CANNOT_CREATE_BUDGET_THROUGH_API"
                }
                AccountBudgetProposalError::InvalidMasterServiceAgreement => {
                    "INVALID_MASTER_SERVICE_AGREEMENT"
                }
                AccountBudgetProposalError::CanceledBillingSetup => {
                    "CANCELED_BILLING_SETUP"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIELD_MASK_NOT_ALLOWED" => Some(Self::FieldMaskNotAllowed),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "CANNOT_CANCEL_APPROVED_PROPOSAL" => {
                    Some(Self::CannotCancelApprovedProposal)
                }
                "CANNOT_REMOVE_UNAPPROVED_BUDGET" => {
                    Some(Self::CannotRemoveUnapprovedBudget)
                }
                "CANNOT_REMOVE_RUNNING_BUDGET" => Some(Self::CannotRemoveRunningBudget),
                "CANNOT_END_UNAPPROVED_BUDGET" => Some(Self::CannotEndUnapprovedBudget),
                "CANNOT_END_INACTIVE_BUDGET" => Some(Self::CannotEndInactiveBudget),
                "BUDGET_NAME_REQUIRED" => Some(Self::BudgetNameRequired),
                "CANNOT_UPDATE_OLD_BUDGET" => Some(Self::CannotUpdateOldBudget),
                "CANNOT_END_IN_PAST" => Some(Self::CannotEndInPast),
                "CANNOT_EXTEND_END_TIME" => Some(Self::CannotExtendEndTime),
                "PURCHASE_ORDER_NUMBER_REQUIRED" => {
                    Some(Self::PurchaseOrderNumberRequired)
                }
                "PENDING_UPDATE_PROPOSAL_EXISTS" => {
                    Some(Self::PendingUpdateProposalExists)
                }
                "MULTIPLE_BUDGETS_NOT_ALLOWED_FOR_UNAPPROVED_BILLING_SETUP" => {
                    Some(Self::MultipleBudgetsNotAllowedForUnapprovedBillingSetup)
                }
                "CANNOT_UPDATE_START_TIME_FOR_STARTED_BUDGET" => {
                    Some(Self::CannotUpdateStartTimeForStartedBudget)
                }
                "SPENDING_LIMIT_LOWER_THAN_ACCRUED_COST_NOT_ALLOWED" => {
                    Some(Self::SpendingLimitLowerThanAccruedCostNotAllowed)
                }
                "UPDATE_IS_NO_OP" => Some(Self::UpdateIsNoOp),
                "END_TIME_MUST_FOLLOW_START_TIME" => {
                    Some(Self::EndTimeMustFollowStartTime)
                }
                "BUDGET_DATE_RANGE_INCOMPATIBLE_WITH_BILLING_SETUP" => {
                    Some(Self::BudgetDateRangeIncompatibleWithBillingSetup)
                }
                "NOT_AUTHORIZED" => Some(Self::NotAuthorized),
                "INVALID_BILLING_SETUP" => Some(Self::InvalidBillingSetup),
                "OVERLAPS_EXISTING_BUDGET" => Some(Self::OverlapsExistingBudget),
                "CANNOT_CREATE_BUDGET_THROUGH_API" => {
                    Some(Self::CannotCreateBudgetThroughApi)
                }
                "INVALID_MASTER_SERVICE_AGREEMENT" => {
                    Some(Self::InvalidMasterServiceAgreement)
                }
                "CANCELED_BILLING_SETUP" => Some(Self::CanceledBillingSetup),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdErrorEnum {}
/// Nested message and enum types in `AdGroupAdErrorEnum`.
pub mod ad_group_ad_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdError {
        Unspecified = 0,
        Unknown = 1,
        AdGroupAdLabelDoesNotExist = 2,
        AdGroupAdLabelAlreadyExists = 3,
        AdNotUnderAdgroup = 4,
        CannotOperateOnRemovedAdgroupad = 5,
        CannotCreateDeprecatedAds = 6,
        CannotCreateTextAds = 7,
        EmptyField = 8,
        ResourceReferencedInMultipleOps = 9,
        AdTypeCannotBePaused = 10,
        AdTypeCannotBeRemoved = 11,
        CannotUpdateDeprecatedAds = 12,
    }
    impl AdGroupAdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdError::Unspecified => "UNSPECIFIED",
                AdGroupAdError::Unknown => "UNKNOWN",
                AdGroupAdError::AdGroupAdLabelDoesNotExist => {
                    "AD_GROUP_AD_LABEL_DOES_NOT_EXIST"
                }
                AdGroupAdError::AdGroupAdLabelAlreadyExists => {
                    "AD_GROUP_AD_LABEL_ALREADY_EXISTS"
                }
                AdGroupAdError::AdNotUnderAdgroup => "AD_NOT_UNDER_ADGROUP",
                AdGroupAdError::CannotOperateOnRemovedAdgroupad => {
                    "CANNOT_OPERATE_ON_REMOVED_ADGROUPAD"
                }
                AdGroupAdError::CannotCreateDeprecatedAds => {
                    "CANNOT_CREATE_DEPRECATED_ADS"
                }
                AdGroupAdError::CannotCreateTextAds => "CANNOT_CREATE_TEXT_ADS",
                AdGroupAdError::EmptyField => "EMPTY_FIELD",
                AdGroupAdError::ResourceReferencedInMultipleOps => {
                    "RESOURCE_REFERENCED_IN_MULTIPLE_OPS"
                }
                AdGroupAdError::AdTypeCannotBePaused => "AD_TYPE_CANNOT_BE_PAUSED",
                AdGroupAdError::AdTypeCannotBeRemoved => "AD_TYPE_CANNOT_BE_REMOVED",
                AdGroupAdError::CannotUpdateDeprecatedAds => {
                    "CANNOT_UPDATE_DEPRECATED_ADS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_AD_LABEL_DOES_NOT_EXIST" => {
                    Some(Self::AdGroupAdLabelDoesNotExist)
                }
                "AD_GROUP_AD_LABEL_ALREADY_EXISTS" => {
                    Some(Self::AdGroupAdLabelAlreadyExists)
                }
                "AD_NOT_UNDER_ADGROUP" => Some(Self::AdNotUnderAdgroup),
                "CANNOT_OPERATE_ON_REMOVED_ADGROUPAD" => {
                    Some(Self::CannotOperateOnRemovedAdgroupad)
                }
                "CANNOT_CREATE_DEPRECATED_ADS" => Some(Self::CannotCreateDeprecatedAds),
                "CANNOT_CREATE_TEXT_ADS" => Some(Self::CannotCreateTextAds),
                "EMPTY_FIELD" => Some(Self::EmptyField),
                "RESOURCE_REFERENCED_IN_MULTIPLE_OPS" => {
                    Some(Self::ResourceReferencedInMultipleOps)
                }
                "AD_TYPE_CANNOT_BE_PAUSED" => Some(Self::AdTypeCannotBePaused),
                "AD_TYPE_CANNOT_BE_REMOVED" => Some(Self::AdTypeCannotBeRemoved),
                "CANNOT_UPDATE_DEPRECATED_ADS" => Some(Self::CannotUpdateDeprecatedAds),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupBidModifierErrorEnum {}
/// Nested message and enum types in `AdGroupBidModifierErrorEnum`.
pub mod ad_group_bid_modifier_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupBidModifierError {
        Unspecified = 0,
        Unknown = 1,
        CriterionIdNotSupported = 2,
        CannotOverrideOptedOutCampaignCriterionBidModifier = 3,
    }
    impl AdGroupBidModifierError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupBidModifierError::Unspecified => "UNSPECIFIED",
                AdGroupBidModifierError::Unknown => "UNKNOWN",
                AdGroupBidModifierError::CriterionIdNotSupported => {
                    "CRITERION_ID_NOT_SUPPORTED"
                }
                AdGroupBidModifierError::CannotOverrideOptedOutCampaignCriterionBidModifier => {
                    "CANNOT_OVERRIDE_OPTED_OUT_CAMPAIGN_CRITERION_BID_MODIFIER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_ID_NOT_SUPPORTED" => Some(Self::CriterionIdNotSupported),
                "CANNOT_OVERRIDE_OPTED_OUT_CAMPAIGN_CRITERION_BID_MODIFIER" => {
                    Some(Self::CannotOverrideOptedOutCampaignCriterionBidModifier)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionCustomizerErrorEnum {}
/// Nested message and enum types in `AdGroupCriterionCustomizerErrorEnum`.
pub mod ad_group_criterion_customizer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionCustomizerError {
        Unspecified = 0,
        Unknown = 1,
        CriterionIsNotKeyword = 2,
    }
    impl AdGroupCriterionCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionCustomizerError::Unspecified => "UNSPECIFIED",
                AdGroupCriterionCustomizerError::Unknown => "UNKNOWN",
                AdGroupCriterionCustomizerError::CriterionIsNotKeyword => {
                    "CRITERION_IS_NOT_KEYWORD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CRITERION_IS_NOT_KEYWORD" => Some(Self::CriterionIsNotKeyword),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionErrorEnum {}
/// Nested message and enum types in `AdGroupCriterionErrorEnum`.
pub mod ad_group_criterion_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionError {
        Unspecified = 0,
        Unknown = 1,
        AdGroupCriterionLabelDoesNotExist = 2,
        AdGroupCriterionLabelAlreadyExists = 3,
        CannotAddLabelToNegativeCriterion = 4,
        TooManyOperations = 5,
        CantUpdateNegative = 6,
        ConcreteTypeRequired = 7,
        BidIncompatibleWithAdgroup = 8,
        CannotTargetAndExclude = 9,
        IllegalUrl = 10,
        InvalidKeywordText = 11,
        InvalidDestinationUrl = 12,
        MissingDestinationUrlTag = 13,
        KeywordLevelBidNotSupportedForManualcpm = 14,
        InvalidUserStatus = 15,
        CannotAddCriteriaType = 16,
        CannotExcludeCriteriaType = 17,
        CampaignTypeNotCompatibleWithPartialFailure = 27,
        OperationsForTooManyShoppingAdgroups = 28,
        CannotModifyUrlFieldsWithDuplicateElements = 29,
        CannotSetWithoutFinalUrls = 30,
        CannotClearFinalUrlsIfFinalMobileUrlsExist = 31,
        CannotClearFinalUrlsIfFinalAppUrlsExist = 32,
        CannotClearFinalUrlsIfTrackingUrlTemplateExists = 33,
        CannotClearFinalUrlsIfUrlCustomParametersExist = 34,
        CannotSetBothDestinationUrlAndFinalUrls = 35,
        CannotSetBothDestinationUrlAndTrackingUrlTemplate = 36,
        FinalUrlsNotSupportedForCriterionType = 37,
        FinalMobileUrlsNotSupportedForCriterionType = 38,
    }
    impl AdGroupCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionError::Unspecified => "UNSPECIFIED",
                AdGroupCriterionError::Unknown => "UNKNOWN",
                AdGroupCriterionError::AdGroupCriterionLabelDoesNotExist => {
                    "AD_GROUP_CRITERION_LABEL_DOES_NOT_EXIST"
                }
                AdGroupCriterionError::AdGroupCriterionLabelAlreadyExists => {
                    "AD_GROUP_CRITERION_LABEL_ALREADY_EXISTS"
                }
                AdGroupCriterionError::CannotAddLabelToNegativeCriterion => {
                    "CANNOT_ADD_LABEL_TO_NEGATIVE_CRITERION"
                }
                AdGroupCriterionError::TooManyOperations => "TOO_MANY_OPERATIONS",
                AdGroupCriterionError::CantUpdateNegative => "CANT_UPDATE_NEGATIVE",
                AdGroupCriterionError::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                AdGroupCriterionError::BidIncompatibleWithAdgroup => {
                    "BID_INCOMPATIBLE_WITH_ADGROUP"
                }
                AdGroupCriterionError::CannotTargetAndExclude => {
                    "CANNOT_TARGET_AND_EXCLUDE"
                }
                AdGroupCriterionError::IllegalUrl => "ILLEGAL_URL",
                AdGroupCriterionError::InvalidKeywordText => "INVALID_KEYWORD_TEXT",
                AdGroupCriterionError::InvalidDestinationUrl => "INVALID_DESTINATION_URL",
                AdGroupCriterionError::MissingDestinationUrlTag => {
                    "MISSING_DESTINATION_URL_TAG"
                }
                AdGroupCriterionError::KeywordLevelBidNotSupportedForManualcpm => {
                    "KEYWORD_LEVEL_BID_NOT_SUPPORTED_FOR_MANUALCPM"
                }
                AdGroupCriterionError::InvalidUserStatus => "INVALID_USER_STATUS",
                AdGroupCriterionError::CannotAddCriteriaType => {
                    "CANNOT_ADD_CRITERIA_TYPE"
                }
                AdGroupCriterionError::CannotExcludeCriteriaType => {
                    "CANNOT_EXCLUDE_CRITERIA_TYPE"
                }
                AdGroupCriterionError::CampaignTypeNotCompatibleWithPartialFailure => {
                    "CAMPAIGN_TYPE_NOT_COMPATIBLE_WITH_PARTIAL_FAILURE"
                }
                AdGroupCriterionError::OperationsForTooManyShoppingAdgroups => {
                    "OPERATIONS_FOR_TOO_MANY_SHOPPING_ADGROUPS"
                }
                AdGroupCriterionError::CannotModifyUrlFieldsWithDuplicateElements => {
                    "CANNOT_MODIFY_URL_FIELDS_WITH_DUPLICATE_ELEMENTS"
                }
                AdGroupCriterionError::CannotSetWithoutFinalUrls => {
                    "CANNOT_SET_WITHOUT_FINAL_URLS"
                }
                AdGroupCriterionError::CannotClearFinalUrlsIfFinalMobileUrlsExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_MOBILE_URLS_EXIST"
                }
                AdGroupCriterionError::CannotClearFinalUrlsIfFinalAppUrlsExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_APP_URLS_EXIST"
                }
                AdGroupCriterionError::CannotClearFinalUrlsIfTrackingUrlTemplateExists => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_TRACKING_URL_TEMPLATE_EXISTS"
                }
                AdGroupCriterionError::CannotClearFinalUrlsIfUrlCustomParametersExist => {
                    "CANNOT_CLEAR_FINAL_URLS_IF_URL_CUSTOM_PARAMETERS_EXIST"
                }
                AdGroupCriterionError::CannotSetBothDestinationUrlAndFinalUrls => {
                    "CANNOT_SET_BOTH_DESTINATION_URL_AND_FINAL_URLS"
                }
                AdGroupCriterionError::CannotSetBothDestinationUrlAndTrackingUrlTemplate => {
                    "CANNOT_SET_BOTH_DESTINATION_URL_AND_TRACKING_URL_TEMPLATE"
                }
                AdGroupCriterionError::FinalUrlsNotSupportedForCriterionType => {
                    "FINAL_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
                AdGroupCriterionError::FinalMobileUrlsNotSupportedForCriterionType => {
                    "FINAL_MOBILE_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_CRITERION_LABEL_DOES_NOT_EXIST" => {
                    Some(Self::AdGroupCriterionLabelDoesNotExist)
                }
                "AD_GROUP_CRITERION_LABEL_ALREADY_EXISTS" => {
                    Some(Self::AdGroupCriterionLabelAlreadyExists)
                }
                "CANNOT_ADD_LABEL_TO_NEGATIVE_CRITERION" => {
                    Some(Self::CannotAddLabelToNegativeCriterion)
                }
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "CANT_UPDATE_NEGATIVE" => Some(Self::CantUpdateNegative),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "BID_INCOMPATIBLE_WITH_ADGROUP" => Some(Self::BidIncompatibleWithAdgroup),
                "CANNOT_TARGET_AND_EXCLUDE" => Some(Self::CannotTargetAndExclude),
                "ILLEGAL_URL" => Some(Self::IllegalUrl),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "INVALID_DESTINATION_URL" => Some(Self::InvalidDestinationUrl),
                "MISSING_DESTINATION_URL_TAG" => Some(Self::MissingDestinationUrlTag),
                "KEYWORD_LEVEL_BID_NOT_SUPPORTED_FOR_MANUALCPM" => {
                    Some(Self::KeywordLevelBidNotSupportedForManualcpm)
                }
                "INVALID_USER_STATUS" => Some(Self::InvalidUserStatus),
                "CANNOT_ADD_CRITERIA_TYPE" => Some(Self::CannotAddCriteriaType),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CAMPAIGN_TYPE_NOT_COMPATIBLE_WITH_PARTIAL_FAILURE" => {
                    Some(Self::CampaignTypeNotCompatibleWithPartialFailure)
                }
                "OPERATIONS_FOR_TOO_MANY_SHOPPING_ADGROUPS" => {
                    Some(Self::OperationsForTooManyShoppingAdgroups)
                }
                "CANNOT_MODIFY_URL_FIELDS_WITH_DUPLICATE_ELEMENTS" => {
                    Some(Self::CannotModifyUrlFieldsWithDuplicateElements)
                }
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_MOBILE_URLS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfFinalMobileUrlsExist)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_FINAL_APP_URLS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfFinalAppUrlsExist)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_TRACKING_URL_TEMPLATE_EXISTS" => {
                    Some(Self::CannotClearFinalUrlsIfTrackingUrlTemplateExists)
                }
                "CANNOT_CLEAR_FINAL_URLS_IF_URL_CUSTOM_PARAMETERS_EXIST" => {
                    Some(Self::CannotClearFinalUrlsIfUrlCustomParametersExist)
                }
                "CANNOT_SET_BOTH_DESTINATION_URL_AND_FINAL_URLS" => {
                    Some(Self::CannotSetBothDestinationUrlAndFinalUrls)
                }
                "CANNOT_SET_BOTH_DESTINATION_URL_AND_TRACKING_URL_TEMPLATE" => {
                    Some(Self::CannotSetBothDestinationUrlAndTrackingUrlTemplate)
                }
                "FINAL_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::FinalUrlsNotSupportedForCriterionType)
                }
                "FINAL_MOBILE_URLS_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::FinalMobileUrlsNotSupportedForCriterionType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCustomizerErrorEnum {}
/// Nested message and enum types in `AdGroupCustomizerErrorEnum`.
pub mod ad_group_customizer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCustomizerError {
        Unspecified = 0,
        Unknown = 1,
    }
    impl AdGroupCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCustomizerError::Unspecified => "UNSPECIFIED",
                AdGroupCustomizerError::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupErrorEnum {}
/// Nested message and enum types in `AdGroupErrorEnum`.
pub mod ad_group_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateAdgroupName = 2,
        InvalidAdgroupName = 3,
        AdvertiserNotOnContentNetwork = 5,
        BidTooBig = 6,
        BidTypeAndBiddingStrategyMismatch = 7,
        MissingAdgroupName = 8,
        AdgroupLabelDoesNotExist = 9,
        AdgroupLabelAlreadyExists = 10,
        InvalidContentBidCriterionTypeGroup = 11,
        AdGroupTypeNotValidForAdvertisingChannelType = 12,
        AdgroupTypeNotSupportedForCampaignSalesCountry = 13,
        CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting = 14,
        PromotedHotelAdGroupsNotAvailableForCustomer = 15,
        InvalidExcludedParentAssetFieldType = 16,
        InvalidExcludedParentAssetSetType = 17,
    }
    impl AdGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupError::Unspecified => "UNSPECIFIED",
                AdGroupError::Unknown => "UNKNOWN",
                AdGroupError::DuplicateAdgroupName => "DUPLICATE_ADGROUP_NAME",
                AdGroupError::InvalidAdgroupName => "INVALID_ADGROUP_NAME",
                AdGroupError::AdvertiserNotOnContentNetwork => {
                    "ADVERTISER_NOT_ON_CONTENT_NETWORK"
                }
                AdGroupError::BidTooBig => "BID_TOO_BIG",
                AdGroupError::BidTypeAndBiddingStrategyMismatch => {
                    "BID_TYPE_AND_BIDDING_STRATEGY_MISMATCH"
                }
                AdGroupError::MissingAdgroupName => "MISSING_ADGROUP_NAME",
                AdGroupError::AdgroupLabelDoesNotExist => "ADGROUP_LABEL_DOES_NOT_EXIST",
                AdGroupError::AdgroupLabelAlreadyExists => "ADGROUP_LABEL_ALREADY_EXISTS",
                AdGroupError::InvalidContentBidCriterionTypeGroup => {
                    "INVALID_CONTENT_BID_CRITERION_TYPE_GROUP"
                }
                AdGroupError::AdGroupTypeNotValidForAdvertisingChannelType => {
                    "AD_GROUP_TYPE_NOT_VALID_FOR_ADVERTISING_CHANNEL_TYPE"
                }
                AdGroupError::AdgroupTypeNotSupportedForCampaignSalesCountry => {
                    "ADGROUP_TYPE_NOT_SUPPORTED_FOR_CAMPAIGN_SALES_COUNTRY"
                }
                AdGroupError::CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting => {
                    "CANNOT_ADD_ADGROUP_OF_TYPE_DSA_TO_CAMPAIGN_WITHOUT_DSA_SETTING"
                }
                AdGroupError::PromotedHotelAdGroupsNotAvailableForCustomer => {
                    "PROMOTED_HOTEL_AD_GROUPS_NOT_AVAILABLE_FOR_CUSTOMER"
                }
                AdGroupError::InvalidExcludedParentAssetFieldType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE"
                }
                AdGroupError::InvalidExcludedParentAssetSetType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_ADGROUP_NAME" => Some(Self::DuplicateAdgroupName),
                "INVALID_ADGROUP_NAME" => Some(Self::InvalidAdgroupName),
                "ADVERTISER_NOT_ON_CONTENT_NETWORK" => {
                    Some(Self::AdvertiserNotOnContentNetwork)
                }
                "BID_TOO_BIG" => Some(Self::BidTooBig),
                "BID_TYPE_AND_BIDDING_STRATEGY_MISMATCH" => {
                    Some(Self::BidTypeAndBiddingStrategyMismatch)
                }
                "MISSING_ADGROUP_NAME" => Some(Self::MissingAdgroupName),
                "ADGROUP_LABEL_DOES_NOT_EXIST" => Some(Self::AdgroupLabelDoesNotExist),
                "ADGROUP_LABEL_ALREADY_EXISTS" => Some(Self::AdgroupLabelAlreadyExists),
                "INVALID_CONTENT_BID_CRITERION_TYPE_GROUP" => {
                    Some(Self::InvalidContentBidCriterionTypeGroup)
                }
                "AD_GROUP_TYPE_NOT_VALID_FOR_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::AdGroupTypeNotValidForAdvertisingChannelType)
                }
                "ADGROUP_TYPE_NOT_SUPPORTED_FOR_CAMPAIGN_SALES_COUNTRY" => {
                    Some(Self::AdgroupTypeNotSupportedForCampaignSalesCountry)
                }
                "CANNOT_ADD_ADGROUP_OF_TYPE_DSA_TO_CAMPAIGN_WITHOUT_DSA_SETTING" => {
                    Some(Self::CannotAddAdgroupOfTypeDsaToCampaignWithoutDsaSetting)
                }
                "PROMOTED_HOTEL_AD_GROUPS_NOT_AVAILABLE_FOR_CUSTOMER" => {
                    Some(Self::PromotedHotelAdGroupsNotAvailableForCustomer)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetFieldType)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetSetType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdxErrorEnum {}
/// Nested message and enum types in `AdxErrorEnum`.
pub mod adx_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdxError {
        Unspecified = 0,
        Unknown = 1,
        UnsupportedFeature = 2,
    }
    impl AdxError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdxError::Unspecified => "UNSPECIFIED",
                AdxError::Unknown => "UNKNOWN",
                AdxError::UnsupportedFeature => "UNSUPPORTED_FEATURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED_FEATURE" => Some(Self::UnsupportedFeature),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetErrorEnum {}
/// Nested message and enum types in `AssetErrorEnum`.
pub mod asset_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetError {
        Unspecified = 0,
        Unknown = 1,
        CustomerNotOnAllowlistForAssetType = 13,
        DuplicateAsset = 3,
        DuplicateAssetName = 4,
        AssetDataIsMissing = 5,
        CannotModifyAssetName = 6,
        FieldIncompatibleWithAssetType = 7,
        InvalidCallToActionText = 8,
        LeadFormInvalidFieldsCombination = 9,
        LeadFormMissingAgreement = 10,
        InvalidAssetStatus = 11,
        FieldCannotBeModifiedForAssetType = 12,
        SchedulesCannotOverlap = 14,
        PromotionCannotSetPercentOffAndMoneyAmountOff = 15,
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 16,
        TooManyDecimalPlacesSpecified = 17,
        DuplicateAssetsWithDifferentFieldValue = 18,
        CallCarrierSpecificShortNumberNotAllowed = 19,
        CallCustomerConsentForCallRecordingRequired = 20,
        CallDisallowedNumberType = 21,
        CallInvalidConversionAction = 22,
        CallInvalidCountryCode = 23,
        CallInvalidDomesticPhoneNumberFormat = 24,
        CallInvalidPhoneNumber = 25,
        CallPhoneNumberNotSupportedForCountry = 26,
        CallPremiumRateNumberNotAllowed = 27,
        CallVanityPhoneNumberNotAllowed = 28,
        PriceHeaderSameAsDescription = 29,
        MobileAppInvalidAppId = 30,
        MobileAppInvalidFinalUrlForAppDownloadUrl = 31,
        NameRequiredForAssetType = 32,
        LeadFormLegacyQualifyingQuestionsDisallowed = 33,
        NameConflictForAssetType = 34,
        CannotModifyAssetSource = 35,
        CannotModifyAutomaticallyCreatedAsset = 36,
        LeadFormLocationAnswerTypeDisallowed = 37,
        PageFeedInvalidLabelText = 38,
    }
    impl AssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetError::Unspecified => "UNSPECIFIED",
                AssetError::Unknown => "UNKNOWN",
                AssetError::CustomerNotOnAllowlistForAssetType => {
                    "CUSTOMER_NOT_ON_ALLOWLIST_FOR_ASSET_TYPE"
                }
                AssetError::DuplicateAsset => "DUPLICATE_ASSET",
                AssetError::DuplicateAssetName => "DUPLICATE_ASSET_NAME",
                AssetError::AssetDataIsMissing => "ASSET_DATA_IS_MISSING",
                AssetError::CannotModifyAssetName => "CANNOT_MODIFY_ASSET_NAME",
                AssetError::FieldIncompatibleWithAssetType => {
                    "FIELD_INCOMPATIBLE_WITH_ASSET_TYPE"
                }
                AssetError::InvalidCallToActionText => "INVALID_CALL_TO_ACTION_TEXT",
                AssetError::LeadFormInvalidFieldsCombination => {
                    "LEAD_FORM_INVALID_FIELDS_COMBINATION"
                }
                AssetError::LeadFormMissingAgreement => "LEAD_FORM_MISSING_AGREEMENT",
                AssetError::InvalidAssetStatus => "INVALID_ASSET_STATUS",
                AssetError::FieldCannotBeModifiedForAssetType => {
                    "FIELD_CANNOT_BE_MODIFIED_FOR_ASSET_TYPE"
                }
                AssetError::SchedulesCannotOverlap => "SCHEDULES_CANNOT_OVERLAP",
                AssetError::PromotionCannotSetPercentOffAndMoneyAmountOff => {
                    "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF"
                }
                AssetError::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                AssetError::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                AssetError::DuplicateAssetsWithDifferentFieldValue => {
                    "DUPLICATE_ASSETS_WITH_DIFFERENT_FIELD_VALUE"
                }
                AssetError::CallCarrierSpecificShortNumberNotAllowed => {
                    "CALL_CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                AssetError::CallCustomerConsentForCallRecordingRequired => {
                    "CALL_CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                AssetError::CallDisallowedNumberType => "CALL_DISALLOWED_NUMBER_TYPE",
                AssetError::CallInvalidConversionAction => {
                    "CALL_INVALID_CONVERSION_ACTION"
                }
                AssetError::CallInvalidCountryCode => "CALL_INVALID_COUNTRY_CODE",
                AssetError::CallInvalidDomesticPhoneNumberFormat => {
                    "CALL_INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                AssetError::CallInvalidPhoneNumber => "CALL_INVALID_PHONE_NUMBER",
                AssetError::CallPhoneNumberNotSupportedForCountry => {
                    "CALL_PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                AssetError::CallPremiumRateNumberNotAllowed => {
                    "CALL_PREMIUM_RATE_NUMBER_NOT_ALLOWED"
                }
                AssetError::CallVanityPhoneNumberNotAllowed => {
                    "CALL_VANITY_PHONE_NUMBER_NOT_ALLOWED"
                }
                AssetError::PriceHeaderSameAsDescription => {
                    "PRICE_HEADER_SAME_AS_DESCRIPTION"
                }
                AssetError::MobileAppInvalidAppId => "MOBILE_APP_INVALID_APP_ID",
                AssetError::MobileAppInvalidFinalUrlForAppDownloadUrl => {
                    "MOBILE_APP_INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL"
                }
                AssetError::NameRequiredForAssetType => "NAME_REQUIRED_FOR_ASSET_TYPE",
                AssetError::LeadFormLegacyQualifyingQuestionsDisallowed => {
                    "LEAD_FORM_LEGACY_QUALIFYING_QUESTIONS_DISALLOWED"
                }
                AssetError::NameConflictForAssetType => "NAME_CONFLICT_FOR_ASSET_TYPE",
                AssetError::CannotModifyAssetSource => "CANNOT_MODIFY_ASSET_SOURCE",
                AssetError::CannotModifyAutomaticallyCreatedAsset => {
                    "CANNOT_MODIFY_AUTOMATICALLY_CREATED_ASSET"
                }
                AssetError::LeadFormLocationAnswerTypeDisallowed => {
                    "LEAD_FORM_LOCATION_ANSWER_TYPE_DISALLOWED"
                }
                AssetError::PageFeedInvalidLabelText => "PAGE_FEED_INVALID_LABEL_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER_NOT_ON_ALLOWLIST_FOR_ASSET_TYPE" => {
                    Some(Self::CustomerNotOnAllowlistForAssetType)
                }
                "DUPLICATE_ASSET" => Some(Self::DuplicateAsset),
                "DUPLICATE_ASSET_NAME" => Some(Self::DuplicateAssetName),
                "ASSET_DATA_IS_MISSING" => Some(Self::AssetDataIsMissing),
                "CANNOT_MODIFY_ASSET_NAME" => Some(Self::CannotModifyAssetName),
                "FIELD_INCOMPATIBLE_WITH_ASSET_TYPE" => {
                    Some(Self::FieldIncompatibleWithAssetType)
                }
                "INVALID_CALL_TO_ACTION_TEXT" => Some(Self::InvalidCallToActionText),
                "LEAD_FORM_INVALID_FIELDS_COMBINATION" => {
                    Some(Self::LeadFormInvalidFieldsCombination)
                }
                "LEAD_FORM_MISSING_AGREEMENT" => Some(Self::LeadFormMissingAgreement),
                "INVALID_ASSET_STATUS" => Some(Self::InvalidAssetStatus),
                "FIELD_CANNOT_BE_MODIFIED_FOR_ASSET_TYPE" => {
                    Some(Self::FieldCannotBeModifiedForAssetType)
                }
                "SCHEDULES_CANNOT_OVERLAP" => Some(Self::SchedulesCannotOverlap),
                "PROMOTION_CANNOT_SET_PERCENT_OFF_AND_MONEY_AMOUNT_OFF" => {
                    Some(Self::PromotionCannotSetPercentOffAndMoneyAmountOff)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "DUPLICATE_ASSETS_WITH_DIFFERENT_FIELD_VALUE" => {
                    Some(Self::DuplicateAssetsWithDifferentFieldValue)
                }
                "CALL_CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallCarrierSpecificShortNumberNotAllowed)
                }
                "CALL_CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CallCustomerConsentForCallRecordingRequired)
                }
                "CALL_DISALLOWED_NUMBER_TYPE" => Some(Self::CallDisallowedNumberType),
                "CALL_INVALID_CONVERSION_ACTION" => {
                    Some(Self::CallInvalidConversionAction)
                }
                "CALL_INVALID_COUNTRY_CODE" => Some(Self::CallInvalidCountryCode),
                "CALL_INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::CallInvalidDomesticPhoneNumberFormat)
                }
                "CALL_INVALID_PHONE_NUMBER" => Some(Self::CallInvalidPhoneNumber),
                "CALL_PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CallPhoneNumberNotSupportedForCountry)
                }
                "CALL_PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallPremiumRateNumberNotAllowed)
                }
                "CALL_VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CallVanityPhoneNumberNotAllowed)
                }
                "PRICE_HEADER_SAME_AS_DESCRIPTION" => {
                    Some(Self::PriceHeaderSameAsDescription)
                }
                "MOBILE_APP_INVALID_APP_ID" => Some(Self::MobileAppInvalidAppId),
                "MOBILE_APP_INVALID_FINAL_URL_FOR_APP_DOWNLOAD_URL" => {
                    Some(Self::MobileAppInvalidFinalUrlForAppDownloadUrl)
                }
                "NAME_REQUIRED_FOR_ASSET_TYPE" => Some(Self::NameRequiredForAssetType),
                "LEAD_FORM_LEGACY_QUALIFYING_QUESTIONS_DISALLOWED" => {
                    Some(Self::LeadFormLegacyQualifyingQuestionsDisallowed)
                }
                "NAME_CONFLICT_FOR_ASSET_TYPE" => Some(Self::NameConflictForAssetType),
                "CANNOT_MODIFY_ASSET_SOURCE" => Some(Self::CannotModifyAssetSource),
                "CANNOT_MODIFY_AUTOMATICALLY_CREATED_ASSET" => {
                    Some(Self::CannotModifyAutomaticallyCreatedAsset)
                }
                "LEAD_FORM_LOCATION_ANSWER_TYPE_DISALLOWED" => {
                    Some(Self::LeadFormLocationAnswerTypeDisallowed)
                }
                "PAGE_FEED_INVALID_LABEL_TEXT" => Some(Self::PageFeedInvalidLabelText),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupListingGroupFilterErrorEnum {}
/// Nested message and enum types in `AssetGroupListingGroupFilterErrorEnum`.
pub mod asset_group_listing_group_filter_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupListingGroupFilterError {
        Unspecified = 0,
        Unknown = 1,
        TreeTooDeep = 2,
        UnitCannotHaveChildren = 3,
        SubdivisionMustHaveEverythingElseChild = 4,
        DifferentDimensionTypeBetweenSiblings = 5,
        SameDimensionValueBetweenSiblings = 6,
        SameDimensionTypeBetweenAncestors = 7,
        MultipleRoots = 8,
        InvalidDimensionValue = 9,
        MustRefineHierarchicalParentType = 10,
        InvalidProductBiddingCategory = 11,
        ChangingCaseValueWithChildren = 12,
        SubdivisionHasChildren = 13,
        CannotRefineHierarchicalEverythingElse = 14,
        MultipleOperationsOnOneNode = 23,
    }
    impl AssetGroupListingGroupFilterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupListingGroupFilterError::Unspecified => "UNSPECIFIED",
                AssetGroupListingGroupFilterError::Unknown => "UNKNOWN",
                AssetGroupListingGroupFilterError::TreeTooDeep => "TREE_TOO_DEEP",
                AssetGroupListingGroupFilterError::UnitCannotHaveChildren => {
                    "UNIT_CANNOT_HAVE_CHILDREN"
                }
                AssetGroupListingGroupFilterError::SubdivisionMustHaveEverythingElseChild => {
                    "SUBDIVISION_MUST_HAVE_EVERYTHING_ELSE_CHILD"
                }
                AssetGroupListingGroupFilterError::DifferentDimensionTypeBetweenSiblings => {
                    "DIFFERENT_DIMENSION_TYPE_BETWEEN_SIBLINGS"
                }
                AssetGroupListingGroupFilterError::SameDimensionValueBetweenSiblings => {
                    "SAME_DIMENSION_VALUE_BETWEEN_SIBLINGS"
                }
                AssetGroupListingGroupFilterError::SameDimensionTypeBetweenAncestors => {
                    "SAME_DIMENSION_TYPE_BETWEEN_ANCESTORS"
                }
                AssetGroupListingGroupFilterError::MultipleRoots => "MULTIPLE_ROOTS",
                AssetGroupListingGroupFilterError::InvalidDimensionValue => {
                    "INVALID_DIMENSION_VALUE"
                }
                AssetGroupListingGroupFilterError::MustRefineHierarchicalParentType => {
                    "MUST_REFINE_HIERARCHICAL_PARENT_TYPE"
                }
                AssetGroupListingGroupFilterError::InvalidProductBiddingCategory => {
                    "INVALID_PRODUCT_BIDDING_CATEGORY"
                }
                AssetGroupListingGroupFilterError::ChangingCaseValueWithChildren => {
                    "CHANGING_CASE_VALUE_WITH_CHILDREN"
                }
                AssetGroupListingGroupFilterError::SubdivisionHasChildren => {
                    "SUBDIVISION_HAS_CHILDREN"
                }
                AssetGroupListingGroupFilterError::CannotRefineHierarchicalEverythingElse => {
                    "CANNOT_REFINE_HIERARCHICAL_EVERYTHING_ELSE"
                }
                AssetGroupListingGroupFilterError::MultipleOperationsOnOneNode => {
                    "MULTIPLE_OPERATIONS_ON_ONE_NODE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TREE_TOO_DEEP" => Some(Self::TreeTooDeep),
                "UNIT_CANNOT_HAVE_CHILDREN" => Some(Self::UnitCannotHaveChildren),
                "SUBDIVISION_MUST_HAVE_EVERYTHING_ELSE_CHILD" => {
                    Some(Self::SubdivisionMustHaveEverythingElseChild)
                }
                "DIFFERENT_DIMENSION_TYPE_BETWEEN_SIBLINGS" => {
                    Some(Self::DifferentDimensionTypeBetweenSiblings)
                }
                "SAME_DIMENSION_VALUE_BETWEEN_SIBLINGS" => {
                    Some(Self::SameDimensionValueBetweenSiblings)
                }
                "SAME_DIMENSION_TYPE_BETWEEN_ANCESTORS" => {
                    Some(Self::SameDimensionTypeBetweenAncestors)
                }
                "MULTIPLE_ROOTS" => Some(Self::MultipleRoots),
                "INVALID_DIMENSION_VALUE" => Some(Self::InvalidDimensionValue),
                "MUST_REFINE_HIERARCHICAL_PARENT_TYPE" => {
                    Some(Self::MustRefineHierarchicalParentType)
                }
                "INVALID_PRODUCT_BIDDING_CATEGORY" => {
                    Some(Self::InvalidProductBiddingCategory)
                }
                "CHANGING_CASE_VALUE_WITH_CHILDREN" => {
                    Some(Self::ChangingCaseValueWithChildren)
                }
                "SUBDIVISION_HAS_CHILDREN" => Some(Self::SubdivisionHasChildren),
                "CANNOT_REFINE_HIERARCHICAL_EVERYTHING_ELSE" => {
                    Some(Self::CannotRefineHierarchicalEverythingElse)
                }
                "MULTIPLE_OPERATIONS_ON_ONE_NODE" => {
                    Some(Self::MultipleOperationsOnOneNode)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalErrorEnum {}
/// Nested message and enum types in `AssetGroupSignalErrorEnum`.
pub mod asset_group_signal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupSignalError {
        Unspecified = 0,
        Unknown = 1,
        TooManyWords = 2,
        SearchThemePolicyViolation = 3,
        AudienceWithWrongAssetGroupId = 4,
    }
    impl AssetGroupSignalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupSignalError::Unspecified => "UNSPECIFIED",
                AssetGroupSignalError::Unknown => "UNKNOWN",
                AssetGroupSignalError::TooManyWords => "TOO_MANY_WORDS",
                AssetGroupSignalError::SearchThemePolicyViolation => {
                    "SEARCH_THEME_POLICY_VIOLATION"
                }
                AssetGroupSignalError::AudienceWithWrongAssetGroupId => {
                    "AUDIENCE_WITH_WRONG_ASSET_GROUP_ID"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TOO_MANY_WORDS" => Some(Self::TooManyWords),
                "SEARCH_THEME_POLICY_VIOLATION" => Some(Self::SearchThemePolicyViolation),
                "AUDIENCE_WITH_WRONG_ASSET_GROUP_ID" => {
                    Some(Self::AudienceWithWrongAssetGroupId)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetAssetErrorEnum {}
/// Nested message and enum types in `AssetSetAssetErrorEnum`.
pub mod asset_set_asset_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetAssetError {
        Unspecified = 0,
        Unknown = 1,
        InvalidAssetType = 2,
        InvalidAssetSetType = 3,
        DuplicateExternalKey = 4,
        ParentLinkageDoesNotExist = 5,
    }
    impl AssetSetAssetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetAssetError::Unspecified => "UNSPECIFIED",
                AssetSetAssetError::Unknown => "UNKNOWN",
                AssetSetAssetError::InvalidAssetType => "INVALID_ASSET_TYPE",
                AssetSetAssetError::InvalidAssetSetType => "INVALID_ASSET_SET_TYPE",
                AssetSetAssetError::DuplicateExternalKey => "DUPLICATE_EXTERNAL_KEY",
                AssetSetAssetError::ParentLinkageDoesNotExist => {
                    "PARENT_LINKAGE_DOES_NOT_EXIST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_ASSET_TYPE" => Some(Self::InvalidAssetType),
                "INVALID_ASSET_SET_TYPE" => Some(Self::InvalidAssetSetType),
                "DUPLICATE_EXTERNAL_KEY" => Some(Self::DuplicateExternalKey),
                "PARENT_LINKAGE_DOES_NOT_EXIST" => Some(Self::ParentLinkageDoesNotExist),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetLinkErrorEnum {}
/// Nested message and enum types in `AssetSetLinkErrorEnum`.
pub mod asset_set_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetLinkError {
        Unspecified = 0,
        Unknown = 1,
        IncompatibleAdvertisingChannelType = 2,
        DuplicateFeedLink = 3,
        IncompatibleAssetSetTypeWithCampaignType = 4,
        DuplicateAssetSetLink = 5,
        AssetSetLinkCannotBeRemoved = 6,
    }
    impl AssetSetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetLinkError::Unspecified => "UNSPECIFIED",
                AssetSetLinkError::Unknown => "UNKNOWN",
                AssetSetLinkError::IncompatibleAdvertisingChannelType => {
                    "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE"
                }
                AssetSetLinkError::DuplicateFeedLink => "DUPLICATE_FEED_LINK",
                AssetSetLinkError::IncompatibleAssetSetTypeWithCampaignType => {
                    "INCOMPATIBLE_ASSET_SET_TYPE_WITH_CAMPAIGN_TYPE"
                }
                AssetSetLinkError::DuplicateAssetSetLink => "DUPLICATE_ASSET_SET_LINK",
                AssetSetLinkError::AssetSetLinkCannotBeRemoved => {
                    "ASSET_SET_LINK_CANNOT_BE_REMOVED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INCOMPATIBLE_ADVERTISING_CHANNEL_TYPE" => {
                    Some(Self::IncompatibleAdvertisingChannelType)
                }
                "DUPLICATE_FEED_LINK" => Some(Self::DuplicateFeedLink),
                "INCOMPATIBLE_ASSET_SET_TYPE_WITH_CAMPAIGN_TYPE" => {
                    Some(Self::IncompatibleAssetSetTypeWithCampaignType)
                }
                "DUPLICATE_ASSET_SET_LINK" => Some(Self::DuplicateAssetSetLink),
                "ASSET_SET_LINK_CANNOT_BE_REMOVED" => {
                    Some(Self::AssetSetLinkCannotBeRemoved)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceErrorEnum {}
/// Nested message and enum types in `AudienceErrorEnum`.
pub mod audience_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceError {
        Unspecified = 0,
        Unknown = 1,
        NameAlreadyInUse = 2,
        DimensionInvalid = 3,
        AudienceSegmentNotFound = 4,
        AudienceSegmentTypeNotSupported = 5,
        DuplicateAudienceSegment = 6,
        TooManySegments = 7,
        TooManyDimensionsOfSameType = 8,
        InUse = 9,
        MissingAssetGroupId = 10,
        CannotChangeFromCustomerToAssetGroupScope = 11,
    }
    impl AudienceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceError::Unspecified => "UNSPECIFIED",
                AudienceError::Unknown => "UNKNOWN",
                AudienceError::NameAlreadyInUse => "NAME_ALREADY_IN_USE",
                AudienceError::DimensionInvalid => "DIMENSION_INVALID",
                AudienceError::AudienceSegmentNotFound => "AUDIENCE_SEGMENT_NOT_FOUND",
                AudienceError::AudienceSegmentTypeNotSupported => {
                    "AUDIENCE_SEGMENT_TYPE_NOT_SUPPORTED"
                }
                AudienceError::DuplicateAudienceSegment => "DUPLICATE_AUDIENCE_SEGMENT",
                AudienceError::TooManySegments => "TOO_MANY_SEGMENTS",
                AudienceError::TooManyDimensionsOfSameType => {
                    "TOO_MANY_DIMENSIONS_OF_SAME_TYPE"
                }
                AudienceError::InUse => "IN_USE",
                AudienceError::MissingAssetGroupId => "MISSING_ASSET_GROUP_ID",
                AudienceError::CannotChangeFromCustomerToAssetGroupScope => {
                    "CANNOT_CHANGE_FROM_CUSTOMER_TO_ASSET_GROUP_SCOPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_IN_USE" => Some(Self::NameAlreadyInUse),
                "DIMENSION_INVALID" => Some(Self::DimensionInvalid),
                "AUDIENCE_SEGMENT_NOT_FOUND" => Some(Self::AudienceSegmentNotFound),
                "AUDIENCE_SEGMENT_TYPE_NOT_SUPPORTED" => {
                    Some(Self::AudienceSegmentTypeNotSupported)
                }
                "DUPLICATE_AUDIENCE_SEGMENT" => Some(Self::DuplicateAudienceSegment),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "TOO_MANY_DIMENSIONS_OF_SAME_TYPE" => {
                    Some(Self::TooManyDimensionsOfSameType)
                }
                "IN_USE" => Some(Self::InUse),
                "MISSING_ASSET_GROUP_ID" => Some(Self::MissingAssetGroupId),
                "CANNOT_CHANGE_FROM_CUSTOMER_TO_ASSET_GROUP_SCOPE" => {
                    Some(Self::CannotChangeFromCustomerToAssetGroupScope)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceInsightsErrorEnum {}
/// Nested message and enum types in `AudienceInsightsErrorEnum`.
pub mod audience_insights_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceInsightsError {
        Unspecified = 0,
        Unknown = 1,
        DimensionIncompatibleWithTopicAudienceCombinations = 2,
    }
    impl AudienceInsightsError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceInsightsError::Unspecified => "UNSPECIFIED",
                AudienceInsightsError::Unknown => "UNKNOWN",
                AudienceInsightsError::DimensionIncompatibleWithTopicAudienceCombinations => {
                    "DIMENSION_INCOMPATIBLE_WITH_TOPIC_AUDIENCE_COMBINATIONS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DIMENSION_INCOMPATIBLE_WITH_TOPIC_AUDIENCE_COMBINATIONS" => {
                    Some(Self::DimensionIncompatibleWithTopicAudienceCombinations)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AuthenticationErrorEnum {}
/// Nested message and enum types in `AuthenticationErrorEnum`.
pub mod authentication_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AuthenticationError {
        Unspecified = 0,
        Unknown = 1,
        AuthenticationError = 2,
        ClientCustomerIdInvalid = 5,
        CustomerNotFound = 8,
        GoogleAccountDeleted = 9,
        GoogleAccountCookieInvalid = 10,
        GoogleAccountAuthenticationFailed = 25,
        GoogleAccountUserAndAdsUserMismatch = 12,
        LoginCookieRequired = 13,
        NotAdsUser = 14,
        OauthTokenInvalid = 15,
        OauthTokenExpired = 16,
        OauthTokenDisabled = 17,
        OauthTokenRevoked = 18,
        OauthTokenHeaderInvalid = 19,
        LoginCookieInvalid = 20,
        UserIdInvalid = 22,
        TwoStepVerificationNotEnrolled = 23,
        AdvancedProtectionNotEnrolled = 24,
        OrganizationNotRecognized = 26,
        OrganizationNotApproved = 27,
        OrganizationNotAssociatedWithDeveloperToken = 28,
    }
    impl AuthenticationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AuthenticationError::Unspecified => "UNSPECIFIED",
                AuthenticationError::Unknown => "UNKNOWN",
                AuthenticationError::AuthenticationError => "AUTHENTICATION_ERROR",
                AuthenticationError::ClientCustomerIdInvalid => {
                    "CLIENT_CUSTOMER_ID_INVALID"
                }
                AuthenticationError::CustomerNotFound => "CUSTOMER_NOT_FOUND",
                AuthenticationError::GoogleAccountDeleted => "GOOGLE_ACCOUNT_DELETED",
                AuthenticationError::GoogleAccountCookieInvalid => {
                    "GOOGLE_ACCOUNT_COOKIE_INVALID"
                }
                AuthenticationError::GoogleAccountAuthenticationFailed => {
                    "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED"
                }
                AuthenticationError::GoogleAccountUserAndAdsUserMismatch => {
                    "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH"
                }
                AuthenticationError::LoginCookieRequired => "LOGIN_COOKIE_REQUIRED",
                AuthenticationError::NotAdsUser => "NOT_ADS_USER",
                AuthenticationError::OauthTokenInvalid => "OAUTH_TOKEN_INVALID",
                AuthenticationError::OauthTokenExpired => "OAUTH_TOKEN_EXPIRED",
                AuthenticationError::OauthTokenDisabled => "OAUTH_TOKEN_DISABLED",
                AuthenticationError::OauthTokenRevoked => "OAUTH_TOKEN_REVOKED",
                AuthenticationError::OauthTokenHeaderInvalid => {
                    "OAUTH_TOKEN_HEADER_INVALID"
                }
                AuthenticationError::LoginCookieInvalid => "LOGIN_COOKIE_INVALID",
                AuthenticationError::UserIdInvalid => "USER_ID_INVALID",
                AuthenticationError::TwoStepVerificationNotEnrolled => {
                    "TWO_STEP_VERIFICATION_NOT_ENROLLED"
                }
                AuthenticationError::AdvancedProtectionNotEnrolled => {
                    "ADVANCED_PROTECTION_NOT_ENROLLED"
                }
                AuthenticationError::OrganizationNotRecognized => {
                    "ORGANIZATION_NOT_RECOGNIZED"
                }
                AuthenticationError::OrganizationNotApproved => {
                    "ORGANIZATION_NOT_APPROVED"
                }
                AuthenticationError::OrganizationNotAssociatedWithDeveloperToken => {
                    "ORGANIZATION_NOT_ASSOCIATED_WITH_DEVELOPER_TOKEN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTHENTICATION_ERROR" => Some(Self::AuthenticationError),
                "CLIENT_CUSTOMER_ID_INVALID" => Some(Self::ClientCustomerIdInvalid),
                "CUSTOMER_NOT_FOUND" => Some(Self::CustomerNotFound),
                "GOOGLE_ACCOUNT_DELETED" => Some(Self::GoogleAccountDeleted),
                "GOOGLE_ACCOUNT_COOKIE_INVALID" => Some(Self::GoogleAccountCookieInvalid),
                "GOOGLE_ACCOUNT_AUTHENTICATION_FAILED" => {
                    Some(Self::GoogleAccountAuthenticationFailed)
                }
                "GOOGLE_ACCOUNT_USER_AND_ADS_USER_MISMATCH" => {
                    Some(Self::GoogleAccountUserAndAdsUserMismatch)
                }
                "LOGIN_COOKIE_REQUIRED" => Some(Self::LoginCookieRequired),
                "NOT_ADS_USER" => Some(Self::NotAdsUser),
                "OAUTH_TOKEN_INVALID" => Some(Self::OauthTokenInvalid),
                "OAUTH_TOKEN_EXPIRED" => Some(Self::OauthTokenExpired),
                "OAUTH_TOKEN_DISABLED" => Some(Self::OauthTokenDisabled),
                "OAUTH_TOKEN_REVOKED" => Some(Self::OauthTokenRevoked),
                "OAUTH_TOKEN_HEADER_INVALID" => Some(Self::OauthTokenHeaderInvalid),
                "LOGIN_COOKIE_INVALID" => Some(Self::LoginCookieInvalid),
                "USER_ID_INVALID" => Some(Self::UserIdInvalid),
                "TWO_STEP_VERIFICATION_NOT_ENROLLED" => {
                    Some(Self::TwoStepVerificationNotEnrolled)
                }
                "ADVANCED_PROTECTION_NOT_ENROLLED" => {
                    Some(Self::AdvancedProtectionNotEnrolled)
                }
                "ORGANIZATION_NOT_RECOGNIZED" => Some(Self::OrganizationNotRecognized),
                "ORGANIZATION_NOT_APPROVED" => Some(Self::OrganizationNotApproved),
                "ORGANIZATION_NOT_ASSOCIATED_WITH_DEVELOPER_TOKEN" => {
                    Some(Self::OrganizationNotAssociatedWithDeveloperToken)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyErrorEnum {}
/// Nested message and enum types in `BiddingStrategyErrorEnum`.
pub mod bidding_strategy_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateName = 2,
        CannotChangeBiddingStrategyType = 3,
        CannotRemoveAssociatedStrategy = 4,
        BiddingStrategyNotSupported = 5,
        IncompatibleBiddingStrategyAndBiddingStrategyGoalType = 6,
    }
    impl BiddingStrategyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategyError::Unspecified => "UNSPECIFIED",
                BiddingStrategyError::Unknown => "UNKNOWN",
                BiddingStrategyError::DuplicateName => "DUPLICATE_NAME",
                BiddingStrategyError::CannotChangeBiddingStrategyType => {
                    "CANNOT_CHANGE_BIDDING_STRATEGY_TYPE"
                }
                BiddingStrategyError::CannotRemoveAssociatedStrategy => {
                    "CANNOT_REMOVE_ASSOCIATED_STRATEGY"
                }
                BiddingStrategyError::BiddingStrategyNotSupported => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED"
                }
                BiddingStrategyError::IncompatibleBiddingStrategyAndBiddingStrategyGoalType => {
                    "INCOMPATIBLE_BIDDING_STRATEGY_AND_BIDDING_STRATEGY_GOAL_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "CANNOT_CHANGE_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::CannotChangeBiddingStrategyType)
                }
                "CANNOT_REMOVE_ASSOCIATED_STRATEGY" => {
                    Some(Self::CannotRemoveAssociatedStrategy)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED" => {
                    Some(Self::BiddingStrategyNotSupported)
                }
                "INCOMPATIBLE_BIDDING_STRATEGY_AND_BIDDING_STRATEGY_GOAL_TYPE" => {
                    Some(Self::IncompatibleBiddingStrategyAndBiddingStrategyGoalType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BillingSetupErrorEnum {}
/// Nested message and enum types in `BillingSetupErrorEnum`.
pub mod billing_setup_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BillingSetupError {
        Unspecified = 0,
        Unknown = 1,
        CannotUseExistingAndNewAccount = 2,
        CannotRemoveStartedBillingSetup = 3,
        CannotChangeBillingToSamePaymentsAccount = 4,
        BillingSetupNotPermittedForCustomerStatus = 5,
        InvalidPaymentsAccount = 6,
        BillingSetupNotPermittedForCustomerCategory = 7,
        InvalidStartTimeType = 8,
        ThirdPartyAlreadyHasBilling = 9,
        BillingSetupInProgress = 10,
        NoSignupPermission = 11,
        ChangeOfBillToInProgress = 12,
        PaymentsProfileNotFound = 13,
        PaymentsAccountNotFound = 14,
        PaymentsProfileIneligible = 15,
        PaymentsAccountIneligible = 16,
        CustomerNeedsInternalApproval = 17,
        PaymentsProfileNeedsServiceAgreementAcceptance = 18,
        PaymentsAccountIneligibleCurrencyCodeMismatch = 19,
        FutureStartTimeProhibited = 20,
        TooManyBillingSetupsForPaymentsAccount = 21,
    }
    impl BillingSetupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BillingSetupError::Unspecified => "UNSPECIFIED",
                BillingSetupError::Unknown => "UNKNOWN",
                BillingSetupError::CannotUseExistingAndNewAccount => {
                    "CANNOT_USE_EXISTING_AND_NEW_ACCOUNT"
                }
                BillingSetupError::CannotRemoveStartedBillingSetup => {
                    "CANNOT_REMOVE_STARTED_BILLING_SETUP"
                }
                BillingSetupError::CannotChangeBillingToSamePaymentsAccount => {
                    "CANNOT_CHANGE_BILLING_TO_SAME_PAYMENTS_ACCOUNT"
                }
                BillingSetupError::BillingSetupNotPermittedForCustomerStatus => {
                    "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_STATUS"
                }
                BillingSetupError::InvalidPaymentsAccount => "INVALID_PAYMENTS_ACCOUNT",
                BillingSetupError::BillingSetupNotPermittedForCustomerCategory => {
                    "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_CATEGORY"
                }
                BillingSetupError::InvalidStartTimeType => "INVALID_START_TIME_TYPE",
                BillingSetupError::ThirdPartyAlreadyHasBilling => {
                    "THIRD_PARTY_ALREADY_HAS_BILLING"
                }
                BillingSetupError::BillingSetupInProgress => "BILLING_SETUP_IN_PROGRESS",
                BillingSetupError::NoSignupPermission => "NO_SIGNUP_PERMISSION",
                BillingSetupError::ChangeOfBillToInProgress => {
                    "CHANGE_OF_BILL_TO_IN_PROGRESS"
                }
                BillingSetupError::PaymentsProfileNotFound => {
                    "PAYMENTS_PROFILE_NOT_FOUND"
                }
                BillingSetupError::PaymentsAccountNotFound => {
                    "PAYMENTS_ACCOUNT_NOT_FOUND"
                }
                BillingSetupError::PaymentsProfileIneligible => {
                    "PAYMENTS_PROFILE_INELIGIBLE"
                }
                BillingSetupError::PaymentsAccountIneligible => {
                    "PAYMENTS_ACCOUNT_INELIGIBLE"
                }
                BillingSetupError::CustomerNeedsInternalApproval => {
                    "CUSTOMER_NEEDS_INTERNAL_APPROVAL"
                }
                BillingSetupError::PaymentsProfileNeedsServiceAgreementAcceptance => {
                    "PAYMENTS_PROFILE_NEEDS_SERVICE_AGREEMENT_ACCEPTANCE"
                }
                BillingSetupError::PaymentsAccountIneligibleCurrencyCodeMismatch => {
                    "PAYMENTS_ACCOUNT_INELIGIBLE_CURRENCY_CODE_MISMATCH"
                }
                BillingSetupError::FutureStartTimeProhibited => {
                    "FUTURE_START_TIME_PROHIBITED"
                }
                BillingSetupError::TooManyBillingSetupsForPaymentsAccount => {
                    "TOO_MANY_BILLING_SETUPS_FOR_PAYMENTS_ACCOUNT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_EXISTING_AND_NEW_ACCOUNT" => {
                    Some(Self::CannotUseExistingAndNewAccount)
                }
                "CANNOT_REMOVE_STARTED_BILLING_SETUP" => {
                    Some(Self::CannotRemoveStartedBillingSetup)
                }
                "CANNOT_CHANGE_BILLING_TO_SAME_PAYMENTS_ACCOUNT" => {
                    Some(Self::CannotChangeBillingToSamePaymentsAccount)
                }
                "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_STATUS" => {
                    Some(Self::BillingSetupNotPermittedForCustomerStatus)
                }
                "INVALID_PAYMENTS_ACCOUNT" => Some(Self::InvalidPaymentsAccount),
                "BILLING_SETUP_NOT_PERMITTED_FOR_CUSTOMER_CATEGORY" => {
                    Some(Self::BillingSetupNotPermittedForCustomerCategory)
                }
                "INVALID_START_TIME_TYPE" => Some(Self::InvalidStartTimeType),
                "THIRD_PARTY_ALREADY_HAS_BILLING" => {
                    Some(Self::ThirdPartyAlreadyHasBilling)
                }
                "BILLING_SETUP_IN_PROGRESS" => Some(Self::BillingSetupInProgress),
                "NO_SIGNUP_PERMISSION" => Some(Self::NoSignupPermission),
                "CHANGE_OF_BILL_TO_IN_PROGRESS" => Some(Self::ChangeOfBillToInProgress),
                "PAYMENTS_PROFILE_NOT_FOUND" => Some(Self::PaymentsProfileNotFound),
                "PAYMENTS_ACCOUNT_NOT_FOUND" => Some(Self::PaymentsAccountNotFound),
                "PAYMENTS_PROFILE_INELIGIBLE" => Some(Self::PaymentsProfileIneligible),
                "PAYMENTS_ACCOUNT_INELIGIBLE" => Some(Self::PaymentsAccountIneligible),
                "CUSTOMER_NEEDS_INTERNAL_APPROVAL" => {
                    Some(Self::CustomerNeedsInternalApproval)
                }
                "PAYMENTS_PROFILE_NEEDS_SERVICE_AGREEMENT_ACCEPTANCE" => {
                    Some(Self::PaymentsProfileNeedsServiceAgreementAcceptance)
                }
                "PAYMENTS_ACCOUNT_INELIGIBLE_CURRENCY_CODE_MISMATCH" => {
                    Some(Self::PaymentsAccountIneligibleCurrencyCodeMismatch)
                }
                "FUTURE_START_TIME_PROHIBITED" => Some(Self::FutureStartTimeProhibited),
                "TOO_MANY_BILLING_SETUPS_FOR_PAYMENTS_ACCOUNT" => {
                    Some(Self::TooManyBillingSetupsForPaymentsAccount)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignBudgetErrorEnum {}
/// Nested message and enum types in `CampaignBudgetErrorEnum`.
pub mod campaign_budget_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignBudgetError {
        Unspecified = 0,
        Unknown = 1,
        CampaignBudgetCannotBeShared = 17,
        CampaignBudgetRemoved = 2,
        CampaignBudgetInUse = 3,
        CampaignBudgetPeriodNotAvailable = 4,
        CannotModifyFieldOfImplicitlySharedCampaignBudget = 6,
        CannotUpdateCampaignBudgetToImplicitlyShared = 7,
        CannotUpdateCampaignBudgetToExplicitlySharedWithoutName = 8,
        CannotUpdateCampaignBudgetToExplicitlyShared = 9,
        CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns = 10,
        DuplicateName = 11,
        MoneyAmountInWrongCurrency = 12,
        MoneyAmountLessThanCurrencyMinimumCpc = 13,
        MoneyAmountTooLarge = 14,
        NegativeMoneyAmount = 15,
        NonMultipleOfMinimumCurrencyUnit = 16,
        TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily = 18,
        InvalidPeriod = 19,
        CannotUseAcceleratedDeliveryMode = 20,
        BudgetAmountMustBeUnsetForCustomBudgetPeriod = 21,
    }
    impl CampaignBudgetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignBudgetError::Unspecified => "UNSPECIFIED",
                CampaignBudgetError::Unknown => "UNKNOWN",
                CampaignBudgetError::CampaignBudgetCannotBeShared => {
                    "CAMPAIGN_BUDGET_CANNOT_BE_SHARED"
                }
                CampaignBudgetError::CampaignBudgetRemoved => "CAMPAIGN_BUDGET_REMOVED",
                CampaignBudgetError::CampaignBudgetInUse => "CAMPAIGN_BUDGET_IN_USE",
                CampaignBudgetError::CampaignBudgetPeriodNotAvailable => {
                    "CAMPAIGN_BUDGET_PERIOD_NOT_AVAILABLE"
                }
                CampaignBudgetError::CannotModifyFieldOfImplicitlySharedCampaignBudget => {
                    "CANNOT_MODIFY_FIELD_OF_IMPLICITLY_SHARED_CAMPAIGN_BUDGET"
                }
                CampaignBudgetError::CannotUpdateCampaignBudgetToImplicitlyShared => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_IMPLICITLY_SHARED"
                }
                CampaignBudgetError::CannotUpdateCampaignBudgetToExplicitlySharedWithoutName => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED_WITHOUT_NAME"
                }
                CampaignBudgetError::CannotUpdateCampaignBudgetToExplicitlyShared => {
                    "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED"
                }
                CampaignBudgetError::CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns => {
                    "CANNOT_USE_IMPLICITLY_SHARED_CAMPAIGN_BUDGET_WITH_MULTIPLE_CAMPAIGNS"
                }
                CampaignBudgetError::DuplicateName => "DUPLICATE_NAME",
                CampaignBudgetError::MoneyAmountInWrongCurrency => {
                    "MONEY_AMOUNT_IN_WRONG_CURRENCY"
                }
                CampaignBudgetError::MoneyAmountLessThanCurrencyMinimumCpc => {
                    "MONEY_AMOUNT_LESS_THAN_CURRENCY_MINIMUM_CPC"
                }
                CampaignBudgetError::MoneyAmountTooLarge => "MONEY_AMOUNT_TOO_LARGE",
                CampaignBudgetError::NegativeMoneyAmount => "NEGATIVE_MONEY_AMOUNT",
                CampaignBudgetError::NonMultipleOfMinimumCurrencyUnit => {
                    "NON_MULTIPLE_OF_MINIMUM_CURRENCY_UNIT"
                }
                CampaignBudgetError::TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily => {
                    "TOTAL_BUDGET_AMOUNT_MUST_BE_UNSET_FOR_BUDGET_PERIOD_DAILY"
                }
                CampaignBudgetError::InvalidPeriod => "INVALID_PERIOD",
                CampaignBudgetError::CannotUseAcceleratedDeliveryMode => {
                    "CANNOT_USE_ACCELERATED_DELIVERY_MODE"
                }
                CampaignBudgetError::BudgetAmountMustBeUnsetForCustomBudgetPeriod => {
                    "BUDGET_AMOUNT_MUST_BE_UNSET_FOR_CUSTOM_BUDGET_PERIOD"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BUDGET_CANNOT_BE_SHARED" => {
                    Some(Self::CampaignBudgetCannotBeShared)
                }
                "CAMPAIGN_BUDGET_REMOVED" => Some(Self::CampaignBudgetRemoved),
                "CAMPAIGN_BUDGET_IN_USE" => Some(Self::CampaignBudgetInUse),
                "CAMPAIGN_BUDGET_PERIOD_NOT_AVAILABLE" => {
                    Some(Self::CampaignBudgetPeriodNotAvailable)
                }
                "CANNOT_MODIFY_FIELD_OF_IMPLICITLY_SHARED_CAMPAIGN_BUDGET" => {
                    Some(Self::CannotModifyFieldOfImplicitlySharedCampaignBudget)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_IMPLICITLY_SHARED" => {
                    Some(Self::CannotUpdateCampaignBudgetToImplicitlyShared)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED_WITHOUT_NAME" => {
                    Some(Self::CannotUpdateCampaignBudgetToExplicitlySharedWithoutName)
                }
                "CANNOT_UPDATE_CAMPAIGN_BUDGET_TO_EXPLICITLY_SHARED" => {
                    Some(Self::CannotUpdateCampaignBudgetToExplicitlyShared)
                }
                "CANNOT_USE_IMPLICITLY_SHARED_CAMPAIGN_BUDGET_WITH_MULTIPLE_CAMPAIGNS" => {
                    Some(
                        Self::CannotUseImplicitlySharedCampaignBudgetWithMultipleCampaigns,
                    )
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "MONEY_AMOUNT_IN_WRONG_CURRENCY" => {
                    Some(Self::MoneyAmountInWrongCurrency)
                }
                "MONEY_AMOUNT_LESS_THAN_CURRENCY_MINIMUM_CPC" => {
                    Some(Self::MoneyAmountLessThanCurrencyMinimumCpc)
                }
                "MONEY_AMOUNT_TOO_LARGE" => Some(Self::MoneyAmountTooLarge),
                "NEGATIVE_MONEY_AMOUNT" => Some(Self::NegativeMoneyAmount),
                "NON_MULTIPLE_OF_MINIMUM_CURRENCY_UNIT" => {
                    Some(Self::NonMultipleOfMinimumCurrencyUnit)
                }
                "TOTAL_BUDGET_AMOUNT_MUST_BE_UNSET_FOR_BUDGET_PERIOD_DAILY" => {
                    Some(Self::TotalBudgetAmountMustBeUnsetForBudgetPeriodDaily)
                }
                "INVALID_PERIOD" => Some(Self::InvalidPeriod),
                "CANNOT_USE_ACCELERATED_DELIVERY_MODE" => {
                    Some(Self::CannotUseAcceleratedDeliveryMode)
                }
                "BUDGET_AMOUNT_MUST_BE_UNSET_FOR_CUSTOM_BUDGET_PERIOD" => {
                    Some(Self::BudgetAmountMustBeUnsetForCustomBudgetPeriod)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCriterionErrorEnum {}
/// Nested message and enum types in `CampaignCriterionErrorEnum`.
pub mod campaign_criterion_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCriterionError {
        Unspecified = 0,
        Unknown = 1,
        ConcreteTypeRequired = 2,
        InvalidPlacementUrl = 3,
        CannotExcludeCriteriaType = 4,
        CannotSetStatusForCriteriaType = 5,
        CannotSetStatusForExcludedCriteria = 6,
        CannotTargetAndExclude = 7,
        TooManyOperations = 8,
        OperatorNotSupportedForCriterionType = 9,
        ShoppingCampaignSalesCountryNotSupportedForSalesChannel = 10,
        CannotAddExistingField = 11,
        CannotUpdateNegativeCriterion = 12,
        CannotSetNegativeKeywordThemeConstantCriterion = 13,
        InvalidKeywordThemeConstant = 14,
        MissingKeywordThemeConstantOrFreeFormKeywordTheme = 15,
        CannotTargetBothProximityAndLocationCriteriaForSmartCampaign = 16,
        CannotTargetMultipleProximityCriteriaForSmartCampaign = 17,
        LocationNotLaunchedForLocalServicesCampaign = 18,
        LocationInvalidForLocalServicesCampaign = 19,
        CannotTargetCountryForLocalServicesCampaign = 20,
        LocationNotInHomeCountryForLocalServicesCampaign = 21,
        CannotAddOrRemoveLocationForLocalServicesCampaign = 22,
        AtLeastOnePositiveLocationRequiredForLocalServicesCampaign = 23,
        AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign = 24,
        LocalServiceIdNotFoundForCategory = 25,
        CannotAttachBrandListToNonQualifiedSearchCampaign = 26,
    }
    impl CampaignCriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignCriterionError::Unspecified => "UNSPECIFIED",
                CampaignCriterionError::Unknown => "UNKNOWN",
                CampaignCriterionError::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                CampaignCriterionError::InvalidPlacementUrl => "INVALID_PLACEMENT_URL",
                CampaignCriterionError::CannotExcludeCriteriaType => {
                    "CANNOT_EXCLUDE_CRITERIA_TYPE"
                }
                CampaignCriterionError::CannotSetStatusForCriteriaType => {
                    "CANNOT_SET_STATUS_FOR_CRITERIA_TYPE"
                }
                CampaignCriterionError::CannotSetStatusForExcludedCriteria => {
                    "CANNOT_SET_STATUS_FOR_EXCLUDED_CRITERIA"
                }
                CampaignCriterionError::CannotTargetAndExclude => {
                    "CANNOT_TARGET_AND_EXCLUDE"
                }
                CampaignCriterionError::TooManyOperations => "TOO_MANY_OPERATIONS",
                CampaignCriterionError::OperatorNotSupportedForCriterionType => {
                    "OPERATOR_NOT_SUPPORTED_FOR_CRITERION_TYPE"
                }
                CampaignCriterionError::ShoppingCampaignSalesCountryNotSupportedForSalesChannel => {
                    "SHOPPING_CAMPAIGN_SALES_COUNTRY_NOT_SUPPORTED_FOR_SALES_CHANNEL"
                }
                CampaignCriterionError::CannotAddExistingField => {
                    "CANNOT_ADD_EXISTING_FIELD"
                }
                CampaignCriterionError::CannotUpdateNegativeCriterion => {
                    "CANNOT_UPDATE_NEGATIVE_CRITERION"
                }
                CampaignCriterionError::CannotSetNegativeKeywordThemeConstantCriterion => {
                    "CANNOT_SET_NEGATIVE_KEYWORD_THEME_CONSTANT_CRITERION"
                }
                CampaignCriterionError::InvalidKeywordThemeConstant => {
                    "INVALID_KEYWORD_THEME_CONSTANT"
                }
                CampaignCriterionError::MissingKeywordThemeConstantOrFreeFormKeywordTheme => {
                    "MISSING_KEYWORD_THEME_CONSTANT_OR_FREE_FORM_KEYWORD_THEME"
                }
                CampaignCriterionError::CannotTargetBothProximityAndLocationCriteriaForSmartCampaign => {
                    "CANNOT_TARGET_BOTH_PROXIMITY_AND_LOCATION_CRITERIA_FOR_SMART_CAMPAIGN"
                }
                CampaignCriterionError::CannotTargetMultipleProximityCriteriaForSmartCampaign => {
                    "CANNOT_TARGET_MULTIPLE_PROXIMITY_CRITERIA_FOR_SMART_CAMPAIGN"
                }
                CampaignCriterionError::LocationNotLaunchedForLocalServicesCampaign => {
                    "LOCATION_NOT_LAUNCHED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::LocationInvalidForLocalServicesCampaign => {
                    "LOCATION_INVALID_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::CannotTargetCountryForLocalServicesCampaign => {
                    "CANNOT_TARGET_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::LocationNotInHomeCountryForLocalServicesCampaign => {
                    "LOCATION_NOT_IN_HOME_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::CannotAddOrRemoveLocationForLocalServicesCampaign => {
                    "CANNOT_ADD_OR_REMOVE_LOCATION_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::AtLeastOnePositiveLocationRequiredForLocalServicesCampaign => {
                    "AT_LEAST_ONE_POSITIVE_LOCATION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign => {
                    "AT_LEAST_ONE_LOCAL_SERVICE_ID_CRITERION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN"
                }
                CampaignCriterionError::LocalServiceIdNotFoundForCategory => {
                    "LOCAL_SERVICE_ID_NOT_FOUND_FOR_CATEGORY"
                }
                CampaignCriterionError::CannotAttachBrandListToNonQualifiedSearchCampaign => {
                    "CANNOT_ATTACH_BRAND_LIST_TO_NON_QUALIFIED_SEARCH_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "INVALID_PLACEMENT_URL" => Some(Self::InvalidPlacementUrl),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CANNOT_SET_STATUS_FOR_CRITERIA_TYPE" => {
                    Some(Self::CannotSetStatusForCriteriaType)
                }
                "CANNOT_SET_STATUS_FOR_EXCLUDED_CRITERIA" => {
                    Some(Self::CannotSetStatusForExcludedCriteria)
                }
                "CANNOT_TARGET_AND_EXCLUDE" => Some(Self::CannotTargetAndExclude),
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "OPERATOR_NOT_SUPPORTED_FOR_CRITERION_TYPE" => {
                    Some(Self::OperatorNotSupportedForCriterionType)
                }
                "SHOPPING_CAMPAIGN_SALES_COUNTRY_NOT_SUPPORTED_FOR_SALES_CHANNEL" => {
                    Some(Self::ShoppingCampaignSalesCountryNotSupportedForSalesChannel)
                }
                "CANNOT_ADD_EXISTING_FIELD" => Some(Self::CannotAddExistingField),
                "CANNOT_UPDATE_NEGATIVE_CRITERION" => {
                    Some(Self::CannotUpdateNegativeCriterion)
                }
                "CANNOT_SET_NEGATIVE_KEYWORD_THEME_CONSTANT_CRITERION" => {
                    Some(Self::CannotSetNegativeKeywordThemeConstantCriterion)
                }
                "INVALID_KEYWORD_THEME_CONSTANT" => {
                    Some(Self::InvalidKeywordThemeConstant)
                }
                "MISSING_KEYWORD_THEME_CONSTANT_OR_FREE_FORM_KEYWORD_THEME" => {
                    Some(Self::MissingKeywordThemeConstantOrFreeFormKeywordTheme)
                }
                "CANNOT_TARGET_BOTH_PROXIMITY_AND_LOCATION_CRITERIA_FOR_SMART_CAMPAIGN" => {
                    Some(
                        Self::CannotTargetBothProximityAndLocationCriteriaForSmartCampaign,
                    )
                }
                "CANNOT_TARGET_MULTIPLE_PROXIMITY_CRITERIA_FOR_SMART_CAMPAIGN" => {
                    Some(Self::CannotTargetMultipleProximityCriteriaForSmartCampaign)
                }
                "LOCATION_NOT_LAUNCHED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationNotLaunchedForLocalServicesCampaign)
                }
                "LOCATION_INVALID_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationInvalidForLocalServicesCampaign)
                }
                "CANNOT_TARGET_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::CannotTargetCountryForLocalServicesCampaign)
                }
                "LOCATION_NOT_IN_HOME_COUNTRY_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::LocationNotInHomeCountryForLocalServicesCampaign)
                }
                "CANNOT_ADD_OR_REMOVE_LOCATION_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(Self::CannotAddOrRemoveLocationForLocalServicesCampaign)
                }
                "AT_LEAST_ONE_POSITIVE_LOCATION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(
                        Self::AtLeastOnePositiveLocationRequiredForLocalServicesCampaign,
                    )
                }
                "AT_LEAST_ONE_LOCAL_SERVICE_ID_CRITERION_REQUIRED_FOR_LOCAL_SERVICES_CAMPAIGN" => {
                    Some(
                        Self::AtLeastOneLocalServiceIdCriterionRequiredForLocalServicesCampaign,
                    )
                }
                "LOCAL_SERVICE_ID_NOT_FOUND_FOR_CATEGORY" => {
                    Some(Self::LocalServiceIdNotFoundForCategory)
                }
                "CANNOT_ATTACH_BRAND_LIST_TO_NON_QUALIFIED_SEARCH_CAMPAIGN" => {
                    Some(Self::CannotAttachBrandListToNonQualifiedSearchCampaign)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignDraftErrorEnum {}
/// Nested message and enum types in `CampaignDraftErrorEnum`.
pub mod campaign_draft_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignDraftError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateDraftName = 2,
        InvalidStatusTransitionFromRemoved = 3,
        InvalidStatusTransitionFromPromoted = 4,
        InvalidStatusTransitionFromPromoteFailed = 5,
        CustomerCannotCreateDraft = 6,
        CampaignCannotCreateDraft = 7,
        InvalidDraftChange = 8,
        InvalidStatusTransition = 9,
        MaxNumberOfDraftsPerCampaignReached = 10,
        ListErrorsForPromotedDraftOnly = 11,
    }
    impl CampaignDraftError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignDraftError::Unspecified => "UNSPECIFIED",
                CampaignDraftError::Unknown => "UNKNOWN",
                CampaignDraftError::DuplicateDraftName => "DUPLICATE_DRAFT_NAME",
                CampaignDraftError::InvalidStatusTransitionFromRemoved => {
                    "INVALID_STATUS_TRANSITION_FROM_REMOVED"
                }
                CampaignDraftError::InvalidStatusTransitionFromPromoted => {
                    "INVALID_STATUS_TRANSITION_FROM_PROMOTED"
                }
                CampaignDraftError::InvalidStatusTransitionFromPromoteFailed => {
                    "INVALID_STATUS_TRANSITION_FROM_PROMOTE_FAILED"
                }
                CampaignDraftError::CustomerCannotCreateDraft => {
                    "CUSTOMER_CANNOT_CREATE_DRAFT"
                }
                CampaignDraftError::CampaignCannotCreateDraft => {
                    "CAMPAIGN_CANNOT_CREATE_DRAFT"
                }
                CampaignDraftError::InvalidDraftChange => "INVALID_DRAFT_CHANGE",
                CampaignDraftError::InvalidStatusTransition => {
                    "INVALID_STATUS_TRANSITION"
                }
                CampaignDraftError::MaxNumberOfDraftsPerCampaignReached => {
                    "MAX_NUMBER_OF_DRAFTS_PER_CAMPAIGN_REACHED"
                }
                CampaignDraftError::ListErrorsForPromotedDraftOnly => {
                    "LIST_ERRORS_FOR_PROMOTED_DRAFT_ONLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_DRAFT_NAME" => Some(Self::DuplicateDraftName),
                "INVALID_STATUS_TRANSITION_FROM_REMOVED" => {
                    Some(Self::InvalidStatusTransitionFromRemoved)
                }
                "INVALID_STATUS_TRANSITION_FROM_PROMOTED" => {
                    Some(Self::InvalidStatusTransitionFromPromoted)
                }
                "INVALID_STATUS_TRANSITION_FROM_PROMOTE_FAILED" => {
                    Some(Self::InvalidStatusTransitionFromPromoteFailed)
                }
                "CUSTOMER_CANNOT_CREATE_DRAFT" => Some(Self::CustomerCannotCreateDraft),
                "CAMPAIGN_CANNOT_CREATE_DRAFT" => Some(Self::CampaignCannotCreateDraft),
                "INVALID_DRAFT_CHANGE" => Some(Self::InvalidDraftChange),
                "INVALID_STATUS_TRANSITION" => Some(Self::InvalidStatusTransition),
                "MAX_NUMBER_OF_DRAFTS_PER_CAMPAIGN_REACHED" => {
                    Some(Self::MaxNumberOfDraftsPerCampaignReached)
                }
                "LIST_ERRORS_FOR_PROMOTED_DRAFT_ONLY" => {
                    Some(Self::ListErrorsForPromotedDraftOnly)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignErrorEnum {}
/// Nested message and enum types in `CampaignErrorEnum`.
pub mod campaign_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignError {
        Unspecified = 0,
        Unknown = 1,
        CannotTargetContentNetwork = 3,
        CannotTargetSearchNetwork = 4,
        CannotTargetSearchNetworkWithoutGoogleSearch = 5,
        CannotTargetGoogleSearchForCpmCampaign = 6,
        CampaignMustTargetAtLeastOneNetwork = 7,
        CannotTargetPartnerSearchNetwork = 8,
        CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy = 9,
        CampaignDurationMustContainAllRunnableTrials = 10,
        CannotModifyForTrialCampaign = 11,
        DuplicateCampaignName = 12,
        IncompatibleCampaignField = 13,
        InvalidCampaignName = 14,
        InvalidAdServingOptimizationStatus = 15,
        InvalidTrackingUrl = 16,
        CannotSetBothTrackingUrlTemplateAndTrackingSetting = 17,
        MaxImpressionsNotInRange = 18,
        TimeUnitNotSupported = 19,
        InvalidOperationIfServingStatusHasEnded = 20,
        BudgetCannotBeShared = 21,
        CampaignCannotUseSharedBudget = 22,
        CannotChangeBudgetOnCampaignWithTrials = 23,
        CampaignLabelDoesNotExist = 24,
        CampaignLabelAlreadyExists = 25,
        MissingShoppingSetting = 26,
        InvalidShoppingSalesCountry = 27,
        AdvertisingChannelTypeNotAvailableForAccountType = 31,
        InvalidAdvertisingChannelSubType = 32,
        AtLeastOneConversionMustBeSelected = 33,
        CannotSetAdRotationMode = 34,
        CannotModifyStartDateIfAlreadyStarted = 35,
        CannotSetDateToPast = 36,
        MissingHotelCustomerLink = 37,
        InvalidHotelCustomerLink = 38,
        MissingHotelSetting = 39,
        CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup = 40,
        AppNotFound = 41,
        ShoppingEnableLocalNotSupportedForCampaignType = 42,
        MerchantNotAllowedForComparisonListingAds = 43,
        InsufficientAppInstallsCount = 44,
        SensitiveCategoryApp = 45,
        HecAgreementRequired = 46,
        NotCompatibleWithViewThroughConversionOptimization = 49,
        InvalidExcludedParentAssetFieldType = 48,
        CannotCreateAppPreRegistrationForNonAndroidApp = 50,
        AppNotAvailableToCreateAppPreRegistrationCampaign = 51,
        IncompatibleBudgetType = 52,
        LocalServicesDuplicateCategoryBid = 53,
        LocalServicesInvalidCategoryBid = 54,
        LocalServicesMissingCategoryBid = 55,
        InvalidStatusChange = 57,
        MissingTravelCustomerLink = 58,
        InvalidTravelCustomerLink = 59,
        InvalidExcludedParentAssetSetType = 62,
        AssetSetNotAHotelPropertyAssetSet = 63,
        HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals = 64,
        AverageDailySpendTooHigh = 65,
        CannotAttachToRemovedCampaignGroup = 66,
        CannotAttachToBiddingStrategy = 67,
        CannotChangeBudgetPeriod = 68,
        NotEnoughConversions = 71,
        CannotSetMoreThanOneConversionAction = 72,
        NotCompatibleWithBudgetType = 73,
        NotCompatibleWithUploadClicksConversion = 74,
        AppIdMustMatchConversionActionAppId = 76,
        ConversionActionWithDownloadCategoryNotAllowed = 77,
        ConversionActionWithDownloadCategoryRequired = 78,
        ConversionTrackingNotEnabled = 79,
        NotCompatibleWithBiddingStrategyType = 80,
        NotCompatibleWithGoogleAttributionConversions = 81,
        ConversionLagTooHigh = 82,
        NotLinkedAdvertisingPartner = 83,
        InvalidNumberOfAdvertisingPartnerIds = 84,
        CannotTargetDisplayNetworkWithoutYoutube = 85,
    }
    impl CampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignError::Unspecified => "UNSPECIFIED",
                CampaignError::Unknown => "UNKNOWN",
                CampaignError::CannotTargetContentNetwork => {
                    "CANNOT_TARGET_CONTENT_NETWORK"
                }
                CampaignError::CannotTargetSearchNetwork => {
                    "CANNOT_TARGET_SEARCH_NETWORK"
                }
                CampaignError::CannotTargetSearchNetworkWithoutGoogleSearch => {
                    "CANNOT_TARGET_SEARCH_NETWORK_WITHOUT_GOOGLE_SEARCH"
                }
                CampaignError::CannotTargetGoogleSearchForCpmCampaign => {
                    "CANNOT_TARGET_GOOGLE_SEARCH_FOR_CPM_CAMPAIGN"
                }
                CampaignError::CampaignMustTargetAtLeastOneNetwork => {
                    "CAMPAIGN_MUST_TARGET_AT_LEAST_ONE_NETWORK"
                }
                CampaignError::CannotTargetPartnerSearchNetwork => {
                    "CANNOT_TARGET_PARTNER_SEARCH_NETWORK"
                }
                CampaignError::CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy => {
                    "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CRITERIA_LEVEL_BIDDING_STRATEGY"
                }
                CampaignError::CampaignDurationMustContainAllRunnableTrials => {
                    "CAMPAIGN_DURATION_MUST_CONTAIN_ALL_RUNNABLE_TRIALS"
                }
                CampaignError::CannotModifyForTrialCampaign => {
                    "CANNOT_MODIFY_FOR_TRIAL_CAMPAIGN"
                }
                CampaignError::DuplicateCampaignName => "DUPLICATE_CAMPAIGN_NAME",
                CampaignError::IncompatibleCampaignField => "INCOMPATIBLE_CAMPAIGN_FIELD",
                CampaignError::InvalidCampaignName => "INVALID_CAMPAIGN_NAME",
                CampaignError::InvalidAdServingOptimizationStatus => {
                    "INVALID_AD_SERVING_OPTIMIZATION_STATUS"
                }
                CampaignError::InvalidTrackingUrl => "INVALID_TRACKING_URL",
                CampaignError::CannotSetBothTrackingUrlTemplateAndTrackingSetting => {
                    "CANNOT_SET_BOTH_TRACKING_URL_TEMPLATE_AND_TRACKING_SETTING"
                }
                CampaignError::MaxImpressionsNotInRange => "MAX_IMPRESSIONS_NOT_IN_RANGE",
                CampaignError::TimeUnitNotSupported => "TIME_UNIT_NOT_SUPPORTED",
                CampaignError::InvalidOperationIfServingStatusHasEnded => {
                    "INVALID_OPERATION_IF_SERVING_STATUS_HAS_ENDED"
                }
                CampaignError::BudgetCannotBeShared => "BUDGET_CANNOT_BE_SHARED",
                CampaignError::CampaignCannotUseSharedBudget => {
                    "CAMPAIGN_CANNOT_USE_SHARED_BUDGET"
                }
                CampaignError::CannotChangeBudgetOnCampaignWithTrials => {
                    "CANNOT_CHANGE_BUDGET_ON_CAMPAIGN_WITH_TRIALS"
                }
                CampaignError::CampaignLabelDoesNotExist => {
                    "CAMPAIGN_LABEL_DOES_NOT_EXIST"
                }
                CampaignError::CampaignLabelAlreadyExists => {
                    "CAMPAIGN_LABEL_ALREADY_EXISTS"
                }
                CampaignError::MissingShoppingSetting => "MISSING_SHOPPING_SETTING",
                CampaignError::InvalidShoppingSalesCountry => {
                    "INVALID_SHOPPING_SALES_COUNTRY"
                }
                CampaignError::AdvertisingChannelTypeNotAvailableForAccountType => {
                    "ADVERTISING_CHANNEL_TYPE_NOT_AVAILABLE_FOR_ACCOUNT_TYPE"
                }
                CampaignError::InvalidAdvertisingChannelSubType => {
                    "INVALID_ADVERTISING_CHANNEL_SUB_TYPE"
                }
                CampaignError::AtLeastOneConversionMustBeSelected => {
                    "AT_LEAST_ONE_CONVERSION_MUST_BE_SELECTED"
                }
                CampaignError::CannotSetAdRotationMode => "CANNOT_SET_AD_ROTATION_MODE",
                CampaignError::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
                CampaignError::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                CampaignError::MissingHotelCustomerLink => "MISSING_HOTEL_CUSTOMER_LINK",
                CampaignError::InvalidHotelCustomerLink => "INVALID_HOTEL_CUSTOMER_LINK",
                CampaignError::MissingHotelSetting => "MISSING_HOTEL_SETTING",
                CampaignError::CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup => {
                    "CANNOT_USE_SHARED_CAMPAIGN_BUDGET_WHILE_PART_OF_CAMPAIGN_GROUP"
                }
                CampaignError::AppNotFound => "APP_NOT_FOUND",
                CampaignError::ShoppingEnableLocalNotSupportedForCampaignType => {
                    "SHOPPING_ENABLE_LOCAL_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE"
                }
                CampaignError::MerchantNotAllowedForComparisonListingAds => {
                    "MERCHANT_NOT_ALLOWED_FOR_COMPARISON_LISTING_ADS"
                }
                CampaignError::InsufficientAppInstallsCount => {
                    "INSUFFICIENT_APP_INSTALLS_COUNT"
                }
                CampaignError::SensitiveCategoryApp => "SENSITIVE_CATEGORY_APP",
                CampaignError::HecAgreementRequired => "HEC_AGREEMENT_REQUIRED",
                CampaignError::NotCompatibleWithViewThroughConversionOptimization => {
                    "NOT_COMPATIBLE_WITH_VIEW_THROUGH_CONVERSION_OPTIMIZATION"
                }
                CampaignError::InvalidExcludedParentAssetFieldType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE"
                }
                CampaignError::CannotCreateAppPreRegistrationForNonAndroidApp => {
                    "CANNOT_CREATE_APP_PRE_REGISTRATION_FOR_NON_ANDROID_APP"
                }
                CampaignError::AppNotAvailableToCreateAppPreRegistrationCampaign => {
                    "APP_NOT_AVAILABLE_TO_CREATE_APP_PRE_REGISTRATION_CAMPAIGN"
                }
                CampaignError::IncompatibleBudgetType => "INCOMPATIBLE_BUDGET_TYPE",
                CampaignError::LocalServicesDuplicateCategoryBid => {
                    "LOCAL_SERVICES_DUPLICATE_CATEGORY_BID"
                }
                CampaignError::LocalServicesInvalidCategoryBid => {
                    "LOCAL_SERVICES_INVALID_CATEGORY_BID"
                }
                CampaignError::LocalServicesMissingCategoryBid => {
                    "LOCAL_SERVICES_MISSING_CATEGORY_BID"
                }
                CampaignError::InvalidStatusChange => "INVALID_STATUS_CHANGE",
                CampaignError::MissingTravelCustomerLink => {
                    "MISSING_TRAVEL_CUSTOMER_LINK"
                }
                CampaignError::InvalidTravelCustomerLink => {
                    "INVALID_TRAVEL_CUSTOMER_LINK"
                }
                CampaignError::InvalidExcludedParentAssetSetType => {
                    "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE"
                }
                CampaignError::AssetSetNotAHotelPropertyAssetSet => {
                    "ASSET_SET_NOT_A_HOTEL_PROPERTY_ASSET_SET"
                }
                CampaignError::HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals => {
                    "HOTEL_PROPERTY_ASSET_SET_ONLY_FOR_PERFORMANCE_MAX_FOR_TRAVEL_GOALS"
                }
                CampaignError::AverageDailySpendTooHigh => "AVERAGE_DAILY_SPEND_TOO_HIGH",
                CampaignError::CannotAttachToRemovedCampaignGroup => {
                    "CANNOT_ATTACH_TO_REMOVED_CAMPAIGN_GROUP"
                }
                CampaignError::CannotAttachToBiddingStrategy => {
                    "CANNOT_ATTACH_TO_BIDDING_STRATEGY"
                }
                CampaignError::CannotChangeBudgetPeriod => "CANNOT_CHANGE_BUDGET_PERIOD",
                CampaignError::NotEnoughConversions => "NOT_ENOUGH_CONVERSIONS",
                CampaignError::CannotSetMoreThanOneConversionAction => {
                    "CANNOT_SET_MORE_THAN_ONE_CONVERSION_ACTION"
                }
                CampaignError::NotCompatibleWithBudgetType => {
                    "NOT_COMPATIBLE_WITH_BUDGET_TYPE"
                }
                CampaignError::NotCompatibleWithUploadClicksConversion => {
                    "NOT_COMPATIBLE_WITH_UPLOAD_CLICKS_CONVERSION"
                }
                CampaignError::AppIdMustMatchConversionActionAppId => {
                    "APP_ID_MUST_MATCH_CONVERSION_ACTION_APP_ID"
                }
                CampaignError::ConversionActionWithDownloadCategoryNotAllowed => {
                    "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_NOT_ALLOWED"
                }
                CampaignError::ConversionActionWithDownloadCategoryRequired => {
                    "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_REQUIRED"
                }
                CampaignError::ConversionTrackingNotEnabled => {
                    "CONVERSION_TRACKING_NOT_ENABLED"
                }
                CampaignError::NotCompatibleWithBiddingStrategyType => {
                    "NOT_COMPATIBLE_WITH_BIDDING_STRATEGY_TYPE"
                }
                CampaignError::NotCompatibleWithGoogleAttributionConversions => {
                    "NOT_COMPATIBLE_WITH_GOOGLE_ATTRIBUTION_CONVERSIONS"
                }
                CampaignError::ConversionLagTooHigh => "CONVERSION_LAG_TOO_HIGH",
                CampaignError::NotLinkedAdvertisingPartner => {
                    "NOT_LINKED_ADVERTISING_PARTNER"
                }
                CampaignError::InvalidNumberOfAdvertisingPartnerIds => {
                    "INVALID_NUMBER_OF_ADVERTISING_PARTNER_IDS"
                }
                CampaignError::CannotTargetDisplayNetworkWithoutYoutube => {
                    "CANNOT_TARGET_DISPLAY_NETWORK_WITHOUT_YOUTUBE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_TARGET_CONTENT_NETWORK" => Some(Self::CannotTargetContentNetwork),
                "CANNOT_TARGET_SEARCH_NETWORK" => Some(Self::CannotTargetSearchNetwork),
                "CANNOT_TARGET_SEARCH_NETWORK_WITHOUT_GOOGLE_SEARCH" => {
                    Some(Self::CannotTargetSearchNetworkWithoutGoogleSearch)
                }
                "CANNOT_TARGET_GOOGLE_SEARCH_FOR_CPM_CAMPAIGN" => {
                    Some(Self::CannotTargetGoogleSearchForCpmCampaign)
                }
                "CAMPAIGN_MUST_TARGET_AT_LEAST_ONE_NETWORK" => {
                    Some(Self::CampaignMustTargetAtLeastOneNetwork)
                }
                "CANNOT_TARGET_PARTNER_SEARCH_NETWORK" => {
                    Some(Self::CannotTargetPartnerSearchNetwork)
                }
                "CANNOT_TARGET_CONTENT_NETWORK_ONLY_WITH_CRITERIA_LEVEL_BIDDING_STRATEGY" => {
                    Some(
                        Self::CannotTargetContentNetworkOnlyWithCriteriaLevelBiddingStrategy,
                    )
                }
                "CAMPAIGN_DURATION_MUST_CONTAIN_ALL_RUNNABLE_TRIALS" => {
                    Some(Self::CampaignDurationMustContainAllRunnableTrials)
                }
                "CANNOT_MODIFY_FOR_TRIAL_CAMPAIGN" => {
                    Some(Self::CannotModifyForTrialCampaign)
                }
                "DUPLICATE_CAMPAIGN_NAME" => Some(Self::DuplicateCampaignName),
                "INCOMPATIBLE_CAMPAIGN_FIELD" => Some(Self::IncompatibleCampaignField),
                "INVALID_CAMPAIGN_NAME" => Some(Self::InvalidCampaignName),
                "INVALID_AD_SERVING_OPTIMIZATION_STATUS" => {
                    Some(Self::InvalidAdServingOptimizationStatus)
                }
                "INVALID_TRACKING_URL" => Some(Self::InvalidTrackingUrl),
                "CANNOT_SET_BOTH_TRACKING_URL_TEMPLATE_AND_TRACKING_SETTING" => {
                    Some(Self::CannotSetBothTrackingUrlTemplateAndTrackingSetting)
                }
                "MAX_IMPRESSIONS_NOT_IN_RANGE" => Some(Self::MaxImpressionsNotInRange),
                "TIME_UNIT_NOT_SUPPORTED" => Some(Self::TimeUnitNotSupported),
                "INVALID_OPERATION_IF_SERVING_STATUS_HAS_ENDED" => {
                    Some(Self::InvalidOperationIfServingStatusHasEnded)
                }
                "BUDGET_CANNOT_BE_SHARED" => Some(Self::BudgetCannotBeShared),
                "CAMPAIGN_CANNOT_USE_SHARED_BUDGET" => {
                    Some(Self::CampaignCannotUseSharedBudget)
                }
                "CANNOT_CHANGE_BUDGET_ON_CAMPAIGN_WITH_TRIALS" => {
                    Some(Self::CannotChangeBudgetOnCampaignWithTrials)
                }
                "CAMPAIGN_LABEL_DOES_NOT_EXIST" => Some(Self::CampaignLabelDoesNotExist),
                "CAMPAIGN_LABEL_ALREADY_EXISTS" => Some(Self::CampaignLabelAlreadyExists),
                "MISSING_SHOPPING_SETTING" => Some(Self::MissingShoppingSetting),
                "INVALID_SHOPPING_SALES_COUNTRY" => {
                    Some(Self::InvalidShoppingSalesCountry)
                }
                "ADVERTISING_CHANNEL_TYPE_NOT_AVAILABLE_FOR_ACCOUNT_TYPE" => {
                    Some(Self::AdvertisingChannelTypeNotAvailableForAccountType)
                }
                "INVALID_ADVERTISING_CHANNEL_SUB_TYPE" => {
                    Some(Self::InvalidAdvertisingChannelSubType)
                }
                "AT_LEAST_ONE_CONVERSION_MUST_BE_SELECTED" => {
                    Some(Self::AtLeastOneConversionMustBeSelected)
                }
                "CANNOT_SET_AD_ROTATION_MODE" => Some(Self::CannotSetAdRotationMode),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "MISSING_HOTEL_CUSTOMER_LINK" => Some(Self::MissingHotelCustomerLink),
                "INVALID_HOTEL_CUSTOMER_LINK" => Some(Self::InvalidHotelCustomerLink),
                "MISSING_HOTEL_SETTING" => Some(Self::MissingHotelSetting),
                "CANNOT_USE_SHARED_CAMPAIGN_BUDGET_WHILE_PART_OF_CAMPAIGN_GROUP" => {
                    Some(Self::CannotUseSharedCampaignBudgetWhilePartOfCampaignGroup)
                }
                "APP_NOT_FOUND" => Some(Self::AppNotFound),
                "SHOPPING_ENABLE_LOCAL_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::ShoppingEnableLocalNotSupportedForCampaignType)
                }
                "MERCHANT_NOT_ALLOWED_FOR_COMPARISON_LISTING_ADS" => {
                    Some(Self::MerchantNotAllowedForComparisonListingAds)
                }
                "INSUFFICIENT_APP_INSTALLS_COUNT" => {
                    Some(Self::InsufficientAppInstallsCount)
                }
                "SENSITIVE_CATEGORY_APP" => Some(Self::SensitiveCategoryApp),
                "HEC_AGREEMENT_REQUIRED" => Some(Self::HecAgreementRequired),
                "NOT_COMPATIBLE_WITH_VIEW_THROUGH_CONVERSION_OPTIMIZATION" => {
                    Some(Self::NotCompatibleWithViewThroughConversionOptimization)
                }
                "INVALID_EXCLUDED_PARENT_ASSET_FIELD_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetFieldType)
                }
                "CANNOT_CREATE_APP_PRE_REGISTRATION_FOR_NON_ANDROID_APP" => {
                    Some(Self::CannotCreateAppPreRegistrationForNonAndroidApp)
                }
                "APP_NOT_AVAILABLE_TO_CREATE_APP_PRE_REGISTRATION_CAMPAIGN" => {
                    Some(Self::AppNotAvailableToCreateAppPreRegistrationCampaign)
                }
                "INCOMPATIBLE_BUDGET_TYPE" => Some(Self::IncompatibleBudgetType),
                "LOCAL_SERVICES_DUPLICATE_CATEGORY_BID" => {
                    Some(Self::LocalServicesDuplicateCategoryBid)
                }
                "LOCAL_SERVICES_INVALID_CATEGORY_BID" => {
                    Some(Self::LocalServicesInvalidCategoryBid)
                }
                "LOCAL_SERVICES_MISSING_CATEGORY_BID" => {
                    Some(Self::LocalServicesMissingCategoryBid)
                }
                "INVALID_STATUS_CHANGE" => Some(Self::InvalidStatusChange),
                "MISSING_TRAVEL_CUSTOMER_LINK" => Some(Self::MissingTravelCustomerLink),
                "INVALID_TRAVEL_CUSTOMER_LINK" => Some(Self::InvalidTravelCustomerLink),
                "INVALID_EXCLUDED_PARENT_ASSET_SET_TYPE" => {
                    Some(Self::InvalidExcludedParentAssetSetType)
                }
                "ASSET_SET_NOT_A_HOTEL_PROPERTY_ASSET_SET" => {
                    Some(Self::AssetSetNotAHotelPropertyAssetSet)
                }
                "HOTEL_PROPERTY_ASSET_SET_ONLY_FOR_PERFORMANCE_MAX_FOR_TRAVEL_GOALS" => {
                    Some(Self::HotelPropertyAssetSetOnlyForPerformanceMaxForTravelGoals)
                }
                "AVERAGE_DAILY_SPEND_TOO_HIGH" => Some(Self::AverageDailySpendTooHigh),
                "CANNOT_ATTACH_TO_REMOVED_CAMPAIGN_GROUP" => {
                    Some(Self::CannotAttachToRemovedCampaignGroup)
                }
                "CANNOT_ATTACH_TO_BIDDING_STRATEGY" => {
                    Some(Self::CannotAttachToBiddingStrategy)
                }
                "CANNOT_CHANGE_BUDGET_PERIOD" => Some(Self::CannotChangeBudgetPeriod),
                "NOT_ENOUGH_CONVERSIONS" => Some(Self::NotEnoughConversions),
                "CANNOT_SET_MORE_THAN_ONE_CONVERSION_ACTION" => {
                    Some(Self::CannotSetMoreThanOneConversionAction)
                }
                "NOT_COMPATIBLE_WITH_BUDGET_TYPE" => {
                    Some(Self::NotCompatibleWithBudgetType)
                }
                "NOT_COMPATIBLE_WITH_UPLOAD_CLICKS_CONVERSION" => {
                    Some(Self::NotCompatibleWithUploadClicksConversion)
                }
                "APP_ID_MUST_MATCH_CONVERSION_ACTION_APP_ID" => {
                    Some(Self::AppIdMustMatchConversionActionAppId)
                }
                "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_NOT_ALLOWED" => {
                    Some(Self::ConversionActionWithDownloadCategoryNotAllowed)
                }
                "CONVERSION_ACTION_WITH_DOWNLOAD_CATEGORY_REQUIRED" => {
                    Some(Self::ConversionActionWithDownloadCategoryRequired)
                }
                "CONVERSION_TRACKING_NOT_ENABLED" => {
                    Some(Self::ConversionTrackingNotEnabled)
                }
                "NOT_COMPATIBLE_WITH_BIDDING_STRATEGY_TYPE" => {
                    Some(Self::NotCompatibleWithBiddingStrategyType)
                }
                "NOT_COMPATIBLE_WITH_GOOGLE_ATTRIBUTION_CONVERSIONS" => {
                    Some(Self::NotCompatibleWithGoogleAttributionConversions)
                }
                "CONVERSION_LAG_TOO_HIGH" => Some(Self::ConversionLagTooHigh),
                "NOT_LINKED_ADVERTISING_PARTNER" => {
                    Some(Self::NotLinkedAdvertisingPartner)
                }
                "INVALID_NUMBER_OF_ADVERTISING_PARTNER_IDS" => {
                    Some(Self::InvalidNumberOfAdvertisingPartnerIds)
                }
                "CANNOT_TARGET_DISPLAY_NETWORK_WITHOUT_YOUTUBE" => {
                    Some(Self::CannotTargetDisplayNetworkWithoutYoutube)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignLifecycleGoalErrorEnum {}
/// Nested message and enum types in `CampaignLifecycleGoalErrorEnum`.
pub mod campaign_lifecycle_goal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignLifecycleGoalError {
        Unspecified = 0,
        Unknown = 1,
        CampaignMissing = 2,
        InvalidCampaign = 3,
        CustomerAcquisitionInvalidOptimizationMode = 4,
        IncompatibleBiddingStrategy = 5,
        MissingPurchaseGoal = 6,
        CustomerAcquisitionInvalidHighLifetimeValue = 7,
        CustomerAcquisitionUnsupportedCampaignType = 8,
        CustomerAcquisitionInvalidValue = 9,
        CustomerAcquisitionValueMissing = 10,
        CustomerAcquisitionMissingExistingCustomerDefinition = 11,
        CustomerAcquisitionMissingHighValueCustomerDefinition = 12,
    }
    impl CampaignLifecycleGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignLifecycleGoalError::Unspecified => "UNSPECIFIED",
                CampaignLifecycleGoalError::Unknown => "UNKNOWN",
                CampaignLifecycleGoalError::CampaignMissing => "CAMPAIGN_MISSING",
                CampaignLifecycleGoalError::InvalidCampaign => "INVALID_CAMPAIGN",
                CampaignLifecycleGoalError::CustomerAcquisitionInvalidOptimizationMode => {
                    "CUSTOMER_ACQUISITION_INVALID_OPTIMIZATION_MODE"
                }
                CampaignLifecycleGoalError::IncompatibleBiddingStrategy => {
                    "INCOMPATIBLE_BIDDING_STRATEGY"
                }
                CampaignLifecycleGoalError::MissingPurchaseGoal => {
                    "MISSING_PURCHASE_GOAL"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionInvalidHighLifetimeValue => {
                    "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionUnsupportedCampaignType => {
                    "CUSTOMER_ACQUISITION_UNSUPPORTED_CAMPAIGN_TYPE"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionInvalidValue => {
                    "CUSTOMER_ACQUISITION_INVALID_VALUE"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionValueMissing => {
                    "CUSTOMER_ACQUISITION_VALUE_MISSING"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionMissingExistingCustomerDefinition => {
                    "CUSTOMER_ACQUISITION_MISSING_EXISTING_CUSTOMER_DEFINITION"
                }
                CampaignLifecycleGoalError::CustomerAcquisitionMissingHighValueCustomerDefinition => {
                    "CUSTOMER_ACQUISITION_MISSING_HIGH_VALUE_CUSTOMER_DEFINITION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_MISSING" => Some(Self::CampaignMissing),
                "INVALID_CAMPAIGN" => Some(Self::InvalidCampaign),
                "CUSTOMER_ACQUISITION_INVALID_OPTIMIZATION_MODE" => {
                    Some(Self::CustomerAcquisitionInvalidOptimizationMode)
                }
                "INCOMPATIBLE_BIDDING_STRATEGY" => {
                    Some(Self::IncompatibleBiddingStrategy)
                }
                "MISSING_PURCHASE_GOAL" => Some(Self::MissingPurchaseGoal),
                "CUSTOMER_ACQUISITION_INVALID_HIGH_LIFETIME_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidHighLifetimeValue)
                }
                "CUSTOMER_ACQUISITION_UNSUPPORTED_CAMPAIGN_TYPE" => {
                    Some(Self::CustomerAcquisitionUnsupportedCampaignType)
                }
                "CUSTOMER_ACQUISITION_INVALID_VALUE" => {
                    Some(Self::CustomerAcquisitionInvalidValue)
                }
                "CUSTOMER_ACQUISITION_VALUE_MISSING" => {
                    Some(Self::CustomerAcquisitionValueMissing)
                }
                "CUSTOMER_ACQUISITION_MISSING_EXISTING_CUSTOMER_DEFINITION" => {
                    Some(Self::CustomerAcquisitionMissingExistingCustomerDefinition)
                }
                "CUSTOMER_ACQUISITION_MISSING_HIGH_VALUE_CUSTOMER_DEFINITION" => {
                    Some(Self::CustomerAcquisitionMissingHighValueCustomerDefinition)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetErrorEnum {}
/// Nested message and enum types in `CampaignSharedSetErrorEnum`.
pub mod campaign_shared_set_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignSharedSetError {
        Unspecified = 0,
        Unknown = 1,
        SharedSetAccessDenied = 2,
    }
    impl CampaignSharedSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignSharedSetError::Unspecified => "UNSPECIFIED",
                CampaignSharedSetError::Unknown => "UNKNOWN",
                CampaignSharedSetError::SharedSetAccessDenied => {
                    "SHARED_SET_ACCESS_DENIED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SHARED_SET_ACCESS_DENIED" => Some(Self::SharedSetAccessDenied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusErrorEnum {}
/// Nested message and enum types in `ChangeStatusErrorEnum`.
pub mod change_status_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusError {
        Unspecified = 0,
        Unknown = 1,
        StartDateTooOld = 3,
        ChangeDateRangeInfinite = 4,
        ChangeDateRangeNegative = 5,
        LimitNotSpecified = 6,
        InvalidLimitClause = 7,
    }
    impl ChangeStatusError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeStatusError::Unspecified => "UNSPECIFIED",
                ChangeStatusError::Unknown => "UNKNOWN",
                ChangeStatusError::StartDateTooOld => "START_DATE_TOO_OLD",
                ChangeStatusError::ChangeDateRangeInfinite => {
                    "CHANGE_DATE_RANGE_INFINITE"
                }
                ChangeStatusError::ChangeDateRangeNegative => {
                    "CHANGE_DATE_RANGE_NEGATIVE"
                }
                ChangeStatusError::LimitNotSpecified => "LIMIT_NOT_SPECIFIED",
                ChangeStatusError::InvalidLimitClause => "INVALID_LIMIT_CLAUSE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "START_DATE_TOO_OLD" => Some(Self::StartDateTooOld),
                "CHANGE_DATE_RANGE_INFINITE" => Some(Self::ChangeDateRangeInfinite),
                "CHANGE_DATE_RANGE_NEGATIVE" => Some(Self::ChangeDateRangeNegative),
                "LIMIT_NOT_SPECIFIED" => Some(Self::LimitNotSpecified),
                "INVALID_LIMIT_CLAUSE" => Some(Self::InvalidLimitClause),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContextErrorEnum {}
/// Nested message and enum types in `ContextErrorEnum`.
pub mod context_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContextError {
        Unspecified = 0,
        Unknown = 1,
        OperationNotPermittedForContext = 2,
        OperationNotPermittedForRemovedResource = 3,
    }
    impl ContextError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContextError::Unspecified => "UNSPECIFIED",
                ContextError::Unknown => "UNKNOWN",
                ContextError::OperationNotPermittedForContext => {
                    "OPERATION_NOT_PERMITTED_FOR_CONTEXT"
                }
                ContextError::OperationNotPermittedForRemovedResource => {
                    "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATION_NOT_PERMITTED_FOR_CONTEXT" => {
                    Some(Self::OperationNotPermittedForContext)
                }
                "OPERATION_NOT_PERMITTED_FOR_REMOVED_RESOURCE" => {
                    Some(Self::OperationNotPermittedForRemovedResource)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableErrorEnum {}
/// Nested message and enum types in `ConversionCustomVariableErrorEnum`.
pub mod conversion_custom_variable_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateName = 2,
        DuplicateTag = 3,
        ReservedTag = 4,
    }
    impl ConversionCustomVariableError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCustomVariableError::Unspecified => "UNSPECIFIED",
                ConversionCustomVariableError::Unknown => "UNKNOWN",
                ConversionCustomVariableError::DuplicateName => "DUPLICATE_NAME",
                ConversionCustomVariableError::DuplicateTag => "DUPLICATE_TAG",
                ConversionCustomVariableError::ReservedTag => "RESERVED_TAG",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "DUPLICATE_TAG" => Some(Self::DuplicateTag),
                "RESERVED_TAG" => Some(Self::ReservedTag),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionGoalCampaignConfigErrorEnum {}
/// Nested message and enum types in `ConversionGoalCampaignConfigErrorEnum`.
pub mod conversion_goal_campaign_config_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionGoalCampaignConfigError {
        Unspecified = 0,
        Unknown = 1,
        CannotUseCampaignGoalForSearchAds360ManagedCampaign = 2,
        CustomGoalDoesNotBelongToGoogleAdsConversionCustomer = 3,
        CampaignCannotUseUnifiedGoals = 4,
        EmptyConversionGoals = 5,
        StoreSaleStoreVisitCannotBeBothIncluded = 6,
        PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales = 7,
    }
    impl ConversionGoalCampaignConfigError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionGoalCampaignConfigError::Unspecified => "UNSPECIFIED",
                ConversionGoalCampaignConfigError::Unknown => "UNKNOWN",
                ConversionGoalCampaignConfigError::CannotUseCampaignGoalForSearchAds360ManagedCampaign => {
                    "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN"
                }
                ConversionGoalCampaignConfigError::CustomGoalDoesNotBelongToGoogleAdsConversionCustomer => {
                    "CUSTOM_GOAL_DOES_NOT_BELONG_TO_GOOGLE_ADS_CONVERSION_CUSTOMER"
                }
                ConversionGoalCampaignConfigError::CampaignCannotUseUnifiedGoals => {
                    "CAMPAIGN_CANNOT_USE_UNIFIED_GOALS"
                }
                ConversionGoalCampaignConfigError::EmptyConversionGoals => {
                    "EMPTY_CONVERSION_GOALS"
                }
                ConversionGoalCampaignConfigError::StoreSaleStoreVisitCannotBeBothIncluded => {
                    "STORE_SALE_STORE_VISIT_CANNOT_BE_BOTH_INCLUDED"
                }
                ConversionGoalCampaignConfigError::PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales => {
                    "PERFORMANCE_MAX_CAMPAIGN_CANNOT_USE_CUSTOM_GOAL_WITH_STORE_SALES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_USE_CAMPAIGN_GOAL_FOR_SEARCH_ADS_360_MANAGED_CAMPAIGN" => {
                    Some(Self::CannotUseCampaignGoalForSearchAds360ManagedCampaign)
                }
                "CUSTOM_GOAL_DOES_NOT_BELONG_TO_GOOGLE_ADS_CONVERSION_CUSTOMER" => {
                    Some(Self::CustomGoalDoesNotBelongToGoogleAdsConversionCustomer)
                }
                "CAMPAIGN_CANNOT_USE_UNIFIED_GOALS" => {
                    Some(Self::CampaignCannotUseUnifiedGoals)
                }
                "EMPTY_CONVERSION_GOALS" => Some(Self::EmptyConversionGoals),
                "STORE_SALE_STORE_VISIT_CANNOT_BE_BOTH_INCLUDED" => {
                    Some(Self::StoreSaleStoreVisitCannotBeBothIncluded)
                }
                "PERFORMANCE_MAX_CAMPAIGN_CANNOT_USE_CUSTOM_GOAL_WITH_STORE_SALES" => {
                    Some(Self::PerformanceMaxCampaignCannotUseCustomGoalWithStoreSales)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleErrorEnum {}
/// Nested message and enum types in `ConversionValueRuleErrorEnum`.
pub mod conversion_value_rule_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleError {
        Unspecified = 0,
        Unknown = 1,
        InvalidGeoTargetConstant = 2,
        ConflictingIncludedAndExcludedGeoTarget = 3,
        ConflictingConditions = 4,
        CannotRemoveIfIncludedInValueRuleSet = 5,
        ConditionNotAllowed = 6,
        FieldMustBeUnset = 7,
        CannotPauseUnlessValueRuleSetIsPaused = 8,
        UntargetableGeoTarget = 9,
        InvalidAudienceUserList = 10,
        InaccessibleUserList = 11,
        InvalidAudienceUserInterest = 12,
        CannotAddRuleWithStatusRemoved = 13,
    }
    impl ConversionValueRuleError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionValueRuleError::Unspecified => "UNSPECIFIED",
                ConversionValueRuleError::Unknown => "UNKNOWN",
                ConversionValueRuleError::InvalidGeoTargetConstant => {
                    "INVALID_GEO_TARGET_CONSTANT"
                }
                ConversionValueRuleError::ConflictingIncludedAndExcludedGeoTarget => {
                    "CONFLICTING_INCLUDED_AND_EXCLUDED_GEO_TARGET"
                }
                ConversionValueRuleError::ConflictingConditions => {
                    "CONFLICTING_CONDITIONS"
                }
                ConversionValueRuleError::CannotRemoveIfIncludedInValueRuleSet => {
                    "CANNOT_REMOVE_IF_INCLUDED_IN_VALUE_RULE_SET"
                }
                ConversionValueRuleError::ConditionNotAllowed => "CONDITION_NOT_ALLOWED",
                ConversionValueRuleError::FieldMustBeUnset => "FIELD_MUST_BE_UNSET",
                ConversionValueRuleError::CannotPauseUnlessValueRuleSetIsPaused => {
                    "CANNOT_PAUSE_UNLESS_VALUE_RULE_SET_IS_PAUSED"
                }
                ConversionValueRuleError::UntargetableGeoTarget => {
                    "UNTARGETABLE_GEO_TARGET"
                }
                ConversionValueRuleError::InvalidAudienceUserList => {
                    "INVALID_AUDIENCE_USER_LIST"
                }
                ConversionValueRuleError::InaccessibleUserList => {
                    "INACCESSIBLE_USER_LIST"
                }
                ConversionValueRuleError::InvalidAudienceUserInterest => {
                    "INVALID_AUDIENCE_USER_INTEREST"
                }
                ConversionValueRuleError::CannotAddRuleWithStatusRemoved => {
                    "CANNOT_ADD_RULE_WITH_STATUS_REMOVED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_GEO_TARGET_CONSTANT" => Some(Self::InvalidGeoTargetConstant),
                "CONFLICTING_INCLUDED_AND_EXCLUDED_GEO_TARGET" => {
                    Some(Self::ConflictingIncludedAndExcludedGeoTarget)
                }
                "CONFLICTING_CONDITIONS" => Some(Self::ConflictingConditions),
                "CANNOT_REMOVE_IF_INCLUDED_IN_VALUE_RULE_SET" => {
                    Some(Self::CannotRemoveIfIncludedInValueRuleSet)
                }
                "CONDITION_NOT_ALLOWED" => Some(Self::ConditionNotAllowed),
                "FIELD_MUST_BE_UNSET" => Some(Self::FieldMustBeUnset),
                "CANNOT_PAUSE_UNLESS_VALUE_RULE_SET_IS_PAUSED" => {
                    Some(Self::CannotPauseUnlessValueRuleSetIsPaused)
                }
                "UNTARGETABLE_GEO_TARGET" => Some(Self::UntargetableGeoTarget),
                "INVALID_AUDIENCE_USER_LIST" => Some(Self::InvalidAudienceUserList),
                "INACCESSIBLE_USER_LIST" => Some(Self::InaccessibleUserList),
                "INVALID_AUDIENCE_USER_INTEREST" => {
                    Some(Self::InvalidAudienceUserInterest)
                }
                "CANNOT_ADD_RULE_WITH_STATUS_REMOVED" => {
                    Some(Self::CannotAddRuleWithStatusRemoved)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetErrorEnum {}
/// Nested message and enum types in `ConversionValueRuleSetErrorEnum`.
pub mod conversion_value_rule_set_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleSetError {
        Unspecified = 0,
        Unknown = 1,
        ConflictingValueRuleConditions = 2,
        InvalidValueRule = 3,
        DimensionsUpdateOnlyAllowAppend = 4,
        ConditionTypeNotAllowed = 5,
        DuplicateDimensions = 6,
        InvalidCampaignId = 7,
        CannotPauseUnlessAllValueRulesArePaused = 8,
        ShouldPauseWhenAllValueRulesArePaused = 9,
        ValueRulesNotSupportedForCampaignType = 10,
        IneligibleConversionActionCategories = 11,
        DimensionNoConditionUsedWithOtherDimensions = 12,
        DimensionNoConditionNotAllowed = 13,
        UnsupportedConversionActionCategories = 14,
    }
    impl ConversionValueRuleSetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionValueRuleSetError::Unspecified => "UNSPECIFIED",
                ConversionValueRuleSetError::Unknown => "UNKNOWN",
                ConversionValueRuleSetError::ConflictingValueRuleConditions => {
                    "CONFLICTING_VALUE_RULE_CONDITIONS"
                }
                ConversionValueRuleSetError::InvalidValueRule => "INVALID_VALUE_RULE",
                ConversionValueRuleSetError::DimensionsUpdateOnlyAllowAppend => {
                    "DIMENSIONS_UPDATE_ONLY_ALLOW_APPEND"
                }
                ConversionValueRuleSetError::ConditionTypeNotAllowed => {
                    "CONDITION_TYPE_NOT_ALLOWED"
                }
                ConversionValueRuleSetError::DuplicateDimensions => {
                    "DUPLICATE_DIMENSIONS"
                }
                ConversionValueRuleSetError::InvalidCampaignId => "INVALID_CAMPAIGN_ID",
                ConversionValueRuleSetError::CannotPauseUnlessAllValueRulesArePaused => {
                    "CANNOT_PAUSE_UNLESS_ALL_VALUE_RULES_ARE_PAUSED"
                }
                ConversionValueRuleSetError::ShouldPauseWhenAllValueRulesArePaused => {
                    "SHOULD_PAUSE_WHEN_ALL_VALUE_RULES_ARE_PAUSED"
                }
                ConversionValueRuleSetError::ValueRulesNotSupportedForCampaignType => {
                    "VALUE_RULES_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE"
                }
                ConversionValueRuleSetError::IneligibleConversionActionCategories => {
                    "INELIGIBLE_CONVERSION_ACTION_CATEGORIES"
                }
                ConversionValueRuleSetError::DimensionNoConditionUsedWithOtherDimensions => {
                    "DIMENSION_NO_CONDITION_USED_WITH_OTHER_DIMENSIONS"
                }
                ConversionValueRuleSetError::DimensionNoConditionNotAllowed => {
                    "DIMENSION_NO_CONDITION_NOT_ALLOWED"
                }
                ConversionValueRuleSetError::UnsupportedConversionActionCategories => {
                    "UNSUPPORTED_CONVERSION_ACTION_CATEGORIES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONFLICTING_VALUE_RULE_CONDITIONS" => {
                    Some(Self::ConflictingValueRuleConditions)
                }
                "INVALID_VALUE_RULE" => Some(Self::InvalidValueRule),
                "DIMENSIONS_UPDATE_ONLY_ALLOW_APPEND" => {
                    Some(Self::DimensionsUpdateOnlyAllowAppend)
                }
                "CONDITION_TYPE_NOT_ALLOWED" => Some(Self::ConditionTypeNotAllowed),
                "DUPLICATE_DIMENSIONS" => Some(Self::DuplicateDimensions),
                "INVALID_CAMPAIGN_ID" => Some(Self::InvalidCampaignId),
                "CANNOT_PAUSE_UNLESS_ALL_VALUE_RULES_ARE_PAUSED" => {
                    Some(Self::CannotPauseUnlessAllValueRulesArePaused)
                }
                "SHOULD_PAUSE_WHEN_ALL_VALUE_RULES_ARE_PAUSED" => {
                    Some(Self::ShouldPauseWhenAllValueRulesArePaused)
                }
                "VALUE_RULES_NOT_SUPPORTED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::ValueRulesNotSupportedForCampaignType)
                }
                "INELIGIBLE_CONVERSION_ACTION_CATEGORIES" => {
                    Some(Self::IneligibleConversionActionCategories)
                }
                "DIMENSION_NO_CONDITION_USED_WITH_OTHER_DIMENSIONS" => {
                    Some(Self::DimensionNoConditionUsedWithOtherDimensions)
                }
                "DIMENSION_NO_CONDITION_NOT_ALLOWED" => {
                    Some(Self::DimensionNoConditionNotAllowed)
                }
                "UNSUPPORTED_CONVERSION_ACTION_CATEGORIES" => {
                    Some(Self::UnsupportedConversionActionCategories)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CountryCodeErrorEnum {}
/// Nested message and enum types in `CountryCodeErrorEnum`.
pub mod country_code_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CountryCodeError {
        Unspecified = 0,
        Unknown = 1,
        InvalidCountryCode = 2,
    }
    impl CountryCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CountryCodeError::Unspecified => "UNSPECIFIED",
                CountryCodeError::Unknown => "UNKNOWN",
                CountryCodeError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionErrorEnum {}
/// Nested message and enum types in `CriterionErrorEnum`.
pub mod criterion_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionError {
        Unspecified = 0,
        Unknown = 1,
        ConcreteTypeRequired = 2,
        InvalidExcludedCategory = 3,
        InvalidKeywordText = 4,
        KeywordTextTooLong = 5,
        KeywordHasTooManyWords = 6,
        KeywordHasInvalidChars = 7,
        InvalidPlacementUrl = 8,
        InvalidUserList = 9,
        InvalidUserInterest = 10,
        InvalidFormatForPlacementUrl = 11,
        PlacementUrlIsTooLong = 12,
        PlacementUrlHasIllegalChar = 13,
        PlacementUrlHasMultipleSitesInLine = 14,
        PlacementIsNotAvailableForTargetingOrExclusion = 15,
        InvalidTopicPath = 16,
        InvalidYoutubeChannelId = 17,
        InvalidYoutubeVideoId = 18,
        YoutubeVerticalChannelDeprecated = 19,
        YoutubeDemographicChannelDeprecated = 20,
        YoutubeUrlUnsupported = 21,
        CannotExcludeCriteriaType = 22,
        CannotAddCriteriaType = 23,
        CannotExcludeSimilarUserList = 26,
        CannotAddClosedUserList = 27,
        CannotAddDisplayOnlyListsToSearchOnlyCampaigns = 28,
        CannotAddDisplayOnlyListsToSearchCampaigns = 29,
        CannotAddDisplayOnlyListsToShoppingCampaigns = 30,
        CannotAddUserInterestsToSearchCampaigns = 31,
        CannotSetBidsOnCriterionTypeInSearchCampaigns = 32,
        CannotAddUrlsToCriterionTypeForCampaignType = 33,
        InvalidCombinedAudience = 122,
        InvalidCustomAffinity = 96,
        InvalidCustomIntent = 97,
        InvalidCustomAudience = 121,
        InvalidIpAddress = 34,
        InvalidIpFormat = 35,
        InvalidMobileApp = 36,
        InvalidMobileAppCategory = 37,
        InvalidCriterionId = 38,
        CannotTargetCriterion = 39,
        CannotTargetObsoleteCriterion = 40,
        CriterionIdAndTypeMismatch = 41,
        InvalidProximityRadius = 42,
        InvalidProximityRadiusUnits = 43,
        InvalidStreetaddressLength = 44,
        InvalidCitynameLength = 45,
        InvalidRegioncodeLength = 46,
        InvalidRegionnameLength = 47,
        InvalidPostalcodeLength = 48,
        InvalidCountryCode = 49,
        InvalidLatitude = 50,
        InvalidLongitude = 51,
        ProximityGeopointAndAddressBothCannotBeNull = 52,
        InvalidProximityAddress = 53,
        InvalidUserDomainName = 54,
        CriterionParameterTooLong = 55,
        AdScheduleTimeIntervalsOverlap = 56,
        AdScheduleIntervalCannotSpanMultipleDays = 57,
        AdScheduleInvalidTimeInterval = 58,
        AdScheduleExceededIntervalsPerDayLimit = 59,
        AdScheduleCriterionIdMismatchingFields = 60,
        CannotBidModifyCriterionType = 61,
        CannotBidModifyCriterionCampaignOptedOut = 62,
        CannotBidModifyNegativeCriterion = 63,
        BidModifierAlreadyExists = 64,
        FeedIdNotAllowed = 65,
        AccountIneligibleForCriteriaType = 66,
        CriteriaTypeInvalidForBiddingStrategy = 67,
        CannotExcludeCriterion = 68,
        CannotRemoveCriterion = 69,
        InvalidProductBiddingCategory = 76,
        MissingShoppingSetting = 77,
        InvalidMatchingFunction = 78,
        LocationFilterNotAllowed = 79,
        InvalidFeedForLocationFilter = 98,
        LocationFilterInvalid = 80,
        CannotSetGeoTargetConstantsWithFeedItemSets = 123,
        CannotSetBothAssetSetAndFeed = 140,
        CannotSetFeedOrFeedItemSetsForCustomer = 142,
        CannotSetAssetSetFieldForCustomer = 150,
        CannotSetGeoTargetConstantsWithAssetSets = 143,
        CannotSetAssetSetsWithFeedItemSets = 144,
        InvalidLocationGroupAssetSet = 141,
        InvalidLocationGroupRadius = 124,
        InvalidLocationGroupRadiusUnit = 125,
        CannotAttachCriteriaAtCampaignAndAdgroup = 81,
        HotelLengthOfStayOverlapsWithExistingCriterion = 82,
        HotelAdvanceBookingWindowOverlapsWithExistingCriterion = 83,
        FieldIncompatibleWithNegativeTargeting = 84,
        InvalidWebpageCondition = 85,
        InvalidWebpageConditionUrl = 86,
        WebpageConditionUrlCannotBeEmpty = 87,
        WebpageConditionUrlUnsupportedProtocol = 88,
        WebpageConditionUrlCannotBeIpAddress = 89,
        WebpageConditionUrlDomainNotConsistentWithCampaignSetting = 90,
        WebpageConditionUrlCannotBePublicSuffix = 91,
        WebpageConditionUrlInvalidPublicSuffix = 92,
        WebpageConditionUrlValueTrackValueNotSupported = 93,
        WebpageCriterionUrlEqualsCanHaveOnlyOneCondition = 94,
        WebpageCriterionNotSupportedOnNonDsaAdGroup = 95,
        CannotTargetUserListForSmartDisplayCampaigns = 99,
        CannotTargetPlacementsForSearchCampaigns = 126,
        ListingScopeTooManyDimensionTypes = 100,
        ListingScopeTooManyInOperators = 101,
        ListingScopeInOperatorNotSupported = 102,
        DuplicateListingDimensionType = 103,
        DuplicateListingDimensionValue = 104,
        CannotSetBidsOnListingGroupSubdivision = 105,
        InvalidListingGroupHierarchy = 106,
        ListingGroupUnitCannotHaveChildren = 107,
        ListingGroupSubdivisionRequiresOthersCase = 108,
        ListingGroupRequiresSameDimensionTypeAsSiblings = 109,
        ListingGroupAlreadyExists = 110,
        ListingGroupDoesNotExist = 111,
        ListingGroupCannotBeRemoved = 112,
        InvalidListingGroupType = 113,
        ListingGroupAddMayOnlyUseTempId = 114,
        ListingScopeTooLong = 115,
        ListingScopeTooManyDimensions = 116,
        ListingGroupTooLong = 117,
        ListingGroupTreeTooDeep = 118,
        InvalidListingDimension = 119,
        InvalidListingDimensionType = 120,
        AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay = 127,
        CannotTargetRemovedCombinedAudience = 128,
        InvalidCombinedAudienceId = 129,
        CannotTargetRemovedCustomAudience = 130,
        HotelCheckInDateRangeOverlapsWithExistingCriterion = 131,
        HotelCheckInDateRangeStartDateTooEarly = 132,
        HotelCheckInDateRangeEndDateTooLate = 133,
        HotelCheckInDateRangeReversed = 134,
        BroadMatchModifierKeywordNotAllowed = 135,
        OneAudienceAllowedPerAssetGroup = 136,
        AudienceNotEligibleForCampaignType = 137,
        AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse = 138,
        CannotTargetCustomerMatchUserList = 139,
        NegativeKeywordSharedSetDoesNotExist = 145,
        CannotAddRemovedNegativeKeywordSharedSet = 146,
        CannotHaveMultipleNegativeKeywordListPerAccount = 147,
        CustomerCannotAddCriterionOfThisType = 149,
        CannotTargetSimilarUserList = 151,
        CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet = 152,
        OneAudienceAllowedPerAdGroup = 153,
        InvalidDetailedDemographic = 154,
        CannotRecognizeBrand = 155,
        BrandSharedSetDoesNotExist = 156,
        CannotAddRemovedBrandSharedSet = 157,
        OnlyExclusionBrandListAllowedForCampaignType = 158,
    }
    impl CriterionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionError::Unspecified => "UNSPECIFIED",
                CriterionError::Unknown => "UNKNOWN",
                CriterionError::ConcreteTypeRequired => "CONCRETE_TYPE_REQUIRED",
                CriterionError::InvalidExcludedCategory => "INVALID_EXCLUDED_CATEGORY",
                CriterionError::InvalidKeywordText => "INVALID_KEYWORD_TEXT",
                CriterionError::KeywordTextTooLong => "KEYWORD_TEXT_TOO_LONG",
                CriterionError::KeywordHasTooManyWords => "KEYWORD_HAS_TOO_MANY_WORDS",
                CriterionError::KeywordHasInvalidChars => "KEYWORD_HAS_INVALID_CHARS",
                CriterionError::InvalidPlacementUrl => "INVALID_PLACEMENT_URL",
                CriterionError::InvalidUserList => "INVALID_USER_LIST",
                CriterionError::InvalidUserInterest => "INVALID_USER_INTEREST",
                CriterionError::InvalidFormatForPlacementUrl => {
                    "INVALID_FORMAT_FOR_PLACEMENT_URL"
                }
                CriterionError::PlacementUrlIsTooLong => "PLACEMENT_URL_IS_TOO_LONG",
                CriterionError::PlacementUrlHasIllegalChar => {
                    "PLACEMENT_URL_HAS_ILLEGAL_CHAR"
                }
                CriterionError::PlacementUrlHasMultipleSitesInLine => {
                    "PLACEMENT_URL_HAS_MULTIPLE_SITES_IN_LINE"
                }
                CriterionError::PlacementIsNotAvailableForTargetingOrExclusion => {
                    "PLACEMENT_IS_NOT_AVAILABLE_FOR_TARGETING_OR_EXCLUSION"
                }
                CriterionError::InvalidTopicPath => "INVALID_TOPIC_PATH",
                CriterionError::InvalidYoutubeChannelId => "INVALID_YOUTUBE_CHANNEL_ID",
                CriterionError::InvalidYoutubeVideoId => "INVALID_YOUTUBE_VIDEO_ID",
                CriterionError::YoutubeVerticalChannelDeprecated => {
                    "YOUTUBE_VERTICAL_CHANNEL_DEPRECATED"
                }
                CriterionError::YoutubeDemographicChannelDeprecated => {
                    "YOUTUBE_DEMOGRAPHIC_CHANNEL_DEPRECATED"
                }
                CriterionError::YoutubeUrlUnsupported => "YOUTUBE_URL_UNSUPPORTED",
                CriterionError::CannotExcludeCriteriaType => {
                    "CANNOT_EXCLUDE_CRITERIA_TYPE"
                }
                CriterionError::CannotAddCriteriaType => "CANNOT_ADD_CRITERIA_TYPE",
                CriterionError::CannotExcludeSimilarUserList => {
                    "CANNOT_EXCLUDE_SIMILAR_USER_LIST"
                }
                CriterionError::CannotAddClosedUserList => "CANNOT_ADD_CLOSED_USER_LIST",
                CriterionError::CannotAddDisplayOnlyListsToSearchOnlyCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_ONLY_CAMPAIGNS"
                }
                CriterionError::CannotAddDisplayOnlyListsToSearchCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_CAMPAIGNS"
                }
                CriterionError::CannotAddDisplayOnlyListsToShoppingCampaigns => {
                    "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SHOPPING_CAMPAIGNS"
                }
                CriterionError::CannotAddUserInterestsToSearchCampaigns => {
                    "CANNOT_ADD_USER_INTERESTS_TO_SEARCH_CAMPAIGNS"
                }
                CriterionError::CannotSetBidsOnCriterionTypeInSearchCampaigns => {
                    "CANNOT_SET_BIDS_ON_CRITERION_TYPE_IN_SEARCH_CAMPAIGNS"
                }
                CriterionError::CannotAddUrlsToCriterionTypeForCampaignType => {
                    "CANNOT_ADD_URLS_TO_CRITERION_TYPE_FOR_CAMPAIGN_TYPE"
                }
                CriterionError::InvalidCombinedAudience => "INVALID_COMBINED_AUDIENCE",
                CriterionError::InvalidCustomAffinity => "INVALID_CUSTOM_AFFINITY",
                CriterionError::InvalidCustomIntent => "INVALID_CUSTOM_INTENT",
                CriterionError::InvalidCustomAudience => "INVALID_CUSTOM_AUDIENCE",
                CriterionError::InvalidIpAddress => "INVALID_IP_ADDRESS",
                CriterionError::InvalidIpFormat => "INVALID_IP_FORMAT",
                CriterionError::InvalidMobileApp => "INVALID_MOBILE_APP",
                CriterionError::InvalidMobileAppCategory => "INVALID_MOBILE_APP_CATEGORY",
                CriterionError::InvalidCriterionId => "INVALID_CRITERION_ID",
                CriterionError::CannotTargetCriterion => "CANNOT_TARGET_CRITERION",
                CriterionError::CannotTargetObsoleteCriterion => {
                    "CANNOT_TARGET_OBSOLETE_CRITERION"
                }
                CriterionError::CriterionIdAndTypeMismatch => {
                    "CRITERION_ID_AND_TYPE_MISMATCH"
                }
                CriterionError::InvalidProximityRadius => "INVALID_PROXIMITY_RADIUS",
                CriterionError::InvalidProximityRadiusUnits => {
                    "INVALID_PROXIMITY_RADIUS_UNITS"
                }
                CriterionError::InvalidStreetaddressLength => {
                    "INVALID_STREETADDRESS_LENGTH"
                }
                CriterionError::InvalidCitynameLength => "INVALID_CITYNAME_LENGTH",
                CriterionError::InvalidRegioncodeLength => "INVALID_REGIONCODE_LENGTH",
                CriterionError::InvalidRegionnameLength => "INVALID_REGIONNAME_LENGTH",
                CriterionError::InvalidPostalcodeLength => "INVALID_POSTALCODE_LENGTH",
                CriterionError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                CriterionError::InvalidLatitude => "INVALID_LATITUDE",
                CriterionError::InvalidLongitude => "INVALID_LONGITUDE",
                CriterionError::ProximityGeopointAndAddressBothCannotBeNull => {
                    "PROXIMITY_GEOPOINT_AND_ADDRESS_BOTH_CANNOT_BE_NULL"
                }
                CriterionError::InvalidProximityAddress => "INVALID_PROXIMITY_ADDRESS",
                CriterionError::InvalidUserDomainName => "INVALID_USER_DOMAIN_NAME",
                CriterionError::CriterionParameterTooLong => {
                    "CRITERION_PARAMETER_TOO_LONG"
                }
                CriterionError::AdScheduleTimeIntervalsOverlap => {
                    "AD_SCHEDULE_TIME_INTERVALS_OVERLAP"
                }
                CriterionError::AdScheduleIntervalCannotSpanMultipleDays => {
                    "AD_SCHEDULE_INTERVAL_CANNOT_SPAN_MULTIPLE_DAYS"
                }
                CriterionError::AdScheduleInvalidTimeInterval => {
                    "AD_SCHEDULE_INVALID_TIME_INTERVAL"
                }
                CriterionError::AdScheduleExceededIntervalsPerDayLimit => {
                    "AD_SCHEDULE_EXCEEDED_INTERVALS_PER_DAY_LIMIT"
                }
                CriterionError::AdScheduleCriterionIdMismatchingFields => {
                    "AD_SCHEDULE_CRITERION_ID_MISMATCHING_FIELDS"
                }
                CriterionError::CannotBidModifyCriterionType => {
                    "CANNOT_BID_MODIFY_CRITERION_TYPE"
                }
                CriterionError::CannotBidModifyCriterionCampaignOptedOut => {
                    "CANNOT_BID_MODIFY_CRITERION_CAMPAIGN_OPTED_OUT"
                }
                CriterionError::CannotBidModifyNegativeCriterion => {
                    "CANNOT_BID_MODIFY_NEGATIVE_CRITERION"
                }
                CriterionError::BidModifierAlreadyExists => "BID_MODIFIER_ALREADY_EXISTS",
                CriterionError::FeedIdNotAllowed => "FEED_ID_NOT_ALLOWED",
                CriterionError::AccountIneligibleForCriteriaType => {
                    "ACCOUNT_INELIGIBLE_FOR_CRITERIA_TYPE"
                }
                CriterionError::CriteriaTypeInvalidForBiddingStrategy => {
                    "CRITERIA_TYPE_INVALID_FOR_BIDDING_STRATEGY"
                }
                CriterionError::CannotExcludeCriterion => "CANNOT_EXCLUDE_CRITERION",
                CriterionError::CannotRemoveCriterion => "CANNOT_REMOVE_CRITERION",
                CriterionError::InvalidProductBiddingCategory => {
                    "INVALID_PRODUCT_BIDDING_CATEGORY"
                }
                CriterionError::MissingShoppingSetting => "MISSING_SHOPPING_SETTING",
                CriterionError::InvalidMatchingFunction => "INVALID_MATCHING_FUNCTION",
                CriterionError::LocationFilterNotAllowed => "LOCATION_FILTER_NOT_ALLOWED",
                CriterionError::InvalidFeedForLocationFilter => {
                    "INVALID_FEED_FOR_LOCATION_FILTER"
                }
                CriterionError::LocationFilterInvalid => "LOCATION_FILTER_INVALID",
                CriterionError::CannotSetGeoTargetConstantsWithFeedItemSets => {
                    "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_FEED_ITEM_SETS"
                }
                CriterionError::CannotSetBothAssetSetAndFeed => {
                    "CANNOT_SET_BOTH_ASSET_SET_AND_FEED"
                }
                CriterionError::CannotSetFeedOrFeedItemSetsForCustomer => {
                    "CANNOT_SET_FEED_OR_FEED_ITEM_SETS_FOR_CUSTOMER"
                }
                CriterionError::CannotSetAssetSetFieldForCustomer => {
                    "CANNOT_SET_ASSET_SET_FIELD_FOR_CUSTOMER"
                }
                CriterionError::CannotSetGeoTargetConstantsWithAssetSets => {
                    "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_ASSET_SETS"
                }
                CriterionError::CannotSetAssetSetsWithFeedItemSets => {
                    "CANNOT_SET_ASSET_SETS_WITH_FEED_ITEM_SETS"
                }
                CriterionError::InvalidLocationGroupAssetSet => {
                    "INVALID_LOCATION_GROUP_ASSET_SET"
                }
                CriterionError::InvalidLocationGroupRadius => {
                    "INVALID_LOCATION_GROUP_RADIUS"
                }
                CriterionError::InvalidLocationGroupRadiusUnit => {
                    "INVALID_LOCATION_GROUP_RADIUS_UNIT"
                }
                CriterionError::CannotAttachCriteriaAtCampaignAndAdgroup => {
                    "CANNOT_ATTACH_CRITERIA_AT_CAMPAIGN_AND_ADGROUP"
                }
                CriterionError::HotelLengthOfStayOverlapsWithExistingCriterion => {
                    "HOTEL_LENGTH_OF_STAY_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                CriterionError::HotelAdvanceBookingWindowOverlapsWithExistingCriterion => {
                    "HOTEL_ADVANCE_BOOKING_WINDOW_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                CriterionError::FieldIncompatibleWithNegativeTargeting => {
                    "FIELD_INCOMPATIBLE_WITH_NEGATIVE_TARGETING"
                }
                CriterionError::InvalidWebpageCondition => "INVALID_WEBPAGE_CONDITION",
                CriterionError::InvalidWebpageConditionUrl => {
                    "INVALID_WEBPAGE_CONDITION_URL"
                }
                CriterionError::WebpageConditionUrlCannotBeEmpty => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_EMPTY"
                }
                CriterionError::WebpageConditionUrlUnsupportedProtocol => {
                    "WEBPAGE_CONDITION_URL_UNSUPPORTED_PROTOCOL"
                }
                CriterionError::WebpageConditionUrlCannotBeIpAddress => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_IP_ADDRESS"
                }
                CriterionError::WebpageConditionUrlDomainNotConsistentWithCampaignSetting => {
                    "WEBPAGE_CONDITION_URL_DOMAIN_NOT_CONSISTENT_WITH_CAMPAIGN_SETTING"
                }
                CriterionError::WebpageConditionUrlCannotBePublicSuffix => {
                    "WEBPAGE_CONDITION_URL_CANNOT_BE_PUBLIC_SUFFIX"
                }
                CriterionError::WebpageConditionUrlInvalidPublicSuffix => {
                    "WEBPAGE_CONDITION_URL_INVALID_PUBLIC_SUFFIX"
                }
                CriterionError::WebpageConditionUrlValueTrackValueNotSupported => {
                    "WEBPAGE_CONDITION_URL_VALUE_TRACK_VALUE_NOT_SUPPORTED"
                }
                CriterionError::WebpageCriterionUrlEqualsCanHaveOnlyOneCondition => {
                    "WEBPAGE_CRITERION_URL_EQUALS_CAN_HAVE_ONLY_ONE_CONDITION"
                }
                CriterionError::WebpageCriterionNotSupportedOnNonDsaAdGroup => {
                    "WEBPAGE_CRITERION_NOT_SUPPORTED_ON_NON_DSA_AD_GROUP"
                }
                CriterionError::CannotTargetUserListForSmartDisplayCampaigns => {
                    "CANNOT_TARGET_USER_LIST_FOR_SMART_DISPLAY_CAMPAIGNS"
                }
                CriterionError::CannotTargetPlacementsForSearchCampaigns => {
                    "CANNOT_TARGET_PLACEMENTS_FOR_SEARCH_CAMPAIGNS"
                }
                CriterionError::ListingScopeTooManyDimensionTypes => {
                    "LISTING_SCOPE_TOO_MANY_DIMENSION_TYPES"
                }
                CriterionError::ListingScopeTooManyInOperators => {
                    "LISTING_SCOPE_TOO_MANY_IN_OPERATORS"
                }
                CriterionError::ListingScopeInOperatorNotSupported => {
                    "LISTING_SCOPE_IN_OPERATOR_NOT_SUPPORTED"
                }
                CriterionError::DuplicateListingDimensionType => {
                    "DUPLICATE_LISTING_DIMENSION_TYPE"
                }
                CriterionError::DuplicateListingDimensionValue => {
                    "DUPLICATE_LISTING_DIMENSION_VALUE"
                }
                CriterionError::CannotSetBidsOnListingGroupSubdivision => {
                    "CANNOT_SET_BIDS_ON_LISTING_GROUP_SUBDIVISION"
                }
                CriterionError::InvalidListingGroupHierarchy => {
                    "INVALID_LISTING_GROUP_HIERARCHY"
                }
                CriterionError::ListingGroupUnitCannotHaveChildren => {
                    "LISTING_GROUP_UNIT_CANNOT_HAVE_CHILDREN"
                }
                CriterionError::ListingGroupSubdivisionRequiresOthersCase => {
                    "LISTING_GROUP_SUBDIVISION_REQUIRES_OTHERS_CASE"
                }
                CriterionError::ListingGroupRequiresSameDimensionTypeAsSiblings => {
                    "LISTING_GROUP_REQUIRES_SAME_DIMENSION_TYPE_AS_SIBLINGS"
                }
                CriterionError::ListingGroupAlreadyExists => {
                    "LISTING_GROUP_ALREADY_EXISTS"
                }
                CriterionError::ListingGroupDoesNotExist => {
                    "LISTING_GROUP_DOES_NOT_EXIST"
                }
                CriterionError::ListingGroupCannotBeRemoved => {
                    "LISTING_GROUP_CANNOT_BE_REMOVED"
                }
                CriterionError::InvalidListingGroupType => "INVALID_LISTING_GROUP_TYPE",
                CriterionError::ListingGroupAddMayOnlyUseTempId => {
                    "LISTING_GROUP_ADD_MAY_ONLY_USE_TEMP_ID"
                }
                CriterionError::ListingScopeTooLong => "LISTING_SCOPE_TOO_LONG",
                CriterionError::ListingScopeTooManyDimensions => {
                    "LISTING_SCOPE_TOO_MANY_DIMENSIONS"
                }
                CriterionError::ListingGroupTooLong => "LISTING_GROUP_TOO_LONG",
                CriterionError::ListingGroupTreeTooDeep => "LISTING_GROUP_TREE_TOO_DEEP",
                CriterionError::InvalidListingDimension => "INVALID_LISTING_DIMENSION",
                CriterionError::InvalidListingDimensionType => {
                    "INVALID_LISTING_DIMENSION_TYPE"
                }
                CriterionError::AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay => {
                    "ADVERTISER_NOT_ON_ALLOWLIST_FOR_COMBINED_AUDIENCE_ON_DISPLAY"
                }
                CriterionError::CannotTargetRemovedCombinedAudience => {
                    "CANNOT_TARGET_REMOVED_COMBINED_AUDIENCE"
                }
                CriterionError::InvalidCombinedAudienceId => {
                    "INVALID_COMBINED_AUDIENCE_ID"
                }
                CriterionError::CannotTargetRemovedCustomAudience => {
                    "CANNOT_TARGET_REMOVED_CUSTOM_AUDIENCE"
                }
                CriterionError::HotelCheckInDateRangeOverlapsWithExistingCriterion => {
                    "HOTEL_CHECK_IN_DATE_RANGE_OVERLAPS_WITH_EXISTING_CRITERION"
                }
                CriterionError::HotelCheckInDateRangeStartDateTooEarly => {
                    "HOTEL_CHECK_IN_DATE_RANGE_START_DATE_TOO_EARLY"
                }
                CriterionError::HotelCheckInDateRangeEndDateTooLate => {
                    "HOTEL_CHECK_IN_DATE_RANGE_END_DATE_TOO_LATE"
                }
                CriterionError::HotelCheckInDateRangeReversed => {
                    "HOTEL_CHECK_IN_DATE_RANGE_REVERSED"
                }
                CriterionError::BroadMatchModifierKeywordNotAllowed => {
                    "BROAD_MATCH_MODIFIER_KEYWORD_NOT_ALLOWED"
                }
                CriterionError::OneAudienceAllowedPerAssetGroup => {
                    "ONE_AUDIENCE_ALLOWED_PER_ASSET_GROUP"
                }
                CriterionError::AudienceNotEligibleForCampaignType => {
                    "AUDIENCE_NOT_ELIGIBLE_FOR_CAMPAIGN_TYPE"
                }
                CriterionError::AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse => {
                    "AUDIENCE_NOT_ALLOWED_TO_ATTACH_WHEN_AUDIENCE_GROUPED_SET_TO_FALSE"
                }
                CriterionError::CannotTargetCustomerMatchUserList => {
                    "CANNOT_TARGET_CUSTOMER_MATCH_USER_LIST"
                }
                CriterionError::NegativeKeywordSharedSetDoesNotExist => {
                    "NEGATIVE_KEYWORD_SHARED_SET_DOES_NOT_EXIST"
                }
                CriterionError::CannotAddRemovedNegativeKeywordSharedSet => {
                    "CANNOT_ADD_REMOVED_NEGATIVE_KEYWORD_SHARED_SET"
                }
                CriterionError::CannotHaveMultipleNegativeKeywordListPerAccount => {
                    "CANNOT_HAVE_MULTIPLE_NEGATIVE_KEYWORD_LIST_PER_ACCOUNT"
                }
                CriterionError::CustomerCannotAddCriterionOfThisType => {
                    "CUSTOMER_CANNOT_ADD_CRITERION_OF_THIS_TYPE"
                }
                CriterionError::CannotTargetSimilarUserList => {
                    "CANNOT_TARGET_SIMILAR_USER_LIST"
                }
                CriterionError::CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet => {
                    "CANNOT_ADD_AUDIENCE_SEGMENT_CRITERION_WHEN_AUDIENCE_GROUPED_IS_SET"
                }
                CriterionError::OneAudienceAllowedPerAdGroup => {
                    "ONE_AUDIENCE_ALLOWED_PER_AD_GROUP"
                }
                CriterionError::InvalidDetailedDemographic => {
                    "INVALID_DETAILED_DEMOGRAPHIC"
                }
                CriterionError::CannotRecognizeBrand => "CANNOT_RECOGNIZE_BRAND",
                CriterionError::BrandSharedSetDoesNotExist => {
                    "BRAND_SHARED_SET_DOES_NOT_EXIST"
                }
                CriterionError::CannotAddRemovedBrandSharedSet => {
                    "CANNOT_ADD_REMOVED_BRAND_SHARED_SET"
                }
                CriterionError::OnlyExclusionBrandListAllowedForCampaignType => {
                    "ONLY_EXCLUSION_BRAND_LIST_ALLOWED_FOR_CAMPAIGN_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCRETE_TYPE_REQUIRED" => Some(Self::ConcreteTypeRequired),
                "INVALID_EXCLUDED_CATEGORY" => Some(Self::InvalidExcludedCategory),
                "INVALID_KEYWORD_TEXT" => Some(Self::InvalidKeywordText),
                "KEYWORD_TEXT_TOO_LONG" => Some(Self::KeywordTextTooLong),
                "KEYWORD_HAS_TOO_MANY_WORDS" => Some(Self::KeywordHasTooManyWords),
                "KEYWORD_HAS_INVALID_CHARS" => Some(Self::KeywordHasInvalidChars),
                "INVALID_PLACEMENT_URL" => Some(Self::InvalidPlacementUrl),
                "INVALID_USER_LIST" => Some(Self::InvalidUserList),
                "INVALID_USER_INTEREST" => Some(Self::InvalidUserInterest),
                "INVALID_FORMAT_FOR_PLACEMENT_URL" => {
                    Some(Self::InvalidFormatForPlacementUrl)
                }
                "PLACEMENT_URL_IS_TOO_LONG" => Some(Self::PlacementUrlIsTooLong),
                "PLACEMENT_URL_HAS_ILLEGAL_CHAR" => {
                    Some(Self::PlacementUrlHasIllegalChar)
                }
                "PLACEMENT_URL_HAS_MULTIPLE_SITES_IN_LINE" => {
                    Some(Self::PlacementUrlHasMultipleSitesInLine)
                }
                "PLACEMENT_IS_NOT_AVAILABLE_FOR_TARGETING_OR_EXCLUSION" => {
                    Some(Self::PlacementIsNotAvailableForTargetingOrExclusion)
                }
                "INVALID_TOPIC_PATH" => Some(Self::InvalidTopicPath),
                "INVALID_YOUTUBE_CHANNEL_ID" => Some(Self::InvalidYoutubeChannelId),
                "INVALID_YOUTUBE_VIDEO_ID" => Some(Self::InvalidYoutubeVideoId),
                "YOUTUBE_VERTICAL_CHANNEL_DEPRECATED" => {
                    Some(Self::YoutubeVerticalChannelDeprecated)
                }
                "YOUTUBE_DEMOGRAPHIC_CHANNEL_DEPRECATED" => {
                    Some(Self::YoutubeDemographicChannelDeprecated)
                }
                "YOUTUBE_URL_UNSUPPORTED" => Some(Self::YoutubeUrlUnsupported),
                "CANNOT_EXCLUDE_CRITERIA_TYPE" => Some(Self::CannotExcludeCriteriaType),
                "CANNOT_ADD_CRITERIA_TYPE" => Some(Self::CannotAddCriteriaType),
                "CANNOT_EXCLUDE_SIMILAR_USER_LIST" => {
                    Some(Self::CannotExcludeSimilarUserList)
                }
                "CANNOT_ADD_CLOSED_USER_LIST" => Some(Self::CannotAddClosedUserList),
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_ONLY_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToSearchOnlyCampaigns)
                }
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToSearchCampaigns)
                }
                "CANNOT_ADD_DISPLAY_ONLY_LISTS_TO_SHOPPING_CAMPAIGNS" => {
                    Some(Self::CannotAddDisplayOnlyListsToShoppingCampaigns)
                }
                "CANNOT_ADD_USER_INTERESTS_TO_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotAddUserInterestsToSearchCampaigns)
                }
                "CANNOT_SET_BIDS_ON_CRITERION_TYPE_IN_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotSetBidsOnCriterionTypeInSearchCampaigns)
                }
                "CANNOT_ADD_URLS_TO_CRITERION_TYPE_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::CannotAddUrlsToCriterionTypeForCampaignType)
                }
                "INVALID_COMBINED_AUDIENCE" => Some(Self::InvalidCombinedAudience),
                "INVALID_CUSTOM_AFFINITY" => Some(Self::InvalidCustomAffinity),
                "INVALID_CUSTOM_INTENT" => Some(Self::InvalidCustomIntent),
                "INVALID_CUSTOM_AUDIENCE" => Some(Self::InvalidCustomAudience),
                "INVALID_IP_ADDRESS" => Some(Self::InvalidIpAddress),
                "INVALID_IP_FORMAT" => Some(Self::InvalidIpFormat),
                "INVALID_MOBILE_APP" => Some(Self::InvalidMobileApp),
                "INVALID_MOBILE_APP_CATEGORY" => Some(Self::InvalidMobileAppCategory),
                "INVALID_CRITERION_ID" => Some(Self::InvalidCriterionId),
                "CANNOT_TARGET_CRITERION" => Some(Self::CannotTargetCriterion),
                "CANNOT_TARGET_OBSOLETE_CRITERION" => {
                    Some(Self::CannotTargetObsoleteCriterion)
                }
                "CRITERION_ID_AND_TYPE_MISMATCH" => {
                    Some(Self::CriterionIdAndTypeMismatch)
                }
                "INVALID_PROXIMITY_RADIUS" => Some(Self::InvalidProximityRadius),
                "INVALID_PROXIMITY_RADIUS_UNITS" => {
                    Some(Self::InvalidProximityRadiusUnits)
                }
                "INVALID_STREETADDRESS_LENGTH" => Some(Self::InvalidStreetaddressLength),
                "INVALID_CITYNAME_LENGTH" => Some(Self::InvalidCitynameLength),
                "INVALID_REGIONCODE_LENGTH" => Some(Self::InvalidRegioncodeLength),
                "INVALID_REGIONNAME_LENGTH" => Some(Self::InvalidRegionnameLength),
                "INVALID_POSTALCODE_LENGTH" => Some(Self::InvalidPostalcodeLength),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_LATITUDE" => Some(Self::InvalidLatitude),
                "INVALID_LONGITUDE" => Some(Self::InvalidLongitude),
                "PROXIMITY_GEOPOINT_AND_ADDRESS_BOTH_CANNOT_BE_NULL" => {
                    Some(Self::ProximityGeopointAndAddressBothCannotBeNull)
                }
                "INVALID_PROXIMITY_ADDRESS" => Some(Self::InvalidProximityAddress),
                "INVALID_USER_DOMAIN_NAME" => Some(Self::InvalidUserDomainName),
                "CRITERION_PARAMETER_TOO_LONG" => Some(Self::CriterionParameterTooLong),
                "AD_SCHEDULE_TIME_INTERVALS_OVERLAP" => {
                    Some(Self::AdScheduleTimeIntervalsOverlap)
                }
                "AD_SCHEDULE_INTERVAL_CANNOT_SPAN_MULTIPLE_DAYS" => {
                    Some(Self::AdScheduleIntervalCannotSpanMultipleDays)
                }
                "AD_SCHEDULE_INVALID_TIME_INTERVAL" => {
                    Some(Self::AdScheduleInvalidTimeInterval)
                }
                "AD_SCHEDULE_EXCEEDED_INTERVALS_PER_DAY_LIMIT" => {
                    Some(Self::AdScheduleExceededIntervalsPerDayLimit)
                }
                "AD_SCHEDULE_CRITERION_ID_MISMATCHING_FIELDS" => {
                    Some(Self::AdScheduleCriterionIdMismatchingFields)
                }
                "CANNOT_BID_MODIFY_CRITERION_TYPE" => {
                    Some(Self::CannotBidModifyCriterionType)
                }
                "CANNOT_BID_MODIFY_CRITERION_CAMPAIGN_OPTED_OUT" => {
                    Some(Self::CannotBidModifyCriterionCampaignOptedOut)
                }
                "CANNOT_BID_MODIFY_NEGATIVE_CRITERION" => {
                    Some(Self::CannotBidModifyNegativeCriterion)
                }
                "BID_MODIFIER_ALREADY_EXISTS" => Some(Self::BidModifierAlreadyExists),
                "FEED_ID_NOT_ALLOWED" => Some(Self::FeedIdNotAllowed),
                "ACCOUNT_INELIGIBLE_FOR_CRITERIA_TYPE" => {
                    Some(Self::AccountIneligibleForCriteriaType)
                }
                "CRITERIA_TYPE_INVALID_FOR_BIDDING_STRATEGY" => {
                    Some(Self::CriteriaTypeInvalidForBiddingStrategy)
                }
                "CANNOT_EXCLUDE_CRITERION" => Some(Self::CannotExcludeCriterion),
                "CANNOT_REMOVE_CRITERION" => Some(Self::CannotRemoveCriterion),
                "INVALID_PRODUCT_BIDDING_CATEGORY" => {
                    Some(Self::InvalidProductBiddingCategory)
                }
                "MISSING_SHOPPING_SETTING" => Some(Self::MissingShoppingSetting),
                "INVALID_MATCHING_FUNCTION" => Some(Self::InvalidMatchingFunction),
                "LOCATION_FILTER_NOT_ALLOWED" => Some(Self::LocationFilterNotAllowed),
                "INVALID_FEED_FOR_LOCATION_FILTER" => {
                    Some(Self::InvalidFeedForLocationFilter)
                }
                "LOCATION_FILTER_INVALID" => Some(Self::LocationFilterInvalid),
                "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_FEED_ITEM_SETS" => {
                    Some(Self::CannotSetGeoTargetConstantsWithFeedItemSets)
                }
                "CANNOT_SET_BOTH_ASSET_SET_AND_FEED" => {
                    Some(Self::CannotSetBothAssetSetAndFeed)
                }
                "CANNOT_SET_FEED_OR_FEED_ITEM_SETS_FOR_CUSTOMER" => {
                    Some(Self::CannotSetFeedOrFeedItemSetsForCustomer)
                }
                "CANNOT_SET_ASSET_SET_FIELD_FOR_CUSTOMER" => {
                    Some(Self::CannotSetAssetSetFieldForCustomer)
                }
                "CANNOT_SET_GEO_TARGET_CONSTANTS_WITH_ASSET_SETS" => {
                    Some(Self::CannotSetGeoTargetConstantsWithAssetSets)
                }
                "CANNOT_SET_ASSET_SETS_WITH_FEED_ITEM_SETS" => {
                    Some(Self::CannotSetAssetSetsWithFeedItemSets)
                }
                "INVALID_LOCATION_GROUP_ASSET_SET" => {
                    Some(Self::InvalidLocationGroupAssetSet)
                }
                "INVALID_LOCATION_GROUP_RADIUS" => Some(Self::InvalidLocationGroupRadius),
                "INVALID_LOCATION_GROUP_RADIUS_UNIT" => {
                    Some(Self::InvalidLocationGroupRadiusUnit)
                }
                "CANNOT_ATTACH_CRITERIA_AT_CAMPAIGN_AND_ADGROUP" => {
                    Some(Self::CannotAttachCriteriaAtCampaignAndAdgroup)
                }
                "HOTEL_LENGTH_OF_STAY_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelLengthOfStayOverlapsWithExistingCriterion)
                }
                "HOTEL_ADVANCE_BOOKING_WINDOW_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelAdvanceBookingWindowOverlapsWithExistingCriterion)
                }
                "FIELD_INCOMPATIBLE_WITH_NEGATIVE_TARGETING" => {
                    Some(Self::FieldIncompatibleWithNegativeTargeting)
                }
                "INVALID_WEBPAGE_CONDITION" => Some(Self::InvalidWebpageCondition),
                "INVALID_WEBPAGE_CONDITION_URL" => Some(Self::InvalidWebpageConditionUrl),
                "WEBPAGE_CONDITION_URL_CANNOT_BE_EMPTY" => {
                    Some(Self::WebpageConditionUrlCannotBeEmpty)
                }
                "WEBPAGE_CONDITION_URL_UNSUPPORTED_PROTOCOL" => {
                    Some(Self::WebpageConditionUrlUnsupportedProtocol)
                }
                "WEBPAGE_CONDITION_URL_CANNOT_BE_IP_ADDRESS" => {
                    Some(Self::WebpageConditionUrlCannotBeIpAddress)
                }
                "WEBPAGE_CONDITION_URL_DOMAIN_NOT_CONSISTENT_WITH_CAMPAIGN_SETTING" => {
                    Some(Self::WebpageConditionUrlDomainNotConsistentWithCampaignSetting)
                }
                "WEBPAGE_CONDITION_URL_CANNOT_BE_PUBLIC_SUFFIX" => {
                    Some(Self::WebpageConditionUrlCannotBePublicSuffix)
                }
                "WEBPAGE_CONDITION_URL_INVALID_PUBLIC_SUFFIX" => {
                    Some(Self::WebpageConditionUrlInvalidPublicSuffix)
                }
                "WEBPAGE_CONDITION_URL_VALUE_TRACK_VALUE_NOT_SUPPORTED" => {
                    Some(Self::WebpageConditionUrlValueTrackValueNotSupported)
                }
                "WEBPAGE_CRITERION_URL_EQUALS_CAN_HAVE_ONLY_ONE_CONDITION" => {
                    Some(Self::WebpageCriterionUrlEqualsCanHaveOnlyOneCondition)
                }
                "WEBPAGE_CRITERION_NOT_SUPPORTED_ON_NON_DSA_AD_GROUP" => {
                    Some(Self::WebpageCriterionNotSupportedOnNonDsaAdGroup)
                }
                "CANNOT_TARGET_USER_LIST_FOR_SMART_DISPLAY_CAMPAIGNS" => {
                    Some(Self::CannotTargetUserListForSmartDisplayCampaigns)
                }
                "CANNOT_TARGET_PLACEMENTS_FOR_SEARCH_CAMPAIGNS" => {
                    Some(Self::CannotTargetPlacementsForSearchCampaigns)
                }
                "LISTING_SCOPE_TOO_MANY_DIMENSION_TYPES" => {
                    Some(Self::ListingScopeTooManyDimensionTypes)
                }
                "LISTING_SCOPE_TOO_MANY_IN_OPERATORS" => {
                    Some(Self::ListingScopeTooManyInOperators)
                }
                "LISTING_SCOPE_IN_OPERATOR_NOT_SUPPORTED" => {
                    Some(Self::ListingScopeInOperatorNotSupported)
                }
                "DUPLICATE_LISTING_DIMENSION_TYPE" => {
                    Some(Self::DuplicateListingDimensionType)
                }
                "DUPLICATE_LISTING_DIMENSION_VALUE" => {
                    Some(Self::DuplicateListingDimensionValue)
                }
                "CANNOT_SET_BIDS_ON_LISTING_GROUP_SUBDIVISION" => {
                    Some(Self::CannotSetBidsOnListingGroupSubdivision)
                }
                "INVALID_LISTING_GROUP_HIERARCHY" => {
                    Some(Self::InvalidListingGroupHierarchy)
                }
                "LISTING_GROUP_UNIT_CANNOT_HAVE_CHILDREN" => {
                    Some(Self::ListingGroupUnitCannotHaveChildren)
                }
                "LISTING_GROUP_SUBDIVISION_REQUIRES_OTHERS_CASE" => {
                    Some(Self::ListingGroupSubdivisionRequiresOthersCase)
                }
                "LISTING_GROUP_REQUIRES_SAME_DIMENSION_TYPE_AS_SIBLINGS" => {
                    Some(Self::ListingGroupRequiresSameDimensionTypeAsSiblings)
                }
                "LISTING_GROUP_ALREADY_EXISTS" => Some(Self::ListingGroupAlreadyExists),
                "LISTING_GROUP_DOES_NOT_EXIST" => Some(Self::ListingGroupDoesNotExist),
                "LISTING_GROUP_CANNOT_BE_REMOVED" => {
                    Some(Self::ListingGroupCannotBeRemoved)
                }
                "INVALID_LISTING_GROUP_TYPE" => Some(Self::InvalidListingGroupType),
                "LISTING_GROUP_ADD_MAY_ONLY_USE_TEMP_ID" => {
                    Some(Self::ListingGroupAddMayOnlyUseTempId)
                }
                "LISTING_SCOPE_TOO_LONG" => Some(Self::ListingScopeTooLong),
                "LISTING_SCOPE_TOO_MANY_DIMENSIONS" => {
                    Some(Self::ListingScopeTooManyDimensions)
                }
                "LISTING_GROUP_TOO_LONG" => Some(Self::ListingGroupTooLong),
                "LISTING_GROUP_TREE_TOO_DEEP" => Some(Self::ListingGroupTreeTooDeep),
                "INVALID_LISTING_DIMENSION" => Some(Self::InvalidListingDimension),
                "INVALID_LISTING_DIMENSION_TYPE" => {
                    Some(Self::InvalidListingDimensionType)
                }
                "ADVERTISER_NOT_ON_ALLOWLIST_FOR_COMBINED_AUDIENCE_ON_DISPLAY" => {
                    Some(Self::AdvertiserNotOnAllowlistForCombinedAudienceOnDisplay)
                }
                "CANNOT_TARGET_REMOVED_COMBINED_AUDIENCE" => {
                    Some(Self::CannotTargetRemovedCombinedAudience)
                }
                "INVALID_COMBINED_AUDIENCE_ID" => Some(Self::InvalidCombinedAudienceId),
                "CANNOT_TARGET_REMOVED_CUSTOM_AUDIENCE" => {
                    Some(Self::CannotTargetRemovedCustomAudience)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_OVERLAPS_WITH_EXISTING_CRITERION" => {
                    Some(Self::HotelCheckInDateRangeOverlapsWithExistingCriterion)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_START_DATE_TOO_EARLY" => {
                    Some(Self::HotelCheckInDateRangeStartDateTooEarly)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_END_DATE_TOO_LATE" => {
                    Some(Self::HotelCheckInDateRangeEndDateTooLate)
                }
                "HOTEL_CHECK_IN_DATE_RANGE_REVERSED" => {
                    Some(Self::HotelCheckInDateRangeReversed)
                }
                "BROAD_MATCH_MODIFIER_KEYWORD_NOT_ALLOWED" => {
                    Some(Self::BroadMatchModifierKeywordNotAllowed)
                }
                "ONE_AUDIENCE_ALLOWED_PER_ASSET_GROUP" => {
                    Some(Self::OneAudienceAllowedPerAssetGroup)
                }
                "AUDIENCE_NOT_ELIGIBLE_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::AudienceNotEligibleForCampaignType)
                }
                "AUDIENCE_NOT_ALLOWED_TO_ATTACH_WHEN_AUDIENCE_GROUPED_SET_TO_FALSE" => {
                    Some(Self::AudienceNotAllowedToAttachWhenAudienceGroupedSetToFalse)
                }
                "CANNOT_TARGET_CUSTOMER_MATCH_USER_LIST" => {
                    Some(Self::CannotTargetCustomerMatchUserList)
                }
                "NEGATIVE_KEYWORD_SHARED_SET_DOES_NOT_EXIST" => {
                    Some(Self::NegativeKeywordSharedSetDoesNotExist)
                }
                "CANNOT_ADD_REMOVED_NEGATIVE_KEYWORD_SHARED_SET" => {
                    Some(Self::CannotAddRemovedNegativeKeywordSharedSet)
                }
                "CANNOT_HAVE_MULTIPLE_NEGATIVE_KEYWORD_LIST_PER_ACCOUNT" => {
                    Some(Self::CannotHaveMultipleNegativeKeywordListPerAccount)
                }
                "CUSTOMER_CANNOT_ADD_CRITERION_OF_THIS_TYPE" => {
                    Some(Self::CustomerCannotAddCriterionOfThisType)
                }
                "CANNOT_TARGET_SIMILAR_USER_LIST" => {
                    Some(Self::CannotTargetSimilarUserList)
                }
                "CANNOT_ADD_AUDIENCE_SEGMENT_CRITERION_WHEN_AUDIENCE_GROUPED_IS_SET" => {
                    Some(Self::CannotAddAudienceSegmentCriterionWhenAudienceGroupedIsSet)
                }
                "ONE_AUDIENCE_ALLOWED_PER_AD_GROUP" => {
                    Some(Self::OneAudienceAllowedPerAdGroup)
                }
                "INVALID_DETAILED_DEMOGRAPHIC" => Some(Self::InvalidDetailedDemographic),
                "CANNOT_RECOGNIZE_BRAND" => Some(Self::CannotRecognizeBrand),
                "BRAND_SHARED_SET_DOES_NOT_EXIST" => {
                    Some(Self::BrandSharedSetDoesNotExist)
                }
                "CANNOT_ADD_REMOVED_BRAND_SHARED_SET" => {
                    Some(Self::CannotAddRemovedBrandSharedSet)
                }
                "ONLY_EXCLUSION_BRAND_LIST_ALLOWED_FOR_CAMPAIGN_TYPE" => {
                    Some(Self::OnlyExclusionBrandListAllowedForCampaignType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CurrencyCodeErrorEnum {}
/// Nested message and enum types in `CurrencyCodeErrorEnum`.
pub mod currency_code_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CurrencyCodeError {
        Unspecified = 0,
        Unknown = 1,
        Unsupported = 2,
    }
    impl CurrencyCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CurrencyCodeError::Unspecified => "UNSPECIFIED",
                CurrencyCodeError::Unknown => "UNKNOWN",
                CurrencyCodeError::Unsupported => "UNSUPPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED" => Some(Self::Unsupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceErrorEnum {}
/// Nested message and enum types in `CustomAudienceErrorEnum`.
pub mod custom_audience_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceError {
        Unspecified = 0,
        Unknown = 1,
        NameAlreadyUsed = 2,
        CannotRemoveWhileInUse = 3,
        ResourceAlreadyRemoved = 4,
        MemberTypeAndParameterAlreadyExisted = 5,
        InvalidMemberType = 6,
        MemberTypeAndValueDoesNotMatch = 7,
        PolicyViolation = 8,
        InvalidTypeChange = 9,
    }
    impl CustomAudienceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomAudienceError::Unspecified => "UNSPECIFIED",
                CustomAudienceError::Unknown => "UNKNOWN",
                CustomAudienceError::NameAlreadyUsed => "NAME_ALREADY_USED",
                CustomAudienceError::CannotRemoveWhileInUse => {
                    "CANNOT_REMOVE_WHILE_IN_USE"
                }
                CustomAudienceError::ResourceAlreadyRemoved => "RESOURCE_ALREADY_REMOVED",
                CustomAudienceError::MemberTypeAndParameterAlreadyExisted => {
                    "MEMBER_TYPE_AND_PARAMETER_ALREADY_EXISTED"
                }
                CustomAudienceError::InvalidMemberType => "INVALID_MEMBER_TYPE",
                CustomAudienceError::MemberTypeAndValueDoesNotMatch => {
                    "MEMBER_TYPE_AND_VALUE_DOES_NOT_MATCH"
                }
                CustomAudienceError::PolicyViolation => "POLICY_VIOLATION",
                CustomAudienceError::InvalidTypeChange => "INVALID_TYPE_CHANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NAME_ALREADY_USED" => Some(Self::NameAlreadyUsed),
                "CANNOT_REMOVE_WHILE_IN_USE" => Some(Self::CannotRemoveWhileInUse),
                "RESOURCE_ALREADY_REMOVED" => Some(Self::ResourceAlreadyRemoved),
                "MEMBER_TYPE_AND_PARAMETER_ALREADY_EXISTED" => {
                    Some(Self::MemberTypeAndParameterAlreadyExisted)
                }
                "INVALID_MEMBER_TYPE" => Some(Self::InvalidMemberType),
                "MEMBER_TYPE_AND_VALUE_DOES_NOT_MATCH" => {
                    Some(Self::MemberTypeAndValueDoesNotMatch)
                }
                "POLICY_VIOLATION" => Some(Self::PolicyViolation),
                "INVALID_TYPE_CHANGE" => Some(Self::InvalidTypeChange),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalErrorEnum {}
/// Nested message and enum types in `CustomConversionGoalErrorEnum`.
pub mod custom_conversion_goal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomConversionGoalError {
        Unspecified = 0,
        Unknown = 1,
        InvalidConversionAction = 2,
        ConversionActionNotEnabled = 3,
        CannotRemoveLinkedCustomConversionGoal = 4,
        CustomGoalDuplicateName = 5,
        DuplicateConversionActionList = 6,
        NonBiddableConversionActionNotEligibleForCustomGoal = 7,
    }
    impl CustomConversionGoalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomConversionGoalError::Unspecified => "UNSPECIFIED",
                CustomConversionGoalError::Unknown => "UNKNOWN",
                CustomConversionGoalError::InvalidConversionAction => {
                    "INVALID_CONVERSION_ACTION"
                }
                CustomConversionGoalError::ConversionActionNotEnabled => {
                    "CONVERSION_ACTION_NOT_ENABLED"
                }
                CustomConversionGoalError::CannotRemoveLinkedCustomConversionGoal => {
                    "CANNOT_REMOVE_LINKED_CUSTOM_CONVERSION_GOAL"
                }
                CustomConversionGoalError::CustomGoalDuplicateName => {
                    "CUSTOM_GOAL_DUPLICATE_NAME"
                }
                CustomConversionGoalError::DuplicateConversionActionList => {
                    "DUPLICATE_CONVERSION_ACTION_LIST"
                }
                CustomConversionGoalError::NonBiddableConversionActionNotEligibleForCustomGoal => {
                    "NON_BIDDABLE_CONVERSION_ACTION_NOT_ELIGIBLE_FOR_CUSTOM_GOAL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_CONVERSION_ACTION" => Some(Self::InvalidConversionAction),
                "CONVERSION_ACTION_NOT_ENABLED" => Some(Self::ConversionActionNotEnabled),
                "CANNOT_REMOVE_LINKED_CUSTOM_CONVERSION_GOAL" => {
                    Some(Self::CannotRemoveLinkedCustomConversionGoal)
                }
                "CUSTOM_GOAL_DUPLICATE_NAME" => Some(Self::CustomGoalDuplicateName),
                "DUPLICATE_CONVERSION_ACTION_LIST" => {
                    Some(Self::DuplicateConversionActionList)
                }
                "NON_BIDDABLE_CONVERSION_ACTION_NOT_ELIGIBLE_FOR_CUSTOM_GOAL" => {
                    Some(Self::NonBiddableConversionActionNotEligibleForCustomGoal)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerCustomizerErrorEnum {}
/// Nested message and enum types in `CustomerCustomizerErrorEnum`.
pub mod customer_customizer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerCustomizerError {
        Unspecified = 0,
        Unknown = 1,
    }
    impl CustomerCustomizerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerCustomizerError::Unspecified => "UNSPECIFIED",
                CustomerCustomizerError::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerErrorEnum {}
/// Nested message and enum types in `CustomerErrorEnum`.
pub mod customer_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerError {
        Unspecified = 0,
        Unknown = 1,
        StatusChangeDisallowed = 2,
        AccountNotSetUp = 3,
    }
    impl CustomerError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerError::Unspecified => "UNSPECIFIED",
                CustomerError::Unknown => "UNKNOWN",
                CustomerError::StatusChangeDisallowed => "STATUS_CHANGE_DISALLOWED",
                CustomerError::AccountNotSetUp => "ACCOUNT_NOT_SET_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STATUS_CHANGE_DISALLOWED" => Some(Self::StatusChangeDisallowed),
                "ACCOUNT_NOT_SET_UP" => Some(Self::AccountNotSetUp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerManagerLinkErrorEnum {}
/// Nested message and enum types in `CustomerManagerLinkErrorEnum`.
pub mod customer_manager_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerManagerLinkError {
        Unspecified = 0,
        Unknown = 1,
        NoPendingInvite = 2,
        SameClientMoreThanOncePerCall = 3,
        ManagerHasMaxNumberOfLinkedAccounts = 4,
        CannotUnlinkAccountWithoutActiveUser = 5,
        CannotRemoveLastClientAccountOwner = 6,
        CannotChangeRoleByNonAccountOwner = 7,
        CannotChangeRoleForNonActiveLinkAccount = 8,
        DuplicateChildFound = 9,
        TestAccountLinksTooManyChildAccounts = 10,
    }
    impl CustomerManagerLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerManagerLinkError::Unspecified => "UNSPECIFIED",
                CustomerManagerLinkError::Unknown => "UNKNOWN",
                CustomerManagerLinkError::NoPendingInvite => "NO_PENDING_INVITE",
                CustomerManagerLinkError::SameClientMoreThanOncePerCall => {
                    "SAME_CLIENT_MORE_THAN_ONCE_PER_CALL"
                }
                CustomerManagerLinkError::ManagerHasMaxNumberOfLinkedAccounts => {
                    "MANAGER_HAS_MAX_NUMBER_OF_LINKED_ACCOUNTS"
                }
                CustomerManagerLinkError::CannotUnlinkAccountWithoutActiveUser => {
                    "CANNOT_UNLINK_ACCOUNT_WITHOUT_ACTIVE_USER"
                }
                CustomerManagerLinkError::CannotRemoveLastClientAccountOwner => {
                    "CANNOT_REMOVE_LAST_CLIENT_ACCOUNT_OWNER"
                }
                CustomerManagerLinkError::CannotChangeRoleByNonAccountOwner => {
                    "CANNOT_CHANGE_ROLE_BY_NON_ACCOUNT_OWNER"
                }
                CustomerManagerLinkError::CannotChangeRoleForNonActiveLinkAccount => {
                    "CANNOT_CHANGE_ROLE_FOR_NON_ACTIVE_LINK_ACCOUNT"
                }
                CustomerManagerLinkError::DuplicateChildFound => "DUPLICATE_CHILD_FOUND",
                CustomerManagerLinkError::TestAccountLinksTooManyChildAccounts => {
                    "TEST_ACCOUNT_LINKS_TOO_MANY_CHILD_ACCOUNTS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_PENDING_INVITE" => Some(Self::NoPendingInvite),
                "SAME_CLIENT_MORE_THAN_ONCE_PER_CALL" => {
                    Some(Self::SameClientMoreThanOncePerCall)
                }
                "MANAGER_HAS_MAX_NUMBER_OF_LINKED_ACCOUNTS" => {
                    Some(Self::ManagerHasMaxNumberOfLinkedAccounts)
                }
                "CANNOT_UNLINK_ACCOUNT_WITHOUT_ACTIVE_USER" => {
                    Some(Self::CannotUnlinkAccountWithoutActiveUser)
                }
                "CANNOT_REMOVE_LAST_CLIENT_ACCOUNT_OWNER" => {
                    Some(Self::CannotRemoveLastClientAccountOwner)
                }
                "CANNOT_CHANGE_ROLE_BY_NON_ACCOUNT_OWNER" => {
                    Some(Self::CannotChangeRoleByNonAccountOwner)
                }
                "CANNOT_CHANGE_ROLE_FOR_NON_ACTIVE_LINK_ACCOUNT" => {
                    Some(Self::CannotChangeRoleForNonActiveLinkAccount)
                }
                "DUPLICATE_CHILD_FOUND" => Some(Self::DuplicateChildFound),
                "TEST_ACCOUNT_LINKS_TOO_MANY_CHILD_ACCOUNTS" => {
                    Some(Self::TestAccountLinksTooManyChildAccounts)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerSkAdNetworkConversionValueSchemaErrorEnum {}
/// Nested message and enum types in `CustomerSkAdNetworkConversionValueSchemaErrorEnum`.
pub mod customer_sk_ad_network_conversion_value_schema_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerSkAdNetworkConversionValueSchemaError {
        Unspecified = 0,
        Unknown = 1,
        InvalidLinkId = 2,
        InvalidAppId = 3,
        InvalidSchema = 4,
        LinkCodeNotFound = 5,
    }
    impl CustomerSkAdNetworkConversionValueSchemaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerSkAdNetworkConversionValueSchemaError::Unspecified => {
                    "UNSPECIFIED"
                }
                CustomerSkAdNetworkConversionValueSchemaError::Unknown => "UNKNOWN",
                CustomerSkAdNetworkConversionValueSchemaError::InvalidLinkId => {
                    "INVALID_LINK_ID"
                }
                CustomerSkAdNetworkConversionValueSchemaError::InvalidAppId => {
                    "INVALID_APP_ID"
                }
                CustomerSkAdNetworkConversionValueSchemaError::InvalidSchema => {
                    "INVALID_SCHEMA"
                }
                CustomerSkAdNetworkConversionValueSchemaError::LinkCodeNotFound => {
                    "LINK_CODE_NOT_FOUND"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_LINK_ID" => Some(Self::InvalidLinkId),
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "INVALID_SCHEMA" => Some(Self::InvalidSchema),
                "LINK_CODE_NOT_FOUND" => Some(Self::LinkCodeNotFound),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerUserAccessErrorEnum {}
/// Nested message and enum types in `CustomerUserAccessErrorEnum`.
pub mod customer_user_access_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerUserAccessError {
        Unspecified = 0,
        Unknown = 1,
        InvalidUserId = 2,
        RemovalDisallowed = 3,
        DisallowedAccessRole = 4,
        LastAdminUserOfServingCustomer = 5,
        LastAdminUserOfManager = 6,
    }
    impl CustomerUserAccessError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerUserAccessError::Unspecified => "UNSPECIFIED",
                CustomerUserAccessError::Unknown => "UNKNOWN",
                CustomerUserAccessError::InvalidUserId => "INVALID_USER_ID",
                CustomerUserAccessError::RemovalDisallowed => "REMOVAL_DISALLOWED",
                CustomerUserAccessError::DisallowedAccessRole => "DISALLOWED_ACCESS_ROLE",
                CustomerUserAccessError::LastAdminUserOfServingCustomer => {
                    "LAST_ADMIN_USER_OF_SERVING_CUSTOMER"
                }
                CustomerUserAccessError::LastAdminUserOfManager => {
                    "LAST_ADMIN_USER_OF_MANAGER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_ID" => Some(Self::InvalidUserId),
                "REMOVAL_DISALLOWED" => Some(Self::RemovalDisallowed),
                "DISALLOWED_ACCESS_ROLE" => Some(Self::DisallowedAccessRole),
                "LAST_ADMIN_USER_OF_SERVING_CUSTOMER" => {
                    Some(Self::LastAdminUserOfServingCustomer)
                }
                "LAST_ADMIN_USER_OF_MANAGER" => Some(Self::LastAdminUserOfManager),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeErrorEnum {}
/// Nested message and enum types in `CustomizerAttributeErrorEnum`.
pub mod customizer_attribute_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeError {
        Unspecified = 0,
        Unknown = 1,
        DuplicateCustomizerAttributeName = 2,
    }
    impl CustomizerAttributeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomizerAttributeError::Unspecified => "UNSPECIFIED",
                CustomizerAttributeError::Unknown => "UNKNOWN",
                CustomizerAttributeError::DuplicateCustomizerAttributeName => {
                    "DUPLICATE_CUSTOMIZER_ATTRIBUTE_NAME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DUPLICATE_CUSTOMIZER_ATTRIBUTE_NAME" => {
                    Some(Self::DuplicateCustomizerAttributeName)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DatabaseErrorEnum {}
/// Nested message and enum types in `DatabaseErrorEnum`.
pub mod database_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DatabaseError {
        Unspecified = 0,
        Unknown = 1,
        ConcurrentModification = 2,
        DataConstraintViolation = 3,
        RequestTooLarge = 4,
    }
    impl DatabaseError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DatabaseError::Unspecified => "UNSPECIFIED",
                DatabaseError::Unknown => "UNKNOWN",
                DatabaseError::ConcurrentModification => "CONCURRENT_MODIFICATION",
                DatabaseError::DataConstraintViolation => "DATA_CONSTRAINT_VIOLATION",
                DatabaseError::RequestTooLarge => "REQUEST_TOO_LARGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONCURRENT_MODIFICATION" => Some(Self::ConcurrentModification),
                "DATA_CONSTRAINT_VIOLATION" => Some(Self::DataConstraintViolation),
                "REQUEST_TOO_LARGE" => Some(Self::RequestTooLarge),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DateRangeErrorEnum {}
/// Nested message and enum types in `DateRangeErrorEnum`.
pub mod date_range_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DateRangeError {
        Unspecified = 0,
        Unknown = 1,
        InvalidDate = 2,
        StartDateAfterEndDate = 3,
        CannotSetDateToPast = 4,
        AfterMaximumAllowableDate = 5,
        CannotModifyStartDateIfAlreadyStarted = 6,
    }
    impl DateRangeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DateRangeError::Unspecified => "UNSPECIFIED",
                DateRangeError::Unknown => "UNKNOWN",
                DateRangeError::InvalidDate => "INVALID_DATE",
                DateRangeError::StartDateAfterEndDate => "START_DATE_AFTER_END_DATE",
                DateRangeError::CannotSetDateToPast => "CANNOT_SET_DATE_TO_PAST",
                DateRangeError::AfterMaximumAllowableDate => {
                    "AFTER_MAXIMUM_ALLOWABLE_DATE"
                }
                DateRangeError::CannotModifyStartDateIfAlreadyStarted => {
                    "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_DATE" => Some(Self::InvalidDate),
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "CANNOT_SET_DATE_TO_PAST" => Some(Self::CannotSetDateToPast),
                "AFTER_MAXIMUM_ALLOWABLE_DATE" => Some(Self::AfterMaximumAllowableDate),
                "CANNOT_MODIFY_START_DATE_IF_ALREADY_STARTED" => {
                    Some(Self::CannotModifyStartDateIfAlreadyStarted)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EnumErrorEnum {}
/// Nested message and enum types in `EnumErrorEnum`.
pub mod enum_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumError {
        Unspecified = 0,
        Unknown = 1,
        EnumValueNotPermitted = 3,
    }
    impl EnumError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EnumError::Unspecified => "UNSPECIFIED",
                EnumError::Unknown => "UNKNOWN",
                EnumError::EnumValueNotPermitted => "ENUM_VALUE_NOT_PERMITTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENUM_VALUE_NOT_PERMITTED" => Some(Self::EnumValueNotPermitted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentArmErrorEnum {}
/// Nested message and enum types in `ExperimentArmErrorEnum`.
pub mod experiment_arm_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentArmError {
        Unspecified = 0,
        Unknown = 1,
        ExperimentArmCountLimitExceeded = 2,
        InvalidCampaignStatus = 3,
        DuplicateExperimentArmName = 4,
        CannotSetTreatmentArmCampaign = 5,
        CannotModifyCampaignIds = 6,
        CannotModifyCampaignWithoutSuffixSet = 7,
        CannotMutateTrafficSplitAfterStart = 8,
        CannotAddCampaignWithSharedBudget = 9,
        CannotAddCampaignWithCustomBudget = 10,
        CannotAddCampaignsWithDynamicAssetsEnabled = 11,
        UnsupportedCampaignAdvertisingChannelSubType = 12,
        CannotAddBaseCampaignWithDateRange = 13,
        BiddingStrategyNotSupportedInExperiments = 14,
        TrafficSplitNotSupportedForChannelType = 15,
    }
    impl ExperimentArmError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentArmError::Unspecified => "UNSPECIFIED",
                ExperimentArmError::Unknown => "UNKNOWN",
                ExperimentArmError::ExperimentArmCountLimitExceeded => {
                    "EXPERIMENT_ARM_COUNT_LIMIT_EXCEEDED"
                }
                ExperimentArmError::InvalidCampaignStatus => "INVALID_CAMPAIGN_STATUS",
                ExperimentArmError::DuplicateExperimentArmName => {
                    "DUPLICATE_EXPERIMENT_ARM_NAME"
                }
                ExperimentArmError::CannotSetTreatmentArmCampaign => {
                    "CANNOT_SET_TREATMENT_ARM_CAMPAIGN"
                }
                ExperimentArmError::CannotModifyCampaignIds => {
                    "CANNOT_MODIFY_CAMPAIGN_IDS"
                }
                ExperimentArmError::CannotModifyCampaignWithoutSuffixSet => {
                    "CANNOT_MODIFY_CAMPAIGN_WITHOUT_SUFFIX_SET"
                }
                ExperimentArmError::CannotMutateTrafficSplitAfterStart => {
                    "CANNOT_MUTATE_TRAFFIC_SPLIT_AFTER_START"
                }
                ExperimentArmError::CannotAddCampaignWithSharedBudget => {
                    "CANNOT_ADD_CAMPAIGN_WITH_SHARED_BUDGET"
                }
                ExperimentArmError::CannotAddCampaignWithCustomBudget => {
                    "CANNOT_ADD_CAMPAIGN_WITH_CUSTOM_BUDGET"
                }
                ExperimentArmError::CannotAddCampaignsWithDynamicAssetsEnabled => {
                    "CANNOT_ADD_CAMPAIGNS_WITH_DYNAMIC_ASSETS_ENABLED"
                }
                ExperimentArmError::UnsupportedCampaignAdvertisingChannelSubType => {
                    "UNSUPPORTED_CAMPAIGN_ADVERTISING_CHANNEL_SUB_TYPE"
                }
                ExperimentArmError::CannotAddBaseCampaignWithDateRange => {
                    "CANNOT_ADD_BASE_CAMPAIGN_WITH_DATE_RANGE"
                }
                ExperimentArmError::BiddingStrategyNotSupportedInExperiments => {
                    "BIDDING_STRATEGY_NOT_SUPPORTED_IN_EXPERIMENTS"
                }
                ExperimentArmError::TrafficSplitNotSupportedForChannelType => {
                    "TRAFFIC_SPLIT_NOT_SUPPORTED_FOR_CHANNEL_TYPE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXPERIMENT_ARM_COUNT_LIMIT_EXCEEDED" => {
                    Some(Self::ExperimentArmCountLimitExceeded)
                }
                "INVALID_CAMPAIGN_STATUS" => Some(Self::InvalidCampaignStatus),
                "DUPLICATE_EXPERIMENT_ARM_NAME" => Some(Self::DuplicateExperimentArmName),
                "CANNOT_SET_TREATMENT_ARM_CAMPAIGN" => {
                    Some(Self::CannotSetTreatmentArmCampaign)
                }
                "CANNOT_MODIFY_CAMPAIGN_IDS" => Some(Self::CannotModifyCampaignIds),
                "CANNOT_MODIFY_CAMPAIGN_WITHOUT_SUFFIX_SET" => {
                    Some(Self::CannotModifyCampaignWithoutSuffixSet)
                }
                "CANNOT_MUTATE_TRAFFIC_SPLIT_AFTER_START" => {
                    Some(Self::CannotMutateTrafficSplitAfterStart)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotAddCampaignWithSharedBudget)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_CUSTOM_BUDGET" => {
                    Some(Self::CannotAddCampaignWithCustomBudget)
                }
                "CANNOT_ADD_CAMPAIGNS_WITH_DYNAMIC_ASSETS_ENABLED" => {
                    Some(Self::CannotAddCampaignsWithDynamicAssetsEnabled)
                }
                "UNSUPPORTED_CAMPAIGN_ADVERTISING_CHANNEL_SUB_TYPE" => {
                    Some(Self::UnsupportedCampaignAdvertisingChannelSubType)
                }
                "CANNOT_ADD_BASE_CAMPAIGN_WITH_DATE_RANGE" => {
                    Some(Self::CannotAddBaseCampaignWithDateRange)
                }
                "BIDDING_STRATEGY_NOT_SUPPORTED_IN_EXPERIMENTS" => {
                    Some(Self::BiddingStrategyNotSupportedInExperiments)
                }
                "TRAFFIC_SPLIT_NOT_SUPPORTED_FOR_CHANNEL_TYPE" => {
                    Some(Self::TrafficSplitNotSupportedForChannelType)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentErrorEnum {}
/// Nested message and enum types in `ExperimentErrorEnum`.
pub mod experiment_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentError {
        Unspecified = 0,
        Unknown = 1,
        CannotSetStartDateInPast = 2,
        EndDateBeforeStartDate = 3,
        StartDateTooFarInFuture = 4,
        DuplicateExperimentName = 5,
        CannotModifyRemovedExperiment = 6,
        StartDateAlreadyPassed = 7,
        CannotSetEndDateInPast = 8,
        CannotSetStatusToRemoved = 9,
        CannotModifyPastEndDate = 10,
        InvalidStatus = 11,
        InvalidCampaignChannelType = 12,
        OverlappingMembersAndDateRange = 13,
        InvalidTrialArmTrafficSplit = 14,
        TrafficSplitOverlapping = 15,
        SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator = 16,
        CannotModifyTrafficSplitAfterStart = 17,
        ExperimentNotFound = 18,
        ExperimentNotYetStarted = 19,
        CannotHaveMultipleControlArms = 20,
        InDesignCampaignsNotSet = 21,
        CannotSetStatusToGraduated = 22,
        CannotCreateExperimentCampaignWithSharedBudget = 23,
        CannotCreateExperimentCampaignWithCustomBudget = 24,
        StatusTransitionInvalid = 25,
        DuplicateExperimentCampaignName = 26,
        CannotRemoveInCreationExperiment = 27,
        CannotAddCampaignWithDeprecatedAdTypes = 28,
    }
    impl ExperimentError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentError::Unspecified => "UNSPECIFIED",
                ExperimentError::Unknown => "UNKNOWN",
                ExperimentError::CannotSetStartDateInPast => {
                    "CANNOT_SET_START_DATE_IN_PAST"
                }
                ExperimentError::EndDateBeforeStartDate => "END_DATE_BEFORE_START_DATE",
                ExperimentError::StartDateTooFarInFuture => {
                    "START_DATE_TOO_FAR_IN_FUTURE"
                }
                ExperimentError::DuplicateExperimentName => "DUPLICATE_EXPERIMENT_NAME",
                ExperimentError::CannotModifyRemovedExperiment => {
                    "CANNOT_MODIFY_REMOVED_EXPERIMENT"
                }
                ExperimentError::StartDateAlreadyPassed => "START_DATE_ALREADY_PASSED",
                ExperimentError::CannotSetEndDateInPast => "CANNOT_SET_END_DATE_IN_PAST",
                ExperimentError::CannotSetStatusToRemoved => {
                    "CANNOT_SET_STATUS_TO_REMOVED"
                }
                ExperimentError::CannotModifyPastEndDate => "CANNOT_MODIFY_PAST_END_DATE",
                ExperimentError::InvalidStatus => "INVALID_STATUS",
                ExperimentError::InvalidCampaignChannelType => {
                    "INVALID_CAMPAIGN_CHANNEL_TYPE"
                }
                ExperimentError::OverlappingMembersAndDateRange => {
                    "OVERLAPPING_MEMBERS_AND_DATE_RANGE"
                }
                ExperimentError::InvalidTrialArmTrafficSplit => {
                    "INVALID_TRIAL_ARM_TRAFFIC_SPLIT"
                }
                ExperimentError::TrafficSplitOverlapping => "TRAFFIC_SPLIT_OVERLAPPING",
                ExperimentError::SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator => {
                    "SUM_TRIAL_ARM_TRAFFIC_UNEQUALS_TO_TRIAL_TRAFFIC_SPLIT_DENOMINATOR"
                }
                ExperimentError::CannotModifyTrafficSplitAfterStart => {
                    "CANNOT_MODIFY_TRAFFIC_SPLIT_AFTER_START"
                }
                ExperimentError::ExperimentNotFound => "EXPERIMENT_NOT_FOUND",
                ExperimentError::ExperimentNotYetStarted => "EXPERIMENT_NOT_YET_STARTED",
                ExperimentError::CannotHaveMultipleControlArms => {
                    "CANNOT_HAVE_MULTIPLE_CONTROL_ARMS"
                }
                ExperimentError::InDesignCampaignsNotSet => "IN_DESIGN_CAMPAIGNS_NOT_SET",
                ExperimentError::CannotSetStatusToGraduated => {
                    "CANNOT_SET_STATUS_TO_GRADUATED"
                }
                ExperimentError::CannotCreateExperimentCampaignWithSharedBudget => {
                    "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_SHARED_BUDGET"
                }
                ExperimentError::CannotCreateExperimentCampaignWithCustomBudget => {
                    "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_CUSTOM_BUDGET"
                }
                ExperimentError::StatusTransitionInvalid => "STATUS_TRANSITION_INVALID",
                ExperimentError::DuplicateExperimentCampaignName => {
                    "DUPLICATE_EXPERIMENT_CAMPAIGN_NAME"
                }
                ExperimentError::CannotRemoveInCreationExperiment => {
                    "CANNOT_REMOVE_IN_CREATION_EXPERIMENT"
                }
                ExperimentError::CannotAddCampaignWithDeprecatedAdTypes => {
                    "CANNOT_ADD_CAMPAIGN_WITH_DEPRECATED_AD_TYPES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_SET_START_DATE_IN_PAST" => Some(Self::CannotSetStartDateInPast),
                "END_DATE_BEFORE_START_DATE" => Some(Self::EndDateBeforeStartDate),
                "START_DATE_TOO_FAR_IN_FUTURE" => Some(Self::StartDateTooFarInFuture),
                "DUPLICATE_EXPERIMENT_NAME" => Some(Self::DuplicateExperimentName),
                "CANNOT_MODIFY_REMOVED_EXPERIMENT" => {
                    Some(Self::CannotModifyRemovedExperiment)
                }
                "START_DATE_ALREADY_PASSED" => Some(Self::StartDateAlreadyPassed),
                "CANNOT_SET_END_DATE_IN_PAST" => Some(Self::CannotSetEndDateInPast),
                "CANNOT_SET_STATUS_TO_REMOVED" => Some(Self::CannotSetStatusToRemoved),
                "CANNOT_MODIFY_PAST_END_DATE" => Some(Self::CannotModifyPastEndDate),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "INVALID_CAMPAIGN_CHANNEL_TYPE" => Some(Self::InvalidCampaignChannelType),
                "OVERLAPPING_MEMBERS_AND_DATE_RANGE" => {
                    Some(Self::OverlappingMembersAndDateRange)
                }
                "INVALID_TRIAL_ARM_TRAFFIC_SPLIT" => {
                    Some(Self::InvalidTrialArmTrafficSplit)
                }
                "TRAFFIC_SPLIT_OVERLAPPING" => Some(Self::TrafficSplitOverlapping),
                "SUM_TRIAL_ARM_TRAFFIC_UNEQUALS_TO_TRIAL_TRAFFIC_SPLIT_DENOMINATOR" => {
                    Some(Self::SumTrialArmTrafficUnequalsToTrialTrafficSplitDenominator)
                }
                "CANNOT_MODIFY_TRAFFIC_SPLIT_AFTER_START" => {
                    Some(Self::CannotModifyTrafficSplitAfterStart)
                }
                "EXPERIMENT_NOT_FOUND" => Some(Self::ExperimentNotFound),
                "EXPERIMENT_NOT_YET_STARTED" => Some(Self::ExperimentNotYetStarted),
                "CANNOT_HAVE_MULTIPLE_CONTROL_ARMS" => {
                    Some(Self::CannotHaveMultipleControlArms)
                }
                "IN_DESIGN_CAMPAIGNS_NOT_SET" => Some(Self::InDesignCampaignsNotSet),
                "CANNOT_SET_STATUS_TO_GRADUATED" => {
                    Some(Self::CannotSetStatusToGraduated)
                }
                "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::CannotCreateExperimentCampaignWithSharedBudget)
                }
                "CANNOT_CREATE_EXPERIMENT_CAMPAIGN_WITH_CUSTOM_BUDGET" => {
                    Some(Self::CannotCreateExperimentCampaignWithCustomBudget)
                }
                "STATUS_TRANSITION_INVALID" => Some(Self::StatusTransitionInvalid),
                "DUPLICATE_EXPERIMENT_CAMPAIGN_NAME" => {
                    Some(Self::DuplicateExperimentCampaignName)
                }
                "CANNOT_REMOVE_IN_CREATION_EXPERIMENT" => {
                    Some(Self::CannotRemoveInCreationExperiment)
                }
                "CANNOT_ADD_CAMPAIGN_WITH_DEPRECATED_AD_TYPES" => {
                    Some(Self::CannotAddCampaignWithDeprecatedAdTypes)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionFeedItemErrorEnum {}
/// Nested message and enum types in `ExtensionFeedItemErrorEnum`.
pub mod extension_feed_item_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionFeedItemError {
        Unspecified = 0,
        Unknown = 1,
        ValueOutOfRange = 2,
        UrlListTooLong = 3,
        CannotHaveRestrictionOnEmptyGeoTargeting = 4,
        CannotSetWithFinalUrls = 5,
        CannotSetWithoutFinalUrls = 6,
        InvalidPhoneNumber = 7,
        PhoneNumberNotSupportedForCountry = 8,
        CarrierSpecificShortNumberNotAllowed = 9,
        PremiumRateNumberNotAllowed = 10,
        DisallowedNumberType = 11,
        InvalidDomesticPhoneNumberFormat = 12,
        VanityPhoneNumberNotAllowed = 13,
        InvalidCallConversionAction = 14,
        CustomerNotOnAllowlistForCalltracking = 47,
        CalltrackingNotSupportedForCountry = 16,
        CustomerConsentForCallRecordingRequired = 17,
        InvalidAppId = 18,
        QuotesInReviewExtensionSnippet = 19,
        HyphensInReviewExtensionSnippet = 20,
        ReviewExtensionSourceIneligible = 21,
        SourceNameInReviewExtensionText = 22,
        InconsistentCurrencyCodes = 23,
        PriceExtensionHasDuplicatedHeaders = 24,
        PriceItemHasDuplicatedHeaderAndDescription = 25,
        PriceExtensionHasTooFewItems = 26,
        PriceExtensionHasTooManyItems = 27,
        UnsupportedValue = 28,
        UnsupportedValueInSelectedLanguage = 29,
        InvalidDevicePreference = 30,
        InvalidScheduleEnd = 31,
        DateTimeMustBeInAccountTimeZone = 32,
        InvalidSnippetsHeader = 33,
        CannotOperateOnRemovedFeedItem = 34,
        PhoneNumberNotSupportedWithCalltrackingForCountry = 35,
        ConflictingCallConversionSettings = 36,
        ExtensionTypeMismatch = 37,
        ExtensionSubtypeRequired = 38,
        ExtensionTypeUnsupported = 39,
        CannotOperateOnFeedWithMultipleMappings = 40,
        CannotOperateOnFeedWithKeyAttributes = 41,
        InvalidPriceFormat = 42,
        PromotionInvalidTime = 43,
        TooManyDecimalPlacesSpecified = 44,
        ConcreteExtensionTypeRequired = 45,
        ScheduleEndNotAfterStart = 46,
    }
    impl ExtensionFeedItemError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtensionFeedItemError::Unspecified => "UNSPECIFIED",
                ExtensionFeedItemError::Unknown => "UNKNOWN",
                ExtensionFeedItemError::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                ExtensionFeedItemError::UrlListTooLong => "URL_LIST_TOO_LONG",
                ExtensionFeedItemError::CannotHaveRestrictionOnEmptyGeoTargeting => {
                    "CANNOT_HAVE_RESTRICTION_ON_EMPTY_GEO_TARGETING"
                }
                ExtensionFeedItemError::CannotSetWithFinalUrls => {
                    "CANNOT_SET_WITH_FINAL_URLS"
                }
                ExtensionFeedItemError::CannotSetWithoutFinalUrls => {
                    "CANNOT_SET_WITHOUT_FINAL_URLS"
                }
                ExtensionFeedItemError::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                ExtensionFeedItemError::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                ExtensionFeedItemError::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                ExtensionFeedItemError::PremiumRateNumberNotAllowed => {
                    "PREMIUM_RATE_NUMBER_NOT_ALLOWED"
                }
                ExtensionFeedItemError::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                ExtensionFeedItemError::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                ExtensionFeedItemError::VanityPhoneNumberNotAllowed => {
                    "VANITY_PHONE_NUMBER_NOT_ALLOWED"
                }
                ExtensionFeedItemError::InvalidCallConversionAction => {
                    "INVALID_CALL_CONVERSION_ACTION"
                }
                ExtensionFeedItemError::CustomerNotOnAllowlistForCalltracking => {
                    "CUSTOMER_NOT_ON_ALLOWLIST_FOR_CALLTRACKING"
                }
                ExtensionFeedItemError::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                ExtensionFeedItemError::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                ExtensionFeedItemError::InvalidAppId => "INVALID_APP_ID",
                ExtensionFeedItemError::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                ExtensionFeedItemError::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                ExtensionFeedItemError::ReviewExtensionSourceIneligible => {
                    "REVIEW_EXTENSION_SOURCE_INELIGIBLE"
                }
                ExtensionFeedItemError::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                ExtensionFeedItemError::InconsistentCurrencyCodes => {
                    "INCONSISTENT_CURRENCY_CODES"
                }
                ExtensionFeedItemError::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                ExtensionFeedItemError::PriceItemHasDuplicatedHeaderAndDescription => {
                    "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                ExtensionFeedItemError::PriceExtensionHasTooFewItems => {
                    "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS"
                }
                ExtensionFeedItemError::PriceExtensionHasTooManyItems => {
                    "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS"
                }
                ExtensionFeedItemError::UnsupportedValue => "UNSUPPORTED_VALUE",
                ExtensionFeedItemError::UnsupportedValueInSelectedLanguage => {
                    "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE"
                }
                ExtensionFeedItemError::InvalidDevicePreference => {
                    "INVALID_DEVICE_PREFERENCE"
                }
                ExtensionFeedItemError::InvalidScheduleEnd => "INVALID_SCHEDULE_END",
                ExtensionFeedItemError::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                ExtensionFeedItemError::InvalidSnippetsHeader => {
                    "INVALID_SNIPPETS_HEADER"
                }
                ExtensionFeedItemError::CannotOperateOnRemovedFeedItem => {
                    "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM"
                }
                ExtensionFeedItemError::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                ExtensionFeedItemError::ConflictingCallConversionSettings => {
                    "CONFLICTING_CALL_CONVERSION_SETTINGS"
                }
                ExtensionFeedItemError::ExtensionTypeMismatch => {
                    "EXTENSION_TYPE_MISMATCH"
                }
                ExtensionFeedItemError::ExtensionSubtypeRequired => {
                    "EXTENSION_SUBTYPE_REQUIRED"
                }
                ExtensionFeedItemError::ExtensionTypeUnsupported => {
                    "EXTENSION_TYPE_UNSUPPORTED"
                }
                ExtensionFeedItemError::CannotOperateOnFeedWithMultipleMappings => {
                    "CANNOT_OPERATE_ON_FEED_WITH_MULTIPLE_MAPPINGS"
                }
                ExtensionFeedItemError::CannotOperateOnFeedWithKeyAttributes => {
                    "CANNOT_OPERATE_ON_FEED_WITH_KEY_ATTRIBUTES"
                }
                ExtensionFeedItemError::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                ExtensionFeedItemError::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                ExtensionFeedItemError::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                ExtensionFeedItemError::ConcreteExtensionTypeRequired => {
                    "CONCRETE_EXTENSION_TYPE_REQUIRED"
                }
                ExtensionFeedItemError::ScheduleEndNotAfterStart => {
                    "SCHEDULE_END_NOT_AFTER_START"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "URL_LIST_TOO_LONG" => Some(Self::UrlListTooLong),
                "CANNOT_HAVE_RESTRICTION_ON_EMPTY_GEO_TARGETING" => {
                    Some(Self::CannotHaveRestrictionOnEmptyGeoTargeting)
                }
                "CANNOT_SET_WITH_FINAL_URLS" => Some(Self::CannotSetWithFinalUrls),
                "CANNOT_SET_WITHOUT_FINAL_URLS" => Some(Self::CannotSetWithoutFinalUrls),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_CALL_CONVERSION_ACTION" => {
                    Some(Self::InvalidCallConversionAction)
                }
                "CUSTOMER_NOT_ON_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotOnAllowlistForCalltracking)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "REVIEW_EXTENSION_SOURCE_INELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceIneligible)
                }
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::PriceItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS" => {
                    Some(Self::PriceExtensionHasTooManyItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "UNSUPPORTED_VALUE_IN_SELECTED_LANGUAGE" => {
                    Some(Self::UnsupportedValueInSelectedLanguage)
                }
                "INVALID_DEVICE_PREFERENCE" => Some(Self::InvalidDevicePreference),
                "INVALID_SCHEDULE_END" => Some(Self::InvalidScheduleEnd),
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "CANNOT_OPERATE_ON_REMOVED_FEED_ITEM" => {
                    Some(Self::CannotOperateOnRemovedFeedItem)
                }
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "CONFLICTING_CALL_CONVERSION_SETTINGS" => {
                    Some(Self::ConflictingCallConversionSettings)
                }
                "EXTENSION_TYPE_MISMATCH" => Some(Self::ExtensionTypeMismatch),
                "EXTENSION_SUBTYPE_REQUIRED" => Some(Self::ExtensionSubtypeRequired),
                "EXTENSION_TYPE_UNSUPPORTED" => Some(Self::ExtensionTypeUnsupported),
                "CANNOT_OPERATE_ON_FEED_WITH_MULTIPLE_MAPPINGS" => {
                    Some(Self::CannotOperateOnFeedWithMultipleMappings)
                }
                "CANNOT_OPERATE_ON_FEED_WITH_KEY_ATTRIBUTES" => {
                    Some(Self::CannotOperateOnFeedWithKeyAttributes)
                }
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "CONCRETE_EXTENSION_TYPE_REQUIRED" => {
                    Some(Self::ConcreteExtensionTypeRequired)
                }
                "SCHEDULE_END_NOT_AFTER_START" => Some(Self::ScheduleEndNotAfterStart),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionSettingErrorEnum {}
/// Nested message and enum types in `ExtensionSettingErrorEnum`.
pub mod extension_setting_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionSettingError {
        Unspecified = 0,
        Unknown = 1,
        ExtensionsRequired = 2,
        FeedTypeExtensionTypeMismatch = 3,
        InvalidFeedType = 4,
        InvalidFeedTypeForCustomerExtensionSetting = 5,
        CannotChangeFeedItemOnCreate = 6,
        CannotUpdateNewlyCreatedExtension = 7,
        NoExistingAdGroupExtensionSettingForType = 8,
        NoExistingCampaignExtensionSettingForType = 9,
        NoExistingCustomerExtensionSettingForType = 10,
        AdGroupExtensionSettingAlreadyExists = 11,
        CampaignExtensionSettingAlreadyExists = 12,
        CustomerExtensionSettingAlreadyExists = 13,
        AdGroupFeedAlreadyExistsForPlaceholderType = 14,
        CampaignFeedAlreadyExistsForPlaceholderType = 15,
        CustomerFeedAlreadyExistsForPlaceholderType = 16,
        ValueOutOfRange = 17,
        CannotSetFieldWithFinalUrls = 18,
        FinalUrlsNotSet = 19,
        InvalidPhoneNumber = 20,
        PhoneNumberNotSupportedForCountry = 21,
        CarrierSpecificShortNumberNotAllowed = 22,
        PremiumRateNumberNotAllowed = 23,
        DisallowedNumberType = 24,
        InvalidDomesticPhoneNumberFormat = 25,
        VanityPhoneNumberNotAllowed = 26,
        InvalidCountryCode = 27,
        InvalidCallConversionTypeId = 28,
        CustomerNotInAllowlistForCalltracking = 69,
        CalltrackingNotSupportedForCountry = 30,
        InvalidAppId = 31,
        QuotesInReviewExtensionSnippet = 32,
        HyphensInReviewExtensionSnippet = 33,
        ReviewExtensionSourceNotEligible = 34,
        SourceNameInReviewExtensionText = 35,
        MissingField = 36,
        InconsistentCurrencyCodes = 37,
        PriceExtensionHasDuplicatedHeaders = 38,
        PriceItemHasDuplicatedHeaderAndDescription = 39,
        PriceExtensionHasTooFewItems = 40,
        PriceExtensionHasTooManyItems = 41,
        UnsupportedValue = 42,
        InvalidDevicePreference = 43,
        InvalidScheduleEnd = 45,
        DateTimeMustBeInAccountTimeZone = 47,
        OverlappingSchedulesNotAllowed = 48,
        ScheduleEndNotAfterStart = 49,
        TooManySchedulesPerDay = 50,
        DuplicateExtensionFeedItemEdit = 51,
        InvalidSnippetsHeader = 52,
        PhoneNumberNotSupportedWithCalltrackingForCountry = 53,
        CampaignTargetingMismatch = 54,
        CannotOperateOnRemovedFeed = 55,
        ExtensionTypeRequired = 56,
        IncompatibleUnderlyingMatchingFunction = 57,
        StartDateAfterEndDate = 58,
        InvalidPriceFormat = 59,
        PromotionInvalidTime = 60,
        PromotionCannotSetPercentDiscountAndMoneyDiscount = 61,
        PromotionCannotSetPromotionCodeAndOrdersOverAmount = 62,
        TooManyDecimalPlacesSpecified = 63,
        InvalidLanguageCode = 64,
        UnsupportedLanguage = 65,
        CustomerConsentForCallRecordingRequired = 66,
        ExtensionSettingUpdateIsANoop = 67,
        DisallowedText = 68,
    }
    impl ExtensionSettingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtensionSettingError::Unspecified => "UNSPECIFIED",
                ExtensionSettingError::Unknown => "UNKNOWN",
                ExtensionSettingError::ExtensionsRequired => "EXTENSIONS_REQUIRED",
                ExtensionSettingError::FeedTypeExtensionTypeMismatch => {
                    "FEED_TYPE_EXTENSION_TYPE_MISMATCH"
                }
                ExtensionSettingError::InvalidFeedType => "INVALID_FEED_TYPE",
                ExtensionSettingError::InvalidFeedTypeForCustomerExtensionSetting => {
                    "INVALID_FEED_TYPE_FOR_CUSTOMER_EXTENSION_SETTING"
                }
                ExtensionSettingError::CannotChangeFeedItemOnCreate => {
                    "CANNOT_CHANGE_FEED_ITEM_ON_CREATE"
                }
                ExtensionSettingError::CannotUpdateNewlyCreatedExtension => {
                    "CANNOT_UPDATE_NEWLY_CREATED_EXTENSION"
                }
                ExtensionSettingError::NoExistingAdGroupExtensionSettingForType => {
                    "NO_EXISTING_AD_GROUP_EXTENSION_SETTING_FOR_TYPE"
                }
                ExtensionSettingError::NoExistingCampaignExtensionSettingForType => {
                    "NO_EXISTING_CAMPAIGN_EXTENSION_SETTING_FOR_TYPE"
                }
                ExtensionSettingError::NoExistingCustomerExtensionSettingForType => {
                    "NO_EXISTING_CUSTOMER_EXTENSION_SETTING_FOR_TYPE"
                }
                ExtensionSettingError::AdGroupExtensionSettingAlreadyExists => {
                    "AD_GROUP_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                ExtensionSettingError::CampaignExtensionSettingAlreadyExists => {
                    "CAMPAIGN_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                ExtensionSettingError::CustomerExtensionSettingAlreadyExists => {
                    "CUSTOMER_EXTENSION_SETTING_ALREADY_EXISTS"
                }
                ExtensionSettingError::AdGroupFeedAlreadyExistsForPlaceholderType => {
                    "AD_GROUP_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                ExtensionSettingError::CampaignFeedAlreadyExistsForPlaceholderType => {
                    "CAMPAIGN_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                ExtensionSettingError::CustomerFeedAlreadyExistsForPlaceholderType => {
                    "CUSTOMER_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE"
                }
                ExtensionSettingError::ValueOutOfRange => "VALUE_OUT_OF_RANGE",
                ExtensionSettingError::CannotSetFieldWithFinalUrls => {
                    "CANNOT_SET_FIELD_WITH_FINAL_URLS"
                }
                ExtensionSettingError::FinalUrlsNotSet => "FINAL_URLS_NOT_SET",
                ExtensionSettingError::InvalidPhoneNumber => "INVALID_PHONE_NUMBER",
                ExtensionSettingError::PhoneNumberNotSupportedForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY"
                }
                ExtensionSettingError::CarrierSpecificShortNumberNotAllowed => {
                    "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED"
                }
                ExtensionSettingError::PremiumRateNumberNotAllowed => {
                    "PREMIUM_RATE_NUMBER_NOT_ALLOWED"
                }
                ExtensionSettingError::DisallowedNumberType => "DISALLOWED_NUMBER_TYPE",
                ExtensionSettingError::InvalidDomesticPhoneNumberFormat => {
                    "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT"
                }
                ExtensionSettingError::VanityPhoneNumberNotAllowed => {
                    "VANITY_PHONE_NUMBER_NOT_ALLOWED"
                }
                ExtensionSettingError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                ExtensionSettingError::InvalidCallConversionTypeId => {
                    "INVALID_CALL_CONVERSION_TYPE_ID"
                }
                ExtensionSettingError::CustomerNotInAllowlistForCalltracking => {
                    "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING"
                }
                ExtensionSettingError::CalltrackingNotSupportedForCountry => {
                    "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY"
                }
                ExtensionSettingError::InvalidAppId => "INVALID_APP_ID",
                ExtensionSettingError::QuotesInReviewExtensionSnippet => {
                    "QUOTES_IN_REVIEW_EXTENSION_SNIPPET"
                }
                ExtensionSettingError::HyphensInReviewExtensionSnippet => {
                    "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET"
                }
                ExtensionSettingError::ReviewExtensionSourceNotEligible => {
                    "REVIEW_EXTENSION_SOURCE_NOT_ELIGIBLE"
                }
                ExtensionSettingError::SourceNameInReviewExtensionText => {
                    "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT"
                }
                ExtensionSettingError::MissingField => "MISSING_FIELD",
                ExtensionSettingError::InconsistentCurrencyCodes => {
                    "INCONSISTENT_CURRENCY_CODES"
                }
                ExtensionSettingError::PriceExtensionHasDuplicatedHeaders => {
                    "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS"
                }
                ExtensionSettingError::PriceItemHasDuplicatedHeaderAndDescription => {
                    "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION"
                }
                ExtensionSettingError::PriceExtensionHasTooFewItems => {
                    "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS"
                }
                ExtensionSettingError::PriceExtensionHasTooManyItems => {
                    "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS"
                }
                ExtensionSettingError::UnsupportedValue => "UNSUPPORTED_VALUE",
                ExtensionSettingError::InvalidDevicePreference => {
                    "INVALID_DEVICE_PREFERENCE"
                }
                ExtensionSettingError::InvalidScheduleEnd => "INVALID_SCHEDULE_END",
                ExtensionSettingError::DateTimeMustBeInAccountTimeZone => {
                    "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE"
                }
                ExtensionSettingError::OverlappingSchedulesNotAllowed => {
                    "OVERLAPPING_SCHEDULES_NOT_ALLOWED"
                }
                ExtensionSettingError::ScheduleEndNotAfterStart => {
                    "SCHEDULE_END_NOT_AFTER_START"
                }
                ExtensionSettingError::TooManySchedulesPerDay => {
                    "TOO_MANY_SCHEDULES_PER_DAY"
                }
                ExtensionSettingError::DuplicateExtensionFeedItemEdit => {
                    "DUPLICATE_EXTENSION_FEED_ITEM_EDIT"
                }
                ExtensionSettingError::InvalidSnippetsHeader => "INVALID_SNIPPETS_HEADER",
                ExtensionSettingError::PhoneNumberNotSupportedWithCalltrackingForCountry => {
                    "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY"
                }
                ExtensionSettingError::CampaignTargetingMismatch => {
                    "CAMPAIGN_TARGETING_MISMATCH"
                }
                ExtensionSettingError::CannotOperateOnRemovedFeed => {
                    "CANNOT_OPERATE_ON_REMOVED_FEED"
                }
                ExtensionSettingError::ExtensionTypeRequired => "EXTENSION_TYPE_REQUIRED",
                ExtensionSettingError::IncompatibleUnderlyingMatchingFunction => {
                    "INCOMPATIBLE_UNDERLYING_MATCHING_FUNCTION"
                }
                ExtensionSettingError::StartDateAfterEndDate => {
                    "START_DATE_AFTER_END_DATE"
                }
                ExtensionSettingError::InvalidPriceFormat => "INVALID_PRICE_FORMAT",
                ExtensionSettingError::PromotionInvalidTime => "PROMOTION_INVALID_TIME",
                ExtensionSettingError::PromotionCannotSetPercentDiscountAndMoneyDiscount => {
                    "PROMOTION_CANNOT_SET_PERCENT_DISCOUNT_AND_MONEY_DISCOUNT"
                }
                ExtensionSettingError::PromotionCannotSetPromotionCodeAndOrdersOverAmount => {
                    "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT"
                }
                ExtensionSettingError::TooManyDecimalPlacesSpecified => {
                    "TOO_MANY_DECIMAL_PLACES_SPECIFIED"
                }
                ExtensionSettingError::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
                ExtensionSettingError::UnsupportedLanguage => "UNSUPPORTED_LANGUAGE",
                ExtensionSettingError::CustomerConsentForCallRecordingRequired => {
                    "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED"
                }
                ExtensionSettingError::ExtensionSettingUpdateIsANoop => {
                    "EXTENSION_SETTING_UPDATE_IS_A_NOOP"
                }
                ExtensionSettingError::DisallowedText => "DISALLOWED_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTENSIONS_REQUIRED" => Some(Self::ExtensionsRequired),
                "FEED_TYPE_EXTENSION_TYPE_MISMATCH" => {
                    Some(Self::FeedTypeExtensionTypeMismatch)
                }
                "INVALID_FEED_TYPE" => Some(Self::InvalidFeedType),
                "INVALID_FEED_TYPE_FOR_CUSTOMER_EXTENSION_SETTING" => {
                    Some(Self::InvalidFeedTypeForCustomerExtensionSetting)
                }
                "CANNOT_CHANGE_FEED_ITEM_ON_CREATE" => {
                    Some(Self::CannotChangeFeedItemOnCreate)
                }
                "CANNOT_UPDATE_NEWLY_CREATED_EXTENSION" => {
                    Some(Self::CannotUpdateNewlyCreatedExtension)
                }
                "NO_EXISTING_AD_GROUP_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingAdGroupExtensionSettingForType)
                }
                "NO_EXISTING_CAMPAIGN_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingCampaignExtensionSettingForType)
                }
                "NO_EXISTING_CUSTOMER_EXTENSION_SETTING_FOR_TYPE" => {
                    Some(Self::NoExistingCustomerExtensionSettingForType)
                }
                "AD_GROUP_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::AdGroupExtensionSettingAlreadyExists)
                }
                "CAMPAIGN_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::CampaignExtensionSettingAlreadyExists)
                }
                "CUSTOMER_EXTENSION_SETTING_ALREADY_EXISTS" => {
                    Some(Self::CustomerExtensionSettingAlreadyExists)
                }
                "AD_GROUP_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::AdGroupFeedAlreadyExistsForPlaceholderType)
                }
                "CAMPAIGN_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::CampaignFeedAlreadyExistsForPlaceholderType)
                }
                "CUSTOMER_FEED_ALREADY_EXISTS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::CustomerFeedAlreadyExistsForPlaceholderType)
                }
                "VALUE_OUT_OF_RANGE" => Some(Self::ValueOutOfRange),
                "CANNOT_SET_FIELD_WITH_FINAL_URLS" => {
                    Some(Self::CannotSetFieldWithFinalUrls)
                }
                "FINAL_URLS_NOT_SET" => Some(Self::FinalUrlsNotSet),
                "INVALID_PHONE_NUMBER" => Some(Self::InvalidPhoneNumber),
                "PHONE_NUMBER_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedForCountry)
                }
                "CARRIER_SPECIFIC_SHORT_NUMBER_NOT_ALLOWED" => {
                    Some(Self::CarrierSpecificShortNumberNotAllowed)
                }
                "PREMIUM_RATE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::PremiumRateNumberNotAllowed)
                }
                "DISALLOWED_NUMBER_TYPE" => Some(Self::DisallowedNumberType),
                "INVALID_DOMESTIC_PHONE_NUMBER_FORMAT" => {
                    Some(Self::InvalidDomesticPhoneNumberFormat)
                }
                "VANITY_PHONE_NUMBER_NOT_ALLOWED" => {
                    Some(Self::VanityPhoneNumberNotAllowed)
                }
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INVALID_CALL_CONVERSION_TYPE_ID" => {
                    Some(Self::InvalidCallConversionTypeId)
                }
                "CUSTOMER_NOT_IN_ALLOWLIST_FOR_CALLTRACKING" => {
                    Some(Self::CustomerNotInAllowlistForCalltracking)
                }
                "CALLTRACKING_NOT_SUPPORTED_FOR_COUNTRY" => {
                    Some(Self::CalltrackingNotSupportedForCountry)
                }
                "INVALID_APP_ID" => Some(Self::InvalidAppId),
                "QUOTES_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::QuotesInReviewExtensionSnippet)
                }
                "HYPHENS_IN_REVIEW_EXTENSION_SNIPPET" => {
                    Some(Self::HyphensInReviewExtensionSnippet)
                }
                "REVIEW_EXTENSION_SOURCE_NOT_ELIGIBLE" => {
                    Some(Self::ReviewExtensionSourceNotEligible)
                }
                "SOURCE_NAME_IN_REVIEW_EXTENSION_TEXT" => {
                    Some(Self::SourceNameInReviewExtensionText)
                }
                "MISSING_FIELD" => Some(Self::MissingField),
                "INCONSISTENT_CURRENCY_CODES" => Some(Self::InconsistentCurrencyCodes),
                "PRICE_EXTENSION_HAS_DUPLICATED_HEADERS" => {
                    Some(Self::PriceExtensionHasDuplicatedHeaders)
                }
                "PRICE_ITEM_HAS_DUPLICATED_HEADER_AND_DESCRIPTION" => {
                    Some(Self::PriceItemHasDuplicatedHeaderAndDescription)
                }
                "PRICE_EXTENSION_HAS_TOO_FEW_ITEMS" => {
                    Some(Self::PriceExtensionHasTooFewItems)
                }
                "PRICE_EXTENSION_HAS_TOO_MANY_ITEMS" => {
                    Some(Self::PriceExtensionHasTooManyItems)
                }
                "UNSUPPORTED_VALUE" => Some(Self::UnsupportedValue),
                "INVALID_DEVICE_PREFERENCE" => Some(Self::InvalidDevicePreference),
                "INVALID_SCHEDULE_END" => Some(Self::InvalidScheduleEnd),
                "DATE_TIME_MUST_BE_IN_ACCOUNT_TIME_ZONE" => {
                    Some(Self::DateTimeMustBeInAccountTimeZone)
                }
                "OVERLAPPING_SCHEDULES_NOT_ALLOWED" => {
                    Some(Self::OverlappingSchedulesNotAllowed)
                }
                "SCHEDULE_END_NOT_AFTER_START" => Some(Self::ScheduleEndNotAfterStart),
                "TOO_MANY_SCHEDULES_PER_DAY" => Some(Self::TooManySchedulesPerDay),
                "DUPLICATE_EXTENSION_FEED_ITEM_EDIT" => {
                    Some(Self::DuplicateExtensionFeedItemEdit)
                }
                "INVALID_SNIPPETS_HEADER" => Some(Self::InvalidSnippetsHeader),
                "PHONE_NUMBER_NOT_SUPPORTED_WITH_CALLTRACKING_FOR_COUNTRY" => {
                    Some(Self::PhoneNumberNotSupportedWithCalltrackingForCountry)
                }
                "CAMPAIGN_TARGETING_MISMATCH" => Some(Self::CampaignTargetingMismatch),
                "CANNOT_OPERATE_ON_REMOVED_FEED" => {
                    Some(Self::CannotOperateOnRemovedFeed)
                }
                "EXTENSION_TYPE_REQUIRED" => Some(Self::ExtensionTypeRequired),
                "INCOMPATIBLE_UNDERLYING_MATCHING_FUNCTION" => {
                    Some(Self::IncompatibleUnderlyingMatchingFunction)
                }
                "START_DATE_AFTER_END_DATE" => Some(Self::StartDateAfterEndDate),
                "INVALID_PRICE_FORMAT" => Some(Self::InvalidPriceFormat),
                "PROMOTION_INVALID_TIME" => Some(Self::PromotionInvalidTime),
                "PROMOTION_CANNOT_SET_PERCENT_DISCOUNT_AND_MONEY_DISCOUNT" => {
                    Some(Self::PromotionCannotSetPercentDiscountAndMoneyDiscount)
                }
                "PROMOTION_CANNOT_SET_PROMOTION_CODE_AND_ORDERS_OVER_AMOUNT" => {
                    Some(Self::PromotionCannotSetPromotionCodeAndOrdersOverAmount)
                }
                "TOO_MANY_DECIMAL_PLACES_SPECIFIED" => {
                    Some(Self::TooManyDecimalPlacesSpecified)
                }
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                "UNSUPPORTED_LANGUAGE" => Some(Self::UnsupportedLanguage),
                "CUSTOMER_CONSENT_FOR_CALL_RECORDING_REQUIRED" => {
                    Some(Self::CustomerConsentForCallRecordingRequired)
                }
                "EXTENSION_SETTING_UPDATE_IS_A_NOOP" => {
                    Some(Self::ExtensionSettingUpdateIsANoop)
                }
                "DISALLOWED_TEXT" => Some(Self::DisallowedText),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedErrorEnum {}
/// Nested message and enum types in `FeedErrorEnum`.
pub mod feed_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedError {
        Unspecified = 0,
        Unknown = 1,
        AttributeNamesNotUnique = 2,
        AttributesDoNotMatchExistingAttributes = 3,
        CannotSpecifyUserOriginForSystemFeed = 4,
        CannotSpecifyGoogleOriginForNonSystemFeed = 5,
        CannotSpecifyFeedAttributesForSystemFeed = 6,
        CannotUpdateFeedAttributesWithOriginGoogle = 7,
        FeedRemoved = 8,
        InvalidOriginValue = 9,
        FeedOriginIsNotUser = 10,
        InvalidAuthTokenForEmail = 11,
        InvalidEmail = 12,
        DuplicateFeedName = 13,
        InvalidFeedName = 14,
        MissingOauthInfo = 15,
        NewAttributeCannotBePartOfUniqueKey = 16,
        TooManyAttributes = 17,
        InvalidBusinessAccount = 18,
        BusinessAccountCannotAccessLocationAccount = 19,
        InvalidAffiliateChainId = 20,
        DuplicateSystemFeed = 21,
        GmbAccessError = 22,
        CannotHaveLocationAndAffiliateLocationFeeds = 23,
        LegacyExtensionTypeReadOnly = 24,
    }
    impl FeedError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedError::Unspecified => "UNSPECIFIED",
                FeedError::Unknown => "UNKNOWN",
                FeedError::AttributeNamesNotUnique => "ATTRIBUTE_NAMES_NOT_UNIQUE",
                FeedError::AttributesDoNotMatchExistingAttributes => {
                    "ATTRIBUTES_DO_NOT_MATCH_EXISTING_ATTRIBUTES"
                }
                FeedError::CannotSpecifyUserOriginForSystemFeed => {
                    "CANNOT_SPECIFY_USER_ORIGIN_FOR_SYSTEM_FEED"
                }
                FeedError::CannotSpecifyGoogleOriginForNonSystemFeed => {
                    "CANNOT_SPECIFY_GOOGLE_ORIGIN_FOR_NON_SYSTEM_FEED"
                }
                FeedError::CannotSpecifyFeedAttributesForSystemFeed => {
                    "CANNOT_SPECIFY_FEED_ATTRIBUTES_FOR_SYSTEM_FEED"
                }
                FeedError::CannotUpdateFeedAttributesWithOriginGoogle => {
                    "CANNOT_UPDATE_FEED_ATTRIBUTES_WITH_ORIGIN_GOOGLE"
                }
                FeedError::FeedRemoved => "FEED_REMOVED",
                FeedError::InvalidOriginValue => "INVALID_ORIGIN_VALUE",
                FeedError::FeedOriginIsNotUser => "FEED_ORIGIN_IS_NOT_USER",
                FeedError::InvalidAuthTokenForEmail => "INVALID_AUTH_TOKEN_FOR_EMAIL",
                FeedError::InvalidEmail => "INVALID_EMAIL",
                FeedError::DuplicateFeedName => "DUPLICATE_FEED_NAME",
                FeedError::InvalidFeedName => "INVALID_FEED_NAME",
                FeedError::MissingOauthInfo => "MISSING_OAUTH_INFO",
                FeedError::NewAttributeCannotBePartOfUniqueKey => {
                    "NEW_ATTRIBUTE_CANNOT_BE_PART_OF_UNIQUE_KEY"
                }
                FeedError::TooManyAttributes => "TOO_MANY_ATTRIBUTES",
                FeedError::InvalidBusinessAccount => "INVALID_BUSINESS_ACCOUNT",
                FeedError::BusinessAccountCannotAccessLocationAccount => {
                    "BUSINESS_ACCOUNT_CANNOT_ACCESS_LOCATION_ACCOUNT"
                }
                FeedError::InvalidAffiliateChainId => "INVALID_AFFILIATE_CHAIN_ID",
                FeedError::DuplicateSystemFeed => "DUPLICATE_SYSTEM_FEED",
                FeedError::GmbAccessError => "GMB_ACCESS_ERROR",
                FeedError::CannotHaveLocationAndAffiliateLocationFeeds => {
                    "CANNOT_HAVE_LOCATION_AND_AFFILIATE_LOCATION_FEEDS"
                }
                FeedError::LegacyExtensionTypeReadOnly => {
                    "LEGACY_EXTENSION_TYPE_READ_ONLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ATTRIBUTE_NAMES_NOT_UNIQUE" => Some(Self::AttributeNamesNotUnique),
                "ATTRIBUTES_DO_NOT_MATCH_EXISTING_ATTRIBUTES" => {
                    Some(Self::AttributesDoNotMatchExistingAttributes)
                }
                "CANNOT_SPECIFY_USER_ORIGIN_FOR_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyUserOriginForSystemFeed)
                }
                "CANNOT_SPECIFY_GOOGLE_ORIGIN_FOR_NON_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyGoogleOriginForNonSystemFeed)
                }
                "CANNOT_SPECIFY_FEED_ATTRIBUTES_FOR_SYSTEM_FEED" => {
                    Some(Self::CannotSpecifyFeedAttributesForSystemFeed)
                }
                "CANNOT_UPDATE_FEED_ATTRIBUTES_WITH_ORIGIN_GOOGLE" => {
                    Some(Self::CannotUpdateFeedAttributesWithOriginGoogle)
                }
                "FEED_REMOVED" => Some(Self::FeedRemoved),
                "INVALID_ORIGIN_VALUE" => Some(Self::InvalidOriginValue),
                "FEED_ORIGIN_IS_NOT_USER" => Some(Self::FeedOriginIsNotUser),
                "INVALID_AUTH_TOKEN_FOR_EMAIL" => Some(Self::InvalidAuthTokenForEmail),
                "INVALID_EMAIL" => Some(Self::InvalidEmail),
                "DUPLICATE_FEED_NAME" => Some(Self::DuplicateFeedName),
                "INVALID_FEED_NAME" => Some(Self::InvalidFeedName),
                "MISSING_OAUTH_INFO" => Some(Self::MissingOauthInfo),
                "NEW_ATTRIBUTE_CANNOT_BE_PART_OF_UNIQUE_KEY" => {
                    Some(Self::NewAttributeCannotBePartOfUniqueKey)
                }
                "TOO_MANY_ATTRIBUTES" => Some(Self::TooManyAttributes),
                "INVALID_BUSINESS_ACCOUNT" => Some(Self::InvalidBusinessAccount),
                "BUSINESS_ACCOUNT_CANNOT_ACCESS_LOCATION_ACCOUNT" => {
                    Some(Self::BusinessAccountCannotAccessLocationAccount)
                }
                "INVALID_AFFILIATE_CHAIN_ID" => Some(Self::InvalidAffiliateChainId),
                "DUPLICATE_SYSTEM_FEED" => Some(Self::DuplicateSystemFeed),
                "GMB_ACCESS_ERROR" => Some(Self::GmbAccessError),
                "CANNOT_HAVE_LOCATION_AND_AFFILIATE_LOCATION_FEEDS" => {
                    Some(Self::CannotHaveLocationAndAffiliateLocationFeeds)
                }
                "LEGACY_EXTENSION_TYPE_READ_ONLY" => {
                    Some(Self::LegacyExtensionTypeReadOnly)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetLinkErrorEnum {}
/// Nested message and enum types in `FeedItemSetLinkErrorEnum`.
pub mod feed_item_set_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetLinkError {
        Unspecified = 0,
        Unknown = 1,
        FeedIdMismatch = 2,
        NoMutateAllowedForDynamicSet = 3,
    }
    impl FeedItemSetLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemSetLinkError::Unspecified => "UNSPECIFIED",
                FeedItemSetLinkError::Unknown => "UNKNOWN",
                FeedItemSetLinkError::FeedIdMismatch => "FEED_ID_MISMATCH",
                FeedItemSetLinkError::NoMutateAllowedForDynamicSet => {
                    "NO_MUTATE_ALLOWED_FOR_DYNAMIC_SET"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ID_MISMATCH" => Some(Self::FeedIdMismatch),
                "NO_MUTATE_ALLOWED_FOR_DYNAMIC_SET" => {
                    Some(Self::NoMutateAllowedForDynamicSet)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetErrorEnum {}
/// Nested message and enum types in `FeedItemTargetErrorEnum`.
pub mod feed_item_target_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetError {
        Unspecified = 0,
        Unknown = 1,
        MustSetTargetOneofOnCreate = 2,
        FeedItemTargetAlreadyExists = 3,
        FeedItemSchedulesCannotOverlap = 4,
        TargetLimitExceededForGivenType = 5,
        TooManySchedulesPerDay = 6,
        CannotHaveEnabledCampaignAndEnabledAdGroupTargets = 7,
        DuplicateAdSchedule = 8,
        DuplicateKeyword = 9,
    }
    impl FeedItemTargetError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemTargetError::Unspecified => "UNSPECIFIED",
                FeedItemTargetError::Unknown => "UNKNOWN",
                FeedItemTargetError::MustSetTargetOneofOnCreate => {
                    "MUST_SET_TARGET_ONEOF_ON_CREATE"
                }
                FeedItemTargetError::FeedItemTargetAlreadyExists => {
                    "FEED_ITEM_TARGET_ALREADY_EXISTS"
                }
                FeedItemTargetError::FeedItemSchedulesCannotOverlap => {
                    "FEED_ITEM_SCHEDULES_CANNOT_OVERLAP"
                }
                FeedItemTargetError::TargetLimitExceededForGivenType => {
                    "TARGET_LIMIT_EXCEEDED_FOR_GIVEN_TYPE"
                }
                FeedItemTargetError::TooManySchedulesPerDay => {
                    "TOO_MANY_SCHEDULES_PER_DAY"
                }
                FeedItemTargetError::CannotHaveEnabledCampaignAndEnabledAdGroupTargets => {
                    "CANNOT_HAVE_ENABLED_CAMPAIGN_AND_ENABLED_AD_GROUP_TARGETS"
                }
                FeedItemTargetError::DuplicateAdSchedule => "DUPLICATE_AD_SCHEDULE",
                FeedItemTargetError::DuplicateKeyword => "DUPLICATE_KEYWORD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MUST_SET_TARGET_ONEOF_ON_CREATE" => {
                    Some(Self::MustSetTargetOneofOnCreate)
                }
                "FEED_ITEM_TARGET_ALREADY_EXISTS" => {
                    Some(Self::FeedItemTargetAlreadyExists)
                }
                "FEED_ITEM_SCHEDULES_CANNOT_OVERLAP" => {
                    Some(Self::FeedItemSchedulesCannotOverlap)
                }
                "TARGET_LIMIT_EXCEEDED_FOR_GIVEN_TYPE" => {
                    Some(Self::TargetLimitExceededForGivenType)
                }
                "TOO_MANY_SCHEDULES_PER_DAY" => Some(Self::TooManySchedulesPerDay),
                "CANNOT_HAVE_ENABLED_CAMPAIGN_AND_ENABLED_AD_GROUP_TARGETS" => {
                    Some(Self::CannotHaveEnabledCampaignAndEnabledAdGroupTargets)
                }
                "DUPLICATE_AD_SCHEDULE" => Some(Self::DuplicateAdSchedule),
                "DUPLICATE_KEYWORD" => Some(Self::DuplicateKeyword),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingErrorEnum {}
/// Nested message and enum types in `FeedMappingErrorEnum`.
pub mod feed_mapping_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingError {
        Unspecified = 0,
        Unknown = 1,
        InvalidPlaceholderField = 2,
        InvalidCriterionField = 3,
        InvalidPlaceholderType = 4,
        InvalidCriterionType = 5,
        NoAttributeFieldMappings = 7,
        FeedAttributeTypeMismatch = 8,
        CannotOperateOnMappingsForSystemGeneratedFeed = 9,
        MultipleMappingsForPlaceholderType = 10,
        MultipleMappingsForCriterionType = 11,
        MultipleMappingsForPlaceholderField = 12,
        MultipleMappingsForCriterionField = 13,
        UnexpectedAttributeFieldMappings = 14,
        LocationPlaceholderOnlyForPlacesFeeds = 15,
        CannotModifyMappingsForTypedFeed = 16,
        InvalidPlaceholderTypeForNonSystemGeneratedFeed = 17,
        InvalidPlaceholderTypeForSystemGeneratedFeedType = 18,
        AttributeFieldMappingMissingField = 19,
        LegacyFeedTypeReadOnly = 20,
    }
    impl FeedMappingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedMappingError::Unspecified => "UNSPECIFIED",
                FeedMappingError::Unknown => "UNKNOWN",
                FeedMappingError::InvalidPlaceholderField => "INVALID_PLACEHOLDER_FIELD",
                FeedMappingError::InvalidCriterionField => "INVALID_CRITERION_FIELD",
                FeedMappingError::InvalidPlaceholderType => "INVALID_PLACEHOLDER_TYPE",
                FeedMappingError::InvalidCriterionType => "INVALID_CRITERION_TYPE",
                FeedMappingError::NoAttributeFieldMappings => {
                    "NO_ATTRIBUTE_FIELD_MAPPINGS"
                }
                FeedMappingError::FeedAttributeTypeMismatch => {
                    "FEED_ATTRIBUTE_TYPE_MISMATCH"
                }
                FeedMappingError::CannotOperateOnMappingsForSystemGeneratedFeed => {
                    "CANNOT_OPERATE_ON_MAPPINGS_FOR_SYSTEM_GENERATED_FEED"
                }
                FeedMappingError::MultipleMappingsForPlaceholderType => {
                    "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_TYPE"
                }
                FeedMappingError::MultipleMappingsForCriterionType => {
                    "MULTIPLE_MAPPINGS_FOR_CRITERION_TYPE"
                }
                FeedMappingError::MultipleMappingsForPlaceholderField => {
                    "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_FIELD"
                }
                FeedMappingError::MultipleMappingsForCriterionField => {
                    "MULTIPLE_MAPPINGS_FOR_CRITERION_FIELD"
                }
                FeedMappingError::UnexpectedAttributeFieldMappings => {
                    "UNEXPECTED_ATTRIBUTE_FIELD_MAPPINGS"
                }
                FeedMappingError::LocationPlaceholderOnlyForPlacesFeeds => {
                    "LOCATION_PLACEHOLDER_ONLY_FOR_PLACES_FEEDS"
                }
                FeedMappingError::CannotModifyMappingsForTypedFeed => {
                    "CANNOT_MODIFY_MAPPINGS_FOR_TYPED_FEED"
                }
                FeedMappingError::InvalidPlaceholderTypeForNonSystemGeneratedFeed => {
                    "INVALID_PLACEHOLDER_TYPE_FOR_NON_SYSTEM_GENERATED_FEED"
                }
                FeedMappingError::InvalidPlaceholderTypeForSystemGeneratedFeedType => {
                    "INVALID_PLACEHOLDER_TYPE_FOR_SYSTEM_GENERATED_FEED_TYPE"
                }
                FeedMappingError::AttributeFieldMappingMissingField => {
                    "ATTRIBUTE_FIELD_MAPPING_MISSING_FIELD"
                }
                FeedMappingError::LegacyFeedTypeReadOnly => "LEGACY_FEED_TYPE_READ_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_PLACEHOLDER_FIELD" => Some(Self::InvalidPlaceholderField),
                "INVALID_CRITERION_FIELD" => Some(Self::InvalidCriterionField),
                "INVALID_PLACEHOLDER_TYPE" => Some(Self::InvalidPlaceholderType),
                "INVALID_CRITERION_TYPE" => Some(Self::InvalidCriterionType),
                "NO_ATTRIBUTE_FIELD_MAPPINGS" => Some(Self::NoAttributeFieldMappings),
                "FEED_ATTRIBUTE_TYPE_MISMATCH" => Some(Self::FeedAttributeTypeMismatch),
                "CANNOT_OPERATE_ON_MAPPINGS_FOR_SYSTEM_GENERATED_FEED" => {
                    Some(Self::CannotOperateOnMappingsForSystemGeneratedFeed)
                }
                "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_TYPE" => {
                    Some(Self::MultipleMappingsForPlaceholderType)
                }
                "MULTIPLE_MAPPINGS_FOR_CRITERION_TYPE" => {
                    Some(Self::MultipleMappingsForCriterionType)
                }
                "MULTIPLE_MAPPINGS_FOR_PLACEHOLDER_FIELD" => {
                    Some(Self::MultipleMappingsForPlaceholderField)
                }
                "MULTIPLE_MAPPINGS_FOR_CRITERION_FIELD" => {
                    Some(Self::MultipleMappingsForCriterionField)
                }
                "UNEXPECTED_ATTRIBUTE_FIELD_MAPPINGS" => {
                    Some(Self::UnexpectedAttributeFieldMappings)
                }
                "LOCATION_PLACEHOLDER_ONLY_FOR_PLACES_FEEDS" => {
                    Some(Self::LocationPlaceholderOnlyForPlacesFeeds)
                }
                "CANNOT_MODIFY_MAPPINGS_FOR_TYPED_FEED" => {
                    Some(Self::CannotModifyMappingsForTypedFeed)
                }
                "INVALID_PLACEHOLDER_TYPE_FOR_NON_SYSTEM_GENERATED_FEED" => {
                    Some(Self::InvalidPlaceholderTypeForNonSystemGeneratedFeed)
                }
                "INVALID_PLACEHOLDER_TYPE_FOR_SYSTEM_GENERATED_FEED_TYPE" => {
                    Some(Self::InvalidPlaceholderTypeForSystemGeneratedFeedType)
                }
                "ATTRIBUTE_FIELD_MAPPING_MISSING_FIELD" => {
                    Some(Self::AttributeFieldMappingMissingField)
                }
                "LEGACY_FEED_TYPE_READ_ONLY" => Some(Self::LegacyFeedTypeReadOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FieldMaskErrorEnum {}
/// Nested message and enum types in `FieldMaskErrorEnum`.
pub mod field_mask_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldMaskError {
        Unspecified = 0,
        Unknown = 1,
        FieldMaskMissing = 5,
        FieldMaskNotAllowed = 4,
        FieldNotFound = 2,
        FieldHasSubfields = 3,
    }
    impl FieldMaskError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FieldMaskError::Unspecified => "UNSPECIFIED",
                FieldMaskError::Unknown => "UNKNOWN",
                FieldMaskError::FieldMaskMissing => "FIELD_MASK_MISSING",
                FieldMaskError::FieldMaskNotAllowed => "FIELD_MASK_NOT_ALLOWED",
                FieldMaskError::FieldNotFound => "FIELD_NOT_FOUND",
                FieldMaskError::FieldHasSubfields => "FIELD_HAS_SUBFIELDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIELD_MASK_MISSING" => Some(Self::FieldMaskMissing),
                "FIELD_MASK_NOT_ALLOWED" => Some(Self::FieldMaskNotAllowed),
                "FIELD_NOT_FOUND" => Some(Self::FieldNotFound),
                "FIELD_HAS_SUBFIELDS" => Some(Self::FieldHasSubfields),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FunctionErrorEnum {}
/// Nested message and enum types in `FunctionErrorEnum`.
pub mod function_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FunctionError {
        Unspecified = 0,
        Unknown = 1,
        InvalidFunctionFormat = 2,
        DataTypeMismatch = 3,
        InvalidConjunctionOperands = 4,
        InvalidNumberOfOperands = 5,
        InvalidOperandType = 6,
        InvalidOperator = 7,
        InvalidRequestContextType = 8,
        InvalidFunctionForCallPlaceholder = 9,
        InvalidFunctionForPlaceholder = 10,
        InvalidOperand = 11,
        MissingConstantOperandValue = 12,
        InvalidConstantOperandValue = 13,
        InvalidNesting = 14,
        MultipleFeedIdsNotSupported = 15,
        InvalidFunctionForFeedWithFixedSchema = 16,
        InvalidAttributeName = 17,
    }
    impl FunctionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FunctionError::Unspecified => "UNSPECIFIED",
                FunctionError::Unknown => "UNKNOWN",
                FunctionError::InvalidFunctionFormat => "INVALID_FUNCTION_FORMAT",
                FunctionError::DataTypeMismatch => "DATA_TYPE_MISMATCH",
                FunctionError::InvalidConjunctionOperands => {
                    "INVALID_CONJUNCTION_OPERANDS"
                }
                FunctionError::InvalidNumberOfOperands => "INVALID_NUMBER_OF_OPERANDS",
                FunctionError::InvalidOperandType => "INVALID_OPERAND_TYPE",
                FunctionError::InvalidOperator => "INVALID_OPERATOR",
                FunctionError::InvalidRequestContextType => {
                    "INVALID_REQUEST_CONTEXT_TYPE"
                }
                FunctionError::InvalidFunctionForCallPlaceholder => {
                    "INVALID_FUNCTION_FOR_CALL_PLACEHOLDER"
                }
                FunctionError::InvalidFunctionForPlaceholder => {
                    "INVALID_FUNCTION_FOR_PLACEHOLDER"
                }
                FunctionError::InvalidOperand => "INVALID_OPERAND",
                FunctionError::MissingConstantOperandValue => {
                    "MISSING_CONSTANT_OPERAND_VALUE"
                }
                FunctionError::InvalidConstantOperandValue => {
                    "INVALID_CONSTANT_OPERAND_VALUE"
                }
                FunctionError::InvalidNesting => "INVALID_NESTING",
                FunctionError::MultipleFeedIdsNotSupported => {
                    "MULTIPLE_FEED_IDS_NOT_SUPPORTED"
                }
                FunctionError::InvalidFunctionForFeedWithFixedSchema => {
                    "INVALID_FUNCTION_FOR_FEED_WITH_FIXED_SCHEMA"
                }
                FunctionError::InvalidAttributeName => "INVALID_ATTRIBUTE_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_FUNCTION_FORMAT" => Some(Self::InvalidFunctionFormat),
                "DATA_TYPE_MISMATCH" => Some(Self::DataTypeMismatch),
                "INVALID_CONJUNCTION_OPERANDS" => Some(Self::InvalidConjunctionOperands),
                "INVALID_NUMBER_OF_OPERANDS" => Some(Self::InvalidNumberOfOperands),
                "INVALID_OPERAND_TYPE" => Some(Self::InvalidOperandType),
                "INVALID_OPERATOR" => Some(Self::InvalidOperator),
                "INVALID_REQUEST_CONTEXT_TYPE" => Some(Self::InvalidRequestContextType),
                "INVALID_FUNCTION_FOR_CALL_PLACEHOLDER" => {
                    Some(Self::InvalidFunctionForCallPlaceholder)
                }
                "INVALID_FUNCTION_FOR_PLACEHOLDER" => {
                    Some(Self::InvalidFunctionForPlaceholder)
                }
                "INVALID_OPERAND" => Some(Self::InvalidOperand),
                "MISSING_CONSTANT_OPERAND_VALUE" => {
                    Some(Self::MissingConstantOperandValue)
                }
                "INVALID_CONSTANT_OPERAND_VALUE" => {
                    Some(Self::InvalidConstantOperandValue)
                }
                "INVALID_NESTING" => Some(Self::InvalidNesting),
                "MULTIPLE_FEED_IDS_NOT_SUPPORTED" => {
                    Some(Self::MultipleFeedIdsNotSupported)
                }
                "INVALID_FUNCTION_FOR_FEED_WITH_FIXED_SCHEMA" => {
                    Some(Self::InvalidFunctionForFeedWithFixedSchema)
                }
                "INVALID_ATTRIBUTE_NAME" => Some(Self::InvalidAttributeName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FunctionParsingErrorEnum {}
/// Nested message and enum types in `FunctionParsingErrorEnum`.
pub mod function_parsing_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FunctionParsingError {
        Unspecified = 0,
        Unknown = 1,
        NoMoreInput = 2,
        ExpectedCharacter = 3,
        UnexpectedSeparator = 4,
        UnmatchedLeftBracket = 5,
        UnmatchedRightBracket = 6,
        TooManyNestedFunctions = 7,
        MissingRightHandOperand = 8,
        InvalidOperatorName = 9,
        FeedAttributeOperandArgumentNotInteger = 10,
        NoOperands = 11,
        TooManyOperands = 12,
    }
    impl FunctionParsingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FunctionParsingError::Unspecified => "UNSPECIFIED",
                FunctionParsingError::Unknown => "UNKNOWN",
                FunctionParsingError::NoMoreInput => "NO_MORE_INPUT",
                FunctionParsingError::ExpectedCharacter => "EXPECTED_CHARACTER",
                FunctionParsingError::UnexpectedSeparator => "UNEXPECTED_SEPARATOR",
                FunctionParsingError::UnmatchedLeftBracket => "UNMATCHED_LEFT_BRACKET",
                FunctionParsingError::UnmatchedRightBracket => "UNMATCHED_RIGHT_BRACKET",
                FunctionParsingError::TooManyNestedFunctions => {
                    "TOO_MANY_NESTED_FUNCTIONS"
                }
                FunctionParsingError::MissingRightHandOperand => {
                    "MISSING_RIGHT_HAND_OPERAND"
                }
                FunctionParsingError::InvalidOperatorName => "INVALID_OPERATOR_NAME",
                FunctionParsingError::FeedAttributeOperandArgumentNotInteger => {
                    "FEED_ATTRIBUTE_OPERAND_ARGUMENT_NOT_INTEGER"
                }
                FunctionParsingError::NoOperands => "NO_OPERANDS",
                FunctionParsingError::TooManyOperands => "TOO_MANY_OPERANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_MORE_INPUT" => Some(Self::NoMoreInput),
                "EXPECTED_CHARACTER" => Some(Self::ExpectedCharacter),
                "UNEXPECTED_SEPARATOR" => Some(Self::UnexpectedSeparator),
                "UNMATCHED_LEFT_BRACKET" => Some(Self::UnmatchedLeftBracket),
                "UNMATCHED_RIGHT_BRACKET" => Some(Self::UnmatchedRightBracket),
                "TOO_MANY_NESTED_FUNCTIONS" => Some(Self::TooManyNestedFunctions),
                "MISSING_RIGHT_HAND_OPERAND" => Some(Self::MissingRightHandOperand),
                "INVALID_OPERATOR_NAME" => Some(Self::InvalidOperatorName),
                "FEED_ATTRIBUTE_OPERAND_ARGUMENT_NOT_INTEGER" => {
                    Some(Self::FeedAttributeOperandArgumentNotInteger)
                }
                "NO_OPERANDS" => Some(Self::NoOperands),
                "TOO_MANY_OPERANDS" => Some(Self::TooManyOperands),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HeaderErrorEnum {}
/// Nested message and enum types in `HeaderErrorEnum`.
pub mod header_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HeaderError {
        Unspecified = 0,
        Unknown = 1,
        InvalidLoginCustomerId = 3,
        InvalidLinkedCustomerId = 7,
    }
    impl HeaderError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HeaderError::Unspecified => "UNSPECIFIED",
                HeaderError::Unknown => "UNKNOWN",
                HeaderError::InvalidLoginCustomerId => "INVALID_LOGIN_CUSTOMER_ID",
                HeaderError::InvalidLinkedCustomerId => "INVALID_LINKED_CUSTOMER_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_LOGIN_CUSTOMER_ID" => Some(Self::InvalidLoginCustomerId),
                "INVALID_LINKED_CUSTOMER_ID" => Some(Self::InvalidLinkedCustomerId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdErrorEnum {}
/// Nested message and enum types in `IdErrorEnum`.
pub mod id_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdError {
        Unspecified = 0,
        Unknown = 1,
        NotFound = 2,
    }
    impl IdError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IdError::Unspecified => "UNSPECIFIED",
                IdError::Unknown => "UNKNOWN",
                IdError::NotFound => "NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_FOUND" => Some(Self::NotFound),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImageErrorEnum {}
/// Nested message and enum types in `ImageErrorEnum`.
pub mod image_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImageError {
        Unspecified = 0,
        Unknown = 1,
        InvalidImage = 2,
        StorageError = 3,
        BadRequest = 4,
        UnexpectedSize = 5,
        AnimatedNotAllowed = 6,
        AnimationTooLong = 7,
        ServerError = 8,
        CmykJpegNotAllowed = 9,
        FlashNotAllowed = 10,
        FlashWithoutClicktag = 11,
        FlashErrorAfterFixingClickTag = 12,
        AnimatedVisualEffect = 13,
        FlashError = 14,
        LayoutProblem = 15,
        ProblemReadingImageFile = 16,
        ErrorStoringImage = 17,
        AspectRatioNotAllowed = 18,
        FlashHasNetworkObjects = 19,
        FlashHasNetworkMethods = 20,
        FlashHasUrl = 21,
        FlashHasMouseTracking = 22,
        FlashHasRandomNum = 23,
        FlashSelfTargets = 24,
        FlashBadGeturlTarget = 25,
        FlashVersionNotSupported = 26,
        FlashWithoutHardCodedClickUrl = 27,
        InvalidFlashFile = 28,
        FailedToFixClickTagInFlash = 29,
        FlashAccessesNetworkResources = 30,
        FlashExternalJsCall = 31,
        FlashExternalFsCall = 32,
        FileTooLarge = 33,
        ImageDataTooLarge = 34,
        ImageProcessingError = 35,
        ImageTooSmall = 36,
        InvalidInput = 37,
        ProblemReadingFile = 38,
        ImageConstraintsViolated = 39,
        FormatNotAllowed = 40,
    }
    impl ImageError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImageError::Unspecified => "UNSPECIFIED",
                ImageError::Unknown => "UNKNOWN",
                ImageError::InvalidImage => "INVALID_IMAGE",
                ImageError::StorageError => "STORAGE_ERROR",
                ImageError::BadRequest => "BAD_REQUEST",
                ImageError::UnexpectedSize => "UNEXPECTED_SIZE",
                ImageError::AnimatedNotAllowed => "ANIMATED_NOT_ALLOWED",
                ImageError::AnimationTooLong => "ANIMATION_TOO_LONG",
                ImageError::ServerError => "SERVER_ERROR",
                ImageError::CmykJpegNotAllowed => "CMYK_JPEG_NOT_ALLOWED",
                ImageError::FlashNotAllowed => "FLASH_NOT_ALLOWED",
                ImageError::FlashWithoutClicktag => "FLASH_WITHOUT_CLICKTAG",
                ImageError::FlashErrorAfterFixingClickTag => {
                    "FLASH_ERROR_AFTER_FIXING_CLICK_TAG"
                }
                ImageError::AnimatedVisualEffect => "ANIMATED_VISUAL_EFFECT",
                ImageError::FlashError => "FLASH_ERROR",
                ImageError::LayoutProblem => "LAYOUT_PROBLEM",
                ImageError::ProblemReadingImageFile => "PROBLEM_READING_IMAGE_FILE",
                ImageError::ErrorStoringImage => "ERROR_STORING_IMAGE",
                ImageError::AspectRatioNotAllowed => "ASPECT_RATIO_NOT_ALLOWED",
                ImageError::FlashHasNetworkObjects => "FLASH_HAS_NETWORK_OBJECTS",
                ImageError::FlashHasNetworkMethods => "FLASH_HAS_NETWORK_METHODS",
                ImageError::FlashHasUrl => "FLASH_HAS_URL",
                ImageError::FlashHasMouseTracking => "FLASH_HAS_MOUSE_TRACKING",
                ImageError::FlashHasRandomNum => "FLASH_HAS_RANDOM_NUM",
                ImageError::FlashSelfTargets => "FLASH_SELF_TARGETS",
                ImageError::FlashBadGeturlTarget => "FLASH_BAD_GETURL_TARGET",
                ImageError::FlashVersionNotSupported => "FLASH_VERSION_NOT_SUPPORTED",
                ImageError::FlashWithoutHardCodedClickUrl => {
                    "FLASH_WITHOUT_HARD_CODED_CLICK_URL"
                }
                ImageError::InvalidFlashFile => "INVALID_FLASH_FILE",
                ImageError::FailedToFixClickTagInFlash => {
                    "FAILED_TO_FIX_CLICK_TAG_IN_FLASH"
                }
                ImageError::FlashAccessesNetworkResources => {
                    "FLASH_ACCESSES_NETWORK_RESOURCES"
                }
                ImageError::FlashExternalJsCall => "FLASH_EXTERNAL_JS_CALL",
                ImageError::FlashExternalFsCall => "FLASH_EXTERNAL_FS_CALL",
                ImageError::FileTooLarge => "FILE_TOO_LARGE",
                ImageError::ImageDataTooLarge => "IMAGE_DATA_TOO_LARGE",
                ImageError::ImageProcessingError => "IMAGE_PROCESSING_ERROR",
                ImageError::ImageTooSmall => "IMAGE_TOO_SMALL",
                ImageError::InvalidInput => "INVALID_INPUT",
                ImageError::ProblemReadingFile => "PROBLEM_READING_FILE",
                ImageError::ImageConstraintsViolated => "IMAGE_CONSTRAINTS_VIOLATED",
                ImageError::FormatNotAllowed => "FORMAT_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_IMAGE" => Some(Self::InvalidImage),
                "STORAGE_ERROR" => Some(Self::StorageError),
                "BAD_REQUEST" => Some(Self::BadRequest),
                "UNEXPECTED_SIZE" => Some(Self::UnexpectedSize),
                "ANIMATED_NOT_ALLOWED" => Some(Self::AnimatedNotAllowed),
                "ANIMATION_TOO_LONG" => Some(Self::AnimationTooLong),
                "SERVER_ERROR" => Some(Self::ServerError),
                "CMYK_JPEG_NOT_ALLOWED" => Some(Self::CmykJpegNotAllowed),
                "FLASH_NOT_ALLOWED" => Some(Self::FlashNotAllowed),
                "FLASH_WITHOUT_CLICKTAG" => Some(Self::FlashWithoutClicktag),
                "FLASH_ERROR_AFTER_FIXING_CLICK_TAG" => {
                    Some(Self::FlashErrorAfterFixingClickTag)
                }
                "ANIMATED_VISUAL_EFFECT" => Some(Self::AnimatedVisualEffect),
                "FLASH_ERROR" => Some(Self::FlashError),
                "LAYOUT_PROBLEM" => Some(Self::LayoutProblem),
                "PROBLEM_READING_IMAGE_FILE" => Some(Self::ProblemReadingImageFile),
                "ERROR_STORING_IMAGE" => Some(Self::ErrorStoringImage),
                "ASPECT_RATIO_NOT_ALLOWED" => Some(Self::AspectRatioNotAllowed),
                "FLASH_HAS_NETWORK_OBJECTS" => Some(Self::FlashHasNetworkObjects),
                "FLASH_HAS_NETWORK_METHODS" => Some(Self::FlashHasNetworkMethods),
                "FLASH_HAS_URL" => Some(Self::FlashHasUrl),
                "FLASH_HAS_MOUSE_TRACKING" => Some(Self::FlashHasMouseTracking),
                "FLASH_HAS_RANDOM_NUM" => Some(Self::FlashHasRandomNum),
                "FLASH_SELF_TARGETS" => Some(Self::FlashSelfTargets),
                "FLASH_BAD_GETURL_TARGET" => Some(Self::FlashBadGeturlTarget),
                "FLASH_VERSION_NOT_SUPPORTED" => Some(Self::FlashVersionNotSupported),
                "FLASH_WITHOUT_HARD_CODED_CLICK_URL" => {
                    Some(Self::FlashWithoutHardCodedClickUrl)
                }
                "INVALID_FLASH_FILE" => Some(Self::InvalidFlashFile),
                "FAILED_TO_FIX_CLICK_TAG_IN_FLASH" => {
                    Some(Self::FailedToFixClickTagInFlash)
                }
                "FLASH_ACCESSES_NETWORK_RESOURCES" => {
                    Some(Self::FlashAccessesNetworkResources)
                }
                "FLASH_EXTERNAL_JS_CALL" => Some(Self::FlashExternalJsCall),
                "FLASH_EXTERNAL_FS_CALL" => Some(Self::FlashExternalFsCall),
                "FILE_TOO_LARGE" => Some(Self::FileTooLarge),
                "IMAGE_DATA_TOO_LARGE" => Some(Self::ImageDataTooLarge),
                "IMAGE_PROCESSING_ERROR" => Some(Self::ImageProcessingError),
                "IMAGE_TOO_SMALL" => Some(Self::ImageTooSmall),
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "PROBLEM_READING_FILE" => Some(Self::ProblemReadingFile),
                "IMAGE_CONSTRAINTS_VIOLATED" => Some(Self::ImageConstraintsViolated),
                "FORMAT_NOT_ALLOWED" => Some(Self::FormatNotAllowed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InternalErrorEnum {}
/// Nested message and enum types in `InternalErrorEnum`.
pub mod internal_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InternalError {
        Unspecified = 0,
        Unknown = 1,
        InternalError = 2,
        ErrorCodeNotPublished = 3,
        TransientError = 4,
        DeadlineExceeded = 5,
    }
    impl InternalError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InternalError::Unspecified => "UNSPECIFIED",
                InternalError::Unknown => "UNKNOWN",
                InternalError::InternalError => "INTERNAL_ERROR",
                InternalError::ErrorCodeNotPublished => "ERROR_CODE_NOT_PUBLISHED",
                InternalError::TransientError => "TRANSIENT_ERROR",
                InternalError::DeadlineExceeded => "DEADLINE_EXCEEDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "ERROR_CODE_NOT_PUBLISHED" => Some(Self::ErrorCodeNotPublished),
                "TRANSIENT_ERROR" => Some(Self::TransientError),
                "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvoiceErrorEnum {}
/// Nested message and enum types in `InvoiceErrorEnum`.
pub mod invoice_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvoiceError {
        Unspecified = 0,
        Unknown = 1,
        YearMonthTooOld = 2,
        NotInvoicedCustomer = 3,
        BillingSetupNotApproved = 4,
        BillingSetupNotOnMonthlyInvoicing = 5,
        NonServingCustomer = 6,
    }
    impl InvoiceError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InvoiceError::Unspecified => "UNSPECIFIED",
                InvoiceError::Unknown => "UNKNOWN",
                InvoiceError::YearMonthTooOld => "YEAR_MONTH_TOO_OLD",
                InvoiceError::NotInvoicedCustomer => "NOT_INVOICED_CUSTOMER",
                InvoiceError::BillingSetupNotApproved => "BILLING_SETUP_NOT_APPROVED",
                InvoiceError::BillingSetupNotOnMonthlyInvoicing => {
                    "BILLING_SETUP_NOT_ON_MONTHLY_INVOICING"
                }
                InvoiceError::NonServingCustomer => "NON_SERVING_CUSTOMER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YEAR_MONTH_TOO_OLD" => Some(Self::YearMonthTooOld),
                "NOT_INVOICED_CUSTOMER" => Some(Self::NotInvoicedCustomer),
                "BILLING_SETUP_NOT_APPROVED" => Some(Self::BillingSetupNotApproved),
                "BILLING_SETUP_NOT_ON_MONTHLY_INVOICING" => {
                    Some(Self::BillingSetupNotOnMonthlyInvoicing)
                }
                "NON_SERVING_CUSTOMER" => Some(Self::NonServingCustomer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAdGroupErrorEnum {}
/// Nested message and enum types in `KeywordPlanAdGroupErrorEnum`.
pub mod keyword_plan_ad_group_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAdGroupError {
        Unspecified = 0,
        Unknown = 1,
        InvalidName = 2,
        DuplicateName = 3,
    }
    impl KeywordPlanAdGroupError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanAdGroupError::Unspecified => "UNSPECIFIED",
                KeywordPlanAdGroupError::Unknown => "UNKNOWN",
                KeywordPlanAdGroupError::InvalidName => "INVALID_NAME",
                KeywordPlanAdGroupError::DuplicateName => "DUPLICATE_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_NAME" => Some(Self::InvalidName),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignErrorEnum {}
/// Nested message and enum types in `KeywordPlanCampaignErrorEnum`.
pub mod keyword_plan_campaign_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCampaignError {
        Unspecified = 0,
        Unknown = 1,
        InvalidName = 2,
        InvalidLanguages = 3,
        InvalidGeos = 4,
        DuplicateName = 5,
        MaxGeosExceeded = 6,
        MaxLanguagesExceeded = 7,
    }
    impl KeywordPlanCampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanCampaignError::Unspecified => "UNSPECIFIED",
                KeywordPlanCampaignError::Unknown => "UNKNOWN",
                KeywordPlanCampaignError::InvalidName => "INVALID_NAME",
                KeywordPlanCampaignError::InvalidLanguages => "INVALID_LANGUAGES",
                KeywordPlanCampaignError::InvalidGeos => "INVALID_GEOS",
                KeywordPlanCampaignError::DuplicateName => "DUPLICATE_NAME",
                KeywordPlanCampaignError::MaxGeosExceeded => "MAX_GEOS_EXCEEDED",
                KeywordPlanCampaignError::MaxLanguagesExceeded => {
                    "MAX_LANGUAGES_EXCEEDED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_NAME" => Some(Self::InvalidName),
                "INVALID_LANGUAGES" => Some(Self::InvalidLanguages),
                "INVALID_GEOS" => Some(Self::InvalidGeos),
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "MAX_GEOS_EXCEEDED" => Some(Self::MaxGeosExceeded),
                "MAX_LANGUAGES_EXCEEDED" => Some(Self::MaxLanguagesExceeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCampaignKeywordErrorEnum {}
/// Nested message and enum types in `KeywordPlanCampaignKeywordErrorEnum`.
pub mod keyword_plan_campaign_keyword_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCampaignKeywordError {
        Unspecified = 0,
        Unknown = 1,
        CampaignKeywordIsPositive = 8,
    }
    impl KeywordPlanCampaignKeywordError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanCampaignKeywordError::Unspecified => "UNSPECIFIED",
                KeywordPlanCampaignKeywordError::Unknown => "UNKNOWN",
                KeywordPlanCampaignKeywordError::CampaignKeywordIsPositive => {
                    "CAMPAIGN_KEYWORD_IS_POSITIVE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_KEYWORD_IS_POSITIVE" => Some(Self::CampaignKeywordIsPositive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanErrorEnum {}
/// Nested message and enum types in `KeywordPlanErrorEnum`.
pub mod keyword_plan_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanError {
        Unspecified = 0,
        Unknown = 1,
        BidMultiplierOutOfRange = 2,
        BidTooHigh = 3,
        BidTooLow = 4,
        BidTooManyFractionalDigits = 5,
        DailyBudgetTooLow = 6,
        DailyBudgetTooManyFractionalDigits = 7,
        InvalidValue = 8,
        KeywordPlanHasNoKeywords = 9,
        KeywordPlanNotEnabled = 10,
        KeywordPlanNotFound = 11,
        MissingBid = 13,
        MissingForecastPeriod = 14,
        InvalidForecastDateRange = 15,
        InvalidName = 16,
    }
    impl KeywordPlanError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanError::Unspecified => "UNSPECIFIED",
                KeywordPlanError::Unknown => "UNKNOWN",
                KeywordPlanError::BidMultiplierOutOfRange => {
                    "BID_MULTIPLIER_OUT_OF_RANGE"
                }
                KeywordPlanError::BidTooHigh => "BID_TOO_HIGH",
                KeywordPlanError::BidTooLow => "BID_TOO_LOW",
                KeywordPlanError::BidTooManyFractionalDigits => {
                    "BID_TOO_MANY_FRACTIONAL_DIGITS"
                }
                KeywordPlanError::DailyBudgetTooLow => "DAILY_BUDGET_TOO_LOW",
                KeywordPlanError::DailyBudgetTooManyFractionalDigits => {
                    "DAILY_BUDGET_TOO_MANY_FRACTIONAL_DIGITS"
                }
                KeywordPlanError::InvalidValue => "INVALID_VALUE",
                KeywordPlanError::KeywordPlanHasNoKeywords => {
                    "KEYWORD_PLAN_HAS_NO_KEYWORDS"
                }
                KeywordPlanError::KeywordPlanNotEnabled => "KEYWORD_PLAN_NOT_ENABLED",
                KeywordPlanError::KeywordPlanNotFound => "KEYWORD_PLAN_NOT_FOUND",
                KeywordPlanError::MissingBid => "MISSING_BID",
                KeywordPlanError::MissingForecastPeriod => "MISSING_FORECAST_PERIOD",
                KeywordPlanError::InvalidForecastDateRange => {
                    "INVALID_FORECAST_DATE_RANGE"
                }
                KeywordPlanError::InvalidName => "INVALID_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BID_MULTIPLIER_OUT_OF_RANGE" => Some(Self::BidMultiplierOutOfRange),
                "BID_TOO_HIGH" => Some(Self::BidTooHigh),
                "BID_TOO_LOW" => Some(Self::BidTooLow),
                "BID_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::BidTooManyFractionalDigits)
                }
                "DAILY_BUDGET_TOO_LOW" => Some(Self::DailyBudgetTooLow),
                "DAILY_BUDGET_TOO_MANY_FRACTIONAL_DIGITS" => {
                    Some(Self::DailyBudgetTooManyFractionalDigits)
                }
                "INVALID_VALUE" => Some(Self::InvalidValue),
                "KEYWORD_PLAN_HAS_NO_KEYWORDS" => Some(Self::KeywordPlanHasNoKeywords),
                "KEYWORD_PLAN_NOT_ENABLED" => Some(Self::KeywordPlanNotEnabled),
                "KEYWORD_PLAN_NOT_FOUND" => Some(Self::KeywordPlanNotFound),
                "MISSING_BID" => Some(Self::MissingBid),
                "MISSING_FORECAST_PERIOD" => Some(Self::MissingForecastPeriod),
                "INVALID_FORECAST_DATE_RANGE" => Some(Self::InvalidForecastDateRange),
                "INVALID_NAME" => Some(Self::InvalidName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanIdeaErrorEnum {}
/// Nested message and enum types in `KeywordPlanIdeaErrorEnum`.
pub mod keyword_plan_idea_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanIdeaError {
        Unspecified = 0,
        Unknown = 1,
        UrlCrawlError = 2,
        InvalidValue = 3,
    }
    impl KeywordPlanIdeaError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanIdeaError::Unspecified => "UNSPECIFIED",
                KeywordPlanIdeaError::Unknown => "UNKNOWN",
                KeywordPlanIdeaError::UrlCrawlError => "URL_CRAWL_ERROR",
                KeywordPlanIdeaError::InvalidValue => "INVALID_VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "URL_CRAWL_ERROR" => Some(Self::UrlCrawlError),
                "INVALID_VALUE" => Some(Self::InvalidValue),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LabelErrorEnum {}
/// Nested message and enum types in `LabelErrorEnum`.
pub mod label_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LabelError {
        Unspecified = 0,
        Unknown = 1,
        CannotApplyInactiveLabel = 2,
        CannotApplyLabelToDisabledAdGroupCriterion = 3,
        CannotApplyLabelToNegativeAdGroupCriterion = 4,
        ExceededLabelLimitPerType = 5,
        InvalidResourceForManagerLabel = 6,
        DuplicateName = 7,
        InvalidLabelName = 8,
        CannotAttachLabelToDraft = 9,
        CannotAttachNonManagerLabelToCustomer = 10,
    }
    impl LabelError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LabelError::Unspecified => "UNSPECIFIED",
                LabelError::Unknown => "UNKNOWN",
                LabelError::CannotApplyInactiveLabel => "CANNOT_APPLY_INACTIVE_LABEL",
                LabelError::CannotApplyLabelToDisabledAdGroupCriterion => {
                    "CANNOT_APPLY_LABEL_TO_DISABLED_AD_GROUP_CRITERION"
                }
                LabelError::CannotApplyLabelToNegativeAdGroupCriterion => {
                    "CANNOT_APPLY_LABEL_TO_NEGATIVE_AD_GROUP_CRITERION"
                }
                LabelError::ExceededLabelLimitPerType => "EXCEEDED_LABEL_LIMIT_PER_TYPE",
                LabelError::InvalidResourceForManagerLabel => {
                    "INVALID_RESOURCE_FOR_MANAGER_LABEL"
                }
                LabelError::DuplicateName => "DUPLICATE_NAME",
                LabelError::InvalidLabelName => "INVALID_LABEL_NAME",
                LabelError::CannotAttachLabelToDraft => "CANNOT_ATTACH_LABEL_TO_DRAFT",
                LabelError::CannotAttachNonManagerLabelToCustomer => {
                    "CANNOT_ATTACH_NON_MANAGER_LABEL_TO_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CANNOT_APPLY_INACTIVE_LABEL" => Some(Self::CannotApplyInactiveLabel),
                "CANNOT_APPLY_LABEL_TO_DISABLED_AD_GROUP_CRITERION" => {
                    Some(Self::CannotApplyLabelToDisabledAdGroupCriterion)
                }
                "CANNOT_APPLY_LABEL_TO_NEGATIVE_AD_GROUP_CRITERION" => {
                    Some(Self::CannotApplyLabelToNegativeAdGroupCriterion)
                }
                "EXCEEDED_LABEL_LIMIT_PER_TYPE" => Some(Self::ExceededLabelLimitPerType),
                "INVALID_RESOURCE_FOR_MANAGER_LABEL" => {
                    Some(Self::InvalidResourceForManagerLabel)
                }
                "DUPLICATE_NAME" => Some(Self::DuplicateName),
                "INVALID_LABEL_NAME" => Some(Self::InvalidLabelName),
                "CANNOT_ATTACH_LABEL_TO_DRAFT" => Some(Self::CannotAttachLabelToDraft),
                "CANNOT_ATTACH_NON_MANAGER_LABEL_TO_CUSTOMER" => {
                    Some(Self::CannotAttachNonManagerLabelToCustomer)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LanguageCodeErrorEnum {}
/// Nested message and enum types in `LanguageCodeErrorEnum`.
pub mod language_code_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LanguageCodeError {
        Unspecified = 0,
        Unknown = 1,
        LanguageCodeNotFound = 2,
        InvalidLanguageCode = 3,
    }
    impl LanguageCodeError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LanguageCodeError::Unspecified => "UNSPECIFIED",
                LanguageCodeError::Unknown => "UNKNOWN",
                LanguageCodeError::LanguageCodeNotFound => "LANGUAGE_CODE_NOT_FOUND",
                LanguageCodeError::InvalidLanguageCode => "INVALID_LANGUAGE_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LANGUAGE_CODE_NOT_FOUND" => Some(Self::LanguageCodeNotFound),
                "INVALID_LANGUAGE_CODE" => Some(Self::InvalidLanguageCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagerLinkErrorEnum {}
/// Nested message and enum types in `ManagerLinkErrorEnum`.
pub mod manager_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagerLinkError {
        Unspecified = 0,
        Unknown = 1,
        AccountsNotCompatibleForLinking = 2,
        TooManyManagers = 3,
        TooManyInvites = 4,
        AlreadyInvitedByThisManager = 5,
        AlreadyManagedByThisManager = 6,
        AlreadyManagedInHierarchy = 7,
        DuplicateChildFound = 8,
        ClientHasNoAdminUser = 9,
        MaxDepthExceeded = 10,
        CycleNotAllowed = 11,
        TooManyAccounts = 12,
        TooManyAccountsAtManager = 13,
        NonOwnerUserCannotModifyLink = 14,
        SuspendedAccountCannotAddClients = 15,
        ClientOutsideTree = 16,
        InvalidStatusChange = 17,
        InvalidChange = 18,
        CustomerCannotManageSelf = 19,
        CreatingEnabledLinkNotAllowed = 20,
    }
    impl ManagerLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ManagerLinkError::Unspecified => "UNSPECIFIED",
                ManagerLinkError::Unknown => "UNKNOWN",
                ManagerLinkError::AccountsNotCompatibleForLinking => {
                    "ACCOUNTS_NOT_COMPATIBLE_FOR_LINKING"
                }
                ManagerLinkError::TooManyManagers => "TOO_MANY_MANAGERS",
                ManagerLinkError::TooManyInvites => "TOO_MANY_INVITES",
                ManagerLinkError::AlreadyInvitedByThisManager => {
                    "ALREADY_INVITED_BY_THIS_MANAGER"
                }
                ManagerLinkError::AlreadyManagedByThisManager => {
                    "ALREADY_MANAGED_BY_THIS_MANAGER"
                }
                ManagerLinkError::AlreadyManagedInHierarchy => {
                    "ALREADY_MANAGED_IN_HIERARCHY"
                }
                ManagerLinkError::DuplicateChildFound => "DUPLICATE_CHILD_FOUND",
                ManagerLinkError::ClientHasNoAdminUser => "CLIENT_HAS_NO_ADMIN_USER",
                ManagerLinkError::MaxDepthExceeded => "MAX_DEPTH_EXCEEDED",
                ManagerLinkError::CycleNotAllowed => "CYCLE_NOT_ALLOWED",
                ManagerLinkError::TooManyAccounts => "TOO_MANY_ACCOUNTS",
                ManagerLinkError::TooManyAccountsAtManager => {
                    "TOO_MANY_ACCOUNTS_AT_MANAGER"
                }
                ManagerLinkError::NonOwnerUserCannotModifyLink => {
                    "NON_OWNER_USER_CANNOT_MODIFY_LINK"
                }
                ManagerLinkError::SuspendedAccountCannotAddClients => {
                    "SUSPENDED_ACCOUNT_CANNOT_ADD_CLIENTS"
                }
                ManagerLinkError::ClientOutsideTree => "CLIENT_OUTSIDE_TREE",
                ManagerLinkError::InvalidStatusChange => "INVALID_STATUS_CHANGE",
                ManagerLinkError::InvalidChange => "INVALID_CHANGE",
                ManagerLinkError::CustomerCannotManageSelf => {
                    "CUSTOMER_CANNOT_MANAGE_SELF"
                }
                ManagerLinkError::CreatingEnabledLinkNotAllowed => {
                    "CREATING_ENABLED_LINK_NOT_ALLOWED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNTS_NOT_COMPATIBLE_FOR_LINKING" => {
                    Some(Self::AccountsNotCompatibleForLinking)
                }
                "TOO_MANY_MANAGERS" => Some(Self::TooManyManagers),
                "TOO_MANY_INVITES" => Some(Self::TooManyInvites),
                "ALREADY_INVITED_BY_THIS_MANAGER" => {
                    Some(Self::AlreadyInvitedByThisManager)
                }
                "ALREADY_MANAGED_BY_THIS_MANAGER" => {
                    Some(Self::AlreadyManagedByThisManager)
                }
                "ALREADY_MANAGED_IN_HIERARCHY" => Some(Self::AlreadyManagedInHierarchy),
                "DUPLICATE_CHILD_FOUND" => Some(Self::DuplicateChildFound),
                "CLIENT_HAS_NO_ADMIN_USER" => Some(Self::ClientHasNoAdminUser),
                "MAX_DEPTH_EXCEEDED" => Some(Self::MaxDepthExceeded),
                "CYCLE_NOT_ALLOWED" => Some(Self::CycleNotAllowed),
                "TOO_MANY_ACCOUNTS" => Some(Self::TooManyAccounts),
                "TOO_MANY_ACCOUNTS_AT_MANAGER" => Some(Self::TooManyAccountsAtManager),
                "NON_OWNER_USER_CANNOT_MODIFY_LINK" => {
                    Some(Self::NonOwnerUserCannotModifyLink)
                }
                "SUSPENDED_ACCOUNT_CANNOT_ADD_CLIENTS" => {
                    Some(Self::SuspendedAccountCannotAddClients)
                }
                "CLIENT_OUTSIDE_TREE" => Some(Self::ClientOutsideTree),
                "INVALID_STATUS_CHANGE" => Some(Self::InvalidStatusChange),
                "INVALID_CHANGE" => Some(Self::InvalidChange),
                "CUSTOMER_CANNOT_MANAGE_SELF" => Some(Self::CustomerCannotManageSelf),
                "CREATING_ENABLED_LINK_NOT_ALLOWED" => {
                    Some(Self::CreatingEnabledLinkNotAllowed)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaBundleErrorEnum {}
/// Nested message and enum types in `MediaBundleErrorEnum`.
pub mod media_bundle_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaBundleError {
        Unspecified = 0,
        Unknown = 1,
        BadRequest = 3,
        DoubleclickBundleNotAllowed = 4,
        ExternalUrlNotAllowed = 5,
        FileTooLarge = 6,
        GoogleWebDesignerZipFileNotPublished = 7,
        InvalidInput = 8,
        InvalidMediaBundle = 9,
        InvalidMediaBundleEntry = 10,
        InvalidMimeType = 11,
        InvalidPath = 12,
        InvalidUrlReference = 13,
        MediaDataTooLarge = 14,
        MissingPrimaryMediaBundleEntry = 15,
        ServerError = 16,
        StorageError = 17,
        SwiffyBundleNotAllowed = 18,
        TooManyFiles = 19,
        UnexpectedSize = 20,
        UnsupportedGoogleWebDesignerEnvironment = 21,
        UnsupportedHtml5Feature = 22,
        UrlInMediaBundleNotSslCompliant = 23,
        CustomExitNotAllowed = 24,
    }
    impl MediaBundleError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaBundleError::Unspecified => "UNSPECIFIED",
                MediaBundleError::Unknown => "UNKNOWN",
                MediaBundleError::BadRequest => "BAD_REQUEST",
                MediaBundleError::DoubleclickBundleNotAllowed => {
                    "DOUBLECLICK_BUNDLE_NOT_ALLOWED"
                }
                MediaBundleError::ExternalUrlNotAllowed => "EXTERNAL_URL_NOT_ALLOWED",
                MediaBundleError::FileTooLarge => "FILE_TOO_LARGE",
                MediaBundleError::GoogleWebDesignerZipFileNotPublished => {
                    "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED"
                }
                MediaBundleError::InvalidInput => "INVALID_INPUT",
                MediaBundleError::InvalidMediaBundle => "INVALID_MEDIA_BUNDLE",
                MediaBundleError::InvalidMediaBundleEntry => "INVALID_MEDIA_BUNDLE_ENTRY",
                MediaBundleError::InvalidMimeType => "INVALID_MIME_TYPE",
                MediaBundleError::InvalidPath => "INVALID_PATH",
                MediaBundleError::InvalidUrlReference => "INVALID_URL_REFERENCE",
                MediaBundleError::MediaDataTooLarge => "MEDIA_DATA_TOO_LARGE",
                MediaBundleError::MissingPrimaryMediaBundleEntry => {
                    "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY"
                }
                MediaBundleError::ServerError => "SERVER_ERROR",
                MediaBundleError::StorageError => "STORAGE_ERROR",
                MediaBundleError::SwiffyBundleNotAllowed => "SWIFFY_BUNDLE_NOT_ALLOWED",
                MediaBundleError::TooManyFiles => "TOO_MANY_FILES",
                MediaBundleError::UnexpectedSize => "UNEXPECTED_SIZE",
                MediaBundleError::UnsupportedGoogleWebDesignerEnvironment => {
                    "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT"
                }
                MediaBundleError::UnsupportedHtml5Feature => "UNSUPPORTED_HTML5_FEATURE",
                MediaBundleError::UrlInMediaBundleNotSslCompliant => {
                    "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT"
                }
                MediaBundleError::CustomExitNotAllowed => "CUSTOM_EXIT_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BAD_REQUEST" => Some(Self::BadRequest),
                "DOUBLECLICK_BUNDLE_NOT_ALLOWED" => {
                    Some(Self::DoubleclickBundleNotAllowed)
                }
                "EXTERNAL_URL_NOT_ALLOWED" => Some(Self::ExternalUrlNotAllowed),
                "FILE_TOO_LARGE" => Some(Self::FileTooLarge),
                "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED" => {
                    Some(Self::GoogleWebDesignerZipFileNotPublished)
                }
                "INVALID_INPUT" => Some(Self::InvalidInput),
                "INVALID_MEDIA_BUNDLE" => Some(Self::InvalidMediaBundle),
                "INVALID_MEDIA_BUNDLE_ENTRY" => Some(Self::InvalidMediaBundleEntry),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_PATH" => Some(Self::InvalidPath),
                "INVALID_URL_REFERENCE" => Some(Self::InvalidUrlReference),
                "MEDIA_DATA_TOO_LARGE" => Some(Self::MediaDataTooLarge),
                "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY" => {
                    Some(Self::MissingPrimaryMediaBundleEntry)
                }
                "SERVER_ERROR" => Some(Self::ServerError),
                "STORAGE_ERROR" => Some(Self::StorageError),
                "SWIFFY_BUNDLE_NOT_ALLOWED" => Some(Self::SwiffyBundleNotAllowed),
                "TOO_MANY_FILES" => Some(Self::TooManyFiles),
                "UNEXPECTED_SIZE" => Some(Self::UnexpectedSize),
                "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT" => {
                    Some(Self::UnsupportedGoogleWebDesignerEnvironment)
                }
                "UNSUPPORTED_HTML5_FEATURE" => Some(Self::UnsupportedHtml5Feature),
                "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT" => {
                    Some(Self::UrlInMediaBundleNotSslCompliant)
                }
                "CUSTOM_EXIT_NOT_ALLOWED" => Some(Self::CustomExitNotAllowed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaUploadErrorEnum {}
/// Nested message and enum types in `MediaUploadErrorEnum`.
pub mod media_upload_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaUploadError {
        Unspecified = 0,
        Unknown = 1,
        FileTooBig = 2,
        UnparseableImage = 3,
        AnimatedImageNotAllowed = 4,
        FormatNotAllowed = 5,
        ExternalUrlNotAllowed = 6,
        InvalidUrlReference = 7,
        MissingPrimaryMediaBundleEntry = 8,
        AnimatedVisualEffect = 9,
        AnimationTooLong = 10,
        AspectRatioNotAllowed = 11,
        AudioNotAllowedInMediaBundle = 12,
        CmykJpegNotAllowed = 13,
        FlashNotAllowed = 14,
        FrameRateTooHigh = 15,
        GoogleWebDesignerZipFileNotPublished = 16,
        ImageConstraintsViolated = 17,
        InvalidMediaBundle = 18,
        InvalidMediaBundleEntry = 19,
        InvalidMimeType = 20,
        InvalidPath = 21,
        LayoutProblem = 22,
        MalformedUrl = 23,
        MediaBundleNotAllowed = 24,
        MediaBundleNotCompatibleToProductType = 25,
        MediaBundleRejectedByMultipleAssetSpecs = 26,
        TooManyFilesInMediaBundle = 27,
        UnsupportedGoogleWebDesignerEnvironment = 28,
        UnsupportedHtml5Feature = 29,
        UrlInMediaBundleNotSslCompliant = 30,
        VideoFileNameTooLong = 31,
        VideoMultipleFilesWithSameName = 32,
        VideoNotAllowedInMediaBundle = 33,
        CannotUploadMediaTypeThroughApi = 34,
        DimensionsNotAllowed = 35,
    }
    impl MediaUploadError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaUploadError::Unspecified => "UNSPECIFIED",
                MediaUploadError::Unknown => "UNKNOWN",
                MediaUploadError::FileTooBig => "FILE_TOO_BIG",
                MediaUploadError::UnparseableImage => "UNPARSEABLE_IMAGE",
                MediaUploadError::AnimatedImageNotAllowed => "ANIMATED_IMAGE_NOT_ALLOWED",
                MediaUploadError::FormatNotAllowed => "FORMAT_NOT_ALLOWED",
                MediaUploadError::ExternalUrlNotAllowed => "EXTERNAL_URL_NOT_ALLOWED",
                MediaUploadError::InvalidUrlReference => "INVALID_URL_REFERENCE",
                MediaUploadError::MissingPrimaryMediaBundleEntry => {
                    "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY"
                }
                MediaUploadError::AnimatedVisualEffect => "ANIMATED_VISUAL_EFFECT",
                MediaUploadError::AnimationTooLong => "ANIMATION_TOO_LONG",
                MediaUploadError::AspectRatioNotAllowed => "ASPECT_RATIO_NOT_ALLOWED",
                MediaUploadError::AudioNotAllowedInMediaBundle => {
                    "AUDIO_NOT_ALLOWED_IN_MEDIA_BUNDLE"
                }
                MediaUploadError::CmykJpegNotAllowed => "CMYK_JPEG_NOT_ALLOWED",
                MediaUploadError::FlashNotAllowed => "FLASH_NOT_ALLOWED",
                MediaUploadError::FrameRateTooHigh => "FRAME_RATE_TOO_HIGH",
                MediaUploadError::GoogleWebDesignerZipFileNotPublished => {
                    "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED"
                }
                MediaUploadError::ImageConstraintsViolated => {
                    "IMAGE_CONSTRAINTS_VIOLATED"
                }
                MediaUploadError::InvalidMediaBundle => "INVALID_MEDIA_BUNDLE",
                MediaUploadError::InvalidMediaBundleEntry => "INVALID_MEDIA_BUNDLE_ENTRY",
                MediaUploadError::InvalidMimeType => "INVALID_MIME_TYPE",
                MediaUploadError::InvalidPath => "INVALID_PATH",
                MediaUploadError::LayoutProblem => "LAYOUT_PROBLEM",
                MediaUploadError::MalformedUrl => "MALFORMED_URL",
                MediaUploadError::MediaBundleNotAllowed => "MEDIA_BUNDLE_NOT_ALLOWED",
                MediaUploadError::MediaBundleNotCompatibleToProductType => {
                    "MEDIA_BUNDLE_NOT_COMPATIBLE_TO_PRODUCT_TYPE"
                }
                MediaUploadError::MediaBundleRejectedByMultipleAssetSpecs => {
                    "MEDIA_BUNDLE_REJECTED_BY_MULTIPLE_ASSET_SPECS"
                }
                MediaUploadError::TooManyFilesInMediaBundle => {
                    "TOO_MANY_FILES_IN_MEDIA_BUNDLE"
                }
                MediaUploadError::UnsupportedGoogleWebDesignerEnvironment => {
                    "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT"
                }
                MediaUploadError::UnsupportedHtml5Feature => "UNSUPPORTED_HTML5_FEATURE",
                MediaUploadError::UrlInMediaBundleNotSslCompliant => {
                    "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT"
                }
                MediaUploadError::VideoFileNameTooLong => "VIDEO_FILE_NAME_TOO_LONG",
                MediaUploadError::VideoMultipleFilesWithSameName => {
                    "VIDEO_MULTIPLE_FILES_WITH_SAME_NAME"
                }
                MediaUploadError::VideoNotAllowedInMediaBundle => {
                    "VIDEO_NOT_ALLOWED_IN_MEDIA_BUNDLE"
                }
                MediaUploadError::CannotUploadMediaTypeThroughApi => {
                    "CANNOT_UPLOAD_MEDIA_TYPE_THROUGH_API"
                }
                MediaUploadError::DimensionsNotAllowed => "DIMENSIONS_NOT_ALLOWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FILE_TOO_BIG" => Some(Self::FileTooBig),
                "UNPARSEABLE_IMAGE" => Some(Self::UnparseableImage),
                "ANIMATED_IMAGE_NOT_ALLOWED" => Some(Self::AnimatedImageNotAllowed),
                "FORMAT_NOT_ALLOWED" => Some(Self::FormatNotAllowed),
                "EXTERNAL_URL_NOT_ALLOWED" => Some(Self::ExternalUrlNotAllowed),
                "INVALID_URL_REFERENCE" => Some(Self::InvalidUrlReference),
                "MISSING_PRIMARY_MEDIA_BUNDLE_ENTRY" => {
                    Some(Self::MissingPrimaryMediaBundleEntry)
                }
                "ANIMATED_VISUAL_EFFECT" => Some(Self::AnimatedVisualEffect),
                "ANIMATION_TOO_LONG" => Some(Self::AnimationTooLong),
                "ASPECT_RATIO_NOT_ALLOWED" => Some(Self::AspectRatioNotAllowed),
                "AUDIO_NOT_ALLOWED_IN_MEDIA_BUNDLE" => {
                    Some(Self::AudioNotAllowedInMediaBundle)
                }
                "CMYK_JPEG_NOT_ALLOWED" => Some(Self::CmykJpegNotAllowed),
                "FLASH_NOT_ALLOWED" => Some(Self::FlashNotAllowed),
                "FRAME_RATE_TOO_HIGH" => Some(Self::FrameRateTooHigh),
                "GOOGLE_WEB_DESIGNER_ZIP_FILE_NOT_PUBLISHED" => {
                    Some(Self::GoogleWebDesignerZipFileNotPublished)
                }
                "IMAGE_CONSTRAINTS_VIOLATED" => Some(Self::ImageConstraintsViolated),
                "INVALID_MEDIA_BUNDLE" => Some(Self::InvalidMediaBundle),
                "INVALID_MEDIA_BUNDLE_ENTRY" => Some(Self::InvalidMediaBundleEntry),
                "INVALID_MIME_TYPE" => Some(Self::InvalidMimeType),
                "INVALID_PATH" => Some(Self::InvalidPath),
                "LAYOUT_PROBLEM" => Some(Self::LayoutProblem),
                "MALFORMED_URL" => Some(Self::MalformedUrl),
                "MEDIA_BUNDLE_NOT_ALLOWED" => Some(Self::MediaBundleNotAllowed),
                "MEDIA_BUNDLE_NOT_COMPATIBLE_TO_PRODUCT_TYPE" => {
                    Some(Self::MediaBundleNotCompatibleToProductType)
                }
                "MEDIA_BUNDLE_REJECTED_BY_MULTIPLE_ASSET_SPECS" => {
                    Some(Self::MediaBundleRejectedByMultipleAssetSpecs)
                }
                "TOO_MANY_FILES_IN_MEDIA_BUNDLE" => Some(Self::TooManyFilesInMediaBundle),
                "UNSUPPORTED_GOOGLE_WEB_DESIGNER_ENVIRONMENT" => {
                    Some(Self::UnsupportedGoogleWebDesignerEnvironment)
                }
                "UNSUPPORTED_HTML5_FEATURE" => Some(Self::UnsupportedHtml5Feature),
                "URL_IN_MEDIA_BUNDLE_NOT_SSL_COMPLIANT" => {
                    Some(Self::UrlInMediaBundleNotSslCompliant)
                }
                "VIDEO_FILE_NAME_TOO_LONG" => Some(Self::VideoFileNameTooLong),
                "VIDEO_MULTIPLE_FILES_WITH_SAME_NAME" => {
                    Some(Self::VideoMultipleFilesWithSameName)
                }
                "VIDEO_NOT_ALLOWED_IN_MEDIA_BUNDLE" => {
                    Some(Self::VideoNotAllowedInMediaBundle)
                }
                "CANNOT_UPLOAD_MEDIA_TYPE_THROUGH_API" => {
                    Some(Self::CannotUploadMediaTypeThroughApi)
                }
                "DIMENSIONS_NOT_ALLOWED" => Some(Self::DimensionsNotAllowed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MultiplierErrorEnum {}
/// Nested message and enum types in `MultiplierErrorEnum`.
pub mod multiplier_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MultiplierError {
        Unspecified = 0,
        Unknown = 1,
        MultiplierTooHigh = 2,
        MultiplierTooLow = 3,
        TooManyFractionalDigits = 4,
        MultiplierNotAllowedForBiddingStrategy = 5,
        MultiplierNotAllowedWhenBaseBidIsMissing = 6,
        NoMultiplierSpecified = 7,
        MultiplierCausesBidToExceedDailyBudget = 8,
        MultiplierCausesBidToExceedMonthlyBudget = 9,
        MultiplierCausesBidToExceedCustomBudget = 10,
        MultiplierCausesBidToExceedMaxAllowedBid = 11,
        BidLessThanMinAllowedBidWithMultiplier = 12,
        MultiplierAndBiddingStrategyTypeMismatch = 13,
    }
    impl MultiplierError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MultiplierError::Unspecified => "UNSPECIFIED",
                MultiplierError::Unknown => "UNKNOWN",
                MultiplierError::MultiplierTooHigh => "MULTIPLIER_TOO_HIGH",
                MultiplierError::MultiplierTooLow => "MULTIPLIER_TOO_LOW",
                MultiplierError::TooManyFractionalDigits => "TOO_MANY_FRACTIONAL_DIGITS",
                MultiplierError::MultiplierNotAllowedForBiddingStrategy => {
                    "MULTIPLIER_NOT_ALLOWED_FOR_BIDDING_STRATEGY"
                }
                MultiplierError::MultiplierNotAllowedWhenBaseBidIsMissing => {
                    "MULTIPLIER_NOT_ALLOWED_WHEN_BASE_BID_IS_MISSING"
                }
                MultiplierError::NoMultiplierSpecified => "NO_MULTIPLIER_SPECIFIED",
                MultiplierError::MultiplierCausesBidToExceedDailyBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_DAILY_BUDGET"
                }
                MultiplierError::MultiplierCausesBidToExceedMonthlyBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_MONTHLY_BUDGET"
                }
                MultiplierError::MultiplierCausesBidToExceedCustomBudget => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_CUSTOM_BUDGET"
                }
                MultiplierError::MultiplierCausesBidToExceedMaxAllowedBid => {
                    "MULTIPLIER_CAUSES_BID_TO_EXCEED_MAX_ALLOWED_BID"
                }
                MultiplierError::BidLessThanMinAllowedBidWithMultiplier => {
                    "BID_LESS_THAN_MIN_ALLOWED_BID_WITH_MULTIPLIER"
                }
                MultiplierError::MultiplierAndBiddingStrategyTypeMismatch => {
                    "MULTIPLIER_AND_BIDDING_STRATEGY_TYPE_MISMATCH"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MULTIPLIER_TOO_HIGH" => Some(Self::MultiplierTooHigh),
                "MULTIPLIER_TOO_LOW" => Some(Self::MultiplierTooLow),
                "TOO_MANY_FRACTIONAL_DIGITS" => Some(Self::TooManyFractionalDigits),
                "MULTIPLIER_NOT_ALLOWED_FOR_BIDDING_STRATEGY" => {
                    Some(Self::MultiplierNotAllowedForBiddingStrategy)
                }
                "MULTIPLIER_NOT_ALLOWED_WHEN_BASE_BID_IS_MISSING" => {
                    Some(Self::MultiplierNotAllowedWhenBaseBidIsMissing)
                }
                "NO_MULTIPLIER_SPECIFIED" => Some(Self::NoMultiplierSpecified),
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_DAILY_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedDailyBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_MONTHLY_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedMonthlyBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_CUSTOM_BUDGET" => {
                    Some(Self::MultiplierCausesBidToExceedCustomBudget)
                }
                "MULTIPLIER_CAUSES_BID_TO_EXCEED_MAX_ALLOWED_BID" => {
                    Some(Self::MultiplierCausesBidToExceedMaxAllowedBid)
                }
                "BID_LESS_THAN_MIN_ALLOWED_BID_WITH_MULTIPLIER" => {
                    Some(Self::BidLessThanMinAllowedBidWithMultiplier)
                }
                "MULTIPLIER_AND_BIDDING_STRATEGY_TYPE_MISMATCH" => {
                    Some(Self::MultiplierAndBiddingStrategyTypeMismatch)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NotEmptyErrorEnum {}
/// Nested message and enum types in `NotEmptyErrorEnum`.
pub mod not_empty_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NotEmptyError {
        Unspecified = 0,
        Unknown = 1,
        EmptyList = 2,
    }
    impl NotEmptyError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NotEmptyError::Unspecified => "UNSPECIFIED",
                NotEmptyError::Unknown => "UNKNOWN",
                NotEmptyError::EmptyList => "EMPTY_LIST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMPTY_LIST" => Some(Self::EmptyList),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobErrorEnum {}
/// Nested message and enum types in `OfflineUserDataJobErrorEnum`.
pub mod offline_user_data_job_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobError {
        Unspecified = 0,
        Unknown = 1,
        InvalidUserListId = 3,
        InvalidUserListType = 4,
        NotOnAllowlistForUserId = 33,
        IncompatibleUploadKeyType = 6,
        MissingUserIdentifier = 7,
        InvalidMobileIdFormat = 8,
        TooManyUserIdentifiers = 9,
        NotOnAllowlistForStoreSalesDirect = 31,
        NotOnAllowlistForUnifiedStoreSales = 32,
        InvalidPartnerId = 11,
        InvalidEncoding = 12,
        InvalidCountryCode = 13,
        IncompatibleUserIdentifier = 14,
        FutureTransactionTime = 15,
        InvalidConversionAction = 16,
        MobileIdNotSupported = 17,
        InvalidOperationOrder = 18,
        ConflictingOperation = 19,
        ExternalUpdateIdAlreadyExists = 21,
        JobAlreadyStarted = 22,
        RemoveNotSupported = 23,
        RemoveAllNotSupported = 24,
        InvalidSha256Format = 25,
        CustomKeyDisabled = 26,
        CustomKeyNotPredefined = 27,
        CustomKeyNotSet = 29,
        CustomerNotAcceptedCustomerDataTerms = 30,
        AttributesNotApplicableForCustomerMatchUserList = 34,
        LifetimeValueBucketNotInRange = 35,
        IncompatibleUserIdentifierForAttributes = 36,
        FutureTimeNotAllowed = 37,
        LastPurchaseTimeLessThanAcquisitionTime = 38,
        CustomerIdentifierNotAllowed = 39,
        InvalidItemId = 40,
        FirstPurchaseTimeGreaterThanLastPurchaseTime = 42,
        InvalidLifecycleStage = 43,
        InvalidEventValue = 44,
        EventAttributeAllFieldsAreRequired = 45,
    }
    impl OfflineUserDataJobError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineUserDataJobError::Unspecified => "UNSPECIFIED",
                OfflineUserDataJobError::Unknown => "UNKNOWN",
                OfflineUserDataJobError::InvalidUserListId => "INVALID_USER_LIST_ID",
                OfflineUserDataJobError::InvalidUserListType => "INVALID_USER_LIST_TYPE",
                OfflineUserDataJobError::NotOnAllowlistForUserId => {
                    "NOT_ON_ALLOWLIST_FOR_USER_ID"
                }
                OfflineUserDataJobError::IncompatibleUploadKeyType => {
                    "INCOMPATIBLE_UPLOAD_KEY_TYPE"
                }
                OfflineUserDataJobError::MissingUserIdentifier => {
                    "MISSING_USER_IDENTIFIER"
                }
                OfflineUserDataJobError::InvalidMobileIdFormat => {
                    "INVALID_MOBILE_ID_FORMAT"
                }
                OfflineUserDataJobError::TooManyUserIdentifiers => {
                    "TOO_MANY_USER_IDENTIFIERS"
                }
                OfflineUserDataJobError::NotOnAllowlistForStoreSalesDirect => {
                    "NOT_ON_ALLOWLIST_FOR_STORE_SALES_DIRECT"
                }
                OfflineUserDataJobError::NotOnAllowlistForUnifiedStoreSales => {
                    "NOT_ON_ALLOWLIST_FOR_UNIFIED_STORE_SALES"
                }
                OfflineUserDataJobError::InvalidPartnerId => "INVALID_PARTNER_ID",
                OfflineUserDataJobError::InvalidEncoding => "INVALID_ENCODING",
                OfflineUserDataJobError::InvalidCountryCode => "INVALID_COUNTRY_CODE",
                OfflineUserDataJobError::IncompatibleUserIdentifier => {
                    "INCOMPATIBLE_USER_IDENTIFIER"
                }
                OfflineUserDataJobError::FutureTransactionTime => {
                    "FUTURE_TRANSACTION_TIME"
                }
                OfflineUserDataJobError::InvalidConversionAction => {
                    "INVALID_CONVERSION_ACTION"
                }
                OfflineUserDataJobError::MobileIdNotSupported => {
                    "MOBILE_ID_NOT_SUPPORTED"
                }
                OfflineUserDataJobError::InvalidOperationOrder => {
                    "INVALID_OPERATION_ORDER"
                }
                OfflineUserDataJobError::ConflictingOperation => "CONFLICTING_OPERATION",
                OfflineUserDataJobError::ExternalUpdateIdAlreadyExists => {
                    "EXTERNAL_UPDATE_ID_ALREADY_EXISTS"
                }
                OfflineUserDataJobError::JobAlreadyStarted => "JOB_ALREADY_STARTED",
                OfflineUserDataJobError::RemoveNotSupported => "REMOVE_NOT_SUPPORTED",
                OfflineUserDataJobError::RemoveAllNotSupported => {
                    "REMOVE_ALL_NOT_SUPPORTED"
                }
                OfflineUserDataJobError::InvalidSha256Format => "INVALID_SHA256_FORMAT",
                OfflineUserDataJobError::CustomKeyDisabled => "CUSTOM_KEY_DISABLED",
                OfflineUserDataJobError::CustomKeyNotPredefined => {
                    "CUSTOM_KEY_NOT_PREDEFINED"
                }
                OfflineUserDataJobError::CustomKeyNotSet => "CUSTOM_KEY_NOT_SET",
                OfflineUserDataJobError::CustomerNotAcceptedCustomerDataTerms => {
                    "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS"
                }
                OfflineUserDataJobError::AttributesNotApplicableForCustomerMatchUserList => {
                    "ATTRIBUTES_NOT_APPLICABLE_FOR_CUSTOMER_MATCH_USER_LIST"
                }
                OfflineUserDataJobError::LifetimeValueBucketNotInRange => {
                    "LIFETIME_VALUE_BUCKET_NOT_IN_RANGE"
                }
                OfflineUserDataJobError::IncompatibleUserIdentifierForAttributes => {
                    "INCOMPATIBLE_USER_IDENTIFIER_FOR_ATTRIBUTES"
                }
                OfflineUserDataJobError::FutureTimeNotAllowed => {
                    "FUTURE_TIME_NOT_ALLOWED"
                }
                OfflineUserDataJobError::LastPurchaseTimeLessThanAcquisitionTime => {
                    "LAST_PURCHASE_TIME_LESS_THAN_ACQUISITION_TIME"
                }
                OfflineUserDataJobError::CustomerIdentifierNotAllowed => {
                    "CUSTOMER_IDENTIFIER_NOT_ALLOWED"
                }
                OfflineUserDataJobError::InvalidItemId => "INVALID_ITEM_ID",
                OfflineUserDataJobError::FirstPurchaseTimeGreaterThanLastPurchaseTime => {
                    "FIRST_PURCHASE_TIME_GREATER_THAN_LAST_PURCHASE_TIME"
                }
                OfflineUserDataJobError::InvalidLifecycleStage => {
                    "INVALID_LIFECYCLE_STAGE"
                }
                OfflineUserDataJobError::InvalidEventValue => "INVALID_EVENT_VALUE",
                OfflineUserDataJobError::EventAttributeAllFieldsAreRequired => {
                    "EVENT_ATTRIBUTE_ALL_FIELDS_ARE_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_USER_LIST_ID" => Some(Self::InvalidUserListId),
                "INVALID_USER_LIST_TYPE" => Some(Self::InvalidUserListType),
                "NOT_ON_ALLOWLIST_FOR_USER_ID" => Some(Self::NotOnAllowlistForUserId),
                "INCOMPATIBLE_UPLOAD_KEY_TYPE" => Some(Self::IncompatibleUploadKeyType),
                "MISSING_USER_IDENTIFIER" => Some(Self::MissingUserIdentifier),
                "INVALID_MOBILE_ID_FORMAT" => Some(Self::InvalidMobileIdFormat),
                "TOO_MANY_USER_IDENTIFIERS" => Some(Self::TooManyUserIdentifiers),
                "NOT_ON_ALLOWLIST_FOR_STORE_SALES_DIRECT" => {
                    Some(Self::NotOnAllowlistForStoreSalesDirect)
                }
                "NOT_ON_ALLOWLIST_FOR_UNIFIED_STORE_SALES" => {
                    Some(Self::NotOnAllowlistForUnifiedStoreSales)
                }
                "INVALID_PARTNER_ID" => Some(Self::InvalidPartnerId),
                "INVALID_ENCODING" => Some(Self::InvalidEncoding),
                "INVALID_COUNTRY_CODE" => Some(Self::InvalidCountryCode),
                "INCOMPATIBLE_USER_IDENTIFIER" => Some(Self::IncompatibleUserIdentifier),
                "FUTURE_TRANSACTION_TIME" => Some(Self::FutureTransactionTime),
                "INVALID_CONVERSION_ACTION" => Some(Self::InvalidConversionAction),
                "MOBILE_ID_NOT_SUPPORTED" => Some(Self::MobileIdNotSupported),
                "INVALID_OPERATION_ORDER" => Some(Self::InvalidOperationOrder),
                "CONFLICTING_OPERATION" => Some(Self::ConflictingOperation),
                "EXTERNAL_UPDATE_ID_ALREADY_EXISTS" => {
                    Some(Self::ExternalUpdateIdAlreadyExists)
                }
                "JOB_ALREADY_STARTED" => Some(Self::JobAlreadyStarted),
                "REMOVE_NOT_SUPPORTED" => Some(Self::RemoveNotSupported),
                "REMOVE_ALL_NOT_SUPPORTED" => Some(Self::RemoveAllNotSupported),
                "INVALID_SHA256_FORMAT" => Some(Self::InvalidSha256Format),
                "CUSTOM_KEY_DISABLED" => Some(Self::CustomKeyDisabled),
                "CUSTOM_KEY_NOT_PREDEFINED" => Some(Self::CustomKeyNotPredefined),
                "CUSTOM_KEY_NOT_SET" => Some(Self::CustomKeyNotSet),
                "CUSTOMER_NOT_ACCEPTED_CUSTOMER_DATA_TERMS" => {
                    Some(Self::CustomerNotAcceptedCustomerDataTerms)
                }
                "ATTRIBUTES_NOT_APPLICABLE_FOR_CUSTOMER_MATCH_USER_LIST" => {
                    Some(Self::AttributesNotApplicableForCustomerMatchUserList)
                }
                "LIFETIME_VALUE_BUCKET_NOT_IN_RANGE" => {
                    Some(Self::LifetimeValueBucketNotInRange)
                }
                "INCOMPATIBLE_USER_IDENTIFIER_FOR_ATTRIBUTES" => {
                    Some(Self::IncompatibleUserIdentifierForAttributes)
                }
                "FUTURE_TIME_NOT_ALLOWED" => Some(Self::FutureTimeNotAllowed),
                "LAST_PURCHASE_TIME_LESS_THAN_ACQUISITION_TIME" => {
                    Some(Self::LastPurchaseTimeLessThanAcquisitionTime)
                }
                "CUSTOMER_IDENTIFIER_NOT_ALLOWED" => {
                    Some(Self::CustomerIdentifierNotAllowed)
                }
                "INVALID_ITEM_ID" => Some(Self::InvalidItemId),
                "FIRST_PURCHASE_TIME_GREATER_THAN_LAST_PURCHASE_TIME" => {
                    Some(Self::FirstPurchaseTimeGreaterThanLastPurchaseTime)
                }
                "INVALID_LIFECYCLE_STAGE" => Some(Self::InvalidLifecycleStage),
                "INVALID_EVENT_VALUE" => Some(Self::InvalidEventValue),
                "EVENT_ATTRIBUTE_ALL_FIELDS_ARE_REQUIRED" => {
                    Some(Self::EventAttributeAllFieldsAreRequired)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PaymentsAccountErrorEnum {}
/// Nested message and enum types in `PaymentsAccountErrorEnum`.
pub mod payments_account_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentsAccountError {
        Unspecified = 0,
        Unknown = 1,
        NotSupportedForManagerCustomer = 2,
    }
    impl PaymentsAccountError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PaymentsAccountError::Unspecified => "UNSPECIFIED",
                PaymentsAccountError::Unknown => "UNKNOWN",
                PaymentsAccountError::NotSupportedForManagerCustomer => {
                    "NOT_SUPPORTED_FOR_MANAGER_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_SUPPORTED_FOR_MANAGER_CUSTOMER" => {
                    Some(Self::NotSupportedForManagerCustomer)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyFindingErrorEnum {}
/// Nested message and enum types in `PolicyFindingErrorEnum`.
pub mod policy_finding_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyFindingError {
        Unspecified = 0,
        Unknown = 1,
        PolicyFinding = 2,
        PolicyTopicNotFound = 3,
    }
    impl PolicyFindingError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyFindingError::Unspecified => "UNSPECIFIED",
                PolicyFindingError::Unknown => "UNKNOWN",
                PolicyFindingError::PolicyFinding => "POLICY_FINDING",
                PolicyFindingError::PolicyTopicNotFound => "POLICY_TOPIC_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "POLICY_FINDING" => Some(Self::PolicyFinding),
                "POLICY_TOPIC_NOT_FOUND" => Some(Self::PolicyTopicNotFound),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyValidationParameterErrorEnum {}
/// Nested message and enum types in `PolicyValidationParameterErrorEnum`.
pub mod policy_validation_parameter_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyValidationParameterError {
        Unspecified = 0,
        Unknown = 1,
        UnsupportedAdTypeForIgnorablePolicyTopics = 2,
        UnsupportedAdTypeForExemptPolicyViolationKeys = 3,
        CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys = 4,
    }
    impl PolicyValidationParameterError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyValidationParameterError::Unspecified => "UNSPECIFIED",
                PolicyValidationParameterError::Unknown => "UNKNOWN",
                PolicyValidationParameterError::UnsupportedAdTypeForIgnorablePolicyTopics => {
                    "UNSUPPORTED_AD_TYPE_FOR_IGNORABLE_POLICY_TOPICS"
                }
                PolicyValidationParameterError::UnsupportedAdTypeForExemptPolicyViolationKeys => {
                    "UNSUPPORTED_AD_TYPE_FOR_EXEMPT_POLICY_VIOLATION_KEYS"
                }
                PolicyValidationParameterError::CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys => {
                    "CANNOT_SET_BOTH_IGNORABLE_POLICY_TOPICS_AND_EXEMPT_POLICY_VIOLATION_KEYS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNSUPPORTED_AD_TYPE_FOR_IGNORABLE_POLICY_TOPICS" => {
                    Some(Self::UnsupportedAdTypeForIgnorablePolicyTopics)
                }
                "UNSUPPORTED_AD_TYPE_FOR_EXEMPT_POLICY_VIOLATION_KEYS" => {
                    Some(Self::UnsupportedAdTypeForExemptPolicyViolationKeys)
                }
                "CANNOT_SET_BOTH_IGNORABLE_POLICY_TOPICS_AND_EXEMPT_POLICY_VIOLATION_KEYS" => {
                    Some(
                        Self::CannotSetBothIgnorablePolicyTopicsAndExemptPolicyViolationKeys,
                    )
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyViolationErrorEnum {}
/// Nested message and enum types in `PolicyViolationErrorEnum`.
pub mod policy_violation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyViolationError {
        Unspecified = 0,
        Unknown = 1,
        PolicyError = 2,
    }
    impl PolicyViolationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyViolationError::Unspecified => "UNSPECIFIED",
                PolicyViolationError::Unknown => "UNKNOWN",
                PolicyViolationError::PolicyError => "POLICY_ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "POLICY_ERROR" => Some(Self::PolicyError),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkErrorEnum {}
/// Nested message and enum types in `ProductLinkErrorEnum`.
pub mod product_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkError {
        Unspecified = 0,
        Unknown = 1,
        InvalidOperation = 2,
        CreationNotPermitted = 3,
    }
    impl ProductLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductLinkError::Unspecified => "UNSPECIFIED",
                ProductLinkError::Unknown => "UNKNOWN",
                ProductLinkError::InvalidOperation => "INVALID_OPERATION",
                ProductLinkError::CreationNotPermitted => "CREATION_NOT_PERMITTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_OPERATION" => Some(Self::InvalidOperation),
                "CREATION_NOT_PERMITTED" => Some(Self::CreationNotPermitted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkInvitationErrorEnum {}
/// Nested message and enum types in `ProductLinkInvitationErrorEnum`.
pub mod product_link_invitation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkInvitationError {
        Unspecified = 0,
        Unknown = 1,
        InvalidStatus = 2,
        PermissionDenied = 3,
        NoInvitationRequired = 4,
    }
    impl ProductLinkInvitationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductLinkInvitationError::Unspecified => "UNSPECIFIED",
                ProductLinkInvitationError::Unknown => "UNKNOWN",
                ProductLinkInvitationError::InvalidStatus => "INVALID_STATUS",
                ProductLinkInvitationError::PermissionDenied => "PERMISSION_DENIED",
                ProductLinkInvitationError::NoInvitationRequired => {
                    "NO_INVITATION_REQUIRED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_STATUS" => Some(Self::InvalidStatus),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NO_INVITATION_REQUIRED" => Some(Self::NoInvitationRequired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryErrorEnum {}
/// Nested message and enum types in `QueryErrorEnum`.
pub mod query_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QueryError {
        Unspecified = 0,
        Unknown = 1,
        QueryError = 50,
        BadEnumConstant = 18,
        BadEscapeSequence = 7,
        BadFieldName = 12,
        BadLimitValue = 15,
        BadNumber = 5,
        BadOperator = 3,
        BadParameterName = 61,
        BadParameterValue = 62,
        BadResourceTypeInFromClause = 45,
        BadSymbol = 2,
        BadValue = 4,
        DateRangeTooWide = 36,
        DateRangeTooNarrow = 60,
        ExpectedAnd = 30,
        ExpectedBy = 14,
        ExpectedDimensionFieldInSelectClause = 37,
        ExpectedFiltersOnDateRange = 55,
        ExpectedFrom = 44,
        ExpectedList = 41,
        ExpectedReferencedFieldInSelectClause = 16,
        ExpectedSelect = 13,
        ExpectedSingleValue = 42,
        ExpectedValueWithBetweenOperator = 29,
        InvalidDateFormat = 38,
        MisalignedDateForFilter = 64,
        InvalidStringValue = 57,
        InvalidValueWithBetweenOperator = 26,
        InvalidValueWithDuringOperator = 22,
        InvalidValueWithLikeOperator = 56,
        OperatorFieldMismatch = 35,
        ProhibitedEmptyListInCondition = 28,
        ProhibitedEnumConstant = 54,
        ProhibitedFieldCombinationInSelectClause = 31,
        ProhibitedFieldInOrderByClause = 40,
        ProhibitedFieldInSelectClause = 23,
        ProhibitedFieldInWhereClause = 24,
        ProhibitedResourceTypeInFromClause = 43,
        ProhibitedResourceTypeInSelectClause = 48,
        ProhibitedResourceTypeInWhereClause = 58,
        ProhibitedMetricInSelectOrWhereClause = 49,
        ProhibitedSegmentInSelectOrWhereClause = 51,
        ProhibitedSegmentWithMetricInSelectOrWhereClause = 53,
        LimitValueTooLow = 25,
        ProhibitedNewlineInString = 8,
        ProhibitedValueCombinationInList = 10,
        ProhibitedValueCombinationWithBetweenOperator = 21,
        StringNotTerminated = 6,
        TooManySegments = 34,
        UnexpectedEndOfQuery = 9,
        UnexpectedFromClause = 47,
        UnrecognizedField = 32,
        UnexpectedInput = 11,
        RequestedMetricsForManager = 59,
        FilterHasTooManyValues = 63,
    }
    impl QueryError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QueryError::Unspecified => "UNSPECIFIED",
                QueryError::Unknown => "UNKNOWN",
                QueryError::QueryError => "QUERY_ERROR",
                QueryError::BadEnumConstant => "BAD_ENUM_CONSTANT",
                QueryError::BadEscapeSequence => "BAD_ESCAPE_SEQUENCE",
                QueryError::BadFieldName => "BAD_FIELD_NAME",
                QueryError::BadLimitValue => "BAD_LIMIT_VALUE",
                QueryError::BadNumber => "BAD_NUMBER",
                QueryError::BadOperator => "BAD_OPERATOR",
                QueryError::BadParameterName => "BAD_PARAMETER_NAME",
                QueryError::BadParameterValue => "BAD_PARAMETER_VALUE",
                QueryError::BadResourceTypeInFromClause => {
                    "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE"
                }
                QueryError::BadSymbol => "BAD_SYMBOL",
                QueryError::BadValue => "BAD_VALUE",
                QueryError::DateRangeTooWide => "DATE_RANGE_TOO_WIDE",
                QueryError::DateRangeTooNarrow => "DATE_RANGE_TOO_NARROW",
                QueryError::ExpectedAnd => "EXPECTED_AND",
                QueryError::ExpectedBy => "EXPECTED_BY",
                QueryError::ExpectedDimensionFieldInSelectClause => {
                    "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE"
                }
                QueryError::ExpectedFiltersOnDateRange => {
                    "EXPECTED_FILTERS_ON_DATE_RANGE"
                }
                QueryError::ExpectedFrom => "EXPECTED_FROM",
                QueryError::ExpectedList => "EXPECTED_LIST",
                QueryError::ExpectedReferencedFieldInSelectClause => {
                    "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE"
                }
                QueryError::ExpectedSelect => "EXPECTED_SELECT",
                QueryError::ExpectedSingleValue => "EXPECTED_SINGLE_VALUE",
                QueryError::ExpectedValueWithBetweenOperator => {
                    "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR"
                }
                QueryError::InvalidDateFormat => "INVALID_DATE_FORMAT",
                QueryError::MisalignedDateForFilter => "MISALIGNED_DATE_FOR_FILTER",
                QueryError::InvalidStringValue => "INVALID_STRING_VALUE",
                QueryError::InvalidValueWithBetweenOperator => {
                    "INVALID_VALUE_WITH_BETWEEN_OPERATOR"
                }
                QueryError::InvalidValueWithDuringOperator => {
                    "INVALID_VALUE_WITH_DURING_OPERATOR"
                }
                QueryError::InvalidValueWithLikeOperator => {
                    "INVALID_VALUE_WITH_LIKE_OPERATOR"
                }
                QueryError::OperatorFieldMismatch => "OPERATOR_FIELD_MISMATCH",
                QueryError::ProhibitedEmptyListInCondition => {
                    "PROHIBITED_EMPTY_LIST_IN_CONDITION"
                }
                QueryError::ProhibitedEnumConstant => "PROHIBITED_ENUM_CONSTANT",
                QueryError::ProhibitedFieldCombinationInSelectClause => {
                    "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE"
                }
                QueryError::ProhibitedFieldInOrderByClause => {
                    "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE"
                }
                QueryError::ProhibitedFieldInSelectClause => {
                    "PROHIBITED_FIELD_IN_SELECT_CLAUSE"
                }
                QueryError::ProhibitedFieldInWhereClause => {
                    "PROHIBITED_FIELD_IN_WHERE_CLAUSE"
                }
                QueryError::ProhibitedResourceTypeInFromClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE"
                }
                QueryError::ProhibitedResourceTypeInSelectClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE"
                }
                QueryError::ProhibitedResourceTypeInWhereClause => {
                    "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE"
                }
                QueryError::ProhibitedMetricInSelectOrWhereClause => {
                    "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::ProhibitedSegmentInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::ProhibitedSegmentWithMetricInSelectOrWhereClause => {
                    "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE"
                }
                QueryError::LimitValueTooLow => "LIMIT_VALUE_TOO_LOW",
                QueryError::ProhibitedNewlineInString => "PROHIBITED_NEWLINE_IN_STRING",
                QueryError::ProhibitedValueCombinationInList => {
                    "PROHIBITED_VALUE_COMBINATION_IN_LIST"
                }
                QueryError::ProhibitedValueCombinationWithBetweenOperator => {
                    "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR"
                }
                QueryError::StringNotTerminated => "STRING_NOT_TERMINATED",
                QueryError::TooManySegments => "TOO_MANY_SEGMENTS",
                QueryError::UnexpectedEndOfQuery => "UNEXPECTED_END_OF_QUERY",
                QueryError::UnexpectedFromClause => "UNEXPECTED_FROM_CLAUSE",
                QueryError::UnrecognizedField => "UNRECOGNIZED_FIELD",
                QueryError::UnexpectedInput => "UNEXPECTED_INPUT",
                QueryError::RequestedMetricsForManager => "REQUESTED_METRICS_FOR_MANAGER",
                QueryError::FilterHasTooManyValues => "FILTER_HAS_TOO_MANY_VALUES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "QUERY_ERROR" => Some(Self::QueryError),
                "BAD_ENUM_CONSTANT" => Some(Self::BadEnumConstant),
                "BAD_ESCAPE_SEQUENCE" => Some(Self::BadEscapeSequence),
                "BAD_FIELD_NAME" => Some(Self::BadFieldName),
                "BAD_LIMIT_VALUE" => Some(Self::BadLimitValue),
                "BAD_NUMBER" => Some(Self::BadNumber),
                "BAD_OPERATOR" => Some(Self::BadOperator),
                "BAD_PARAMETER_NAME" => Some(Self::BadParameterName),
                "BAD_PARAMETER_VALUE" => Some(Self::BadParameterValue),
                "BAD_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::BadResourceTypeInFromClause)
                }
                "BAD_SYMBOL" => Some(Self::BadSymbol),
                "BAD_VALUE" => Some(Self::BadValue),
                "DATE_RANGE_TOO_WIDE" => Some(Self::DateRangeTooWide),
                "DATE_RANGE_TOO_NARROW" => Some(Self::DateRangeTooNarrow),
                "EXPECTED_AND" => Some(Self::ExpectedAnd),
                "EXPECTED_BY" => Some(Self::ExpectedBy),
                "EXPECTED_DIMENSION_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedDimensionFieldInSelectClause)
                }
                "EXPECTED_FILTERS_ON_DATE_RANGE" => {
                    Some(Self::ExpectedFiltersOnDateRange)
                }
                "EXPECTED_FROM" => Some(Self::ExpectedFrom),
                "EXPECTED_LIST" => Some(Self::ExpectedList),
                "EXPECTED_REFERENCED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ExpectedReferencedFieldInSelectClause)
                }
                "EXPECTED_SELECT" => Some(Self::ExpectedSelect),
                "EXPECTED_SINGLE_VALUE" => Some(Self::ExpectedSingleValue),
                "EXPECTED_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ExpectedValueWithBetweenOperator)
                }
                "INVALID_DATE_FORMAT" => Some(Self::InvalidDateFormat),
                "MISALIGNED_DATE_FOR_FILTER" => Some(Self::MisalignedDateForFilter),
                "INVALID_STRING_VALUE" => Some(Self::InvalidStringValue),
                "INVALID_VALUE_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::InvalidValueWithBetweenOperator)
                }
                "INVALID_VALUE_WITH_DURING_OPERATOR" => {
                    Some(Self::InvalidValueWithDuringOperator)
                }
                "INVALID_VALUE_WITH_LIKE_OPERATOR" => {
                    Some(Self::InvalidValueWithLikeOperator)
                }
                "OPERATOR_FIELD_MISMATCH" => Some(Self::OperatorFieldMismatch),
                "PROHIBITED_EMPTY_LIST_IN_CONDITION" => {
                    Some(Self::ProhibitedEmptyListInCondition)
                }
                "PROHIBITED_ENUM_CONSTANT" => Some(Self::ProhibitedEnumConstant),
                "PROHIBITED_FIELD_COMBINATION_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldCombinationInSelectClause)
                }
                "PROHIBITED_FIELD_IN_ORDER_BY_CLAUSE" => {
                    Some(Self::ProhibitedFieldInOrderByClause)
                }
                "PROHIBITED_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedFieldInSelectClause)
                }
                "PROHIBITED_FIELD_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedFieldInWhereClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_FROM_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInFromClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_SELECT_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInSelectClause)
                }
                "PROHIBITED_RESOURCE_TYPE_IN_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedResourceTypeInWhereClause)
                }
                "PROHIBITED_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedMetricInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentInSelectOrWhereClause)
                }
                "PROHIBITED_SEGMENT_WITH_METRIC_IN_SELECT_OR_WHERE_CLAUSE" => {
                    Some(Self::ProhibitedSegmentWithMetricInSelectOrWhereClause)
                }
                "LIMIT_VALUE_TOO_LOW" => Some(Self::LimitValueTooLow),
                "PROHIBITED_NEWLINE_IN_STRING" => Some(Self::ProhibitedNewlineInString),
                "PROHIBITED_VALUE_COMBINATION_IN_LIST" => {
                    Some(Self::ProhibitedValueCombinationInList)
                }
                "PROHIBITED_VALUE_COMBINATION_WITH_BETWEEN_OPERATOR" => {
                    Some(Self::ProhibitedValueCombinationWithBetweenOperator)
                }
                "STRING_NOT_TERMINATED" => Some(Self::StringNotTerminated),
                "TOO_MANY_SEGMENTS" => Some(Self::TooManySegments),
                "UNEXPECTED_END_OF_QUERY" => Some(Self::UnexpectedEndOfQuery),
                "UNEXPECTED_FROM_CLAUSE" => Some(Self::UnexpectedFromClause),
                "UNRECOGNIZED_FIELD" => Some(Self::UnrecognizedField),
                "UNEXPECTED_INPUT" => Some(Self::UnexpectedInput),
                "REQUESTED_METRICS_FOR_MANAGER" => Some(Self::RequestedMetricsForManager),
                "FILTER_HAS_TOO_MANY_VALUES" => Some(Self::FilterHasTooManyValues),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanErrorEnum {}
/// Nested message and enum types in `ReachPlanErrorEnum`.
pub mod reach_plan_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanError {
        Unspecified = 0,
        Unknown = 1,
        NotForecastableMissingRate = 2,
        NotForecastableNotEnoughInventory = 3,
        NotForecastableAccountNotEnabled = 4,
    }
    impl ReachPlanError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReachPlanError::Unspecified => "UNSPECIFIED",
                ReachPlanError::Unknown => "UNKNOWN",
                ReachPlanError::NotForecastableMissingRate => {
                    "NOT_FORECASTABLE_MISSING_RATE"
                }
                ReachPlanError::NotForecastableNotEnoughInventory => {
                    "NOT_FORECASTABLE_NOT_ENOUGH_INVENTORY"
                }
                ReachPlanError::NotForecastableAccountNotEnabled => {
                    "NOT_FORECASTABLE_ACCOUNT_NOT_ENABLED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_FORECASTABLE_MISSING_RATE" => Some(Self::NotForecastableMissingRate),
                "NOT_FORECASTABLE_NOT_ENOUGH_INVENTORY" => {
                    Some(Self::NotForecastableNotEnoughInventory)
                }
                "NOT_FORECASTABLE_ACCOUNT_NOT_ENABLED" => {
                    Some(Self::NotForecastableAccountNotEnabled)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationErrorEnum {}
/// Nested message and enum types in `RecommendationErrorEnum`.
pub mod recommendation_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationError {
        Unspecified = 0,
        Unknown = 1,
        BudgetAmountTooSmall = 2,
        BudgetAmountTooLarge = 3,
        InvalidBudgetAmount = 4,
        PolicyError = 5,
        InvalidBidAmount = 6,
        AdgroupKeywordLimit = 7,
        RecommendationAlreadyApplied = 8,
        RecommendationInvalidated = 9,
        TooManyOperations = 10,
        NoOperations = 11,
        DifferentTypesNotSupported = 12,
        DuplicateResourceName = 13,
        RecommendationAlreadyDismissed = 14,
        InvalidApplyRequest = 15,
        RecommendationTypeApplyNotSupported = 17,
        InvalidMultiplier = 18,
    }
    impl RecommendationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecommendationError::Unspecified => "UNSPECIFIED",
                RecommendationError::Unknown => "UNKNOWN",
                RecommendationError::BudgetAmountTooSmall => "BUDGET_AMOUNT_TOO_SMALL",
                RecommendationError::BudgetAmountTooLarge => "BUDGET_AMOUNT_TOO_LARGE",
                RecommendationError::InvalidBudgetAmount => "INVALID_BUDGET_AMOUNT",
                RecommendationError::PolicyError => "POLICY_ERROR",
                RecommendationError::InvalidBidAmount => "INVALID_BID_AMOUNT",
                RecommendationError::AdgroupKeywordLimit => "ADGROUP_KEYWORD_LIMIT",
                RecommendationError::RecommendationAlreadyApplied => {
                    "RECOMMENDATION_ALREADY_APPLIED"
                }
                RecommendationError::RecommendationInvalidated => {
                    "RECOMMENDATION_INVALIDATED"
                }
                RecommendationError::TooManyOperations => "TOO_MANY_OPERATIONS",
                RecommendationError::NoOperations => "NO_OPERATIONS",
                RecommendationError::DifferentTypesNotSupported => {
                    "DIFFERENT_TYPES_NOT_SUPPORTED"
                }
                RecommendationError::DuplicateResourceName => "DUPLICATE_RESOURCE_NAME",
                RecommendationError::RecommendationAlreadyDismissed => {
                    "RECOMMENDATION_ALREADY_DISMISSED"
                }
                RecommendationError::InvalidApplyRequest => "INVALID_APPLY_REQUEST",
                RecommendationError::RecommendationTypeApplyNotSupported => {
                    "RECOMMENDATION_TYPE_APPLY_NOT_SUPPORTED"
                }
                RecommendationError::InvalidMultiplier => "INVALID_MULTIPLIER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUDGET_AMOUNT_TOO_SMALL" => Some(Self::BudgetAmountTooSmall),
                "BUDGET_AMOUNT_TOO_LARGE" => Some(Self::BudgetAmountTooLarge),
                "INVALID_BUDGET_AMOUNT" => Some(Self::InvalidBudgetAmount),
                "POLICY_ERROR" => Some(Self::PolicyError),
                "INVALID_BID_AMOUNT" => Some(Self::InvalidBidAmount),
                "ADGROUP_KEYWORD_LIMIT" => Some(Self::AdgroupKeywordLimit),
                "RECOMMENDATION_ALREADY_APPLIED" => {
                    Some(Self::RecommendationAlreadyApplied)
                }
                "RECOMMENDATION_INVALIDATED" => Some(Self::RecommendationInvalidated),
                "TOO_MANY_OPERATIONS" => Some(Self::TooManyOperations),
                "NO_OPERATIONS" => Some(Self::NoOperations),
                "DIFFERENT_TYPES_NOT_SUPPORTED" => Some(Self::DifferentTypesNotSupported),
                "DUPLICATE_RESOURCE_NAME" => Some(Self::DuplicateResourceName),
                "RECOMMENDATION_ALREADY_DISMISSED" => {
                    Some(Self::RecommendationAlreadyDismissed)
                }
                "INVALID_APPLY_REQUEST" => Some(Self::InvalidApplyRequest),
                "RECOMMENDATION_TYPE_APPLY_NOT_SUPPORTED" => {
                    Some(Self::RecommendationTypeApplyNotSupported)
                }
                "INVALID_MULTIPLIER" => Some(Self::InvalidMultiplier),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionErrorEnum {}
/// Nested message and enum types in `RecommendationSubscriptionErrorEnum`.
pub mod recommendation_subscription_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationSubscriptionError {
        Unspecified = 0,
        Unknown = 1,
    }
    impl RecommendationSubscriptionError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecommendationSubscriptionError::Unspecified => "UNSPECIFIED",
                RecommendationSubscriptionError::Unknown => "UNKNOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RequestErrorEnum {}
/// Nested message and enum types in `RequestErrorEnum`.
pub mod request_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RequestError {
        Unspecified = 0,
        Unknown = 1,
        ResourceNameMissing = 3,
        ResourceNameMalformed = 4,
        BadResourceId = 17,
        InvalidCustomerId = 16,
        OperationRequired = 5,
        ResourceNotFound = 6,
        InvalidPageToken = 7,
        ExpiredPageToken = 8,
        InvalidPageSize = 22,
        RequiredFieldMissing = 9,
        ImmutableField = 11,
        TooManyMutateOperations = 13,
        CannotBeExecutedByManagerAccount = 14,
        CannotModifyForeignField = 15,
        InvalidEnumValue = 18,
        DeveloperTokenParameterMissing = 19,
        LoginCustomerIdParameterMissing = 20,
        ValidateOnlyRequestHasPageToken = 21,
        CannotReturnSummaryRowForRequestWithoutMetrics = 29,
        CannotReturnSummaryRowForValidateOnlyRequests = 30,
        InconsistentReturnSummaryRowValue = 31,
        TotalResultsCountNotOriginallyRequested = 32,
        RpcDeadlineTooShort = 33,
        UnsupportedVersion = 38,
        CloudProjectNotFound = 39,
    }
    impl RequestError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RequestError::Unspecified => "UNSPECIFIED",
                RequestError::Unknown => "UNKNOWN",
                RequestError::ResourceNameMissing => "RESOURCE_NAME_MISSING",
                RequestError::ResourceNameMalformed => "RESOURCE_NAME_MALFORMED",
                RequestError::BadResourceId => "BAD_RESOURCE_ID",
                RequestError::InvalidCustomerId => "INVALID_CUSTOMER_ID",
                RequestError::OperationRequired => "OPERATION_REQUIRED",
                RequestError::ResourceNotFound => "RESOURCE_NOT_FOUND",
                RequestError::InvalidPageToken => "INVALID_PAGE_TOKEN",
                RequestError::ExpiredPageToken => "EXPIRED_PAGE_TOKEN",
                RequestError::InvalidPageSize => "INVALID_PAGE_SIZE",
                RequestError::RequiredFieldMissing => "REQUIRED_FIELD_MISSING",
                RequestError::ImmutableField => "IMMUTABLE_FIELD",
                RequestError::TooManyMutateOperations => "TOO_MANY_MUTATE_OPERATIONS",
                RequestError::CannotBeExecutedByManagerAccount => {
                    "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT"
                }
                RequestError::CannotModifyForeignField => "CANNOT_MODIFY_FOREIGN_FIELD",
                RequestError::InvalidEnumValue => "INVALID_ENUM_VALUE",
                RequestError::DeveloperTokenParameterMissing => {
                    "DEVELOPER_TOKEN_PARAMETER_MISSING"
                }
                RequestError::LoginCustomerIdParameterMissing => {
                    "LOGIN_CUSTOMER_ID_PARAMETER_MISSING"
                }
                RequestError::ValidateOnlyRequestHasPageToken => {
                    "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN"
                }
                RequestError::CannotReturnSummaryRowForRequestWithoutMetrics => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS"
                }
                RequestError::CannotReturnSummaryRowForValidateOnlyRequests => {
                    "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS"
                }
                RequestError::InconsistentReturnSummaryRowValue => {
                    "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE"
                }
                RequestError::TotalResultsCountNotOriginallyRequested => {
                    "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED"
                }
                RequestError::RpcDeadlineTooShort => "RPC_DEADLINE_TOO_SHORT",
                RequestError::UnsupportedVersion => "UNSUPPORTED_VERSION",
                RequestError::CloudProjectNotFound => "CLOUD_PROJECT_NOT_FOUND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE_NAME_MISSING" => Some(Self::ResourceNameMissing),
                "RESOURCE_NAME_MALFORMED" => Some(Self::ResourceNameMalformed),
                "BAD_RESOURCE_ID" => Some(Self::BadResourceId),
                "INVALID_CUSTOMER_ID" => Some(Self::InvalidCustomerId),
                "OPERATION_REQUIRED" => Some(Self::OperationRequired),
                "RESOURCE_NOT_FOUND" => Some(Self::ResourceNotFound),
                "INVALID_PAGE_TOKEN" => Some(Self::InvalidPageToken),
                "EXPIRED_PAGE_TOKEN" => Some(Self::ExpiredPageToken),
                "INVALID_PAGE_SIZE" => Some(Self::InvalidPageSize),
                "REQUIRED_FIELD_MISSING" => Some(Self::RequiredFieldMissing),
                "IMMUTABLE_FIELD" => Some(Self::ImmutableField),
                "TOO_MANY_MUTATE_OPERATIONS" => Some(Self::TooManyMutateOperations),
                "CANNOT_BE_EXECUTED_BY_MANAGER_ACCOUNT" => {
                    Some(Self::CannotBeExecutedByManagerAccount)
                }
                "CANNOT_MODIFY_FOREIGN_FIELD" => Some(Self::CannotModifyForeignField),
                "INVALID_ENUM_VALUE" => Some(Self::InvalidEnumValue),
                "DEVELOPER_TOKEN_PARAMETER_MISSING" => {
                    Some(Self::DeveloperTokenParameterMissing)
                }
                "LOGIN_CUSTOMER_ID_PARAMETER_MISSING" => {
                    Some(Self::LoginCustomerIdParameterMissing)
                }
                "VALIDATE_ONLY_REQUEST_HAS_PAGE_TOKEN" => {
                    Some(Self::ValidateOnlyRequestHasPageToken)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_REQUEST_WITHOUT_METRICS" => {
                    Some(Self::CannotReturnSummaryRowForRequestWithoutMetrics)
                }
                "CANNOT_RETURN_SUMMARY_ROW_FOR_VALIDATE_ONLY_REQUESTS" => {
                    Some(Self::CannotReturnSummaryRowForValidateOnlyRequests)
                }
                "INCONSISTENT_RETURN_SUMMARY_ROW_VALUE" => {
                    Some(Self::InconsistentReturnSummaryRowValue)
                }
                "TOTAL_RESULTS_COUNT_NOT_ORIGINALLY_REQUESTED" => {
                    Some(Self::TotalResultsCountNotOriginallyRequested)
                }
                "RPC_DEADLINE_TOO_SHORT" => Some(Self::RpcDeadlineTooShort),
                "UNSUPPORTED_VERSION" => Some(Self::UnsupportedVersion),
                "CLOUD_PROJECT_NOT_FOUND" => Some(Self::CloudProjectNotFound),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceCountLimitExceededErrorEnum {}
/// Nested message and enum types in `ResourceCountLimitExceededErrorEnum`.
pub mod resource_count_limit_exceeded_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceCountLimitExceededError {
        Unspecified = 0,
        Unknown = 1,
        AccountLimit = 2,
        CampaignLimit = 3,
        AdgroupLimit = 4,
        AdGroupAdLimit = 5,
        AdGroupCriterionLimit = 6,
        SharedSetLimit = 7,
        MatchingFunctionLimit = 8,
        ResponseRowLimitExceeded = 9,
        ResourceLimit = 10,
    }
    impl ResourceCountLimitExceededError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceCountLimitExceededError::Unspecified => "UNSPECIFIED",
                ResourceCountLimitExceededError::Unknown => "UNKNOWN",
                ResourceCountLimitExceededError::AccountLimit => "ACCOUNT_LIMIT",
                ResourceCountLimitExceededError::CampaignLimit => "CAMPAIGN_LIMIT",
                ResourceCountLimitExceededError::AdgroupLimit => "ADGROUP_LIMIT",
                ResourceCountLimitExceededError::AdGroupAdLimit => "AD_GROUP_AD_LIMIT",
                ResourceCountLimitExceededError::AdGroupCriterionLimit => {
                    "AD_GROUP_CRITERION_LIMIT"
                }
                ResourceCountLimitExceededError::SharedSetLimit => "SHARED_SET_LIMIT",
                ResourceCountLimitExceededError::MatchingFunctionLimit => {
                    "MATCHING_FUNCTION_LIMIT"
                }
                ResourceCountLimitExceededError::ResponseRowLimitExceeded => {
                    "RESPONSE_ROW_LIMIT_EXCEEDED"
                }
                ResourceCountLimitExceededError::ResourceLimit => "RESOURCE_LIMIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT_LIMIT" => Some(Self::AccountLimit),
                "CAMPAIGN_LIMIT" => Some(Self::CampaignLimit),
                "ADGROUP_LIMIT" => Some(Self::AdgroupLimit),
                "AD_GROUP_AD_LIMIT" => Some(Self::AdGroupAdLimit),
                "AD_GROUP_CRITERION_LIMIT" => Some(Self::AdGroupCriterionLimit),
                "SHARED_SET_LIMIT" => Some(Self::SharedSetLimit),
                "MATCHING_FUNCTION_LIMIT" => Some(Self::MatchingFunctionLimit),
                "RESPONSE_ROW_LIMIT_EXCEEDED" => Some(Self::ResponseRowLimitExceeded),
                "RESOURCE_LIMIT" => Some(Self::ResourceLimit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermInsightErrorEnum {}
/// Nested message and enum types in `SearchTermInsightErrorEnum`.
pub mod search_term_insight_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermInsightError {
        Unspecified = 0,
        Unknown = 1,
        FilteringNotAllowedWithSegments = 2,
        LimitNotAllowedWithSegments = 3,
        MissingFieldInSelectClause = 4,
        RequiresFilterBySingleResource = 5,
        SortingNotAllowedWithSegments = 6,
        SummaryRowNotAllowedWithSegments = 7,
    }
    impl SearchTermInsightError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchTermInsightError::Unspecified => "UNSPECIFIED",
                SearchTermInsightError::Unknown => "UNKNOWN",
                SearchTermInsightError::FilteringNotAllowedWithSegments => {
                    "FILTERING_NOT_ALLOWED_WITH_SEGMENTS"
                }
                SearchTermInsightError::LimitNotAllowedWithSegments => {
                    "LIMIT_NOT_ALLOWED_WITH_SEGMENTS"
                }
                SearchTermInsightError::MissingFieldInSelectClause => {
                    "MISSING_FIELD_IN_SELECT_CLAUSE"
                }
                SearchTermInsightError::RequiresFilterBySingleResource => {
                    "REQUIRES_FILTER_BY_SINGLE_RESOURCE"
                }
                SearchTermInsightError::SortingNotAllowedWithSegments => {
                    "SORTING_NOT_ALLOWED_WITH_SEGMENTS"
                }
                SearchTermInsightError::SummaryRowNotAllowedWithSegments => {
                    "SUMMARY_ROW_NOT_ALLOWED_WITH_SEGMENTS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FILTERING_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::FilteringNotAllowedWithSegments)
                }
                "LIMIT_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::LimitNotAllowedWithSegments)
                }
                "MISSING_FIELD_IN_SELECT_CLAUSE" => {
                    Some(Self::MissingFieldInSelectClause)
                }
                "REQUIRES_FILTER_BY_SINGLE_RESOURCE" => {
                    Some(Self::RequiresFilterBySingleResource)
                }
                "SORTING_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::SortingNotAllowedWithSegments)
                }
                "SUMMARY_ROW_NOT_ALLOWED_WITH_SEGMENTS" => {
                    Some(Self::SummaryRowNotAllowedWithSegments)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SizeLimitErrorEnum {}
/// Nested message and enum types in `SizeLimitErrorEnum`.
pub mod size_limit_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SizeLimitError {
        Unspecified = 0,
        Unknown = 1,
        RequestSizeLimitExceeded = 2,
        ResponseSizeLimitExceeded = 3,
    }
    impl SizeLimitError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SizeLimitError::Unspecified => "UNSPECIFIED",
                SizeLimitError::Unknown => "UNKNOWN",
                SizeLimitError::RequestSizeLimitExceeded => "REQUEST_SIZE_LIMIT_EXCEEDED",
                SizeLimitError::ResponseSizeLimitExceeded => {
                    "RESPONSE_SIZE_LIMIT_EXCEEDED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUEST_SIZE_LIMIT_EXCEEDED" => Some(Self::RequestSizeLimitExceeded),
                "RESPONSE_SIZE_LIMIT_EXCEEDED" => Some(Self::ResponseSizeLimitExceeded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignErrorEnum {}
/// Nested message and enum types in `SmartCampaignErrorEnum`.
pub mod smart_campaign_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignError {
        Unspecified = 0,
        Unknown = 1,
        InvalidBusinessLocationId = 2,
        InvalidCampaign = 3,
        BusinessNameOrBusinessLocationIdMissing = 4,
        RequiredSuggestionFieldMissing = 5,
        GeoTargetsRequired = 6,
        CannotDetermineSuggestionLocale = 7,
        FinalUrlNotCrawlable = 8,
    }
    impl SmartCampaignError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SmartCampaignError::Unspecified => "UNSPECIFIED",
                SmartCampaignError::Unknown => "UNKNOWN",
                SmartCampaignError::InvalidBusinessLocationId => {
                    "INVALID_BUSINESS_LOCATION_ID"
                }
                SmartCampaignError::InvalidCampaign => "INVALID_CAMPAIGN",
                SmartCampaignError::BusinessNameOrBusinessLocationIdMissing => {
                    "BUSINESS_NAME_OR_BUSINESS_LOCATION_ID_MISSING"
                }
                SmartCampaignError::RequiredSuggestionFieldMissing => {
                    "REQUIRED_SUGGESTION_FIELD_MISSING"
                }
                SmartCampaignError::GeoTargetsRequired => "GEO_TARGETS_REQUIRED",
                SmartCampaignError::CannotDetermineSuggestionLocale => {
                    "CANNOT_DETERMINE_SUGGESTION_LOCALE"
                }
                SmartCampaignError::FinalUrlNotCrawlable => "FINAL_URL_NOT_CRAWLABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_BUSINESS_LOCATION_ID" => Some(Self::InvalidBusinessLocationId),
                "INVALID_CAMPAIGN" => Some(Self::InvalidCampaign),
                "BUSINESS_NAME_OR_BUSINESS_LOCATION_ID_MISSING" => {
                    Some(Self::BusinessNameOrBusinessLocationIdMissing)
                }
                "REQUIRED_SUGGESTION_FIELD_MISSING" => {
                    Some(Self::RequiredSuggestionFieldMissing)
                }
                "GEO_TARGETS_REQUIRED" => Some(Self::GeoTargetsRequired),
                "CANNOT_DETERMINE_SUGGESTION_LOCALE" => {
                    Some(Self::CannotDetermineSuggestionLocale)
                }
                "FINAL_URL_NOT_CRAWLABLE" => Some(Self::FinalUrlNotCrawlable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ThirdPartyAppAnalyticsLinkErrorEnum {}
/// Nested message and enum types in `ThirdPartyAppAnalyticsLinkErrorEnum`.
pub mod third_party_app_analytics_link_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ThirdPartyAppAnalyticsLinkError {
        Unspecified = 0,
        Unknown = 1,
        InvalidAnalyticsProviderId = 2,
        InvalidMobileAppId = 3,
        MobileAppIsNotEnabled = 4,
        CannotRegenerateShareableLinkIdForRemovedLink = 5,
    }
    impl ThirdPartyAppAnalyticsLinkError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ThirdPartyAppAnalyticsLinkError::Unspecified => "UNSPECIFIED",
                ThirdPartyAppAnalyticsLinkError::Unknown => "UNKNOWN",
                ThirdPartyAppAnalyticsLinkError::InvalidAnalyticsProviderId => {
                    "INVALID_ANALYTICS_PROVIDER_ID"
                }
                ThirdPartyAppAnalyticsLinkError::InvalidMobileAppId => {
                    "INVALID_MOBILE_APP_ID"
                }
                ThirdPartyAppAnalyticsLinkError::MobileAppIsNotEnabled => {
                    "MOBILE_APP_IS_NOT_ENABLED"
                }
                ThirdPartyAppAnalyticsLinkError::CannotRegenerateShareableLinkIdForRemovedLink => {
                    "CANNOT_REGENERATE_SHAREABLE_LINK_ID_FOR_REMOVED_LINK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INVALID_ANALYTICS_PROVIDER_ID" => Some(Self::InvalidAnalyticsProviderId),
                "INVALID_MOBILE_APP_ID" => Some(Self::InvalidMobileAppId),
                "MOBILE_APP_IS_NOT_ENABLED" => Some(Self::MobileAppIsNotEnabled),
                "CANNOT_REGENERATE_SHAREABLE_LINK_ID_FOR_REMOVED_LINK" => {
                    Some(Self::CannotRegenerateShareableLinkIdForRemovedLink)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserDataErrorEnum {}
/// Nested message and enum types in `UserDataErrorEnum`.
pub mod user_data_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserDataError {
        Unspecified = 0,
        Unknown = 1,
        OperationsForCustomerMatchNotAllowed = 2,
        TooManyUserIdentifiers = 3,
        UserListNotApplicable = 4,
    }
    impl UserDataError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserDataError::Unspecified => "UNSPECIFIED",
                UserDataError::Unknown => "UNKNOWN",
                UserDataError::OperationsForCustomerMatchNotAllowed => {
                    "OPERATIONS_FOR_CUSTOMER_MATCH_NOT_ALLOWED"
                }
                UserDataError::TooManyUserIdentifiers => "TOO_MANY_USER_IDENTIFIERS",
                UserDataError::UserListNotApplicable => "USER_LIST_NOT_APPLICABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPERATIONS_FOR_CUSTOMER_MATCH_NOT_ALLOWED" => {
                    Some(Self::OperationsForCustomerMatchNotAllowed)
                }
                "TOO_MANY_USER_IDENTIFIERS" => Some(Self::TooManyUserIdentifiers),
                "USER_LIST_NOT_APPLICABLE" => Some(Self::UserListNotApplicable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct YoutubeVideoRegistrationErrorEnum {}
/// Nested message and enum types in `YoutubeVideoRegistrationErrorEnum`.
pub mod youtube_video_registration_error_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum YoutubeVideoRegistrationError {
        Unspecified = 0,
        Unknown = 1,
        VideoNotFound = 2,
        VideoNotAccessible = 3,
        VideoNotEligible = 4,
    }
    impl YoutubeVideoRegistrationError {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                YoutubeVideoRegistrationError::Unspecified => "UNSPECIFIED",
                YoutubeVideoRegistrationError::Unknown => "UNKNOWN",
                YoutubeVideoRegistrationError::VideoNotFound => "VIDEO_NOT_FOUND",
                YoutubeVideoRegistrationError::VideoNotAccessible => {
                    "VIDEO_NOT_ACCESSIBLE"
                }
                YoutubeVideoRegistrationError::VideoNotEligible => "VIDEO_NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VIDEO_NOT_FOUND" => Some(Self::VideoNotFound),
                "VIDEO_NOT_ACCESSIBLE" => Some(Self::VideoNotAccessible),
                "VIDEO_NOT_ELIGIBLE" => Some(Self::VideoNotEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsFailure {
    #[prost(message, repeated, tag = "1")]
    pub errors: ::prost::alloc::vec::Vec<GoogleAdsError>,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsError {
    #[prost(message, optional, tag = "1")]
    pub error_code: ::core::option::Option<ErrorCode>,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub trigger: ::core::option::Option<super::common::Value>,
    #[prost(message, optional, tag = "4")]
    pub location: ::core::option::Option<ErrorLocation>,
    #[prost(message, optional, tag = "5")]
    pub details: ::core::option::Option<ErrorDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ErrorCode {
    #[prost(
        oneof = "error_code::ErrorCode",
        tags = "1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 161, 18, 159, 19, 21, 24, 25, 107, 149, 155, 148, 153, 154, 152, 26, 29, 166, 160, 31, 165, 109, 32, 150, 158, 90, 151, 33, 34, 35, 36, 37, 38, 39, 40, 110, 42, 116, 86, 162, 44, 45, 46, 47, 48, 49, 58, 180, 51, 52, 53, 54, 55, 56, 57, 117, 59, 60, 61, 62, 63, 64, 65, 115, 143, 111, 145, 146, 66, 67, 68, 70, 71, 72, 132, 74, 133, 76, 77, 78, 136, 79, 80, 81, 82, 83, 84, 87, 88, 91, 92, 93, 94, 96, 97, 98, 100, 101, 102, 103, 140, 141, 104, 105, 112, 114, 118, 119, 137, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 134, 135, 138, 139, 164, 174, 147, 156, 167, 169, 170, 171, 176, 177, 178, 179"
    )]
    pub error_code: ::core::option::Option<error_code::ErrorCode>,
}
/// Nested message and enum types in `ErrorCode`.
pub mod error_code {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum ErrorCode {
        #[prost(enumeration = "super::request_error_enum::RequestError", tag = "1")]
        RequestError(i32),
        #[prost(
            enumeration = "super::bidding_strategy_error_enum::BiddingStrategyError",
            tag = "2"
        )]
        BiddingStrategyError(i32),
        #[prost(enumeration = "super::url_field_error_enum::UrlFieldError", tag = "3")]
        UrlFieldError(i32),
        #[prost(
            enumeration = "super::list_operation_error_enum::ListOperationError",
            tag = "4"
        )]
        ListOperationError(i32),
        #[prost(enumeration = "super::query_error_enum::QueryError", tag = "5")]
        QueryError(i32),
        #[prost(enumeration = "super::mutate_error_enum::MutateError", tag = "7")]
        MutateError(i32),
        #[prost(enumeration = "super::field_mask_error_enum::FieldMaskError", tag = "8")]
        FieldMaskError(i32),
        #[prost(
            enumeration = "super::authorization_error_enum::AuthorizationError",
            tag = "9"
        )]
        AuthorizationError(i32),
        #[prost(enumeration = "super::internal_error_enum::InternalError", tag = "10")]
        InternalError(i32),
        #[prost(enumeration = "super::quota_error_enum::QuotaError", tag = "11")]
        QuotaError(i32),
        #[prost(enumeration = "super::ad_error_enum::AdError", tag = "12")]
        AdError(i32),
        #[prost(enumeration = "super::ad_group_error_enum::AdGroupError", tag = "13")]
        AdGroupError(i32),
        #[prost(
            enumeration = "super::campaign_budget_error_enum::CampaignBudgetError",
            tag = "14"
        )]
        CampaignBudgetError(i32),
        #[prost(enumeration = "super::campaign_error_enum::CampaignError", tag = "15")]
        CampaignError(i32),
        #[prost(
            enumeration = "super::authentication_error_enum::AuthenticationError",
            tag = "17"
        )]
        AuthenticationError(i32),
        #[prost(
            enumeration = "super::ad_group_criterion_customizer_error_enum::AdGroupCriterionCustomizerError",
            tag = "161"
        )]
        AdGroupCriterionCustomizerError(i32),
        #[prost(
            enumeration = "super::ad_group_criterion_error_enum::AdGroupCriterionError",
            tag = "18"
        )]
        AdGroupCriterionError(i32),
        #[prost(
            enumeration = "super::ad_group_customizer_error_enum::AdGroupCustomizerError",
            tag = "159"
        )]
        AdGroupCustomizerError(i32),
        #[prost(
            enumeration = "super::ad_customizer_error_enum::AdCustomizerError",
            tag = "19"
        )]
        AdCustomizerError(i32),
        #[prost(
            enumeration = "super::ad_group_ad_error_enum::AdGroupAdError",
            tag = "21"
        )]
        AdGroupAdError(i32),
        #[prost(
            enumeration = "super::ad_sharing_error_enum::AdSharingError",
            tag = "24"
        )]
        AdSharingError(i32),
        #[prost(enumeration = "super::adx_error_enum::AdxError", tag = "25")]
        AdxError(i32),
        #[prost(enumeration = "super::asset_error_enum::AssetError", tag = "107")]
        AssetError(i32),
        #[prost(
            enumeration = "super::asset_group_asset_error_enum::AssetGroupAssetError",
            tag = "149"
        )]
        AssetGroupAssetError(i32),
        #[prost(
            enumeration = "super::asset_group_listing_group_filter_error_enum::AssetGroupListingGroupFilterError",
            tag = "155"
        )]
        AssetGroupListingGroupFilterError(i32),
        #[prost(
            enumeration = "super::asset_group_error_enum::AssetGroupError",
            tag = "148"
        )]
        AssetGroupError(i32),
        #[prost(
            enumeration = "super::asset_set_asset_error_enum::AssetSetAssetError",
            tag = "153"
        )]
        AssetSetAssetError(i32),
        #[prost(
            enumeration = "super::asset_set_link_error_enum::AssetSetLinkError",
            tag = "154"
        )]
        AssetSetLinkError(i32),
        #[prost(enumeration = "super::asset_set_error_enum::AssetSetError", tag = "152")]
        AssetSetError(i32),
        #[prost(enumeration = "super::bidding_error_enum::BiddingError", tag = "26")]
        BiddingError(i32),
        #[prost(
            enumeration = "super::campaign_criterion_error_enum::CampaignCriterionError",
            tag = "29"
        )]
        CampaignCriterionError(i32),
        #[prost(
            enumeration = "super::campaign_conversion_goal_error_enum::CampaignConversionGoalError",
            tag = "166"
        )]
        CampaignConversionGoalError(i32),
        #[prost(
            enumeration = "super::campaign_customizer_error_enum::CampaignCustomizerError",
            tag = "160"
        )]
        CampaignCustomizerError(i32),
        #[prost(
            enumeration = "super::collection_size_error_enum::CollectionSizeError",
            tag = "31"
        )]
        CollectionSizeError(i32),
        #[prost(
            enumeration = "super::conversion_goal_campaign_config_error_enum::ConversionGoalCampaignConfigError",
            tag = "165"
        )]
        ConversionGoalCampaignConfigError(i32),
        #[prost(
            enumeration = "super::country_code_error_enum::CountryCodeError",
            tag = "109"
        )]
        CountryCodeError(i32),
        #[prost(enumeration = "super::criterion_error_enum::CriterionError", tag = "32")]
        CriterionError(i32),
        #[prost(
            enumeration = "super::custom_conversion_goal_error_enum::CustomConversionGoalError",
            tag = "150"
        )]
        CustomConversionGoalError(i32),
        #[prost(
            enumeration = "super::customer_customizer_error_enum::CustomerCustomizerError",
            tag = "158"
        )]
        CustomerCustomizerError(i32),
        #[prost(enumeration = "super::customer_error_enum::CustomerError", tag = "90")]
        CustomerError(i32),
        #[prost(
            enumeration = "super::customizer_attribute_error_enum::CustomizerAttributeError",
            tag = "151"
        )]
        CustomizerAttributeError(i32),
        #[prost(enumeration = "super::date_error_enum::DateError", tag = "33")]
        DateError(i32),
        #[prost(
            enumeration = "super::date_range_error_enum::DateRangeError",
            tag = "34"
        )]
        DateRangeError(i32),
        #[prost(enumeration = "super::distinct_error_enum::DistinctError", tag = "35")]
        DistinctError(i32),
        #[prost(
            enumeration = "super::feed_attribute_reference_error_enum::FeedAttributeReferenceError",
            tag = "36"
        )]
        FeedAttributeReferenceError(i32),
        #[prost(enumeration = "super::function_error_enum::FunctionError", tag = "37")]
        FunctionError(i32),
        #[prost(
            enumeration = "super::function_parsing_error_enum::FunctionParsingError",
            tag = "38"
        )]
        FunctionParsingError(i32),
        #[prost(enumeration = "super::id_error_enum::IdError", tag = "39")]
        IdError(i32),
        #[prost(enumeration = "super::image_error_enum::ImageError", tag = "40")]
        ImageError(i32),
        #[prost(
            enumeration = "super::language_code_error_enum::LanguageCodeError",
            tag = "110"
        )]
        LanguageCodeError(i32),
        #[prost(
            enumeration = "super::media_bundle_error_enum::MediaBundleError",
            tag = "42"
        )]
        MediaBundleError(i32),
        #[prost(
            enumeration = "super::media_upload_error_enum::MediaUploadError",
            tag = "116"
        )]
        MediaUploadError(i32),
        #[prost(
            enumeration = "super::media_file_error_enum::MediaFileError",
            tag = "86"
        )]
        MediaFileError(i32),
        #[prost(
            enumeration = "super::merchant_center_error_enum::MerchantCenterError",
            tag = "162"
        )]
        MerchantCenterError(i32),
        #[prost(
            enumeration = "super::multiplier_error_enum::MultiplierError",
            tag = "44"
        )]
        MultiplierError(i32),
        #[prost(
            enumeration = "super::new_resource_creation_error_enum::NewResourceCreationError",
            tag = "45"
        )]
        NewResourceCreationError(i32),
        #[prost(enumeration = "super::not_empty_error_enum::NotEmptyError", tag = "46")]
        NotEmptyError(i32),
        #[prost(enumeration = "super::null_error_enum::NullError", tag = "47")]
        NullError(i32),
        #[prost(enumeration = "super::operator_error_enum::OperatorError", tag = "48")]
        OperatorError(i32),
        #[prost(enumeration = "super::range_error_enum::RangeError", tag = "49")]
        RangeError(i32),
        #[prost(
            enumeration = "super::recommendation_error_enum::RecommendationError",
            tag = "58"
        )]
        RecommendationError(i32),
        #[prost(
            enumeration = "super::recommendation_subscription_error_enum::RecommendationSubscriptionError",
            tag = "180"
        )]
        RecommendationSubscriptionError(i32),
        #[prost(
            enumeration = "super::region_code_error_enum::RegionCodeError",
            tag = "51"
        )]
        RegionCodeError(i32),
        #[prost(enumeration = "super::setting_error_enum::SettingError", tag = "52")]
        SettingError(i32),
        #[prost(
            enumeration = "super::string_format_error_enum::StringFormatError",
            tag = "53"
        )]
        StringFormatError(i32),
        #[prost(
            enumeration = "super::string_length_error_enum::StringLengthError",
            tag = "54"
        )]
        StringLengthError(i32),
        #[prost(
            enumeration = "super::operation_access_denied_error_enum::OperationAccessDeniedError",
            tag = "55"
        )]
        OperationAccessDeniedError(i32),
        #[prost(
            enumeration = "super::resource_access_denied_error_enum::ResourceAccessDeniedError",
            tag = "56"
        )]
        ResourceAccessDeniedError(i32),
        #[prost(
            enumeration = "super::resource_count_limit_exceeded_error_enum::ResourceCountLimitExceededError",
            tag = "57"
        )]
        ResourceCountLimitExceededError(i32),
        #[prost(
            enumeration = "super::youtube_video_registration_error_enum::YoutubeVideoRegistrationError",
            tag = "117"
        )]
        YoutubeVideoRegistrationError(i32),
        #[prost(
            enumeration = "super::ad_group_bid_modifier_error_enum::AdGroupBidModifierError",
            tag = "59"
        )]
        AdGroupBidModifierError(i32),
        #[prost(enumeration = "super::context_error_enum::ContextError", tag = "60")]
        ContextError(i32),
        #[prost(enumeration = "super::field_error_enum::FieldError", tag = "61")]
        FieldError(i32),
        #[prost(
            enumeration = "super::shared_set_error_enum::SharedSetError",
            tag = "62"
        )]
        SharedSetError(i32),
        #[prost(
            enumeration = "super::shared_criterion_error_enum::SharedCriterionError",
            tag = "63"
        )]
        SharedCriterionError(i32),
        #[prost(
            enumeration = "super::campaign_shared_set_error_enum::CampaignSharedSetError",
            tag = "64"
        )]
        CampaignSharedSetError(i32),
        #[prost(
            enumeration = "super::conversion_action_error_enum::ConversionActionError",
            tag = "65"
        )]
        ConversionActionError(i32),
        #[prost(
            enumeration = "super::conversion_adjustment_upload_error_enum::ConversionAdjustmentUploadError",
            tag = "115"
        )]
        ConversionAdjustmentUploadError(i32),
        #[prost(
            enumeration = "super::conversion_custom_variable_error_enum::ConversionCustomVariableError",
            tag = "143"
        )]
        ConversionCustomVariableError(i32),
        #[prost(
            enumeration = "super::conversion_upload_error_enum::ConversionUploadError",
            tag = "111"
        )]
        ConversionUploadError(i32),
        #[prost(
            enumeration = "super::conversion_value_rule_error_enum::ConversionValueRuleError",
            tag = "145"
        )]
        ConversionValueRuleError(i32),
        #[prost(
            enumeration = "super::conversion_value_rule_set_error_enum::ConversionValueRuleSetError",
            tag = "146"
        )]
        ConversionValueRuleSetError(i32),
        #[prost(enumeration = "super::header_error_enum::HeaderError", tag = "66")]
        HeaderError(i32),
        #[prost(enumeration = "super::database_error_enum::DatabaseError", tag = "67")]
        DatabaseError(i32),
        #[prost(
            enumeration = "super::policy_finding_error_enum::PolicyFindingError",
            tag = "68"
        )]
        PolicyFindingError(i32),
        #[prost(enumeration = "super::enum_error_enum::EnumError", tag = "70")]
        EnumError(i32),
        #[prost(
            enumeration = "super::keyword_plan_error_enum::KeywordPlanError",
            tag = "71"
        )]
        KeywordPlanError(i32),
        #[prost(
            enumeration = "super::keyword_plan_campaign_error_enum::KeywordPlanCampaignError",
            tag = "72"
        )]
        KeywordPlanCampaignError(i32),
        #[prost(
            enumeration = "super::keyword_plan_campaign_keyword_error_enum::KeywordPlanCampaignKeywordError",
            tag = "132"
        )]
        KeywordPlanCampaignKeywordError(i32),
        #[prost(
            enumeration = "super::keyword_plan_ad_group_error_enum::KeywordPlanAdGroupError",
            tag = "74"
        )]
        KeywordPlanAdGroupError(i32),
        #[prost(
            enumeration = "super::keyword_plan_ad_group_keyword_error_enum::KeywordPlanAdGroupKeywordError",
            tag = "133"
        )]
        KeywordPlanAdGroupKeywordError(i32),
        #[prost(
            enumeration = "super::keyword_plan_idea_error_enum::KeywordPlanIdeaError",
            tag = "76"
        )]
        KeywordPlanIdeaError(i32),
        #[prost(
            enumeration = "super::account_budget_proposal_error_enum::AccountBudgetProposalError",
            tag = "77"
        )]
        AccountBudgetProposalError(i32),
        #[prost(enumeration = "super::user_list_error_enum::UserListError", tag = "78")]
        UserListError(i32),
        #[prost(
            enumeration = "super::change_event_error_enum::ChangeEventError",
            tag = "136"
        )]
        ChangeEventError(i32),
        #[prost(
            enumeration = "super::change_status_error_enum::ChangeStatusError",
            tag = "79"
        )]
        ChangeStatusError(i32),
        #[prost(enumeration = "super::feed_error_enum::FeedError", tag = "80")]
        FeedError(i32),
        #[prost(
            enumeration = "super::geo_target_constant_suggestion_error_enum::GeoTargetConstantSuggestionError",
            tag = "81"
        )]
        GeoTargetConstantSuggestionError(i32),
        #[prost(
            enumeration = "super::campaign_draft_error_enum::CampaignDraftError",
            tag = "82"
        )]
        CampaignDraftError(i32),
        #[prost(enumeration = "super::feed_item_error_enum::FeedItemError", tag = "83")]
        FeedItemError(i32),
        #[prost(enumeration = "super::label_error_enum::LabelError", tag = "84")]
        LabelError(i32),
        #[prost(
            enumeration = "super::billing_setup_error_enum::BillingSetupError",
            tag = "87"
        )]
        BillingSetupError(i32),
        #[prost(
            enumeration = "super::customer_client_link_error_enum::CustomerClientLinkError",
            tag = "88"
        )]
        CustomerClientLinkError(i32),
        #[prost(
            enumeration = "super::customer_manager_link_error_enum::CustomerManagerLinkError",
            tag = "91"
        )]
        CustomerManagerLinkError(i32),
        #[prost(
            enumeration = "super::feed_mapping_error_enum::FeedMappingError",
            tag = "92"
        )]
        FeedMappingError(i32),
        #[prost(
            enumeration = "super::customer_feed_error_enum::CustomerFeedError",
            tag = "93"
        )]
        CustomerFeedError(i32),
        #[prost(
            enumeration = "super::ad_group_feed_error_enum::AdGroupFeedError",
            tag = "94"
        )]
        AdGroupFeedError(i32),
        #[prost(
            enumeration = "super::campaign_feed_error_enum::CampaignFeedError",
            tag = "96"
        )]
        CampaignFeedError(i32),
        #[prost(
            enumeration = "super::custom_interest_error_enum::CustomInterestError",
            tag = "97"
        )]
        CustomInterestError(i32),
        #[prost(
            enumeration = "super::campaign_experiment_error_enum::CampaignExperimentError",
            tag = "98"
        )]
        CampaignExperimentError(i32),
        #[prost(
            enumeration = "super::extension_feed_item_error_enum::ExtensionFeedItemError",
            tag = "100"
        )]
        ExtensionFeedItemError(i32),
        #[prost(
            enumeration = "super::ad_parameter_error_enum::AdParameterError",
            tag = "101"
        )]
        AdParameterError(i32),
        #[prost(
            enumeration = "super::feed_item_validation_error_enum::FeedItemValidationError",
            tag = "102"
        )]
        FeedItemValidationError(i32),
        #[prost(
            enumeration = "super::extension_setting_error_enum::ExtensionSettingError",
            tag = "103"
        )]
        ExtensionSettingError(i32),
        #[prost(
            enumeration = "super::feed_item_set_error_enum::FeedItemSetError",
            tag = "140"
        )]
        FeedItemSetError(i32),
        #[prost(
            enumeration = "super::feed_item_set_link_error_enum::FeedItemSetLinkError",
            tag = "141"
        )]
        FeedItemSetLinkError(i32),
        #[prost(
            enumeration = "super::feed_item_target_error_enum::FeedItemTargetError",
            tag = "104"
        )]
        FeedItemTargetError(i32),
        #[prost(
            enumeration = "super::policy_violation_error_enum::PolicyViolationError",
            tag = "105"
        )]
        PolicyViolationError(i32),
        #[prost(
            enumeration = "super::partial_failure_error_enum::PartialFailureError",
            tag = "112"
        )]
        PartialFailureError(i32),
        #[prost(
            enumeration = "super::policy_validation_parameter_error_enum::PolicyValidationParameterError",
            tag = "114"
        )]
        PolicyValidationParameterError(i32),
        #[prost(
            enumeration = "super::size_limit_error_enum::SizeLimitError",
            tag = "118"
        )]
        SizeLimitError(i32),
        #[prost(
            enumeration = "super::offline_user_data_job_error_enum::OfflineUserDataJobError",
            tag = "119"
        )]
        OfflineUserDataJobError(i32),
        #[prost(
            enumeration = "super::not_allowlisted_error_enum::NotAllowlistedError",
            tag = "137"
        )]
        NotAllowlistedError(i32),
        #[prost(
            enumeration = "super::manager_link_error_enum::ManagerLinkError",
            tag = "121"
        )]
        ManagerLinkError(i32),
        #[prost(
            enumeration = "super::currency_code_error_enum::CurrencyCodeError",
            tag = "122"
        )]
        CurrencyCodeError(i32),
        #[prost(
            enumeration = "super::experiment_error_enum::ExperimentError",
            tag = "123"
        )]
        ExperimentError(i32),
        #[prost(
            enumeration = "super::access_invitation_error_enum::AccessInvitationError",
            tag = "124"
        )]
        AccessInvitationError(i32),
        #[prost(
            enumeration = "super::reach_plan_error_enum::ReachPlanError",
            tag = "125"
        )]
        ReachPlanError(i32),
        #[prost(enumeration = "super::invoice_error_enum::InvoiceError", tag = "126")]
        InvoiceError(i32),
        #[prost(
            enumeration = "super::payments_account_error_enum::PaymentsAccountError",
            tag = "127"
        )]
        PaymentsAccountError(i32),
        #[prost(enumeration = "super::time_zone_error_enum::TimeZoneError", tag = "128")]
        TimeZoneError(i32),
        #[prost(
            enumeration = "super::asset_link_error_enum::AssetLinkError",
            tag = "129"
        )]
        AssetLinkError(i32),
        #[prost(enumeration = "super::user_data_error_enum::UserDataError", tag = "130")]
        UserDataError(i32),
        #[prost(enumeration = "super::batch_job_error_enum::BatchJobError", tag = "131")]
        BatchJobError(i32),
        #[prost(
            enumeration = "super::account_link_error_enum::AccountLinkError",
            tag = "134"
        )]
        AccountLinkError(i32),
        #[prost(
            enumeration = "super::third_party_app_analytics_link_error_enum::ThirdPartyAppAnalyticsLinkError",
            tag = "135"
        )]
        ThirdPartyAppAnalyticsLinkError(i32),
        #[prost(
            enumeration = "super::customer_user_access_error_enum::CustomerUserAccessError",
            tag = "138"
        )]
        CustomerUserAccessError(i32),
        #[prost(
            enumeration = "super::custom_audience_error_enum::CustomAudienceError",
            tag = "139"
        )]
        CustomAudienceError(i32),
        #[prost(enumeration = "super::audience_error_enum::AudienceError", tag = "164")]
        AudienceError(i32),
        #[prost(
            enumeration = "super::search_term_insight_error_enum::SearchTermInsightError",
            tag = "174"
        )]
        SearchTermInsightError(i32),
        #[prost(
            enumeration = "super::smart_campaign_error_enum::SmartCampaignError",
            tag = "147"
        )]
        SmartCampaignError(i32),
        #[prost(
            enumeration = "super::experiment_arm_error_enum::ExperimentArmError",
            tag = "156"
        )]
        ExperimentArmError(i32),
        #[prost(
            enumeration = "super::audience_insights_error_enum::AudienceInsightsError",
            tag = "167"
        )]
        AudienceInsightsError(i32),
        #[prost(
            enumeration = "super::product_link_error_enum::ProductLinkError",
            tag = "169"
        )]
        ProductLinkError(i32),
        #[prost(
            enumeration = "super::customer_sk_ad_network_conversion_value_schema_error_enum::CustomerSkAdNetworkConversionValueSchemaError",
            tag = "170"
        )]
        CustomerSkAdNetworkConversionValueSchemaError(i32),
        #[prost(enumeration = "super::currency_error_enum::CurrencyError", tag = "171")]
        CurrencyError(i32),
        #[prost(
            enumeration = "super::asset_group_signal_error_enum::AssetGroupSignalError",
            tag = "176"
        )]
        AssetGroupSignalError(i32),
        #[prost(
            enumeration = "super::product_link_invitation_error_enum::ProductLinkInvitationError",
            tag = "177"
        )]
        ProductLinkInvitationError(i32),
        #[prost(
            enumeration = "super::customer_lifecycle_goal_error_enum::CustomerLifecycleGoalError",
            tag = "178"
        )]
        CustomerLifecycleGoalError(i32),
        #[prost(
            enumeration = "super::campaign_lifecycle_goal_error_enum::CampaignLifecycleGoalError",
            tag = "179"
        )]
        CampaignLifecycleGoalError(i32),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorLocation {
    #[prost(message, repeated, tag = "2")]
    pub field_path_elements: ::prost::alloc::vec::Vec<error_location::FieldPathElement>,
}
/// Nested message and enum types in `ErrorLocation`.
pub mod error_location {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct FieldPathElement {
        #[prost(string, tag = "1")]
        pub field_name: ::prost::alloc::string::String,
        #[prost(int32, optional, tag = "3")]
        pub index: ::core::option::Option<i32>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ErrorDetails {
    #[prost(string, tag = "1")]
    pub unpublished_error_code: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub policy_violation_details: ::core::option::Option<PolicyViolationDetails>,
    #[prost(message, optional, tag = "3")]
    pub policy_finding_details: ::core::option::Option<PolicyFindingDetails>,
    #[prost(message, optional, tag = "4")]
    pub quota_error_details: ::core::option::Option<QuotaErrorDetails>,
    #[prost(message, optional, tag = "5")]
    pub resource_count_details: ::core::option::Option<ResourceCountDetails>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolationDetails {
    #[prost(string, tag = "2")]
    pub external_policy_description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub key: ::core::option::Option<super::common::PolicyViolationKey>,
    #[prost(string, tag = "5")]
    pub external_policy_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_exemptible: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyFindingDetails {
    #[prost(message, repeated, tag = "1")]
    pub policy_topic_entries: ::prost::alloc::vec::Vec<super::common::PolicyTopicEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuotaErrorDetails {
    #[prost(enumeration = "quota_error_details::QuotaRateScope", tag = "1")]
    pub rate_scope: i32,
    #[prost(string, tag = "2")]
    pub rate_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub retry_delay: ::core::option::Option<::prost_types::Duration>,
}
/// Nested message and enum types in `QuotaErrorDetails`.
pub mod quota_error_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QuotaRateScope {
        Unspecified = 0,
        Unknown = 1,
        Account = 2,
        Developer = 3,
    }
    impl QuotaRateScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QuotaRateScope::Unspecified => "UNSPECIFIED",
                QuotaRateScope::Unknown => "UNKNOWN",
                QuotaRateScope::Account => "ACCOUNT",
                QuotaRateScope::Developer => "DEVELOPER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT" => Some(Self::Account),
                "DEVELOPER" => Some(Self::Developer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResourceCountDetails {
    #[prost(string, tag = "1")]
    pub enclosing_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub enclosing_resource: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub limit: i32,
    #[prost(
        enumeration = "super::enums::resource_limit_type_enum::ResourceLimitType",
        tag = "3"
    )]
    pub limit_type: i32,
    #[prost(int32, tag = "4")]
    pub existing_count: i32,
}
