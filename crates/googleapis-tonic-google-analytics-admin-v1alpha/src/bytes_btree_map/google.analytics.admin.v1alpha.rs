// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessDimension {
    #[prost(string, tag = "1")]
    pub dimension_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessMetric {
    #[prost(string, tag = "1")]
    pub metric_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessDateRange {
    #[prost(string, tag = "1")]
    pub start_date: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub end_date: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessFilterExpression {
    #[prost(oneof = "access_filter_expression::OneExpression", tags = "1, 2, 3, 4")]
    pub one_expression: ::core::option::Option<access_filter_expression::OneExpression>,
}
/// Nested message and enum types in `AccessFilterExpression`.
pub mod access_filter_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneExpression {
        #[prost(message, tag = "1")]
        AndGroup(super::AccessFilterExpressionList),
        #[prost(message, tag = "2")]
        OrGroup(super::AccessFilterExpressionList),
        #[prost(message, tag = "3")]
        NotExpression(::prost::alloc::boxed::Box<super::AccessFilterExpression>),
        #[prost(message, tag = "4")]
        AccessFilter(super::AccessFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessFilterExpressionList {
    #[prost(message, repeated, tag = "1")]
    pub expressions: ::prost::alloc::vec::Vec<AccessFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessFilter {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(oneof = "access_filter::OneFilter", tags = "2, 3, 4, 5")]
    pub one_filter: ::core::option::Option<access_filter::OneFilter>,
}
/// Nested message and enum types in `AccessFilter`.
pub mod access_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneFilter {
        #[prost(message, tag = "2")]
        StringFilter(super::AccessStringFilter),
        #[prost(message, tag = "3")]
        InListFilter(super::AccessInListFilter),
        #[prost(message, tag = "4")]
        NumericFilter(super::AccessNumericFilter),
        #[prost(message, tag = "5")]
        BetweenFilter(super::AccessBetweenFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessStringFilter {
    #[prost(enumeration = "access_string_filter::MatchType", tag = "1")]
    pub match_type: i32,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub case_sensitive: bool,
}
/// Nested message and enum types in `AccessStringFilter`.
pub mod access_string_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchType {
        Unspecified = 0,
        Exact = 1,
        BeginsWith = 2,
        EndsWith = 3,
        Contains = 4,
        FullRegexp = 5,
        PartialRegexp = 6,
    }
    impl MatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MatchType::Unspecified => "MATCH_TYPE_UNSPECIFIED",
                MatchType::Exact => "EXACT",
                MatchType::BeginsWith => "BEGINS_WITH",
                MatchType::EndsWith => "ENDS_WITH",
                MatchType::Contains => "CONTAINS",
                MatchType::FullRegexp => "FULL_REGEXP",
                MatchType::PartialRegexp => "PARTIAL_REGEXP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXACT" => Some(Self::Exact),
                "BEGINS_WITH" => Some(Self::BeginsWith),
                "ENDS_WITH" => Some(Self::EndsWith),
                "CONTAINS" => Some(Self::Contains),
                "FULL_REGEXP" => Some(Self::FullRegexp),
                "PARTIAL_REGEXP" => Some(Self::PartialRegexp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessInListFilter {
    #[prost(string, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub case_sensitive: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessNumericFilter {
    #[prost(enumeration = "access_numeric_filter::Operation", tag = "1")]
    pub operation: i32,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<NumericValue>,
}
/// Nested message and enum types in `AccessNumericFilter`.
pub mod access_numeric_filter {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        Unspecified = 0,
        Equal = 1,
        LessThan = 2,
        LessThanOrEqual = 3,
        GreaterThan = 4,
        GreaterThanOrEqual = 5,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operation::Unspecified => "OPERATION_UNSPECIFIED",
                Operation::Equal => "EQUAL",
                Operation::LessThan => "LESS_THAN",
                Operation::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                Operation::GreaterThan => "GREATER_THAN",
                Operation::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "EQUAL" => Some(Self::Equal),
                "LESS_THAN" => Some(Self::LessThan),
                "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                "GREATER_THAN" => Some(Self::GreaterThan),
                "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessBetweenFilter {
    #[prost(message, optional, tag = "1")]
    pub from_value: ::core::option::Option<NumericValue>,
    #[prost(message, optional, tag = "2")]
    pub to_value: ::core::option::Option<NumericValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NumericValue {
    #[prost(oneof = "numeric_value::OneValue", tags = "1, 2")]
    pub one_value: ::core::option::Option<numeric_value::OneValue>,
}
/// Nested message and enum types in `NumericValue`.
pub mod numeric_value {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum OneValue {
        #[prost(int64, tag = "1")]
        Int64Value(i64),
        #[prost(double, tag = "2")]
        DoubleValue(f64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessOrderBy {
    #[prost(bool, tag = "3")]
    pub desc: bool,
    #[prost(oneof = "access_order_by::OneOrderBy", tags = "1, 2")]
    pub one_order_by: ::core::option::Option<access_order_by::OneOrderBy>,
}
/// Nested message and enum types in `AccessOrderBy`.
pub mod access_order_by {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct MetricOrderBy {
        #[prost(string, tag = "1")]
        pub metric_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DimensionOrderBy {
        #[prost(string, tag = "1")]
        pub dimension_name: ::prost::alloc::string::String,
        #[prost(enumeration = "dimension_order_by::OrderType", tag = "2")]
        pub order_type: i32,
    }
    /// Nested message and enum types in `DimensionOrderBy`.
    pub mod dimension_order_by {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum OrderType {
            Unspecified = 0,
            Alphanumeric = 1,
            CaseInsensitiveAlphanumeric = 2,
            Numeric = 3,
        }
        impl OrderType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    OrderType::Unspecified => "ORDER_TYPE_UNSPECIFIED",
                    OrderType::Alphanumeric => "ALPHANUMERIC",
                    OrderType::CaseInsensitiveAlphanumeric => {
                        "CASE_INSENSITIVE_ALPHANUMERIC"
                    }
                    OrderType::Numeric => "NUMERIC",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "ALPHANUMERIC" => Some(Self::Alphanumeric),
                    "CASE_INSENSITIVE_ALPHANUMERIC" => {
                        Some(Self::CaseInsensitiveAlphanumeric)
                    }
                    "NUMERIC" => Some(Self::Numeric),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneOrderBy {
        #[prost(message, tag = "1")]
        Metric(MetricOrderBy),
        #[prost(message, tag = "2")]
        Dimension(DimensionOrderBy),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessDimensionHeader {
    #[prost(string, tag = "1")]
    pub dimension_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessMetricHeader {
    #[prost(string, tag = "1")]
    pub metric_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessRow {
    #[prost(message, repeated, tag = "1")]
    pub dimension_values: ::prost::alloc::vec::Vec<AccessDimensionValue>,
    #[prost(message, repeated, tag = "2")]
    pub metric_values: ::prost::alloc::vec::Vec<AccessMetricValue>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessDimensionValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessMetricValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessQuota {
    #[prost(message, optional, tag = "1")]
    pub tokens_per_day: ::core::option::Option<AccessQuotaStatus>,
    #[prost(message, optional, tag = "2")]
    pub tokens_per_hour: ::core::option::Option<AccessQuotaStatus>,
    #[prost(message, optional, tag = "3")]
    pub concurrent_requests: ::core::option::Option<AccessQuotaStatus>,
    #[prost(message, optional, tag = "4")]
    pub server_errors_per_project_per_hour: ::core::option::Option<AccessQuotaStatus>,
    #[prost(message, optional, tag = "5")]
    pub tokens_per_project_per_hour: ::core::option::Option<AccessQuotaStatus>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessQuotaStatus {
    #[prost(int32, tag = "1")]
    pub consumed: i32,
    #[prost(int32, tag = "2")]
    pub remaining: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceDimensionOrMetricFilter {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub at_any_point_in_time: bool,
    #[prost(int32, tag = "7")]
    pub in_any_n_day_period: i32,
    #[prost(
        oneof = "audience_dimension_or_metric_filter::OneFilter",
        tags = "2, 3, 4, 5"
    )]
    pub one_filter: ::core::option::Option<
        audience_dimension_or_metric_filter::OneFilter,
    >,
}
/// Nested message and enum types in `AudienceDimensionOrMetricFilter`.
pub mod audience_dimension_or_metric_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringFilter {
        #[prost(enumeration = "string_filter::MatchType", tag = "1")]
        pub match_type: i32,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub case_sensitive: bool,
    }
    /// Nested message and enum types in `StringFilter`.
    pub mod string_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MatchType {
            Unspecified = 0,
            Exact = 1,
            BeginsWith = 2,
            EndsWith = 3,
            Contains = 4,
            FullRegexp = 5,
        }
        impl MatchType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    MatchType::Unspecified => "MATCH_TYPE_UNSPECIFIED",
                    MatchType::Exact => "EXACT",
                    MatchType::BeginsWith => "BEGINS_WITH",
                    MatchType::EndsWith => "ENDS_WITH",
                    MatchType::Contains => "CONTAINS",
                    MatchType::FullRegexp => "FULL_REGEXP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXACT" => Some(Self::Exact),
                    "BEGINS_WITH" => Some(Self::BeginsWith),
                    "ENDS_WITH" => Some(Self::EndsWith),
                    "CONTAINS" => Some(Self::Contains),
                    "FULL_REGEXP" => Some(Self::FullRegexp),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InListFilter {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "2")]
        pub case_sensitive: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NumericValue {
        #[prost(oneof = "numeric_value::OneValue", tags = "1, 2")]
        pub one_value: ::core::option::Option<numeric_value::OneValue>,
    }
    /// Nested message and enum types in `NumericValue`.
    pub mod numeric_value {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
        pub enum OneValue {
            #[prost(int64, tag = "1")]
            Int64Value(i64),
            #[prost(double, tag = "2")]
            DoubleValue(f64),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NumericFilter {
        #[prost(enumeration = "numeric_filter::Operation", tag = "1")]
        pub operation: i32,
        #[prost(message, optional, tag = "2")]
        pub value: ::core::option::Option<NumericValue>,
    }
    /// Nested message and enum types in `NumericFilter`.
    pub mod numeric_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Operation {
            Unspecified = 0,
            Equal = 1,
            LessThan = 2,
            GreaterThan = 4,
        }
        impl Operation {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Operation::Unspecified => "OPERATION_UNSPECIFIED",
                    Operation::Equal => "EQUAL",
                    Operation::LessThan => "LESS_THAN",
                    Operation::GreaterThan => "GREATER_THAN",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                    "EQUAL" => Some(Self::Equal),
                    "LESS_THAN" => Some(Self::LessThan),
                    "GREATER_THAN" => Some(Self::GreaterThan),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct BetweenFilter {
        #[prost(message, optional, tag = "1")]
        pub from_value: ::core::option::Option<NumericValue>,
        #[prost(message, optional, tag = "2")]
        pub to_value: ::core::option::Option<NumericValue>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneFilter {
        #[prost(message, tag = "2")]
        StringFilter(StringFilter),
        #[prost(message, tag = "3")]
        InListFilter(InListFilter),
        #[prost(message, tag = "4")]
        NumericFilter(NumericFilter),
        #[prost(message, tag = "5")]
        BetweenFilter(BetweenFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceEventFilter {
    #[prost(string, tag = "1")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(message, optional, boxed, tag = "2")]
    pub event_parameter_filter_expression: ::core::option::Option<
        ::prost::alloc::boxed::Box<AudienceFilterExpression>,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceFilterExpression {
    #[prost(oneof = "audience_filter_expression::Expr", tags = "1, 2, 3, 4, 5")]
    pub expr: ::core::option::Option<audience_filter_expression::Expr>,
}
/// Nested message and enum types in `AudienceFilterExpression`.
pub mod audience_filter_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expr {
        #[prost(message, tag = "1")]
        AndGroup(super::AudienceFilterExpressionList),
        #[prost(message, tag = "2")]
        OrGroup(super::AudienceFilterExpressionList),
        #[prost(message, tag = "3")]
        NotExpression(::prost::alloc::boxed::Box<super::AudienceFilterExpression>),
        #[prost(message, tag = "4")]
        DimensionOrMetricFilter(super::AudienceDimensionOrMetricFilter),
        #[prost(message, tag = "5")]
        EventFilter(::prost::alloc::boxed::Box<super::AudienceEventFilter>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceFilterExpressionList {
    #[prost(message, repeated, tag = "1")]
    pub filter_expressions: ::prost::alloc::vec::Vec<AudienceFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceSimpleFilter {
    #[prost(enumeration = "AudienceFilterScope", tag = "1")]
    pub scope: i32,
    #[prost(message, optional, tag = "2")]
    pub filter_expression: ::core::option::Option<AudienceFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceSequenceFilter {
    #[prost(enumeration = "AudienceFilterScope", tag = "1")]
    pub scope: i32,
    #[prost(message, optional, tag = "2")]
    pub sequence_maximum_duration: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, repeated, tag = "3")]
    pub sequence_steps: ::prost::alloc::vec::Vec<
        audience_sequence_filter::AudienceSequenceStep,
    >,
}
/// Nested message and enum types in `AudienceSequenceFilter`.
pub mod audience_sequence_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AudienceSequenceStep {
        #[prost(enumeration = "super::AudienceFilterScope", tag = "1")]
        pub scope: i32,
        #[prost(bool, tag = "2")]
        pub immediately_follows: bool,
        #[prost(message, optional, tag = "3")]
        pub constraint_duration: ::core::option::Option<::prost_types::Duration>,
        #[prost(message, optional, tag = "4")]
        pub filter_expression: ::core::option::Option<super::AudienceFilterExpression>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceFilterClause {
    #[prost(enumeration = "audience_filter_clause::AudienceClauseType", tag = "1")]
    pub clause_type: i32,
    #[prost(oneof = "audience_filter_clause::Filter", tags = "2, 3")]
    pub filter: ::core::option::Option<audience_filter_clause::Filter>,
}
/// Nested message and enum types in `AudienceFilterClause`.
pub mod audience_filter_clause {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceClauseType {
        Unspecified = 0,
        Include = 1,
        Exclude = 2,
    }
    impl AudienceClauseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceClauseType::Unspecified => "AUDIENCE_CLAUSE_TYPE_UNSPECIFIED",
                AudienceClauseType::Include => "INCLUDE",
                AudienceClauseType::Exclude => "EXCLUDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIENCE_CLAUSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUDE" => Some(Self::Include),
                "EXCLUDE" => Some(Self::Exclude),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        #[prost(message, tag = "2")]
        SimpleFilter(super::AudienceSimpleFilter),
        #[prost(message, tag = "3")]
        SequenceFilter(super::AudienceSequenceFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AudienceEventTrigger {
    #[prost(string, tag = "1")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(enumeration = "audience_event_trigger::LogCondition", tag = "2")]
    pub log_condition: i32,
}
/// Nested message and enum types in `AudienceEventTrigger`.
pub mod audience_event_trigger {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LogCondition {
        Unspecified = 0,
        AudienceJoined = 1,
        AudienceMembershipRenewed = 2,
    }
    impl LogCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LogCondition::Unspecified => "LOG_CONDITION_UNSPECIFIED",
                LogCondition::AudienceJoined => "AUDIENCE_JOINED",
                LogCondition::AudienceMembershipRenewed => "AUDIENCE_MEMBERSHIP_RENEWED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOG_CONDITION_UNSPECIFIED" => Some(Self::Unspecified),
                "AUDIENCE_JOINED" => Some(Self::AudienceJoined),
                "AUDIENCE_MEMBERSHIP_RENEWED" => Some(Self::AudienceMembershipRenewed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Audience {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub membership_duration_days: i32,
    #[prost(bool, tag = "5")]
    pub ads_personalization_enabled: bool,
    #[prost(message, optional, tag = "6")]
    pub event_trigger: ::core::option::Option<AudienceEventTrigger>,
    #[prost(enumeration = "audience::AudienceExclusionDurationMode", tag = "7")]
    pub exclusion_duration_mode: i32,
    #[prost(message, repeated, tag = "8")]
    pub filter_clauses: ::prost::alloc::vec::Vec<AudienceFilterClause>,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Audience`.
pub mod audience {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceExclusionDurationMode {
        Unspecified = 0,
        ExcludeTemporarily = 1,
        ExcludePermanently = 2,
    }
    impl AudienceExclusionDurationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceExclusionDurationMode::Unspecified => {
                    "AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED"
                }
                AudienceExclusionDurationMode::ExcludeTemporarily => {
                    "EXCLUDE_TEMPORARILY"
                }
                AudienceExclusionDurationMode::ExcludePermanently => {
                    "EXCLUDE_PERMANENTLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AUDIENCE_EXCLUSION_DURATION_MODE_UNSPECIFIED" => Some(Self::Unspecified),
                "EXCLUDE_TEMPORARILY" => Some(Self::ExcludeTemporarily),
                "EXCLUDE_PERMANENTLY" => Some(Self::ExcludePermanently),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AudienceFilterScope {
    Unspecified = 0,
    WithinSameEvent = 1,
    WithinSameSession = 2,
    AcrossAllSessions = 3,
}
impl AudienceFilterScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AudienceFilterScope::Unspecified => "AUDIENCE_FILTER_SCOPE_UNSPECIFIED",
            AudienceFilterScope::WithinSameEvent => {
                "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT"
            }
            AudienceFilterScope::WithinSameSession => {
                "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION"
            }
            AudienceFilterScope::AcrossAllSessions => {
                "AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AUDIENCE_FILTER_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_EVENT" => Some(Self::WithinSameEvent),
            "AUDIENCE_FILTER_SCOPE_WITHIN_SAME_SESSION" => Some(Self::WithinSameSession),
            "AUDIENCE_FILTER_SCOPE_ACROSS_ALL_SESSIONS" => Some(Self::AcrossAllSessions),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelGroupFilter {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(oneof = "channel_group_filter::ValueFilter", tags = "2, 3")]
    pub value_filter: ::core::option::Option<channel_group_filter::ValueFilter>,
}
/// Nested message and enum types in `ChannelGroupFilter`.
pub mod channel_group_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringFilter {
        #[prost(enumeration = "string_filter::MatchType", tag = "1")]
        pub match_type: i32,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
    }
    /// Nested message and enum types in `StringFilter`.
    pub mod string_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MatchType {
            Unspecified = 0,
            Exact = 1,
            BeginsWith = 2,
            EndsWith = 3,
            Contains = 4,
            FullRegexp = 5,
            PartialRegexp = 6,
        }
        impl MatchType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    MatchType::Unspecified => "MATCH_TYPE_UNSPECIFIED",
                    MatchType::Exact => "EXACT",
                    MatchType::BeginsWith => "BEGINS_WITH",
                    MatchType::EndsWith => "ENDS_WITH",
                    MatchType::Contains => "CONTAINS",
                    MatchType::FullRegexp => "FULL_REGEXP",
                    MatchType::PartialRegexp => "PARTIAL_REGEXP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXACT" => Some(Self::Exact),
                    "BEGINS_WITH" => Some(Self::BeginsWith),
                    "ENDS_WITH" => Some(Self::EndsWith),
                    "CONTAINS" => Some(Self::Contains),
                    "FULL_REGEXP" => Some(Self::FullRegexp),
                    "PARTIAL_REGEXP" => Some(Self::PartialRegexp),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InListFilter {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ValueFilter {
        #[prost(message, tag = "2")]
        StringFilter(StringFilter),
        #[prost(message, tag = "3")]
        InListFilter(InListFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelGroupFilterExpression {
    #[prost(oneof = "channel_group_filter_expression::Expr", tags = "1, 2, 3, 4")]
    pub expr: ::core::option::Option<channel_group_filter_expression::Expr>,
}
/// Nested message and enum types in `ChannelGroupFilterExpression`.
pub mod channel_group_filter_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expr {
        #[prost(message, tag = "1")]
        AndGroup(super::ChannelGroupFilterExpressionList),
        #[prost(message, tag = "2")]
        OrGroup(super::ChannelGroupFilterExpressionList),
        #[prost(message, tag = "3")]
        NotExpression(::prost::alloc::boxed::Box<super::ChannelGroupFilterExpression>),
        #[prost(message, tag = "4")]
        Filter(super::ChannelGroupFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelGroupFilterExpressionList {
    #[prost(message, repeated, tag = "1")]
    pub filter_expressions: ::prost::alloc::vec::Vec<ChannelGroupFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupingRule {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expression: ::core::option::Option<ChannelGroupFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChannelGroup {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub grouping_rule: ::prost::alloc::vec::Vec<GroupingRule>,
    #[prost(bool, tag = "5")]
    pub system_defined: bool,
    #[prost(bool, tag = "6")]
    pub primary: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ParameterMutation {
    #[prost(string, tag = "1")]
    pub parameter: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parameter_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventCreateRule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_event: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub event_conditions: ::prost::alloc::vec::Vec<MatchingCondition>,
    #[prost(bool, tag = "4")]
    pub source_copy_parameters: bool,
    #[prost(message, repeated, tag = "5")]
    pub parameter_mutations: ::prost::alloc::vec::Vec<ParameterMutation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventEditRule {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub event_conditions: ::prost::alloc::vec::Vec<MatchingCondition>,
    #[prost(message, repeated, tag = "4")]
    pub parameter_mutations: ::prost::alloc::vec::Vec<ParameterMutation>,
    #[prost(int64, tag = "5")]
    pub processing_order: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MatchingCondition {
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    #[prost(enumeration = "matching_condition::ComparisonType", tag = "2")]
    pub comparison_type: i32,
    #[prost(string, tag = "3")]
    pub value: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub negated: bool,
}
/// Nested message and enum types in `MatchingCondition`.
pub mod matching_condition {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ComparisonType {
        Unspecified = 0,
        Equals = 1,
        EqualsCaseInsensitive = 2,
        Contains = 3,
        ContainsCaseInsensitive = 4,
        StartsWith = 5,
        StartsWithCaseInsensitive = 6,
        EndsWith = 7,
        EndsWithCaseInsensitive = 8,
        GreaterThan = 9,
        GreaterThanOrEqual = 10,
        LessThan = 11,
        LessThanOrEqual = 12,
        RegularExpression = 13,
        RegularExpressionCaseInsensitive = 14,
    }
    impl ComparisonType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ComparisonType::Unspecified => "COMPARISON_TYPE_UNSPECIFIED",
                ComparisonType::Equals => "EQUALS",
                ComparisonType::EqualsCaseInsensitive => "EQUALS_CASE_INSENSITIVE",
                ComparisonType::Contains => "CONTAINS",
                ComparisonType::ContainsCaseInsensitive => "CONTAINS_CASE_INSENSITIVE",
                ComparisonType::StartsWith => "STARTS_WITH",
                ComparisonType::StartsWithCaseInsensitive => {
                    "STARTS_WITH_CASE_INSENSITIVE"
                }
                ComparisonType::EndsWith => "ENDS_WITH",
                ComparisonType::EndsWithCaseInsensitive => "ENDS_WITH_CASE_INSENSITIVE",
                ComparisonType::GreaterThan => "GREATER_THAN",
                ComparisonType::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                ComparisonType::LessThan => "LESS_THAN",
                ComparisonType::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                ComparisonType::RegularExpression => "REGULAR_EXPRESSION",
                ComparisonType::RegularExpressionCaseInsensitive => {
                    "REGULAR_EXPRESSION_CASE_INSENSITIVE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPARISON_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EQUALS" => Some(Self::Equals),
                "EQUALS_CASE_INSENSITIVE" => Some(Self::EqualsCaseInsensitive),
                "CONTAINS" => Some(Self::Contains),
                "CONTAINS_CASE_INSENSITIVE" => Some(Self::ContainsCaseInsensitive),
                "STARTS_WITH" => Some(Self::StartsWith),
                "STARTS_WITH_CASE_INSENSITIVE" => Some(Self::StartsWithCaseInsensitive),
                "ENDS_WITH" => Some(Self::EndsWith),
                "ENDS_WITH_CASE_INSENSITIVE" => Some(Self::EndsWithCaseInsensitive),
                "GREATER_THAN" => Some(Self::GreaterThan),
                "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                "LESS_THAN" => Some(Self::LessThan),
                "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                "REGULAR_EXPRESSION" => Some(Self::RegularExpression),
                "REGULAR_EXPRESSION_CASE_INSENSITIVE" => {
                    Some(Self::RegularExpressionCaseInsensitive)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandedDataSetFilter {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(oneof = "expanded_data_set_filter::OneFilter", tags = "2, 3")]
    pub one_filter: ::core::option::Option<expanded_data_set_filter::OneFilter>,
}
/// Nested message and enum types in `ExpandedDataSetFilter`.
pub mod expanded_data_set_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringFilter {
        #[prost(enumeration = "string_filter::MatchType", tag = "1")]
        pub match_type: i32,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub case_sensitive: bool,
    }
    /// Nested message and enum types in `StringFilter`.
    pub mod string_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MatchType {
            Unspecified = 0,
            Exact = 1,
            Contains = 2,
        }
        impl MatchType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    MatchType::Unspecified => "MATCH_TYPE_UNSPECIFIED",
                    MatchType::Exact => "EXACT",
                    MatchType::Contains => "CONTAINS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXACT" => Some(Self::Exact),
                    "CONTAINS" => Some(Self::Contains),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct InListFilter {
        #[prost(string, repeated, tag = "1")]
        pub values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(bool, tag = "2")]
        pub case_sensitive: bool,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneFilter {
        #[prost(message, tag = "2")]
        StringFilter(StringFilter),
        #[prost(message, tag = "3")]
        InListFilter(InListFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandedDataSetFilterExpression {
    #[prost(oneof = "expanded_data_set_filter_expression::Expr", tags = "1, 2, 3")]
    pub expr: ::core::option::Option<expanded_data_set_filter_expression::Expr>,
}
/// Nested message and enum types in `ExpandedDataSetFilterExpression`.
pub mod expanded_data_set_filter_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expr {
        #[prost(message, tag = "1")]
        AndGroup(super::ExpandedDataSetFilterExpressionList),
        #[prost(message, tag = "2")]
        NotExpression(
            ::prost::alloc::boxed::Box<super::ExpandedDataSetFilterExpression>,
        ),
        #[prost(message, tag = "3")]
        Filter(super::ExpandedDataSetFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandedDataSetFilterExpressionList {
    #[prost(message, repeated, tag = "1")]
    pub filter_expressions: ::prost::alloc::vec::Vec<ExpandedDataSetFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExpandedDataSet {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub dimension_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub metric_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub dimension_filter_expression: ::core::option::Option<
        ExpandedDataSetFilterExpression,
    >,
    #[prost(message, optional, tag = "7")]
    pub data_collection_start_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Account {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "4")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub region_code: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub deleted: bool,
    #[prost(string, tag = "7")]
    pub gmp_organization: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Property {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "PropertyType", tag = "14")]
    pub property_type: i32,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "IndustryCategory", tag = "6")]
    pub industry_category: i32,
    #[prost(string, tag = "7")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub currency_code: ::prost::alloc::string::String,
    #[prost(enumeration = "ServiceLevel", tag = "10")]
    pub service_level: i32,
    #[prost(message, optional, tag = "11")]
    pub delete_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub expire_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "13")]
    pub account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataStream {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "data_stream::DataStreamType", tag = "2")]
    pub r#type: i32,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "data_stream::StreamData", tags = "6, 7, 8")]
    pub stream_data: ::core::option::Option<data_stream::StreamData>,
}
/// Nested message and enum types in `DataStream`.
pub mod data_stream {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WebStreamData {
        #[prost(string, tag = "1")]
        pub measurement_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub firebase_app_id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub default_uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AndroidAppStreamData {
        #[prost(string, tag = "1")]
        pub firebase_app_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub package_name: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct IosAppStreamData {
        #[prost(string, tag = "1")]
        pub firebase_app_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub bundle_id: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataStreamType {
        Unspecified = 0,
        WebDataStream = 1,
        AndroidAppDataStream = 2,
        IosAppDataStream = 3,
    }
    impl DataStreamType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataStreamType::Unspecified => "DATA_STREAM_TYPE_UNSPECIFIED",
                DataStreamType::WebDataStream => "WEB_DATA_STREAM",
                DataStreamType::AndroidAppDataStream => "ANDROID_APP_DATA_STREAM",
                DataStreamType::IosAppDataStream => "IOS_APP_DATA_STREAM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DATA_STREAM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "WEB_DATA_STREAM" => Some(Self::WebDataStream),
                "ANDROID_APP_DATA_STREAM" => Some(Self::AndroidAppDataStream),
                "IOS_APP_DATA_STREAM" => Some(Self::IosAppDataStream),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StreamData {
        #[prost(message, tag = "6")]
        WebStreamData(WebStreamData),
        #[prost(message, tag = "7")]
        AndroidAppStreamData(AndroidAppStreamData),
        #[prost(message, tag = "8")]
        IosAppStreamData(IosAppStreamData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirebaseLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GlobalSiteTag {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub snippet: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleAdsLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub customer_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub can_manage_clients: bool,
    #[prost(message, optional, tag = "5")]
    pub ads_personalization_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "9")]
    pub creator_email_address: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataSharingSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub sharing_with_google_support_enabled: bool,
    #[prost(bool, tag = "3")]
    pub sharing_with_google_assigned_sales_enabled: bool,
    #[prost(bool, tag = "4")]
    pub sharing_with_google_any_sales_enabled: bool,
    #[prost(bool, tag = "5")]
    pub sharing_with_google_products_enabled: bool,
    #[prost(bool, tag = "6")]
    pub sharing_with_others_enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccountSummary {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub property_summaries: ::prost::alloc::vec::Vec<PropertySummary>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PropertySummary {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(enumeration = "PropertyType", tag = "3")]
    pub property_type: i32,
    #[prost(string, tag = "4")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MeasurementProtocolSecret {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub secret_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SkAdNetworkConversionValueSchema {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub postback_window_one: ::core::option::Option<PostbackWindow>,
    #[prost(message, optional, tag = "3")]
    pub postback_window_two: ::core::option::Option<PostbackWindow>,
    #[prost(message, optional, tag = "4")]
    pub postback_window_three: ::core::option::Option<PostbackWindow>,
    #[prost(bool, tag = "5")]
    pub apply_conversion_values: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PostbackWindow {
    #[prost(message, repeated, tag = "1")]
    pub conversion_values: ::prost::alloc::vec::Vec<ConversionValues>,
    #[prost(bool, tag = "2")]
    pub postback_window_settings_enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionValues {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2")]
    pub fine_value: ::core::option::Option<i32>,
    #[prost(enumeration = "CoarseValue", tag = "3")]
    pub coarse_value: i32,
    #[prost(message, repeated, tag = "4")]
    pub event_mappings: ::prost::alloc::vec::Vec<EventMapping>,
    #[prost(bool, tag = "5")]
    pub lock_enabled: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMapping {
    #[prost(string, tag = "1")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "2")]
    pub min_event_count: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "3")]
    pub max_event_count: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "4")]
    pub min_event_value: ::core::option::Option<f64>,
    #[prost(double, optional, tag = "5")]
    pub max_event_value: ::core::option::Option<f64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeHistoryEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub change_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(enumeration = "ActorType", tag = "3")]
    pub actor_type: i32,
    #[prost(string, tag = "4")]
    pub user_actor_email: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub changes_filtered: bool,
    #[prost(message, repeated, tag = "6")]
    pub changes: ::prost::alloc::vec::Vec<ChangeHistoryChange>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeHistoryChange {
    #[prost(string, tag = "1")]
    pub resource: ::prost::alloc::string::String,
    #[prost(enumeration = "ActionType", tag = "2")]
    pub action: i32,
    #[prost(message, optional, tag = "3")]
    pub resource_before_change: ::core::option::Option<
        change_history_change::ChangeHistoryResource,
    >,
    #[prost(message, optional, tag = "4")]
    pub resource_after_change: ::core::option::Option<
        change_history_change::ChangeHistoryResource,
    >,
}
/// Nested message and enum types in `ChangeHistoryChange`.
pub mod change_history_change {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ChangeHistoryResource {
        #[prost(
            oneof = "change_history_resource::Resource",
            tags = "1, 2, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31"
        )]
        pub resource: ::core::option::Option<change_history_resource::Resource>,
    }
    /// Nested message and enum types in `ChangeHistoryResource`.
    pub mod change_history_resource {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Resource {
            #[prost(message, tag = "1")]
            Account(super::super::Account),
            #[prost(message, tag = "2")]
            Property(super::super::Property),
            #[prost(message, tag = "6")]
            FirebaseLink(super::super::FirebaseLink),
            #[prost(message, tag = "7")]
            GoogleAdsLink(super::super::GoogleAdsLink),
            #[prost(message, tag = "8")]
            GoogleSignalsSettings(super::super::GoogleSignalsSettings),
            #[prost(message, tag = "9")]
            DisplayVideo360AdvertiserLink(super::super::DisplayVideo360AdvertiserLink),
            #[prost(message, tag = "10")]
            DisplayVideo360AdvertiserLinkProposal(
                super::super::DisplayVideo360AdvertiserLinkProposal,
            ),
            #[prost(message, tag = "11")]
            ConversionEvent(super::super::ConversionEvent),
            #[prost(message, tag = "12")]
            MeasurementProtocolSecret(super::super::MeasurementProtocolSecret),
            #[prost(message, tag = "13")]
            CustomDimension(super::super::CustomDimension),
            #[prost(message, tag = "14")]
            CustomMetric(super::super::CustomMetric),
            #[prost(message, tag = "15")]
            DataRetentionSettings(super::super::DataRetentionSettings),
            #[prost(message, tag = "16")]
            SearchAds360Link(super::super::SearchAds360Link),
            #[prost(message, tag = "18")]
            DataStream(super::super::DataStream),
            #[prost(message, tag = "20")]
            AttributionSettings(super::super::AttributionSettings),
            #[prost(message, tag = "21")]
            ExpandedDataSet(super::super::ExpandedDataSet),
            #[prost(message, tag = "22")]
            ChannelGroup(super::super::ChannelGroup),
            #[prost(message, tag = "23")]
            BigqueryLink(super::super::BigQueryLink),
            #[prost(message, tag = "24")]
            EnhancedMeasurementSettings(super::super::EnhancedMeasurementSettings),
            #[prost(message, tag = "25")]
            DataRedactionSettings(super::super::DataRedactionSettings),
            #[prost(message, tag = "26")]
            SkadnetworkConversionValueSchema(
                super::super::SkAdNetworkConversionValueSchema,
            ),
            #[prost(message, tag = "27")]
            AdsenseLink(super::super::AdSenseLink),
            #[prost(message, tag = "28")]
            Audience(super::super::Audience),
            #[prost(message, tag = "29")]
            EventCreateRule(super::super::EventCreateRule),
            #[prost(message, tag = "31")]
            CalculatedMetric(super::super::CalculatedMetric),
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisplayVideo360AdvertiserLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub advertiser_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub advertiser_display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub ads_personalization_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "5")]
    pub campaign_data_sharing_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "6")]
    pub cost_data_sharing_enabled: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisplayVideo360AdvertiserLinkProposal {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub advertiser_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub link_proposal_status_details: ::core::option::Option<LinkProposalStatusDetails>,
    #[prost(string, tag = "4")]
    pub advertiser_display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub validation_email: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub ads_personalization_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub campaign_data_sharing_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "8")]
    pub cost_data_sharing_enabled: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAds360Link {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub advertiser_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub campaign_data_sharing_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub cost_data_sharing_enabled: ::core::option::Option<bool>,
    #[prost(string, tag = "5")]
    pub advertiser_display_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub ads_personalization_enabled: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub site_stats_sharing_enabled: ::core::option::Option<bool>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkProposalStatusDetails {
    #[prost(enumeration = "LinkProposalInitiatingProduct", tag = "1")]
    pub link_proposal_initiating_product: i32,
    #[prost(string, tag = "2")]
    pub requestor_email: ::prost::alloc::string::String,
    #[prost(enumeration = "LinkProposalState", tag = "3")]
    pub link_proposal_state: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConversionEvent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub deletable: bool,
    #[prost(bool, tag = "5")]
    pub custom: bool,
    #[prost(enumeration = "conversion_event::ConversionCountingMethod", tag = "6")]
    pub counting_method: i32,
    #[prost(message, optional, tag = "7")]
    pub default_conversion_value: ::core::option::Option<
        conversion_event::DefaultConversionValue,
    >,
}
/// Nested message and enum types in `ConversionEvent`.
pub mod conversion_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DefaultConversionValue {
        #[prost(double, optional, tag = "1")]
        pub value: ::core::option::Option<f64>,
        #[prost(string, optional, tag = "2")]
        pub currency_code: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCountingMethod {
        Unspecified = 0,
        OncePerEvent = 1,
        OncePerSession = 2,
    }
    impl ConversionCountingMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCountingMethod::Unspecified => {
                    "CONVERSION_COUNTING_METHOD_UNSPECIFIED"
                }
                ConversionCountingMethod::OncePerEvent => "ONCE_PER_EVENT",
                ConversionCountingMethod::OncePerSession => "ONCE_PER_SESSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CONVERSION_COUNTING_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "ONCE_PER_EVENT" => Some(Self::OncePerEvent),
                "ONCE_PER_SESSION" => Some(Self::OncePerSession),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub event_name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub deletable: bool,
    #[prost(bool, tag = "5")]
    pub custom: bool,
    #[prost(enumeration = "key_event::CountingMethod", tag = "6")]
    pub counting_method: i32,
    #[prost(message, optional, tag = "7")]
    pub default_value: ::core::option::Option<key_event::DefaultValue>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DefaultValue {
        #[prost(double, tag = "1")]
        pub numeric_value: f64,
        #[prost(string, tag = "2")]
        pub currency_code: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CountingMethod {
        Unspecified = 0,
        OncePerEvent = 1,
        OncePerSession = 2,
    }
    impl CountingMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CountingMethod::Unspecified => "COUNTING_METHOD_UNSPECIFIED",
                CountingMethod::OncePerEvent => "ONCE_PER_EVENT",
                CountingMethod::OncePerSession => "ONCE_PER_SESSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COUNTING_METHOD_UNSPECIFIED" => Some(Self::Unspecified),
                "ONCE_PER_EVENT" => Some(Self::OncePerEvent),
                "ONCE_PER_SESSION" => Some(Self::OncePerSession),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleSignalsSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "GoogleSignalsState", tag = "3")]
    pub state: i32,
    #[prost(enumeration = "GoogleSignalsConsent", tag = "4")]
    pub consent: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomDimension {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parameter_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "custom_dimension::DimensionScope", tag = "5")]
    pub scope: i32,
    #[prost(bool, tag = "6")]
    pub disallow_ads_personalization: bool,
}
/// Nested message and enum types in `CustomDimension`.
pub mod custom_dimension {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DimensionScope {
        Unspecified = 0,
        Event = 1,
        User = 2,
        Item = 3,
    }
    impl DimensionScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DimensionScope::Unspecified => "DIMENSION_SCOPE_UNSPECIFIED",
                DimensionScope::Event => "EVENT",
                DimensionScope::User => "USER",
                DimensionScope::Item => "ITEM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DIMENSION_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EVENT" => Some(Self::Event),
                "USER" => Some(Self::User),
                "ITEM" => Some(Self::Item),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CustomMetric {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub parameter_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "custom_metric::MeasurementUnit", tag = "5")]
    pub measurement_unit: i32,
    #[prost(enumeration = "custom_metric::MetricScope", tag = "6")]
    pub scope: i32,
    #[prost(
        enumeration = "custom_metric::RestrictedMetricType",
        repeated,
        packed = "false",
        tag = "8"
    )]
    pub restricted_metric_type: ::prost::alloc::vec::Vec<i32>,
}
/// Nested message and enum types in `CustomMetric`.
pub mod custom_metric {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MeasurementUnit {
        Unspecified = 0,
        Standard = 1,
        Currency = 2,
        Feet = 3,
        Meters = 4,
        Kilometers = 5,
        Miles = 6,
        Milliseconds = 7,
        Seconds = 8,
        Minutes = 9,
        Hours = 10,
    }
    impl MeasurementUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MeasurementUnit::Unspecified => "MEASUREMENT_UNIT_UNSPECIFIED",
                MeasurementUnit::Standard => "STANDARD",
                MeasurementUnit::Currency => "CURRENCY",
                MeasurementUnit::Feet => "FEET",
                MeasurementUnit::Meters => "METERS",
                MeasurementUnit::Kilometers => "KILOMETERS",
                MeasurementUnit::Miles => "MILES",
                MeasurementUnit::Milliseconds => "MILLISECONDS",
                MeasurementUnit::Seconds => "SECONDS",
                MeasurementUnit::Minutes => "MINUTES",
                MeasurementUnit::Hours => "HOURS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MEASUREMENT_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "CURRENCY" => Some(Self::Currency),
                "FEET" => Some(Self::Feet),
                "METERS" => Some(Self::Meters),
                "KILOMETERS" => Some(Self::Kilometers),
                "MILES" => Some(Self::Miles),
                "MILLISECONDS" => Some(Self::Milliseconds),
                "SECONDS" => Some(Self::Seconds),
                "MINUTES" => Some(Self::Minutes),
                "HOURS" => Some(Self::Hours),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricScope {
        Unspecified = 0,
        Event = 1,
    }
    impl MetricScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MetricScope::Unspecified => "METRIC_SCOPE_UNSPECIFIED",
                MetricScope::Event => "EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METRIC_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "EVENT" => Some(Self::Event),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RestrictedMetricType {
        Unspecified = 0,
        CostData = 1,
        RevenueData = 2,
    }
    impl RestrictedMetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RestrictedMetricType::Unspecified => "RESTRICTED_METRIC_TYPE_UNSPECIFIED",
                RestrictedMetricType::CostData => "COST_DATA",
                RestrictedMetricType::RevenueData => "REVENUE_DATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESTRICTED_METRIC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "COST_DATA" => Some(Self::CostData),
                "REVENUE_DATA" => Some(Self::RevenueData),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CalculatedMetric {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub calculated_metric_id: ::prost::alloc::string::String,
    #[prost(enumeration = "calculated_metric::MetricUnit", tag = "5")]
    pub metric_unit: i32,
    #[prost(
        enumeration = "calculated_metric::RestrictedMetricType",
        repeated,
        packed = "false",
        tag = "6"
    )]
    pub restricted_metric_type: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "7")]
    pub formula: ::prost::alloc::string::String,
    #[prost(bool, tag = "9")]
    pub invalid_metric_reference: bool,
}
/// Nested message and enum types in `CalculatedMetric`.
pub mod calculated_metric {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MetricUnit {
        Unspecified = 0,
        Standard = 1,
        Currency = 2,
        Feet = 3,
        Miles = 4,
        Meters = 5,
        Kilometers = 6,
        Milliseconds = 7,
        Seconds = 8,
        Minutes = 9,
        Hours = 10,
    }
    impl MetricUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MetricUnit::Unspecified => "METRIC_UNIT_UNSPECIFIED",
                MetricUnit::Standard => "STANDARD",
                MetricUnit::Currency => "CURRENCY",
                MetricUnit::Feet => "FEET",
                MetricUnit::Miles => "MILES",
                MetricUnit::Meters => "METERS",
                MetricUnit::Kilometers => "KILOMETERS",
                MetricUnit::Milliseconds => "MILLISECONDS",
                MetricUnit::Seconds => "SECONDS",
                MetricUnit::Minutes => "MINUTES",
                MetricUnit::Hours => "HOURS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METRIC_UNIT_UNSPECIFIED" => Some(Self::Unspecified),
                "STANDARD" => Some(Self::Standard),
                "CURRENCY" => Some(Self::Currency),
                "FEET" => Some(Self::Feet),
                "MILES" => Some(Self::Miles),
                "METERS" => Some(Self::Meters),
                "KILOMETERS" => Some(Self::Kilometers),
                "MILLISECONDS" => Some(Self::Milliseconds),
                "SECONDS" => Some(Self::Seconds),
                "MINUTES" => Some(Self::Minutes),
                "HOURS" => Some(Self::Hours),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RestrictedMetricType {
        Unspecified = 0,
        CostData = 1,
        RevenueData = 2,
    }
    impl RestrictedMetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RestrictedMetricType::Unspecified => "RESTRICTED_METRIC_TYPE_UNSPECIFIED",
                RestrictedMetricType::CostData => "COST_DATA",
                RestrictedMetricType::RevenueData => "REVENUE_DATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESTRICTED_METRIC_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "COST_DATA" => Some(Self::CostData),
                "REVENUE_DATA" => Some(Self::RevenueData),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataRetentionSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "data_retention_settings::RetentionDuration", tag = "2")]
    pub event_data_retention: i32,
    #[prost(bool, tag = "3")]
    pub reset_user_data_on_new_activity: bool,
}
/// Nested message and enum types in `DataRetentionSettings`.
pub mod data_retention_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RetentionDuration {
        Unspecified = 0,
        TwoMonths = 1,
        FourteenMonths = 3,
        TwentySixMonths = 4,
        ThirtyEightMonths = 5,
        FiftyMonths = 6,
    }
    impl RetentionDuration {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RetentionDuration::Unspecified => "RETENTION_DURATION_UNSPECIFIED",
                RetentionDuration::TwoMonths => "TWO_MONTHS",
                RetentionDuration::FourteenMonths => "FOURTEEN_MONTHS",
                RetentionDuration::TwentySixMonths => "TWENTY_SIX_MONTHS",
                RetentionDuration::ThirtyEightMonths => "THIRTY_EIGHT_MONTHS",
                RetentionDuration::FiftyMonths => "FIFTY_MONTHS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETENTION_DURATION_UNSPECIFIED" => Some(Self::Unspecified),
                "TWO_MONTHS" => Some(Self::TwoMonths),
                "FOURTEEN_MONTHS" => Some(Self::FourteenMonths),
                "TWENTY_SIX_MONTHS" => Some(Self::TwentySixMonths),
                "THIRTY_EIGHT_MONTHS" => Some(Self::ThirtyEightMonths),
                "FIFTY_MONTHS" => Some(Self::FiftyMonths),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributionSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(
        enumeration = "attribution_settings::AcquisitionConversionEventLookbackWindow",
        tag = "2"
    )]
    pub acquisition_conversion_event_lookback_window: i32,
    #[prost(
        enumeration = "attribution_settings::OtherConversionEventLookbackWindow",
        tag = "3"
    )]
    pub other_conversion_event_lookback_window: i32,
    #[prost(enumeration = "attribution_settings::ReportingAttributionModel", tag = "4")]
    pub reporting_attribution_model: i32,
    #[prost(
        enumeration = "attribution_settings::AdsWebConversionDataExportScope",
        tag = "5"
    )]
    pub ads_web_conversion_data_export_scope: i32,
}
/// Nested message and enum types in `AttributionSettings`.
pub mod attribution_settings {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AcquisitionConversionEventLookbackWindow {
        Unspecified = 0,
        AcquisitionConversionEventLookbackWindow7Days = 1,
        AcquisitionConversionEventLookbackWindow30Days = 2,
    }
    impl AcquisitionConversionEventLookbackWindow {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AcquisitionConversionEventLookbackWindow::Unspecified => {
                    "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_UNSPECIFIED"
                }
                AcquisitionConversionEventLookbackWindow::AcquisitionConversionEventLookbackWindow7Days => {
                    "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_7_DAYS"
                }
                AcquisitionConversionEventLookbackWindow::AcquisitionConversionEventLookbackWindow30Days => {
                    "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_30_DAYS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_7_DAYS" => {
                    Some(Self::AcquisitionConversionEventLookbackWindow7Days)
                }
                "ACQUISITION_CONVERSION_EVENT_LOOKBACK_WINDOW_30_DAYS" => {
                    Some(Self::AcquisitionConversionEventLookbackWindow30Days)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OtherConversionEventLookbackWindow {
        Unspecified = 0,
        OtherConversionEventLookbackWindow30Days = 1,
        OtherConversionEventLookbackWindow60Days = 2,
        OtherConversionEventLookbackWindow90Days = 3,
    }
    impl OtherConversionEventLookbackWindow {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OtherConversionEventLookbackWindow::Unspecified => {
                    "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_UNSPECIFIED"
                }
                OtherConversionEventLookbackWindow::OtherConversionEventLookbackWindow30Days => {
                    "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_30_DAYS"
                }
                OtherConversionEventLookbackWindow::OtherConversionEventLookbackWindow60Days => {
                    "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_60_DAYS"
                }
                OtherConversionEventLookbackWindow::OtherConversionEventLookbackWindow90Days => {
                    "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_90_DAYS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_30_DAYS" => {
                    Some(Self::OtherConversionEventLookbackWindow30Days)
                }
                "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_60_DAYS" => {
                    Some(Self::OtherConversionEventLookbackWindow60Days)
                }
                "OTHER_CONVERSION_EVENT_LOOKBACK_WINDOW_90_DAYS" => {
                    Some(Self::OtherConversionEventLookbackWindow90Days)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReportingAttributionModel {
        Unspecified = 0,
        PaidAndOrganicChannelsDataDriven = 1,
        PaidAndOrganicChannelsLastClick = 2,
        GooglePaidChannelsLastClick = 7,
    }
    impl ReportingAttributionModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReportingAttributionModel::Unspecified => {
                    "REPORTING_ATTRIBUTION_MODEL_UNSPECIFIED"
                }
                ReportingAttributionModel::PaidAndOrganicChannelsDataDriven => {
                    "PAID_AND_ORGANIC_CHANNELS_DATA_DRIVEN"
                }
                ReportingAttributionModel::PaidAndOrganicChannelsLastClick => {
                    "PAID_AND_ORGANIC_CHANNELS_LAST_CLICK"
                }
                ReportingAttributionModel::GooglePaidChannelsLastClick => {
                    "GOOGLE_PAID_CHANNELS_LAST_CLICK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPORTING_ATTRIBUTION_MODEL_UNSPECIFIED" => Some(Self::Unspecified),
                "PAID_AND_ORGANIC_CHANNELS_DATA_DRIVEN" => {
                    Some(Self::PaidAndOrganicChannelsDataDriven)
                }
                "PAID_AND_ORGANIC_CHANNELS_LAST_CLICK" => {
                    Some(Self::PaidAndOrganicChannelsLastClick)
                }
                "GOOGLE_PAID_CHANNELS_LAST_CLICK" => {
                    Some(Self::GooglePaidChannelsLastClick)
                }
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdsWebConversionDataExportScope {
        Unspecified = 0,
        NotSelectedYet = 1,
        PaidAndOrganicChannels = 2,
        GooglePaidChannels = 3,
    }
    impl AdsWebConversionDataExportScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdsWebConversionDataExportScope::Unspecified => {
                    "ADS_WEB_CONVERSION_DATA_EXPORT_SCOPE_UNSPECIFIED"
                }
                AdsWebConversionDataExportScope::NotSelectedYet => "NOT_SELECTED_YET",
                AdsWebConversionDataExportScope::PaidAndOrganicChannels => {
                    "PAID_AND_ORGANIC_CHANNELS"
                }
                AdsWebConversionDataExportScope::GooglePaidChannels => {
                    "GOOGLE_PAID_CHANNELS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ADS_WEB_CONVERSION_DATA_EXPORT_SCOPE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "NOT_SELECTED_YET" => Some(Self::NotSelectedYet),
                "PAID_AND_ORGANIC_CHANNELS" => Some(Self::PaidAndOrganicChannels),
                "GOOGLE_PAID_CHANNELS" => Some(Self::GooglePaidChannels),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AccessBinding {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub roles: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(oneof = "access_binding::AccessTarget", tags = "2")]
    pub access_target: ::core::option::Option<access_binding::AccessTarget>,
}
/// Nested message and enum types in `AccessBinding`.
pub mod access_binding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AccessTarget {
        #[prost(string, tag = "2")]
        User(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BigQueryLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub project: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "4")]
    pub daily_export_enabled: bool,
    #[prost(bool, tag = "5")]
    pub streaming_export_enabled: bool,
    #[prost(bool, tag = "9")]
    pub fresh_daily_export_enabled: bool,
    #[prost(bool, tag = "6")]
    pub include_advertising_id: bool,
    #[prost(string, repeated, tag = "7")]
    pub export_streams: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub excluded_events: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub dataset_location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnhancedMeasurementSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub stream_enabled: bool,
    #[prost(bool, tag = "3")]
    pub scrolls_enabled: bool,
    #[prost(bool, tag = "4")]
    pub outbound_clicks_enabled: bool,
    #[prost(bool, tag = "5")]
    pub site_search_enabled: bool,
    #[prost(bool, tag = "6")]
    pub video_engagement_enabled: bool,
    #[prost(bool, tag = "7")]
    pub file_downloads_enabled: bool,
    #[prost(bool, tag = "8")]
    pub page_changes_enabled: bool,
    #[prost(bool, tag = "9")]
    pub form_interactions_enabled: bool,
    #[prost(string, tag = "10")]
    pub search_query_parameter: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub uri_query_parameter: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectedSiteTag {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tag_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataRedactionSettings {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub email_redaction_enabled: bool,
    #[prost(bool, tag = "3")]
    pub query_parameter_redaction_enabled: bool,
    #[prost(string, repeated, tag = "4")]
    pub query_parameter_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdSenseLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub ad_client_code: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RollupPropertySourceLink {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub source_property: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndustryCategory {
    Unspecified = 0,
    Automotive = 1,
    BusinessAndIndustrialMarkets = 2,
    Finance = 3,
    Healthcare = 4,
    Technology = 5,
    Travel = 6,
    Other = 7,
    ArtsAndEntertainment = 8,
    BeautyAndFitness = 9,
    BooksAndLiterature = 10,
    FoodAndDrink = 11,
    Games = 12,
    HobbiesAndLeisure = 13,
    HomeAndGarden = 14,
    InternetAndTelecom = 15,
    LawAndGovernment = 16,
    News = 17,
    OnlineCommunities = 18,
    PeopleAndSociety = 19,
    PetsAndAnimals = 20,
    RealEstate = 21,
    Reference = 22,
    Science = 23,
    Sports = 24,
    JobsAndEducation = 25,
    Shopping = 26,
}
impl IndustryCategory {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IndustryCategory::Unspecified => "INDUSTRY_CATEGORY_UNSPECIFIED",
            IndustryCategory::Automotive => "AUTOMOTIVE",
            IndustryCategory::BusinessAndIndustrialMarkets => {
                "BUSINESS_AND_INDUSTRIAL_MARKETS"
            }
            IndustryCategory::Finance => "FINANCE",
            IndustryCategory::Healthcare => "HEALTHCARE",
            IndustryCategory::Technology => "TECHNOLOGY",
            IndustryCategory::Travel => "TRAVEL",
            IndustryCategory::Other => "OTHER",
            IndustryCategory::ArtsAndEntertainment => "ARTS_AND_ENTERTAINMENT",
            IndustryCategory::BeautyAndFitness => "BEAUTY_AND_FITNESS",
            IndustryCategory::BooksAndLiterature => "BOOKS_AND_LITERATURE",
            IndustryCategory::FoodAndDrink => "FOOD_AND_DRINK",
            IndustryCategory::Games => "GAMES",
            IndustryCategory::HobbiesAndLeisure => "HOBBIES_AND_LEISURE",
            IndustryCategory::HomeAndGarden => "HOME_AND_GARDEN",
            IndustryCategory::InternetAndTelecom => "INTERNET_AND_TELECOM",
            IndustryCategory::LawAndGovernment => "LAW_AND_GOVERNMENT",
            IndustryCategory::News => "NEWS",
            IndustryCategory::OnlineCommunities => "ONLINE_COMMUNITIES",
            IndustryCategory::PeopleAndSociety => "PEOPLE_AND_SOCIETY",
            IndustryCategory::PetsAndAnimals => "PETS_AND_ANIMALS",
            IndustryCategory::RealEstate => "REAL_ESTATE",
            IndustryCategory::Reference => "REFERENCE",
            IndustryCategory::Science => "SCIENCE",
            IndustryCategory::Sports => "SPORTS",
            IndustryCategory::JobsAndEducation => "JOBS_AND_EDUCATION",
            IndustryCategory::Shopping => "SHOPPING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDUSTRY_CATEGORY_UNSPECIFIED" => Some(Self::Unspecified),
            "AUTOMOTIVE" => Some(Self::Automotive),
            "BUSINESS_AND_INDUSTRIAL_MARKETS" => Some(Self::BusinessAndIndustrialMarkets),
            "FINANCE" => Some(Self::Finance),
            "HEALTHCARE" => Some(Self::Healthcare),
            "TECHNOLOGY" => Some(Self::Technology),
            "TRAVEL" => Some(Self::Travel),
            "OTHER" => Some(Self::Other),
            "ARTS_AND_ENTERTAINMENT" => Some(Self::ArtsAndEntertainment),
            "BEAUTY_AND_FITNESS" => Some(Self::BeautyAndFitness),
            "BOOKS_AND_LITERATURE" => Some(Self::BooksAndLiterature),
            "FOOD_AND_DRINK" => Some(Self::FoodAndDrink),
            "GAMES" => Some(Self::Games),
            "HOBBIES_AND_LEISURE" => Some(Self::HobbiesAndLeisure),
            "HOME_AND_GARDEN" => Some(Self::HomeAndGarden),
            "INTERNET_AND_TELECOM" => Some(Self::InternetAndTelecom),
            "LAW_AND_GOVERNMENT" => Some(Self::LawAndGovernment),
            "NEWS" => Some(Self::News),
            "ONLINE_COMMUNITIES" => Some(Self::OnlineCommunities),
            "PEOPLE_AND_SOCIETY" => Some(Self::PeopleAndSociety),
            "PETS_AND_ANIMALS" => Some(Self::PetsAndAnimals),
            "REAL_ESTATE" => Some(Self::RealEstate),
            "REFERENCE" => Some(Self::Reference),
            "SCIENCE" => Some(Self::Science),
            "SPORTS" => Some(Self::Sports),
            "JOBS_AND_EDUCATION" => Some(Self::JobsAndEducation),
            "SHOPPING" => Some(Self::Shopping),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ServiceLevel {
    Unspecified = 0,
    GoogleAnalyticsStandard = 1,
    GoogleAnalytics360 = 2,
}
impl ServiceLevel {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ServiceLevel::Unspecified => "SERVICE_LEVEL_UNSPECIFIED",
            ServiceLevel::GoogleAnalyticsStandard => "GOOGLE_ANALYTICS_STANDARD",
            ServiceLevel::GoogleAnalytics360 => "GOOGLE_ANALYTICS_360",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SERVICE_LEVEL_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_ANALYTICS_STANDARD" => Some(Self::GoogleAnalyticsStandard),
            "GOOGLE_ANALYTICS_360" => Some(Self::GoogleAnalytics360),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActorType {
    Unspecified = 0,
    User = 1,
    System = 2,
    Support = 3,
}
impl ActorType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActorType::Unspecified => "ACTOR_TYPE_UNSPECIFIED",
            ActorType::User => "USER",
            ActorType::System => "SYSTEM",
            ActorType::Support => "SUPPORT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTOR_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "USER" => Some(Self::User),
            "SYSTEM" => Some(Self::System),
            "SUPPORT" => Some(Self::Support),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ActionType {
    Unspecified = 0,
    Created = 1,
    Updated = 2,
    Deleted = 3,
}
impl ActionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ActionType::Unspecified => "ACTION_TYPE_UNSPECIFIED",
            ActionType::Created => "CREATED",
            ActionType::Updated => "UPDATED",
            ActionType::Deleted => "DELETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ACTION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CREATED" => Some(Self::Created),
            "UPDATED" => Some(Self::Updated),
            "DELETED" => Some(Self::Deleted),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChangeHistoryResourceType {
    Unspecified = 0,
    Account = 1,
    Property = 2,
    FirebaseLink = 6,
    GoogleAdsLink = 7,
    GoogleSignalsSettings = 8,
    ConversionEvent = 9,
    MeasurementProtocolSecret = 10,
    CustomDimension = 11,
    CustomMetric = 12,
    DataRetentionSettings = 13,
    DisplayVideo360AdvertiserLink = 14,
    DisplayVideo360AdvertiserLinkProposal = 15,
    SearchAds360Link = 16,
    DataStream = 18,
    AttributionSettings = 20,
    ExpandedDataSet = 21,
    ChannelGroup = 22,
    BigqueryLink = 23,
    EnhancedMeasurementSettings = 24,
    DataRedactionSettings = 25,
    SkadnetworkConversionValueSchema = 26,
    AdsenseLink = 27,
    Audience = 28,
    EventCreateRule = 29,
    CalculatedMetric = 31,
}
impl ChangeHistoryResourceType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            ChangeHistoryResourceType::Unspecified => {
                "CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED"
            }
            ChangeHistoryResourceType::Account => "ACCOUNT",
            ChangeHistoryResourceType::Property => "PROPERTY",
            ChangeHistoryResourceType::FirebaseLink => "FIREBASE_LINK",
            ChangeHistoryResourceType::GoogleAdsLink => "GOOGLE_ADS_LINK",
            ChangeHistoryResourceType::GoogleSignalsSettings => "GOOGLE_SIGNALS_SETTINGS",
            ChangeHistoryResourceType::ConversionEvent => "CONVERSION_EVENT",
            ChangeHistoryResourceType::MeasurementProtocolSecret => {
                "MEASUREMENT_PROTOCOL_SECRET"
            }
            ChangeHistoryResourceType::CustomDimension => "CUSTOM_DIMENSION",
            ChangeHistoryResourceType::CustomMetric => "CUSTOM_METRIC",
            ChangeHistoryResourceType::DataRetentionSettings => "DATA_RETENTION_SETTINGS",
            ChangeHistoryResourceType::DisplayVideo360AdvertiserLink => {
                "DISPLAY_VIDEO_360_ADVERTISER_LINK"
            }
            ChangeHistoryResourceType::DisplayVideo360AdvertiserLinkProposal => {
                "DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL"
            }
            ChangeHistoryResourceType::SearchAds360Link => "SEARCH_ADS_360_LINK",
            ChangeHistoryResourceType::DataStream => "DATA_STREAM",
            ChangeHistoryResourceType::AttributionSettings => "ATTRIBUTION_SETTINGS",
            ChangeHistoryResourceType::ExpandedDataSet => "EXPANDED_DATA_SET",
            ChangeHistoryResourceType::ChannelGroup => "CHANNEL_GROUP",
            ChangeHistoryResourceType::BigqueryLink => "BIGQUERY_LINK",
            ChangeHistoryResourceType::EnhancedMeasurementSettings => {
                "ENHANCED_MEASUREMENT_SETTINGS"
            }
            ChangeHistoryResourceType::DataRedactionSettings => "DATA_REDACTION_SETTINGS",
            ChangeHistoryResourceType::SkadnetworkConversionValueSchema => {
                "SKADNETWORK_CONVERSION_VALUE_SCHEMA"
            }
            ChangeHistoryResourceType::AdsenseLink => "ADSENSE_LINK",
            ChangeHistoryResourceType::Audience => "AUDIENCE",
            ChangeHistoryResourceType::EventCreateRule => "EVENT_CREATE_RULE",
            ChangeHistoryResourceType::CalculatedMetric => "CALCULATED_METRIC",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHANGE_HISTORY_RESOURCE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ACCOUNT" => Some(Self::Account),
            "PROPERTY" => Some(Self::Property),
            "FIREBASE_LINK" => Some(Self::FirebaseLink),
            "GOOGLE_ADS_LINK" => Some(Self::GoogleAdsLink),
            "GOOGLE_SIGNALS_SETTINGS" => Some(Self::GoogleSignalsSettings),
            "CONVERSION_EVENT" => Some(Self::ConversionEvent),
            "MEASUREMENT_PROTOCOL_SECRET" => Some(Self::MeasurementProtocolSecret),
            "CUSTOM_DIMENSION" => Some(Self::CustomDimension),
            "CUSTOM_METRIC" => Some(Self::CustomMetric),
            "DATA_RETENTION_SETTINGS" => Some(Self::DataRetentionSettings),
            "DISPLAY_VIDEO_360_ADVERTISER_LINK" => {
                Some(Self::DisplayVideo360AdvertiserLink)
            }
            "DISPLAY_VIDEO_360_ADVERTISER_LINK_PROPOSAL" => {
                Some(Self::DisplayVideo360AdvertiserLinkProposal)
            }
            "SEARCH_ADS_360_LINK" => Some(Self::SearchAds360Link),
            "DATA_STREAM" => Some(Self::DataStream),
            "ATTRIBUTION_SETTINGS" => Some(Self::AttributionSettings),
            "EXPANDED_DATA_SET" => Some(Self::ExpandedDataSet),
            "CHANNEL_GROUP" => Some(Self::ChannelGroup),
            "BIGQUERY_LINK" => Some(Self::BigqueryLink),
            "ENHANCED_MEASUREMENT_SETTINGS" => Some(Self::EnhancedMeasurementSettings),
            "DATA_REDACTION_SETTINGS" => Some(Self::DataRedactionSettings),
            "SKADNETWORK_CONVERSION_VALUE_SCHEMA" => {
                Some(Self::SkadnetworkConversionValueSchema)
            }
            "ADSENSE_LINK" => Some(Self::AdsenseLink),
            "AUDIENCE" => Some(Self::Audience),
            "EVENT_CREATE_RULE" => Some(Self::EventCreateRule),
            "CALCULATED_METRIC" => Some(Self::CalculatedMetric),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoogleSignalsState {
    Unspecified = 0,
    GoogleSignalsEnabled = 1,
    GoogleSignalsDisabled = 2,
}
impl GoogleSignalsState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GoogleSignalsState::Unspecified => "GOOGLE_SIGNALS_STATE_UNSPECIFIED",
            GoogleSignalsState::GoogleSignalsEnabled => "GOOGLE_SIGNALS_ENABLED",
            GoogleSignalsState::GoogleSignalsDisabled => "GOOGLE_SIGNALS_DISABLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GOOGLE_SIGNALS_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_SIGNALS_ENABLED" => Some(Self::GoogleSignalsEnabled),
            "GOOGLE_SIGNALS_DISABLED" => Some(Self::GoogleSignalsDisabled),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GoogleSignalsConsent {
    Unspecified = 0,
    Consented = 2,
    NotConsented = 1,
}
impl GoogleSignalsConsent {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            GoogleSignalsConsent::Unspecified => "GOOGLE_SIGNALS_CONSENT_UNSPECIFIED",
            GoogleSignalsConsent::Consented => "GOOGLE_SIGNALS_CONSENT_CONSENTED",
            GoogleSignalsConsent::NotConsented => "GOOGLE_SIGNALS_CONSENT_NOT_CONSENTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GOOGLE_SIGNALS_CONSENT_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_SIGNALS_CONSENT_CONSENTED" => Some(Self::Consented),
            "GOOGLE_SIGNALS_CONSENT_NOT_CONSENTED" => Some(Self::NotConsented),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkProposalInitiatingProduct {
    Unspecified = 0,
    GoogleAnalytics = 1,
    LinkedProduct = 2,
}
impl LinkProposalInitiatingProduct {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkProposalInitiatingProduct::Unspecified => {
                "LINK_PROPOSAL_INITIATING_PRODUCT_UNSPECIFIED"
            }
            LinkProposalInitiatingProduct::GoogleAnalytics => "GOOGLE_ANALYTICS",
            LinkProposalInitiatingProduct::LinkedProduct => "LINKED_PRODUCT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_PROPOSAL_INITIATING_PRODUCT_UNSPECIFIED" => Some(Self::Unspecified),
            "GOOGLE_ANALYTICS" => Some(Self::GoogleAnalytics),
            "LINKED_PRODUCT" => Some(Self::LinkedProduct),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LinkProposalState {
    Unspecified = 0,
    AwaitingReviewFromGoogleAnalytics = 1,
    AwaitingReviewFromLinkedProduct = 2,
    Withdrawn = 3,
    Declined = 4,
    Expired = 5,
    Obsolete = 6,
}
impl LinkProposalState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LinkProposalState::Unspecified => "LINK_PROPOSAL_STATE_UNSPECIFIED",
            LinkProposalState::AwaitingReviewFromGoogleAnalytics => {
                "AWAITING_REVIEW_FROM_GOOGLE_ANALYTICS"
            }
            LinkProposalState::AwaitingReviewFromLinkedProduct => {
                "AWAITING_REVIEW_FROM_LINKED_PRODUCT"
            }
            LinkProposalState::Withdrawn => "WITHDRAWN",
            LinkProposalState::Declined => "DECLINED",
            LinkProposalState::Expired => "EXPIRED",
            LinkProposalState::Obsolete => "OBSOLETE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LINK_PROPOSAL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
            "AWAITING_REVIEW_FROM_GOOGLE_ANALYTICS" => {
                Some(Self::AwaitingReviewFromGoogleAnalytics)
            }
            "AWAITING_REVIEW_FROM_LINKED_PRODUCT" => {
                Some(Self::AwaitingReviewFromLinkedProduct)
            }
            "WITHDRAWN" => Some(Self::Withdrawn),
            "DECLINED" => Some(Self::Declined),
            "EXPIRED" => Some(Self::Expired),
            "OBSOLETE" => Some(Self::Obsolete),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PropertyType {
    Unspecified = 0,
    Ordinary = 1,
    Subproperty = 2,
    Rollup = 3,
}
impl PropertyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            PropertyType::Unspecified => "PROPERTY_TYPE_UNSPECIFIED",
            PropertyType::Ordinary => "PROPERTY_TYPE_ORDINARY",
            PropertyType::Subproperty => "PROPERTY_TYPE_SUBPROPERTY",
            PropertyType::Rollup => "PROPERTY_TYPE_ROLLUP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROPERTY_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PROPERTY_TYPE_ORDINARY" => Some(Self::Ordinary),
            "PROPERTY_TYPE_SUBPROPERTY" => Some(Self::Subproperty),
            "PROPERTY_TYPE_ROLLUP" => Some(Self::Rollup),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CoarseValue {
    Unspecified = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}
impl CoarseValue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CoarseValue::Unspecified => "COARSE_VALUE_UNSPECIFIED",
            CoarseValue::Low => "COARSE_VALUE_LOW",
            CoarseValue::Medium => "COARSE_VALUE_MEDIUM",
            CoarseValue::High => "COARSE_VALUE_HIGH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COARSE_VALUE_UNSPECIFIED" => Some(Self::Unspecified),
            "COARSE_VALUE_LOW" => Some(Self::Low),
            "COARSE_VALUE_MEDIUM" => Some(Self::Medium),
            "COARSE_VALUE_HIGH" => Some(Self::High),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubpropertyEventFilterCondition {
    #[prost(string, tag = "1")]
    pub field_name: ::prost::alloc::string::String,
    #[prost(oneof = "subproperty_event_filter_condition::OneFilter", tags = "2, 3")]
    pub one_filter: ::core::option::Option<
        subproperty_event_filter_condition::OneFilter,
    >,
}
/// Nested message and enum types in `SubpropertyEventFilterCondition`.
pub mod subproperty_event_filter_condition {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StringFilter {
        #[prost(enumeration = "string_filter::MatchType", tag = "1")]
        pub match_type: i32,
        #[prost(string, tag = "2")]
        pub value: ::prost::alloc::string::String,
        #[prost(bool, tag = "3")]
        pub case_sensitive: bool,
    }
    /// Nested message and enum types in `StringFilter`.
    pub mod string_filter {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum MatchType {
            Unspecified = 0,
            Exact = 1,
            BeginsWith = 2,
            EndsWith = 3,
            Contains = 4,
            FullRegexp = 5,
            PartialRegexp = 6,
        }
        impl MatchType {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    MatchType::Unspecified => "MATCH_TYPE_UNSPECIFIED",
                    MatchType::Exact => "EXACT",
                    MatchType::BeginsWith => "BEGINS_WITH",
                    MatchType::EndsWith => "ENDS_WITH",
                    MatchType::Contains => "CONTAINS",
                    MatchType::FullRegexp => "FULL_REGEXP",
                    MatchType::PartialRegexp => "PARTIAL_REGEXP",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "MATCH_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                    "EXACT" => Some(Self::Exact),
                    "BEGINS_WITH" => Some(Self::BeginsWith),
                    "ENDS_WITH" => Some(Self::EndsWith),
                    "CONTAINS" => Some(Self::Contains),
                    "FULL_REGEXP" => Some(Self::FullRegexp),
                    "PARTIAL_REGEXP" => Some(Self::PartialRegexp),
                    _ => None,
                }
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum OneFilter {
        #[prost(bool, tag = "2")]
        NullFilter(bool),
        #[prost(message, tag = "3")]
        StringFilter(StringFilter),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubpropertyEventFilterExpression {
    #[prost(oneof = "subproperty_event_filter_expression::Expr", tags = "1, 2, 3")]
    pub expr: ::core::option::Option<subproperty_event_filter_expression::Expr>,
}
/// Nested message and enum types in `SubpropertyEventFilterExpression`.
pub mod subproperty_event_filter_expression {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Expr {
        #[prost(message, tag = "1")]
        OrGroup(super::SubpropertyEventFilterExpressionList),
        #[prost(message, tag = "2")]
        NotExpression(
            ::prost::alloc::boxed::Box<super::SubpropertyEventFilterExpression>,
        ),
        #[prost(message, tag = "3")]
        FilterCondition(super::SubpropertyEventFilterCondition),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubpropertyEventFilterExpressionList {
    #[prost(message, repeated, tag = "1")]
    pub filter_expressions: ::prost::alloc::vec::Vec<SubpropertyEventFilterExpression>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubpropertyEventFilterClause {
    #[prost(
        enumeration = "subproperty_event_filter_clause::FilterClauseType",
        tag = "1"
    )]
    pub filter_clause_type: i32,
    #[prost(message, optional, tag = "2")]
    pub filter_expression: ::core::option::Option<SubpropertyEventFilterExpression>,
}
/// Nested message and enum types in `SubpropertyEventFilterClause`.
pub mod subproperty_event_filter_clause {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FilterClauseType {
        Unspecified = 0,
        Include = 1,
        Exclude = 2,
    }
    impl FilterClauseType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FilterClauseType::Unspecified => "FILTER_CLAUSE_TYPE_UNSPECIFIED",
                FilterClauseType::Include => "INCLUDE",
                FilterClauseType::Exclude => "EXCLUDE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FILTER_CLAUSE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUDE" => Some(Self::Include),
                "EXCLUDE" => Some(Self::Exclude),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubpropertyEventFilter {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub apply_to_property: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub filter_clauses: ::prost::alloc::vec::Vec<SubpropertyEventFilterClause>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunAccessReportRequest {
    #[prost(string, tag = "1")]
    pub entity: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub dimensions: ::prost::alloc::vec::Vec<AccessDimension>,
    #[prost(message, repeated, tag = "3")]
    pub metrics: ::prost::alloc::vec::Vec<AccessMetric>,
    #[prost(message, repeated, tag = "4")]
    pub date_ranges: ::prost::alloc::vec::Vec<AccessDateRange>,
    #[prost(message, optional, tag = "5")]
    pub dimension_filter: ::core::option::Option<AccessFilterExpression>,
    #[prost(message, optional, tag = "6")]
    pub metric_filter: ::core::option::Option<AccessFilterExpression>,
    #[prost(int64, tag = "7")]
    pub offset: i64,
    #[prost(int64, tag = "8")]
    pub limit: i64,
    #[prost(string, tag = "9")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "10")]
    pub order_bys: ::prost::alloc::vec::Vec<AccessOrderBy>,
    #[prost(bool, tag = "11")]
    pub return_entity_quota: bool,
    #[prost(bool, tag = "12")]
    pub include_all_users: bool,
    #[prost(bool, tag = "13")]
    pub expand_groups: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunAccessReportResponse {
    #[prost(message, repeated, tag = "1")]
    pub dimension_headers: ::prost::alloc::vec::Vec<AccessDimensionHeader>,
    #[prost(message, repeated, tag = "2")]
    pub metric_headers: ::prost::alloc::vec::Vec<AccessMetricHeader>,
    #[prost(message, repeated, tag = "3")]
    pub rows: ::prost::alloc::vec::Vec<AccessRow>,
    #[prost(int32, tag = "4")]
    pub row_count: i32,
    #[prost(message, optional, tag = "5")]
    pub quota: ::core::option::Option<AccessQuota>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccountRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountsRequest {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub show_deleted: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountsResponse {
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<Account>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccountRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionAccountTicketRequest {
    #[prost(message, optional, tag = "1")]
    pub account: ::core::option::Option<Account>,
    #[prost(string, tag = "2")]
    pub redirect_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionAccountTicketResponse {
    #[prost(string, tag = "1")]
    pub account_ticket_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPropertyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPropertiesRequest {
    #[prost(string, tag = "1")]
    pub filter: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(bool, tag = "4")]
    pub show_deleted: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListPropertiesResponse {
    #[prost(message, repeated, tag = "1")]
    pub properties: ::prost::alloc::vec::Vec<Property>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdatePropertyRequest {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<Property>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePropertyRequest {
    #[prost(message, optional, tag = "1")]
    pub property: ::core::option::Option<Property>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletePropertyRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateFirebaseLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub firebase_link: ::core::option::Option<FirebaseLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteFirebaseLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirebaseLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListFirebaseLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub firebase_links: ::prost::alloc::vec::Vec<FirebaseLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGlobalSiteTagRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateGoogleAdsLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub google_ads_link: ::core::option::Option<GoogleAdsLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGoogleAdsLinkRequest {
    #[prost(message, optional, tag = "1")]
    pub google_ads_link: ::core::option::Option<GoogleAdsLink>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteGoogleAdsLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGoogleAdsLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGoogleAdsLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub google_ads_links: ::prost::alloc::vec::Vec<GoogleAdsLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataSharingSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountSummariesRequest {
    #[prost(int32, tag = "1")]
    pub page_size: i32,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccountSummariesResponse {
    #[prost(message, repeated, tag = "1")]
    pub account_summaries: ::prost::alloc::vec::Vec<AccountSummary>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AcknowledgeUserDataCollectionRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub acknowledgement: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AcknowledgeUserDataCollectionResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchChangeHistoryEventsRequest {
    #[prost(string, tag = "1")]
    pub account: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub property: ::prost::alloc::string::String,
    #[prost(
        enumeration = "ChangeHistoryResourceType",
        repeated,
        packed = "false",
        tag = "3"
    )]
    pub resource_type: ::prost::alloc::vec::Vec<i32>,
    #[prost(enumeration = "ActionType", repeated, packed = "false", tag = "4")]
    pub action: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, repeated, tag = "5")]
    pub actor_email: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "6")]
    pub earliest_change_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "7")]
    pub latest_change_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(int32, tag = "8")]
    pub page_size: i32,
    #[prost(string, tag = "9")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchChangeHistoryEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub change_history_events: ::prost::alloc::vec::Vec<ChangeHistoryEvent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMeasurementProtocolSecretRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateMeasurementProtocolSecretRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub measurement_protocol_secret: ::core::option::Option<MeasurementProtocolSecret>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteMeasurementProtocolSecretRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateMeasurementProtocolSecretRequest {
    #[prost(message, optional, tag = "1")]
    pub measurement_protocol_secret: ::core::option::Option<MeasurementProtocolSecret>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMeasurementProtocolSecretsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListMeasurementProtocolSecretsResponse {
    #[prost(message, repeated, tag = "1")]
    pub measurement_protocol_secrets: ::prost::alloc::vec::Vec<
        MeasurementProtocolSecret,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSkAdNetworkConversionValueSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSkAdNetworkConversionValueSchemaRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub skadnetwork_conversion_value_schema: ::core::option::Option<
        SkAdNetworkConversionValueSchema,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSkAdNetworkConversionValueSchemaRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSkAdNetworkConversionValueSchemaRequest {
    #[prost(message, optional, tag = "1")]
    pub skadnetwork_conversion_value_schema: ::core::option::Option<
        SkAdNetworkConversionValueSchema,
    >,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkAdNetworkConversionValueSchemasRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSkAdNetworkConversionValueSchemasResponse {
    #[prost(message, repeated, tag = "1")]
    pub skadnetwork_conversion_value_schemas: ::prost::alloc::vec::Vec<
        SkAdNetworkConversionValueSchema,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetGoogleSignalsSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateGoogleSignalsSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub google_signals_settings: ::core::option::Option<GoogleSignalsSettings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConversionEventRequest {
    #[prost(message, optional, tag = "1")]
    pub conversion_event: ::core::option::Option<ConversionEvent>,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConversionEventRequest {
    #[prost(message, optional, tag = "1")]
    pub conversion_event: ::core::option::Option<ConversionEvent>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConversionEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConversionEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversionEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConversionEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub conversion_events: ::prost::alloc::vec::Vec<ConversionEvent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateKeyEventRequest {
    #[prost(message, optional, tag = "1")]
    pub key_event: ::core::option::Option<KeyEvent>,
    #[prost(string, tag = "2")]
    pub parent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateKeyEventRequest {
    #[prost(message, optional, tag = "1")]
    pub key_event: ::core::option::Option<KeyEvent>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetKeyEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteKeyEventRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyEventsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListKeyEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub key_events: ::prost::alloc::vec::Vec<KeyEvent>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDisplayVideo360AdvertiserLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisplayVideo360AdvertiserLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisplayVideo360AdvertiserLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub display_video_360_advertiser_links: ::prost::alloc::vec::Vec<
        DisplayVideo360AdvertiserLink,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDisplayVideo360AdvertiserLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub display_video_360_advertiser_link: ::core::option::Option<
        DisplayVideo360AdvertiserLink,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDisplayVideo360AdvertiserLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDisplayVideo360AdvertiserLinkRequest {
    #[prost(message, optional, tag = "1")]
    pub display_video_360_advertiser_link: ::core::option::Option<
        DisplayVideo360AdvertiserLink,
    >,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDisplayVideo360AdvertiserLinkProposalRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisplayVideo360AdvertiserLinkProposalsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDisplayVideo360AdvertiserLinkProposalsResponse {
    #[prost(message, repeated, tag = "1")]
    pub display_video_360_advertiser_link_proposals: ::prost::alloc::vec::Vec<
        DisplayVideo360AdvertiserLinkProposal,
    >,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDisplayVideo360AdvertiserLinkProposalRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub display_video_360_advertiser_link_proposal: ::core::option::Option<
        DisplayVideo360AdvertiserLinkProposal,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDisplayVideo360AdvertiserLinkProposalRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveDisplayVideo360AdvertiserLinkProposalRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApproveDisplayVideo360AdvertiserLinkProposalResponse {
    #[prost(message, optional, tag = "1")]
    pub display_video_360_advertiser_link: ::core::option::Option<
        DisplayVideo360AdvertiserLink,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelDisplayVideo360AdvertiserLinkProposalRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSearchAds360LinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchAds360LinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSearchAds360LinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub search_ads_360_links: ::prost::alloc::vec::Vec<SearchAds360Link>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSearchAds360LinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub search_ads_360_link: ::core::option::Option<SearchAds360Link>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSearchAds360LinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSearchAds360LinkRequest {
    #[prost(message, optional, tag = "1")]
    pub search_ads_360_link: ::core::option::Option<SearchAds360Link>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomDimensionRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_dimension: ::core::option::Option<CustomDimension>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomDimensionRequest {
    #[prost(message, optional, tag = "1")]
    pub custom_dimension: ::core::option::Option<CustomDimension>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomDimensionsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomDimensionsResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_dimensions: ::prost::alloc::vec::Vec<CustomDimension>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchiveCustomDimensionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomDimensionRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCustomMetricRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub custom_metric: ::core::option::Option<CustomMetric>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCustomMetricRequest {
    #[prost(message, optional, tag = "1")]
    pub custom_metric: ::core::option::Option<CustomMetric>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomMetricsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCustomMetricsResponse {
    #[prost(message, repeated, tag = "1")]
    pub custom_metrics: ::prost::alloc::vec::Vec<CustomMetric>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchiveCustomMetricRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCustomMetricRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCalculatedMetricRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub calculated_metric_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub calculated_metric: ::core::option::Option<CalculatedMetric>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCalculatedMetricRequest {
    #[prost(message, optional, tag = "1")]
    pub calculated_metric: ::core::option::Option<CalculatedMetric>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCalculatedMetricRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCalculatedMetricsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCalculatedMetricsResponse {
    #[prost(message, repeated, tag = "1")]
    pub calculated_metrics: ::prost::alloc::vec::Vec<CalculatedMetric>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCalculatedMetricRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataRetentionSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataRetentionSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub data_retention_settings: ::core::option::Option<DataRetentionSettings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDataStreamRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_stream: ::core::option::Option<DataStream>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDataStreamRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataStreamRequest {
    #[prost(message, optional, tag = "1")]
    pub data_stream: ::core::option::Option<DataStream>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStreamsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDataStreamsResponse {
    #[prost(message, repeated, tag = "1")]
    pub data_streams: ::prost::alloc::vec::Vec<DataStream>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataStreamRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAudienceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudiencesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAudiencesResponse {
    #[prost(message, repeated, tag = "1")]
    pub audiences: ::prost::alloc::vec::Vec<Audience>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAudienceRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub audience: ::core::option::Option<Audience>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAudienceRequest {
    #[prost(message, optional, tag = "1")]
    pub audience: ::core::option::Option<Audience>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArchiveAudienceRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAttributionSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAttributionSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub attribution_settings: ::core::option::Option<AttributionSettings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchGetAccessBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_bindings: ::prost::alloc::vec::Vec<AccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAccessBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_bindings: ::prost::alloc::vec::Vec<AccessBinding>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub access_binding: ::core::option::Option<AccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub requests: ::prost::alloc::vec::Vec<CreateAccessBindingRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAccessBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_bindings: ::prost::alloc::vec::Vec<AccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAccessBindingRequest {
    #[prost(message, optional, tag = "1")]
    pub access_binding: ::core::option::Option<AccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<UpdateAccessBindingRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchUpdateAccessBindingsResponse {
    #[prost(message, repeated, tag = "1")]
    pub access_bindings: ::prost::alloc::vec::Vec<AccessBinding>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAccessBindingRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchDeleteAccessBindingsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub requests: ::prost::alloc::vec::Vec<DeleteAccessBindingRequest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateExpandedDataSetRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub expanded_data_set: ::core::option::Option<ExpandedDataSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateExpandedDataSetRequest {
    #[prost(message, optional, tag = "1")]
    pub expanded_data_set: ::core::option::Option<ExpandedDataSet>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteExpandedDataSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetExpandedDataSetRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExpandedDataSetsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListExpandedDataSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub expanded_data_sets: ::prost::alloc::vec::Vec<ExpandedDataSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateChannelGroupRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub channel_group: ::core::option::Option<ChannelGroup>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateChannelGroupRequest {
    #[prost(message, optional, tag = "1")]
    pub channel_group: ::core::option::Option<ChannelGroup>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteChannelGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetChannelGroupRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelGroupsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListChannelGroupsResponse {
    #[prost(message, repeated, tag = "1")]
    pub channel_groups: ::prost::alloc::vec::Vec<ChannelGroup>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetAutomatedGa4ConfigurationOptOutRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub opt_out: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SetAutomatedGa4ConfigurationOptOutResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchAutomatedGa4ConfigurationOptOutRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FetchAutomatedGa4ConfigurationOptOutResponse {
    #[prost(bool, tag = "1")]
    pub opt_out: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateBigQueryLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub bigquery_link: ::core::option::Option<BigQueryLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBigQueryLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBigQueryLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBigQueryLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub bigquery_links: ::prost::alloc::vec::Vec<BigQueryLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateBigQueryLinkRequest {
    #[prost(message, optional, tag = "1")]
    pub bigquery_link: ::core::option::Option<BigQueryLink>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteBigQueryLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEnhancedMeasurementSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEnhancedMeasurementSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub enhanced_measurement_settings: ::core::option::Option<
        EnhancedMeasurementSettings,
    >,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDataRedactionSettingsRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDataRedactionSettingsRequest {
    #[prost(message, optional, tag = "1")]
    pub data_redaction_settings: ::core::option::Option<DataRedactionSettings>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectedSiteTagRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub connected_site_tag: ::core::option::Option<ConnectedSiteTag>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateConnectedSiteTagResponse {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectedSiteTagRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tag_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectedSiteTagsRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectedSiteTagsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connected_site_tags: ::prost::alloc::vec::Vec<ConnectedSiteTag>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAdSenseLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub adsense_link: ::core::option::Option<AdSenseLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAdSenseLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAdSenseLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdSenseLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAdSenseLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub adsense_links: ::prost::alloc::vec::Vec<AdSenseLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchConnectedGa4PropertyRequest {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchConnectedGa4PropertyResponse {
    #[prost(string, tag = "1")]
    pub property: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventCreateRuleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub event_create_rule: ::core::option::Option<EventCreateRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEventCreateRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub event_create_rule: ::core::option::Option<EventCreateRule>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventCreateRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventCreateRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventCreateRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventCreateRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub event_create_rules: ::prost::alloc::vec::Vec<EventCreateRule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateEventEditRuleRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub event_edit_rule: ::core::option::Option<EventEditRule>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateEventEditRuleRequest {
    #[prost(message, optional, tag = "1")]
    pub event_edit_rule: ::core::option::Option<EventEditRule>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteEventEditRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventEditRuleRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventEditRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListEventEditRulesResponse {
    #[prost(message, repeated, tag = "1")]
    pub event_edit_rules: ::prost::alloc::vec::Vec<EventEditRule>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReorderEventEditRulesRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub event_edit_rules: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRollupPropertyRequest {
    #[prost(message, optional, tag = "1")]
    pub rollup_property: ::core::option::Option<Property>,
    #[prost(string, repeated, tag = "2")]
    pub source_properties: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRollupPropertyResponse {
    #[prost(message, optional, tag = "1")]
    pub rollup_property: ::core::option::Option<Property>,
    #[prost(message, repeated, tag = "2")]
    pub rollup_property_source_links: ::prost::alloc::vec::Vec<RollupPropertySourceLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRollupPropertySourceLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRollupPropertySourceLinksRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRollupPropertySourceLinksResponse {
    #[prost(message, repeated, tag = "1")]
    pub rollup_property_source_links: ::prost::alloc::vec::Vec<RollupPropertySourceLink>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRollupPropertySourceLinkRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub rollup_property_source_link: ::core::option::Option<RollupPropertySourceLink>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteRollupPropertySourceLinkRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionSubpropertyRequest {
    #[prost(message, optional, tag = "2")]
    pub subproperty: ::core::option::Option<Property>,
    #[prost(message, optional, tag = "3")]
    pub subproperty_event_filter: ::core::option::Option<SubpropertyEventFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProvisionSubpropertyResponse {
    #[prost(message, optional, tag = "1")]
    pub subproperty: ::core::option::Option<Property>,
    #[prost(message, optional, tag = "2")]
    pub subproperty_event_filter: ::core::option::Option<SubpropertyEventFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSubpropertyEventFilterRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub subproperty_event_filter: ::core::option::Option<SubpropertyEventFilter>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubpropertyEventFilterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubpropertyEventFiltersRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListSubpropertyEventFiltersResponse {
    #[prost(message, repeated, tag = "1")]
    pub subproperty_event_filters: ::prost::alloc::vec::Vec<SubpropertyEventFilter>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateSubpropertyEventFilterRequest {
    #[prost(message, optional, tag = "1")]
    pub subproperty_event_filter: ::core::option::Option<SubpropertyEventFilter>,
    #[prost(message, optional, tag = "2")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteSubpropertyEventFilterRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod analytics_admin_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Service Interface for the Analytics Admin API (GA4).
    #[derive(Debug, Clone)]
    pub struct AnalyticsAdminServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AnalyticsAdminServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnalyticsAdminServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AnalyticsAdminServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lookup for a single Account.
        pub async fn get_account(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::Account>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns all accounts accessible by the caller.
        ///
        /// Note that these accounts might not currently have GA4 properties.
        /// Soft-deleted (ie: "trashed") accounts are excluded by default.
        /// Returns an empty list if no relevant accounts are found.
        pub async fn list_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccountsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Marks target Account as soft-deleted (ie: "trashed") and returns it.
        ///
        /// This API does not have a method to restore soft-deleted accounts.
        /// However, they can be restored using the Trash Can UI.
        ///
        /// If the accounts are not restored before the expiration time, the account
        /// and all child resources (eg: Properties, GoogleAdsLinks, Streams,
        /// AccessBindings) will be permanently purged.
        /// https://support.google.com/analytics/answer/6154772
        ///
        /// Returns an error if the target is not found.
        pub async fn delete_account(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccountRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an account.
        pub async fn update_account(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccountRequest>,
        ) -> std::result::Result<tonic::Response<super::Account>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateAccount",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Requests a ticket for creating an account.
        pub async fn provision_account_ticket(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvisionAccountTicketRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProvisionAccountTicketResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ProvisionAccountTicket",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ProvisionAccountTicket",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns summaries of all accounts accessible by the caller.
        pub async fn list_account_summaries(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccountSummariesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccountSummariesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListAccountSummaries",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListAccountSummaries",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single "GA4" Property.
        pub async fn get_property(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPropertyRequest>,
        ) -> std::result::Result<tonic::Response<super::Property>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetProperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetProperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns child Properties under the specified parent Account.
        ///
        /// Only "GA4" properties will be returned.
        /// Properties will be excluded if the caller does not have access.
        /// Soft-deleted (ie: "trashed") properties are excluded by default.
        /// Returns an empty list if no relevant properties are found.
        pub async fn list_properties(
            &mut self,
            request: impl tonic::IntoRequest<super::ListPropertiesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListPropertiesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListProperties",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListProperties",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an "GA4" property with the specified location and attributes.
        pub async fn create_property(
            &mut self,
            request: impl tonic::IntoRequest<super::CreatePropertyRequest>,
        ) -> std::result::Result<tonic::Response<super::Property>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateProperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateProperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Marks target Property as soft-deleted (ie: "trashed") and returns it.
        ///
        /// This API does not have a method to restore soft-deleted properties.
        /// However, they can be restored using the Trash Can UI.
        ///
        /// If the properties are not restored before the expiration time, the Property
        /// and all child resources (eg: GoogleAdsLinks, Streams, AccessBindings)
        /// will be permanently purged.
        /// https://support.google.com/analytics/answer/6154772
        ///
        /// Returns an error if the target is not found, or is not a GA4 Property.
        pub async fn delete_property(
            &mut self,
            request: impl tonic::IntoRequest<super::DeletePropertyRequest>,
        ) -> std::result::Result<tonic::Response<super::Property>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteProperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteProperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a property.
        pub async fn update_property(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdatePropertyRequest>,
        ) -> std::result::Result<tonic::Response<super::Property>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateProperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateProperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a FirebaseLink.
        ///
        /// Properties can have at most one FirebaseLink.
        pub async fn create_firebase_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateFirebaseLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::FirebaseLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateFirebaseLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateFirebaseLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a FirebaseLink on a property
        pub async fn delete_firebase_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteFirebaseLinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteFirebaseLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteFirebaseLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists FirebaseLinks on a property.
        /// Properties can have at most one FirebaseLink.
        pub async fn list_firebase_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListFirebaseLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListFirebaseLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListFirebaseLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListFirebaseLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the Site Tag for the specified web stream.
        /// Site Tags are immutable singletons.
        pub async fn get_global_site_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGlobalSiteTagRequest>,
        ) -> std::result::Result<tonic::Response<super::GlobalSiteTag>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetGlobalSiteTag",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetGlobalSiteTag",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a GoogleAdsLink.
        pub async fn create_google_ads_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateGoogleAdsLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::GoogleAdsLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateGoogleAdsLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateGoogleAdsLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a GoogleAdsLink on a property
        pub async fn update_google_ads_link(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGoogleAdsLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::GoogleAdsLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateGoogleAdsLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateGoogleAdsLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a GoogleAdsLink on a property
        pub async fn delete_google_ads_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteGoogleAdsLinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteGoogleAdsLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteGoogleAdsLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists GoogleAdsLinks on a property.
        pub async fn list_google_ads_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGoogleAdsLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGoogleAdsLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListGoogleAdsLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListGoogleAdsLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Get data sharing settings on an account.
        /// Data sharing settings are singletons.
        pub async fn get_data_sharing_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataSharingSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataSharingSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDataSharingSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDataSharingSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single "GA4" MeasurementProtocolSecret.
        pub async fn get_measurement_protocol_secret(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMeasurementProtocolSecretRequest>,
        ) -> std::result::Result<
            tonic::Response<super::MeasurementProtocolSecret>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetMeasurementProtocolSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetMeasurementProtocolSecret",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns child MeasurementProtocolSecrets under the specified parent
        /// Property.
        pub async fn list_measurement_protocol_secrets(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListMeasurementProtocolSecretsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListMeasurementProtocolSecretsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListMeasurementProtocolSecrets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListMeasurementProtocolSecrets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a measurement protocol secret.
        pub async fn create_measurement_protocol_secret(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateMeasurementProtocolSecretRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::MeasurementProtocolSecret>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateMeasurementProtocolSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateMeasurementProtocolSecret",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes target MeasurementProtocolSecret.
        pub async fn delete_measurement_protocol_secret(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteMeasurementProtocolSecretRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteMeasurementProtocolSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteMeasurementProtocolSecret",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a measurement protocol secret.
        pub async fn update_measurement_protocol_secret(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateMeasurementProtocolSecretRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::MeasurementProtocolSecret>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateMeasurementProtocolSecret",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateMeasurementProtocolSecret",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Acknowledges the terms of user data collection for the specified property.
        ///
        /// This acknowledgement must be completed (either in the Google Analytics UI
        /// or through this API) before MeasurementProtocolSecret resources may be
        /// created.
        pub async fn acknowledge_user_data_collection(
            &mut self,
            request: impl tonic::IntoRequest<super::AcknowledgeUserDataCollectionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AcknowledgeUserDataCollectionResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/AcknowledgeUserDataCollection",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "AcknowledgeUserDataCollection",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up a single SKAdNetworkConversionValueSchema.
        pub async fn get_sk_ad_network_conversion_value_schema(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetSkAdNetworkConversionValueSchemaRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SkAdNetworkConversionValueSchema>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetSKAdNetworkConversionValueSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetSKAdNetworkConversionValueSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a SKAdNetworkConversionValueSchema.
        pub async fn create_sk_ad_network_conversion_value_schema(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateSkAdNetworkConversionValueSchemaRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SkAdNetworkConversionValueSchema>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateSKAdNetworkConversionValueSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateSKAdNetworkConversionValueSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes target SKAdNetworkConversionValueSchema.
        pub async fn delete_sk_ad_network_conversion_value_schema(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteSkAdNetworkConversionValueSchemaRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteSKAdNetworkConversionValueSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteSKAdNetworkConversionValueSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a SKAdNetworkConversionValueSchema.
        pub async fn update_sk_ad_network_conversion_value_schema(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateSkAdNetworkConversionValueSchemaRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SkAdNetworkConversionValueSchema>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateSKAdNetworkConversionValueSchema",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateSKAdNetworkConversionValueSchema",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists SKAdNetworkConversionValueSchema on a stream.
        /// Properties can have at most one SKAdNetworkConversionValueSchema.
        pub async fn list_sk_ad_network_conversion_value_schemas(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListSkAdNetworkConversionValueSchemasRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListSkAdNetworkConversionValueSchemasResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListSKAdNetworkConversionValueSchemas",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListSKAdNetworkConversionValueSchemas",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches through all changes to an account or its children given the
        /// specified set of filters.
        pub async fn search_change_history_events(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchChangeHistoryEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchChangeHistoryEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/SearchChangeHistoryEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "SearchChangeHistoryEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for Google Signals settings for a property.
        pub async fn get_google_signals_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetGoogleSignalsSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GoogleSignalsSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetGoogleSignalsSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetGoogleSignalsSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates Google Signals settings for a property.
        pub async fn update_google_signals_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateGoogleSignalsSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GoogleSignalsSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateGoogleSignalsSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateGoogleSignalsSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use `CreateKeyEvent` instead.
        /// Creates a conversion event with the specified attributes.
        pub async fn create_conversion_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConversionEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversionEvent>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateConversionEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateConversionEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use `UpdateKeyEvent` instead.
        /// Updates a conversion event with the specified attributes.
        pub async fn update_conversion_event(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConversionEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversionEvent>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateConversionEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateConversionEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use `GetKeyEvent` instead.
        /// Retrieve a single conversion event.
        pub async fn get_conversion_event(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConversionEventRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConversionEvent>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetConversionEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetConversionEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use `DeleteKeyEvent` instead.
        /// Deletes a conversion event in a property.
        pub async fn delete_conversion_event(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConversionEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteConversionEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteConversionEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deprecated: Use `ListKeyEvents` instead.
        /// Returns a list of conversion events in the specified parent property.
        ///
        /// Returns an empty list if no conversion events are found.
        pub async fn list_conversion_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConversionEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConversionEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListConversionEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListConversionEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a Key Event.
        pub async fn create_key_event(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateKeyEventRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateKeyEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateKeyEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a Key Event.
        pub async fn update_key_event(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateKeyEventRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateKeyEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateKeyEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Retrieve a single Key Event.
        pub async fn get_key_event(
            &mut self,
            request: impl tonic::IntoRequest<super::GetKeyEventRequest>,
        ) -> std::result::Result<tonic::Response<super::KeyEvent>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetKeyEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetKeyEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a Key Event.
        pub async fn delete_key_event(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteKeyEventRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteKeyEvent",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteKeyEvent",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of Key Events in the specified parent property.
        /// Returns an empty list if no Key Events are found.
        pub async fn list_key_events(
            &mut self,
            request: impl tonic::IntoRequest<super::ListKeyEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListKeyEventsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListKeyEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListKeyEvents",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Look up a single DisplayVideo360AdvertiserLink
        pub async fn get_display_video360_advertiser_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetDisplayVideo360AdvertiserLinkRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDisplayVideo360AdvertiserLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDisplayVideo360AdvertiserLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all DisplayVideo360AdvertiserLinks on a property.
        pub async fn list_display_video360_advertiser_links(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListDisplayVideo360AdvertiserLinksRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListDisplayVideo360AdvertiserLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListDisplayVideo360AdvertiserLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListDisplayVideo360AdvertiserLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a DisplayVideo360AdvertiserLink.
        /// This can only be utilized by users who have proper authorization both on
        /// the Google Analytics property and on the Display & Video 360 advertiser.
        /// Users who do not have access to the Display & Video 360 advertiser should
        /// instead seek to create a DisplayVideo360LinkProposal.
        pub async fn create_display_video360_advertiser_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateDisplayVideo360AdvertiserLinkRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateDisplayVideo360AdvertiserLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateDisplayVideo360AdvertiserLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DisplayVideo360AdvertiserLink on a property.
        pub async fn delete_display_video360_advertiser_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteDisplayVideo360AdvertiserLinkRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteDisplayVideo360AdvertiserLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteDisplayVideo360AdvertiserLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DisplayVideo360AdvertiserLink on a property.
        pub async fn update_display_video360_advertiser_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateDisplayVideo360AdvertiserLinkRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateDisplayVideo360AdvertiserLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateDisplayVideo360AdvertiserLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single DisplayVideo360AdvertiserLinkProposal.
        pub async fn get_display_video360_advertiser_link_proposal(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetDisplayVideo360AdvertiserLinkProposalRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLinkProposal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDisplayVideo360AdvertiserLinkProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDisplayVideo360AdvertiserLinkProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DisplayVideo360AdvertiserLinkProposals on a property.
        pub async fn list_display_video360_advertiser_link_proposals(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ListDisplayVideo360AdvertiserLinkProposalsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ListDisplayVideo360AdvertiserLinkProposalsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListDisplayVideo360AdvertiserLinkProposals",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListDisplayVideo360AdvertiserLinkProposals",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a DisplayVideo360AdvertiserLinkProposal.
        pub async fn create_display_video360_advertiser_link_proposal(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateDisplayVideo360AdvertiserLinkProposalRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLinkProposal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateDisplayVideo360AdvertiserLinkProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateDisplayVideo360AdvertiserLinkProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DisplayVideo360AdvertiserLinkProposal on a property.
        /// This can only be used on cancelled proposals.
        pub async fn delete_display_video360_advertiser_link_proposal(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteDisplayVideo360AdvertiserLinkProposalRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteDisplayVideo360AdvertiserLinkProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteDisplayVideo360AdvertiserLinkProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Approves a DisplayVideo360AdvertiserLinkProposal.
        /// The DisplayVideo360AdvertiserLinkProposal will be deleted and a new
        /// DisplayVideo360AdvertiserLink will be created.
        pub async fn approve_display_video360_advertiser_link_proposal(
            &mut self,
            request: impl tonic::IntoRequest<
                super::ApproveDisplayVideo360AdvertiserLinkProposalRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::ApproveDisplayVideo360AdvertiserLinkProposalResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ApproveDisplayVideo360AdvertiserLinkProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ApproveDisplayVideo360AdvertiserLinkProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Cancels a DisplayVideo360AdvertiserLinkProposal.
        /// Cancelling can mean either:
        ///
        /// * Declining a proposal initiated from Display & Video 360
        /// * Withdrawing a proposal initiated from Google Analytics
        ///  After being cancelled, a proposal will eventually be deleted automatically.
        pub async fn cancel_display_video360_advertiser_link_proposal(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CancelDisplayVideo360AdvertiserLinkProposalRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::DisplayVideo360AdvertiserLinkProposal>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CancelDisplayVideo360AdvertiserLinkProposal",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CancelDisplayVideo360AdvertiserLinkProposal",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a CustomDimension.
        pub async fn create_custom_dimension(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomDimensionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomDimension>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateCustomDimension",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateCustomDimension",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a CustomDimension on a property.
        pub async fn update_custom_dimension(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomDimensionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomDimension>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateCustomDimension",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateCustomDimension",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CustomDimensions on a property.
        pub async fn list_custom_dimensions(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomDimensionsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomDimensionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListCustomDimensions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListCustomDimensions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives a CustomDimension on a property.
        pub async fn archive_custom_dimension(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchiveCustomDimensionRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ArchiveCustomDimension",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ArchiveCustomDimension",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single CustomDimension.
        pub async fn get_custom_dimension(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomDimensionRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CustomDimension>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetCustomDimension",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetCustomDimension",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a CustomMetric.
        pub async fn create_custom_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCustomMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomMetric>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateCustomMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateCustomMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a CustomMetric on a property.
        pub async fn update_custom_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCustomMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomMetric>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateCustomMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateCustomMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CustomMetrics on a property.
        pub async fn list_custom_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCustomMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCustomMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListCustomMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListCustomMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives a CustomMetric on a property.
        pub async fn archive_custom_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchiveCustomMetricRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ArchiveCustomMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ArchiveCustomMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single CustomMetric.
        pub async fn get_custom_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCustomMetricRequest>,
        ) -> std::result::Result<tonic::Response<super::CustomMetric>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetCustomMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetCustomMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the singleton data retention settings for this property.
        pub async fn get_data_retention_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataRetentionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataRetentionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDataRetentionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDataRetentionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the singleton data retention settings for this property.
        pub async fn update_data_retention_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataRetentionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataRetentionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateDataRetentionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateDataRetentionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a DataStream.
        pub async fn create_data_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDataStreamRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStream>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateDataStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateDataStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a DataStream on a property.
        pub async fn delete_data_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDataStreamRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteDataStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteDataStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataStream on a property.
        pub async fn update_data_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataStreamRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStream>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateDataStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateDataStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists DataStreams on a property.
        pub async fn list_data_streams(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDataStreamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDataStreamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListDataStreams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListDataStreams",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single DataStream.
        pub async fn get_data_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataStreamRequest>,
        ) -> std::result::Result<tonic::Response<super::DataStream>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDataStream",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDataStream",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single Audience.
        /// Audiences created before 2020 may not be supported.
        /// Default audiences will not show filter definitions.
        pub async fn get_audience(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAudienceRequest>,
        ) -> std::result::Result<tonic::Response<super::Audience>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetAudience",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetAudience",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists Audiences on a property.
        /// Audiences created before 2020 may not be supported.
        /// Default audiences will not show filter definitions.
        pub async fn list_audiences(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAudiencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAudiencesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListAudiences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListAudiences",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an Audience.
        pub async fn create_audience(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAudienceRequest>,
        ) -> std::result::Result<tonic::Response<super::Audience>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateAudience",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateAudience",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an Audience on a property.
        pub async fn update_audience(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAudienceRequest>,
        ) -> std::result::Result<tonic::Response<super::Audience>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateAudience",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateAudience",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Archives an Audience on a property.
        pub async fn archive_audience(
            &mut self,
            request: impl tonic::IntoRequest<super::ArchiveAudienceRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ArchiveAudience",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ArchiveAudience",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Look up a single SearchAds360Link
        pub async fn get_search_ads360_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSearchAds360LinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAds360Link>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetSearchAds360Link",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetSearchAds360Link",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all SearchAds360Links on a property.
        pub async fn list_search_ads360_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSearchAds360LinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSearchAds360LinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListSearchAds360Links",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListSearchAds360Links",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a SearchAds360Link.
        pub async fn create_search_ads360_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSearchAds360LinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAds360Link>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateSearchAds360Link",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateSearchAds360Link",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a SearchAds360Link on a property.
        pub async fn delete_search_ads360_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSearchAds360LinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteSearchAds360Link",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteSearchAds360Link",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a SearchAds360Link on a property.
        pub async fn update_search_ads360_link(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSearchAds360LinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAds360Link>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateSearchAds360Link",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateSearchAds360Link",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a AttributionSettings singleton.
        pub async fn get_attribution_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAttributionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AttributionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetAttributionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetAttributionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates attribution settings on a property.
        pub async fn update_attribution_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAttributionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AttributionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateAttributionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateAttributionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a customized report of data access records. The report provides
        /// records of each time a user reads Google Analytics reporting data. Access
        /// records are retained for up to 2 years.
        ///
        /// Data Access Reports can be requested for a property. Reports may be
        /// requested for any property, but dimensions that aren't related to quota can
        /// only be requested on Google Analytics 360 properties. This method is only
        /// available to Administrators.
        ///
        /// These data access records include GA4 UI Reporting, GA4 UI Explorations,
        /// GA4 Data API, and other products like Firebase & Admob that can retrieve
        /// data from Google Analytics through a linkage. These records don't include
        /// property configuration changes like adding a stream or changing a
        /// property's time zone. For configuration change history, see
        /// [searchChangeHistoryEvents](https://developers.google.com/analytics/devguides/config/admin/v1/rest/v1alpha/accounts/searchChangeHistoryEvents).
        pub async fn run_access_report(
            &mut self,
            request: impl tonic::IntoRequest<super::RunAccessReportRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RunAccessReportResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/RunAccessReport",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "RunAccessReport",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an access binding on an account or property.
        pub async fn create_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAccessBindingRequest>,
        ) -> std::result::Result<tonic::Response<super::AccessBinding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about an access binding.
        pub async fn get_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAccessBindingRequest>,
        ) -> std::result::Result<tonic::Response<super::AccessBinding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an access binding on an account or property.
        pub async fn update_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAccessBindingRequest>,
        ) -> std::result::Result<tonic::Response<super::AccessBinding>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an access binding on an account or property.
        pub async fn delete_access_binding(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAccessBindingRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteAccessBinding",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteAccessBinding",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists all access bindings on an account or property.
        pub async fn list_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAccessBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAccessBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates information about multiple access bindings to an account or
        /// property.
        ///
        /// This method is transactional. If any AccessBinding cannot be created, none
        /// of the AccessBindings will be created.
        pub async fn batch_create_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateAccessBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateAccessBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/BatchCreateAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "BatchCreateAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets information about multiple access bindings to an account or property.
        pub async fn batch_get_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchGetAccessBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchGetAccessBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/BatchGetAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "BatchGetAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates information about multiple access bindings to an account or
        /// property.
        pub async fn batch_update_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchUpdateAccessBindingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchUpdateAccessBindingsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/BatchUpdateAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "BatchUpdateAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes information about multiple users' links to an account or property.
        pub async fn batch_delete_access_bindings(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchDeleteAccessBindingsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/BatchDeleteAccessBindings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "BatchDeleteAccessBindings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single ExpandedDataSet.
        pub async fn get_expanded_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetExpandedDataSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExpandedDataSet>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetExpandedDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetExpandedDataSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists ExpandedDataSets on a property.
        pub async fn list_expanded_data_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListExpandedDataSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListExpandedDataSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListExpandedDataSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListExpandedDataSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ExpandedDataSet.
        pub async fn create_expanded_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateExpandedDataSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExpandedDataSet>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateExpandedDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateExpandedDataSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a ExpandedDataSet on a property.
        pub async fn update_expanded_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateExpandedDataSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ExpandedDataSet>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateExpandedDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateExpandedDataSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ExpandedDataSet on a property.
        pub async fn delete_expanded_data_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteExpandedDataSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteExpandedDataSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteExpandedDataSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single ChannelGroup.
        pub async fn get_channel_group(
            &mut self,
            request: impl tonic::IntoRequest<super::GetChannelGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::ChannelGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetChannelGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetChannelGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists ChannelGroups on a property.
        pub async fn list_channel_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListChannelGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListChannelGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListChannelGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListChannelGroups",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a ChannelGroup.
        pub async fn create_channel_group(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateChannelGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::ChannelGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateChannelGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateChannelGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a ChannelGroup.
        pub async fn update_channel_group(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateChannelGroupRequest>,
        ) -> std::result::Result<tonic::Response<super::ChannelGroup>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateChannelGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateChannelGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a ChannelGroup on a property.
        pub async fn delete_channel_group(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteChannelGroupRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteChannelGroup",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteChannelGroup",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the opt out status for the automated GA4 setup process for a UA
        /// property.
        /// Note: this has no effect on GA4 property.
        pub async fn set_automated_ga4_configuration_opt_out(
            &mut self,
            request: impl tonic::IntoRequest<
                super::SetAutomatedGa4ConfigurationOptOutRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::SetAutomatedGa4ConfigurationOptOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/SetAutomatedGa4ConfigurationOptOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "SetAutomatedGa4ConfigurationOptOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Fetches the opt out status for the automated GA4 setup process for a UA
        /// property.
        /// Note: this has no effect on GA4 property.
        pub async fn fetch_automated_ga4_configuration_opt_out(
            &mut self,
            request: impl tonic::IntoRequest<
                super::FetchAutomatedGa4ConfigurationOptOutRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::FetchAutomatedGa4ConfigurationOptOutResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/FetchAutomatedGa4ConfigurationOptOut",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "FetchAutomatedGa4ConfigurationOptOut",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a BigQueryLink.
        pub async fn create_big_query_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateBigQueryLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateBigQueryLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateBigQueryLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single BigQuery Link.
        pub async fn get_big_query_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBigQueryLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetBigQueryLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetBigQueryLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists BigQuery Links on a property.
        pub async fn list_big_query_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBigQueryLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBigQueryLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListBigQueryLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListBigQueryLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a BigQueryLink on a property.
        pub async fn delete_big_query_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteBigQueryLinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteBigQueryLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteBigQueryLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a BigQueryLink.
        pub async fn update_big_query_link(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateBigQueryLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::BigQueryLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateBigQueryLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateBigQueryLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns the enhanced measurement settings for this data stream.
        /// Note that the stream must enable enhanced measurement for these settings to
        /// take effect.
        pub async fn get_enhanced_measurement_settings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::GetEnhancedMeasurementSettingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EnhancedMeasurementSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetEnhancedMeasurementSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetEnhancedMeasurementSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the enhanced measurement settings for this data stream.
        /// Note that the stream must enable enhanced measurement for these settings to
        /// take effect.
        pub async fn update_enhanced_measurement_settings(
            &mut self,
            request: impl tonic::IntoRequest<
                super::UpdateEnhancedMeasurementSettingsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::EnhancedMeasurementSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateEnhancedMeasurementSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateEnhancedMeasurementSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a connected site tag for a Universal Analytics property. You can
        /// create a maximum of 20 connected site tags per property.
        /// Note: This API cannot be used on GA4 properties.
        pub async fn create_connected_site_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectedSiteTagRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateConnectedSiteTagResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateConnectedSiteTag",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateConnectedSiteTag",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a connected site tag for a Universal Analytics property.
        /// Note: this has no effect on GA4 properties.
        pub async fn delete_connected_site_tag(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConnectedSiteTagRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteConnectedSiteTag",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteConnectedSiteTag",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the connected site tags for a Universal Analytics property. A maximum
        /// of 20 connected site tags will be returned. Note: this has no effect on GA4
        /// property.
        pub async fn list_connected_site_tags(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectedSiteTagsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectedSiteTagsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListConnectedSiteTags",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListConnectedSiteTags",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Given a specified UA property, looks up the GA4 property connected to it.
        /// Note: this cannot be used with GA4 properties.
        pub async fn fetch_connected_ga4_property(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchConnectedGa4PropertyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::FetchConnectedGa4PropertyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/FetchConnectedGa4Property",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "FetchConnectedGa4Property",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Looks up a single AdSenseLink.
        pub async fn get_ad_sense_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAdSenseLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::AdSenseLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetAdSenseLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetAdSenseLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an AdSenseLink.
        pub async fn create_ad_sense_link(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAdSenseLinkRequest>,
        ) -> std::result::Result<tonic::Response<super::AdSenseLink>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateAdSenseLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateAdSenseLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an AdSenseLink.
        pub async fn delete_ad_sense_link(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAdSenseLinkRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteAdSenseLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteAdSenseLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists AdSenseLinks on a property.
        pub async fn list_ad_sense_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAdSenseLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAdSenseLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListAdSenseLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListAdSenseLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single EventCreateRule.
        pub async fn get_event_create_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventCreateRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EventCreateRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetEventCreateRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetEventCreateRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EventCreateRules on a web data stream.
        pub async fn list_event_create_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEventCreateRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEventCreateRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListEventCreateRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListEventCreateRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an EventCreateRule.
        pub async fn create_event_create_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEventCreateRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EventCreateRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateEventCreateRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateEventCreateRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an EventCreateRule.
        pub async fn update_event_create_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEventCreateRuleRequest>,
        ) -> std::result::Result<
            tonic::Response<super::EventCreateRule>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateEventCreateRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateEventCreateRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an EventCreateRule.
        pub async fn delete_event_create_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEventCreateRuleRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteEventCreateRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteEventCreateRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single EventEditRule.
        pub async fn get_event_edit_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventEditRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::EventEditRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetEventEditRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetEventEditRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists EventEditRules on a web data stream.
        pub async fn list_event_edit_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ListEventEditRulesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListEventEditRulesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListEventEditRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListEventEditRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates an EventEditRule.
        pub async fn create_event_edit_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateEventEditRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::EventEditRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateEventEditRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateEventEditRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an EventEditRule.
        pub async fn update_event_edit_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateEventEditRuleRequest>,
        ) -> std::result::Result<tonic::Response<super::EventEditRule>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateEventEditRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateEventEditRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an EventEditRule.
        pub async fn delete_event_edit_rule(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteEventEditRuleRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteEventEditRule",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteEventEditRule",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Changes the processing order of event edit rules on the specified stream.
        pub async fn reorder_event_edit_rules(
            &mut self,
            request: impl tonic::IntoRequest<super::ReorderEventEditRulesRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ReorderEventEditRules",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ReorderEventEditRules",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a DataRedactionSettings on a property.
        pub async fn update_data_redaction_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDataRedactionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataRedactionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateDataRedactionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateDataRedactionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single DataRedactionSettings.
        pub async fn get_data_redaction_settings(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDataRedactionSettingsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DataRedactionSettings>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetDataRedactionSettings",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetDataRedactionSettings",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single CalculatedMetric.
        pub async fn get_calculated_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCalculatedMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalculatedMetric>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetCalculatedMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetCalculatedMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a CalculatedMetric.
        pub async fn create_calculated_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCalculatedMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalculatedMetric>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateCalculatedMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateCalculatedMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists CalculatedMetrics on a property.
        pub async fn list_calculated_metrics(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCalculatedMetricsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCalculatedMetricsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListCalculatedMetrics",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListCalculatedMetrics",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a CalculatedMetric on a property.
        pub async fn update_calculated_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCalculatedMetricRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CalculatedMetric>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateCalculatedMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateCalculatedMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a CalculatedMetric on a property.
        pub async fn delete_calculated_metric(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCalculatedMetricRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteCalculatedMetric",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteCalculatedMetric",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a roll-up property and all roll-up property source links.
        pub async fn create_rollup_property(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRollupPropertyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::CreateRollupPropertyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateRollupProperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateRollupProperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single roll-up property source Link.
        /// Only roll-up properties can have source links, so this method will throw an
        /// error if used on other types of properties.
        pub async fn get_rollup_property_source_link(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRollupPropertySourceLinkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RollupPropertySourceLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetRollupPropertySourceLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetRollupPropertySourceLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists roll-up property source Links on a property.
        /// Only roll-up properties can have source links, so this method will throw an
        /// error if used on other types of properties.
        pub async fn list_rollup_property_source_links(
            &mut self,
            request: impl tonic::IntoRequest<super::ListRollupPropertySourceLinksRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListRollupPropertySourceLinksResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListRollupPropertySourceLinks",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListRollupPropertySourceLinks",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a roll-up property source link.
        /// Only roll-up properties can have source links, so this method will throw an
        /// error if used on other types of properties.
        pub async fn create_rollup_property_source_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::CreateRollupPropertySourceLinkRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::RollupPropertySourceLink>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateRollupPropertySourceLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateRollupPropertySourceLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a roll-up property source link.
        /// Only roll-up properties can have source links, so this method will throw an
        /// error if used on other types of properties.
        pub async fn delete_rollup_property_source_link(
            &mut self,
            request: impl tonic::IntoRequest<
                super::DeleteRollupPropertySourceLinkRequest,
            >,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteRollupPropertySourceLink",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteRollupPropertySourceLink",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Create a subproperty and a subproperty event filter that applies to the
        /// created subproperty.
        pub async fn provision_subproperty(
            &mut self,
            request: impl tonic::IntoRequest<super::ProvisionSubpropertyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ProvisionSubpropertyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ProvisionSubproperty",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ProvisionSubproperty",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a subproperty Event Filter.
        pub async fn create_subproperty_event_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateSubpropertyEventFilterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubpropertyEventFilter>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/CreateSubpropertyEventFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "CreateSubpropertyEventFilter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lookup for a single subproperty Event Filter.
        pub async fn get_subproperty_event_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubpropertyEventFilterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubpropertyEventFilter>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/GetSubpropertyEventFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "GetSubpropertyEventFilter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// List all subproperty Event Filters on a property.
        pub async fn list_subproperty_event_filters(
            &mut self,
            request: impl tonic::IntoRequest<super::ListSubpropertyEventFiltersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListSubpropertyEventFiltersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/ListSubpropertyEventFilters",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "ListSubpropertyEventFilters",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a subproperty Event Filter.
        pub async fn update_subproperty_event_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateSubpropertyEventFilterRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubpropertyEventFilter>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/UpdateSubpropertyEventFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "UpdateSubpropertyEventFilter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a subproperty event filter.
        pub async fn delete_subproperty_event_filter(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteSubpropertyEventFilterRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.analytics.admin.v1alpha.AnalyticsAdminService/DeleteSubpropertyEventFilter",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.analytics.admin.v1alpha.AnalyticsAdminService",
                        "DeleteSubpropertyEventFilter",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
