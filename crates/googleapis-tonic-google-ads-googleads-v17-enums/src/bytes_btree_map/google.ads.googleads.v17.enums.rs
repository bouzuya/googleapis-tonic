// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEntryTypeEnum {}
/// Nested message and enum types in `PolicyTopicEntryTypeEnum`.
pub mod policy_topic_entry_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEntryType {
        Unspecified = 0,
        Unknown = 1,
        Prohibited = 2,
        Limited = 4,
        FullyLimited = 8,
        Descriptive = 5,
        Broadening = 6,
        AreaOfInterestOnly = 7,
    }
    impl PolicyTopicEntryType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyTopicEntryType::Unspecified => "UNSPECIFIED",
                PolicyTopicEntryType::Unknown => "UNKNOWN",
                PolicyTopicEntryType::Prohibited => "PROHIBITED",
                PolicyTopicEntryType::Limited => "LIMITED",
                PolicyTopicEntryType::FullyLimited => "FULLY_LIMITED",
                PolicyTopicEntryType::Descriptive => "DESCRIPTIVE",
                PolicyTopicEntryType::Broadening => "BROADENING",
                PolicyTopicEntryType::AreaOfInterestOnly => "AREA_OF_INTEREST_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROHIBITED" => Some(Self::Prohibited),
                "LIMITED" => Some(Self::Limited),
                "FULLY_LIMITED" => Some(Self::FullyLimited),
                "DESCRIPTIVE" => Some(Self::Descriptive),
                "BROADENING" => Some(Self::Broadening),
                "AREA_OF_INTEREST_ONLY" => Some(Self::AreaOfInterestOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationMismatchUrlTypeEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationMismatchUrlTypeEnum`.
pub mod policy_topic_evidence_destination_mismatch_url_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationMismatchUrlType {
        Unspecified = 0,
        Unknown = 1,
        DisplayUrl = 2,
        FinalUrl = 3,
        FinalMobileUrl = 4,
        TrackingUrl = 5,
        MobileTrackingUrl = 6,
    }
    impl PolicyTopicEvidenceDestinationMismatchUrlType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyTopicEvidenceDestinationMismatchUrlType::Unspecified => {
                    "UNSPECIFIED"
                }
                PolicyTopicEvidenceDestinationMismatchUrlType::Unknown => "UNKNOWN",
                PolicyTopicEvidenceDestinationMismatchUrlType::DisplayUrl => {
                    "DISPLAY_URL"
                }
                PolicyTopicEvidenceDestinationMismatchUrlType::FinalUrl => "FINAL_URL",
                PolicyTopicEvidenceDestinationMismatchUrlType::FinalMobileUrl => {
                    "FINAL_MOBILE_URL"
                }
                PolicyTopicEvidenceDestinationMismatchUrlType::TrackingUrl => {
                    "TRACKING_URL"
                }
                PolicyTopicEvidenceDestinationMismatchUrlType::MobileTrackingUrl => {
                    "MOBILE_TRACKING_URL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISPLAY_URL" => Some(Self::DisplayUrl),
                "FINAL_URL" => Some(Self::FinalUrl),
                "FINAL_MOBILE_URL" => Some(Self::FinalMobileUrl),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "MOBILE_TRACKING_URL" => Some(Self::MobileTrackingUrl),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationNotWorkingDeviceEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationNotWorkingDeviceEnum`.
pub mod policy_topic_evidence_destination_not_working_device_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationNotWorkingDevice {
        Unspecified = 0,
        Unknown = 1,
        Desktop = 2,
        Android = 3,
        Ios = 4,
    }
    impl PolicyTopicEvidenceDestinationNotWorkingDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyTopicEvidenceDestinationNotWorkingDevice::Unspecified => {
                    "UNSPECIFIED"
                }
                PolicyTopicEvidenceDestinationNotWorkingDevice::Unknown => "UNKNOWN",
                PolicyTopicEvidenceDestinationNotWorkingDevice::Desktop => "DESKTOP",
                PolicyTopicEvidenceDestinationNotWorkingDevice::Android => "ANDROID",
                PolicyTopicEvidenceDestinationNotWorkingDevice::Ios => "IOS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESKTOP" => Some(Self::Desktop),
                "ANDROID" => Some(Self::Android),
                "IOS" => Some(Self::Ios),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum {}
/// Nested message and enum types in `PolicyTopicEvidenceDestinationNotWorkingDnsErrorTypeEnum`.
pub mod policy_topic_evidence_destination_not_working_dns_error_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyTopicEvidenceDestinationNotWorkingDnsErrorType {
        Unspecified = 0,
        Unknown = 1,
        HostnameNotFound = 2,
        GoogleCrawlerDnsIssue = 3,
    }
    impl PolicyTopicEvidenceDestinationNotWorkingDnsErrorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyTopicEvidenceDestinationNotWorkingDnsErrorType::Unspecified => {
                    "UNSPECIFIED"
                }
                PolicyTopicEvidenceDestinationNotWorkingDnsErrorType::Unknown => {
                    "UNKNOWN"
                }
                PolicyTopicEvidenceDestinationNotWorkingDnsErrorType::HostnameNotFound => {
                    "HOSTNAME_NOT_FOUND"
                }
                PolicyTopicEvidenceDestinationNotWorkingDnsErrorType::GoogleCrawlerDnsIssue => {
                    "GOOGLE_CRAWLER_DNS_ISSUE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HOSTNAME_NOT_FOUND" => Some(Self::HostnameNotFound),
                "GOOGLE_CRAWLER_DNS_ISSUE" => Some(Self::GoogleCrawlerDnsIssue),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkPrimaryStatusEnum {}
/// Nested message and enum types in `AssetLinkPrimaryStatusEnum`.
pub mod asset_link_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        Pending = 5,
        Limited = 6,
        NotEligible = 7,
    }
    impl AssetLinkPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetLinkPrimaryStatus::Unspecified => "UNSPECIFIED",
                AssetLinkPrimaryStatus::Unknown => "UNKNOWN",
                AssetLinkPrimaryStatus::Eligible => "ELIGIBLE",
                AssetLinkPrimaryStatus::Paused => "PAUSED",
                AssetLinkPrimaryStatus::Removed => "REMOVED",
                AssetLinkPrimaryStatus::Pending => "PENDING",
                AssetLinkPrimaryStatus::Limited => "LIMITED",
                AssetLinkPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "LIMITED" => Some(Self::Limited),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AssetLinkPrimaryStatusReasonEnum`.
pub mod asset_link_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        AssetLinkPaused = 2,
        AssetLinkRemoved = 3,
        AssetDisapproved = 4,
        AssetUnderReview = 5,
        AssetApprovedLabeled = 6,
    }
    impl AssetLinkPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetLinkPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                AssetLinkPrimaryStatusReason::Unknown => "UNKNOWN",
                AssetLinkPrimaryStatusReason::AssetLinkPaused => "ASSET_LINK_PAUSED",
                AssetLinkPrimaryStatusReason::AssetLinkRemoved => "ASSET_LINK_REMOVED",
                AssetLinkPrimaryStatusReason::AssetDisapproved => "ASSET_DISAPPROVED",
                AssetLinkPrimaryStatusReason::AssetUnderReview => "ASSET_UNDER_REVIEW",
                AssetLinkPrimaryStatusReason::AssetApprovedLabeled => {
                    "ASSET_APPROVED_LABELED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_LINK_PAUSED" => Some(Self::AssetLinkPaused),
                "ASSET_LINK_REMOVED" => Some(Self::AssetLinkRemoved),
                "ASSET_DISAPPROVED" => Some(Self::AssetDisapproved),
                "ASSET_UNDER_REVIEW" => Some(Self::AssetUnderReview),
                "ASSET_APPROVED_LABELED" => Some(Self::AssetApprovedLabeled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetOfflineEvaluationErrorReasonsEnum {}
/// Nested message and enum types in `AssetOfflineEvaluationErrorReasonsEnum`.
pub mod asset_offline_evaluation_error_reasons_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetOfflineEvaluationErrorReasons {
        Unspecified = 0,
        Unknown = 1,
        PriceAssetDescriptionRepeatsRowHeader = 2,
        PriceAssetRepetitiveHeaders = 3,
        PriceAssetHeaderIncompatibleWithPriceType = 4,
        PriceAssetDescriptionIncompatibleWithItemHeader = 5,
        PriceAssetDescriptionHasPriceQualifier = 6,
        PriceAssetUnsupportedLanguage = 7,
        PriceAssetOtherError = 8,
    }
    impl AssetOfflineEvaluationErrorReasons {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetOfflineEvaluationErrorReasons::Unspecified => "UNSPECIFIED",
                AssetOfflineEvaluationErrorReasons::Unknown => "UNKNOWN",
                AssetOfflineEvaluationErrorReasons::PriceAssetDescriptionRepeatsRowHeader => {
                    "PRICE_ASSET_DESCRIPTION_REPEATS_ROW_HEADER"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetRepetitiveHeaders => {
                    "PRICE_ASSET_REPETITIVE_HEADERS"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetHeaderIncompatibleWithPriceType => {
                    "PRICE_ASSET_HEADER_INCOMPATIBLE_WITH_PRICE_TYPE"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetDescriptionIncompatibleWithItemHeader => {
                    "PRICE_ASSET_DESCRIPTION_INCOMPATIBLE_WITH_ITEM_HEADER"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetDescriptionHasPriceQualifier => {
                    "PRICE_ASSET_DESCRIPTION_HAS_PRICE_QUALIFIER"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetUnsupportedLanguage => {
                    "PRICE_ASSET_UNSUPPORTED_LANGUAGE"
                }
                AssetOfflineEvaluationErrorReasons::PriceAssetOtherError => {
                    "PRICE_ASSET_OTHER_ERROR"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRICE_ASSET_DESCRIPTION_REPEATS_ROW_HEADER" => {
                    Some(Self::PriceAssetDescriptionRepeatsRowHeader)
                }
                "PRICE_ASSET_REPETITIVE_HEADERS" => {
                    Some(Self::PriceAssetRepetitiveHeaders)
                }
                "PRICE_ASSET_HEADER_INCOMPATIBLE_WITH_PRICE_TYPE" => {
                    Some(Self::PriceAssetHeaderIncompatibleWithPriceType)
                }
                "PRICE_ASSET_DESCRIPTION_INCOMPATIBLE_WITH_ITEM_HEADER" => {
                    Some(Self::PriceAssetDescriptionIncompatibleWithItemHeader)
                }
                "PRICE_ASSET_DESCRIPTION_HAS_PRICE_QUALIFIER" => {
                    Some(Self::PriceAssetDescriptionHasPriceQualifier)
                }
                "PRICE_ASSET_UNSUPPORTED_LANGUAGE" => {
                    Some(Self::PriceAssetUnsupportedLanguage)
                }
                "PRICE_ASSET_OTHER_ERROR" => Some(Self::PriceAssetOtherError),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyApprovalStatusEnum {}
/// Nested message and enum types in `PolicyApprovalStatusEnum`.
pub mod policy_approval_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyApprovalStatus {
        Unspecified = 0,
        Unknown = 1,
        Disapproved = 2,
        ApprovedLimited = 3,
        Approved = 4,
        AreaOfInterestOnly = 5,
    }
    impl PolicyApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyApprovalStatus::Unspecified => "UNSPECIFIED",
                PolicyApprovalStatus::Unknown => "UNKNOWN",
                PolicyApprovalStatus::Disapproved => "DISAPPROVED",
                PolicyApprovalStatus::ApprovedLimited => "APPROVED_LIMITED",
                PolicyApprovalStatus::Approved => "APPROVED",
                PolicyApprovalStatus::AreaOfInterestOnly => "AREA_OF_INTEREST_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISAPPROVED" => Some(Self::Disapproved),
                "APPROVED_LIMITED" => Some(Self::ApprovedLimited),
                "APPROVED" => Some(Self::Approved),
                "AREA_OF_INTEREST_ONLY" => Some(Self::AreaOfInterestOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PolicyReviewStatusEnum {}
/// Nested message and enum types in `PolicyReviewStatusEnum`.
pub mod policy_review_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PolicyReviewStatus {
        Unspecified = 0,
        Unknown = 1,
        ReviewInProgress = 2,
        Reviewed = 3,
        UnderAppeal = 4,
        EligibleMayServe = 5,
    }
    impl PolicyReviewStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PolicyReviewStatus::Unspecified => "UNSPECIFIED",
                PolicyReviewStatus::Unknown => "UNKNOWN",
                PolicyReviewStatus::ReviewInProgress => "REVIEW_IN_PROGRESS",
                PolicyReviewStatus::Reviewed => "REVIEWED",
                PolicyReviewStatus::UnderAppeal => "UNDER_APPEAL",
                PolicyReviewStatus::EligibleMayServe => "ELIGIBLE_MAY_SERVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REVIEW_IN_PROGRESS" => Some(Self::ReviewInProgress),
                "REVIEWED" => Some(Self::Reviewed),
                "UNDER_APPEAL" => Some(Self::UnderAppeal),
                "ELIGIBLE_MAY_SERVE" => Some(Self::EligibleMayServe),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetFieldTypeEnum {}
/// Nested message and enum types in `AssetFieldTypeEnum`.
pub mod asset_field_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetFieldType {
        Unspecified = 0,
        Unknown = 1,
        Headline = 2,
        Description = 3,
        MandatoryAdText = 4,
        MarketingImage = 5,
        MediaBundle = 6,
        YoutubeVideo = 7,
        BookOnGoogle = 8,
        LeadForm = 9,
        Promotion = 10,
        Callout = 11,
        StructuredSnippet = 12,
        Sitelink = 13,
        MobileApp = 14,
        HotelCallout = 15,
        Call = 16,
        Price = 24,
        LongHeadline = 17,
        BusinessName = 18,
        SquareMarketingImage = 19,
        PortraitMarketingImage = 20,
        Logo = 21,
        LandscapeLogo = 22,
        Video = 23,
        CallToActionSelection = 25,
        AdImage = 26,
        BusinessLogo = 27,
        HotelProperty = 28,
        DemandGenCarouselCard = 30,
    }
    impl AssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetFieldType::Unspecified => "UNSPECIFIED",
                AssetFieldType::Unknown => "UNKNOWN",
                AssetFieldType::Headline => "HEADLINE",
                AssetFieldType::Description => "DESCRIPTION",
                AssetFieldType::MandatoryAdText => "MANDATORY_AD_TEXT",
                AssetFieldType::MarketingImage => "MARKETING_IMAGE",
                AssetFieldType::MediaBundle => "MEDIA_BUNDLE",
                AssetFieldType::YoutubeVideo => "YOUTUBE_VIDEO",
                AssetFieldType::BookOnGoogle => "BOOK_ON_GOOGLE",
                AssetFieldType::LeadForm => "LEAD_FORM",
                AssetFieldType::Promotion => "PROMOTION",
                AssetFieldType::Callout => "CALLOUT",
                AssetFieldType::StructuredSnippet => "STRUCTURED_SNIPPET",
                AssetFieldType::Sitelink => "SITELINK",
                AssetFieldType::MobileApp => "MOBILE_APP",
                AssetFieldType::HotelCallout => "HOTEL_CALLOUT",
                AssetFieldType::Call => "CALL",
                AssetFieldType::Price => "PRICE",
                AssetFieldType::LongHeadline => "LONG_HEADLINE",
                AssetFieldType::BusinessName => "BUSINESS_NAME",
                AssetFieldType::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                AssetFieldType::PortraitMarketingImage => "PORTRAIT_MARKETING_IMAGE",
                AssetFieldType::Logo => "LOGO",
                AssetFieldType::LandscapeLogo => "LANDSCAPE_LOGO",
                AssetFieldType::Video => "VIDEO",
                AssetFieldType::CallToActionSelection => "CALL_TO_ACTION_SELECTION",
                AssetFieldType::AdImage => "AD_IMAGE",
                AssetFieldType::BusinessLogo => "BUSINESS_LOGO",
                AssetFieldType::HotelProperty => "HOTEL_PROPERTY",
                AssetFieldType::DemandGenCarouselCard => "DEMAND_GEN_CAROUSEL_CARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE" => Some(Self::Headline),
                "DESCRIPTION" => Some(Self::Description),
                "MANDATORY_AD_TEXT" => Some(Self::MandatoryAdText),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "LEAD_FORM" => Some(Self::LeadForm),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "VIDEO" => Some(Self::Video),
                "CALL_TO_ACTION_SELECTION" => Some(Self::CallToActionSelection),
                "AD_IMAGE" => Some(Self::AdImage),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                "DEMAND_GEN_CAROUSEL_CARD" => Some(Self::DemandGenCarouselCard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkStatusEnum {}
/// Nested message and enum types in `AssetLinkStatusEnum`.
pub mod asset_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Paused = 4,
    }
    impl AssetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetLinkStatus::Unspecified => "UNSPECIFIED",
                AssetLinkStatus::Unknown => "UNKNOWN",
                AssetLinkStatus::Enabled => "ENABLED",
                AssetLinkStatus::Removed => "REMOVED",
                AssetLinkStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSourceEnum {}
/// Nested message and enum types in `AssetSourceEnum`.
pub mod asset_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSource {
        Unspecified = 0,
        Unknown = 1,
        Advertiser = 2,
        AutomaticallyCreated = 3,
    }
    impl AssetSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSource::Unspecified => "UNSPECIFIED",
                AssetSource::Unknown => "UNKNOWN",
                AssetSource::Advertiser => "ADVERTISER",
                AssetSource::AutomaticallyCreated => "AUTOMATICALLY_CREATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER" => Some(Self::Advertiser),
                "AUTOMATICALLY_CREATED" => Some(Self::AutomaticallyCreated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanNetworkEnum {}
/// Nested message and enum types in `KeywordPlanNetworkEnum`.
pub mod keyword_plan_network_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanNetwork {
        Unspecified = 0,
        Unknown = 1,
        GoogleSearch = 2,
        GoogleSearchAndPartners = 3,
    }
    impl KeywordPlanNetwork {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanNetwork::Unspecified => "UNSPECIFIED",
                KeywordPlanNetwork::Unknown => "UNKNOWN",
                KeywordPlanNetwork::GoogleSearch => "GOOGLE_SEARCH",
                KeywordPlanNetwork::GoogleSearchAndPartners => {
                    "GOOGLE_SEARCH_AND_PARTNERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_SEARCH" => Some(Self::GoogleSearch),
                "GOOGLE_SEARCH_AND_PARTNERS" => Some(Self::GoogleSearchAndPartners),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetingTypeEnum {}
/// Nested message and enum types in `GeoTargetingTypeEnum`.
pub mod geo_targeting_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetingType {
        Unspecified = 0,
        Unknown = 1,
        AreaOfInterest = 2,
        LocationOfPresence = 3,
    }
    impl GeoTargetingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GeoTargetingType::Unspecified => "UNSPECIFIED",
                GeoTargetingType::Unknown => "UNKNOWN",
                GeoTargetingType::AreaOfInterest => "AREA_OF_INTEREST",
                GeoTargetingType::LocationOfPresence => "LOCATION_OF_PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AREA_OF_INTEREST" => Some(Self::AreaOfInterest),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkedProductTypeEnum {}
/// Nested message and enum types in `LinkedProductTypeEnum`.
pub mod linked_product_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LinkedProductType {
        Unspecified = 0,
        Unknown = 1,
        DataPartner = 2,
        GoogleAds = 3,
        HotelCenter = 7,
        MerchantCenter = 8,
        AdvertisingPartner = 9,
    }
    impl LinkedProductType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LinkedProductType::Unspecified => "UNSPECIFIED",
                LinkedProductType::Unknown => "UNKNOWN",
                LinkedProductType::DataPartner => "DATA_PARTNER",
                LinkedProductType::GoogleAds => "GOOGLE_ADS",
                LinkedProductType::HotelCenter => "HOTEL_CENTER",
                LinkedProductType::MerchantCenter => "MERCHANT_CENTER",
                LinkedProductType::AdvertisingPartner => "ADVERTISING_PARTNER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DATA_PARTNER" => Some(Self::DataPartner),
                "GOOGLE_ADS" => Some(Self::GoogleAds),
                "HOTEL_CENTER" => Some(Self::HotelCenter),
                "MERCHANT_CENTER" => Some(Self::MerchantCenter),
                "ADVERTISING_PARTNER" => Some(Self::AdvertisingPartner),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelTypeEnum`.
pub mod advertising_channel_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelType {
        Unspecified = 0,
        Unknown = 1,
        Search = 2,
        Display = 3,
        Shopping = 4,
        Hotel = 5,
        Video = 6,
        MultiChannel = 7,
        Local = 8,
        Smart = 9,
        PerformanceMax = 10,
        LocalServices = 11,
        Travel = 13,
        DemandGen = 14,
    }
    impl AdvertisingChannelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisingChannelType::Unspecified => "UNSPECIFIED",
                AdvertisingChannelType::Unknown => "UNKNOWN",
                AdvertisingChannelType::Search => "SEARCH",
                AdvertisingChannelType::Display => "DISPLAY",
                AdvertisingChannelType::Shopping => "SHOPPING",
                AdvertisingChannelType::Hotel => "HOTEL",
                AdvertisingChannelType::Video => "VIDEO",
                AdvertisingChannelType::MultiChannel => "MULTI_CHANNEL",
                AdvertisingChannelType::Local => "LOCAL",
                AdvertisingChannelType::Smart => "SMART",
                AdvertisingChannelType::PerformanceMax => "PERFORMANCE_MAX",
                AdvertisingChannelType::LocalServices => "LOCAL_SERVICES",
                AdvertisingChannelType::Travel => "TRAVEL",
                AdvertisingChannelType::DemandGen => "DEMAND_GEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "DISPLAY" => Some(Self::Display),
                "SHOPPING" => Some(Self::Shopping),
                "HOTEL" => Some(Self::Hotel),
                "VIDEO" => Some(Self::Video),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                "LOCAL" => Some(Self::Local),
                "SMART" => Some(Self::Smart),
                "PERFORMANCE_MAX" => Some(Self::PerformanceMax),
                "LOCAL_SERVICES" => Some(Self::LocalServices),
                "TRAVEL" => Some(Self::Travel),
                "DEMAND_GEN" => Some(Self::DemandGen),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceEnum {}
/// Nested message and enum types in `DeviceEnum`.
pub mod device_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Device {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
        Tablet = 3,
        Desktop = 4,
        ConnectedTv = 6,
        Other = 5,
    }
    impl Device {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Device::Unspecified => "UNSPECIFIED",
                Device::Unknown => "UNKNOWN",
                Device::Mobile => "MOBILE",
                Device::Tablet => "TABLET",
                Device::Desktop => "DESKTOP",
                Device::ConnectedTv => "CONNECTED_TV",
                Device::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "TABLET" => Some(Self::Tablet),
                "DESKTOP" => Some(Self::Desktop),
                "CONNECTED_TV" => Some(Self::ConnectedTv),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonalityEventScopeEnum {}
/// Nested message and enum types in `SeasonalityEventScopeEnum`.
pub mod seasonality_event_scope_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SeasonalityEventScope {
        Unspecified = 0,
        Unknown = 1,
        Customer = 2,
        Campaign = 4,
        Channel = 5,
    }
    impl SeasonalityEventScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SeasonalityEventScope::Unspecified => "UNSPECIFIED",
                SeasonalityEventScope::Unknown => "UNKNOWN",
                SeasonalityEventScope::Customer => "CUSTOMER",
                SeasonalityEventScope::Campaign => "CAMPAIGN",
                SeasonalityEventScope::Channel => "CHANNEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                "CHANNEL" => Some(Self::Channel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SeasonalityEventStatusEnum {}
/// Nested message and enum types in `SeasonalityEventStatusEnum`.
pub mod seasonality_event_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SeasonalityEventStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 4,
    }
    impl SeasonalityEventStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SeasonalityEventStatus::Unspecified => "UNSPECIFIED",
                SeasonalityEventStatus::Unknown => "UNKNOWN",
                SeasonalityEventStatus::Enabled => "ENABLED",
                SeasonalityEventStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductAvailabilityEnum {}
/// Nested message and enum types in `ProductAvailabilityEnum`.
pub mod product_availability_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductAvailability {
        Unspecified = 0,
        Unknown = 1,
        InStock = 2,
        OutOfStock = 3,
        Preorder = 4,
    }
    impl ProductAvailability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductAvailability::Unspecified => "UNSPECIFIED",
                ProductAvailability::Unknown => "UNKNOWN",
                ProductAvailability::InStock => "IN_STOCK",
                ProductAvailability::OutOfStock => "OUT_OF_STOCK",
                ProductAvailability::Preorder => "PREORDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IN_STOCK" => Some(Self::InStock),
                "OUT_OF_STOCK" => Some(Self::OutOfStock),
                "PREORDER" => Some(Self::Preorder),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelEnum {}
/// Nested message and enum types in `ProductChannelEnum`.
pub mod product_channel_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannel {
        Unspecified = 0,
        Unknown = 1,
        Online = 2,
        Local = 3,
    }
    impl ProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductChannel::Unspecified => "UNSPECIFIED",
                ProductChannel::Unknown => "UNKNOWN",
                ProductChannel::Online => "ONLINE",
                ProductChannel::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelExclusivityEnum {}
/// Nested message and enum types in `ProductChannelExclusivityEnum`.
pub mod product_channel_exclusivity_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannelExclusivity {
        Unspecified = 0,
        Unknown = 1,
        SingleChannel = 2,
        MultiChannel = 3,
    }
    impl ProductChannelExclusivity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductChannelExclusivity::Unspecified => "UNSPECIFIED",
                ProductChannelExclusivity::Unknown => "UNKNOWN",
                ProductChannelExclusivity::SingleChannel => "SINGLE_CHANNEL",
                ProductChannelExclusivity::MultiChannel => "MULTI_CHANNEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SINGLE_CHANNEL" => Some(Self::SingleChannel),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductConditionEnum {}
/// Nested message and enum types in `ProductConditionEnum`.
pub mod product_condition_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCondition {
        Unspecified = 0,
        Unknown = 1,
        New = 3,
        Refurbished = 4,
        Used = 5,
    }
    impl ProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductCondition::Unspecified => "UNSPECIFIED",
                ProductCondition::Unknown => "UNKNOWN",
                ProductCondition::New => "NEW",
                ProductCondition::Refurbished => "REFURBISHED",
                ProductCondition::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductIssueSeverityEnum {}
/// Nested message and enum types in `ProductIssueSeverityEnum`.
pub mod product_issue_severity_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductIssueSeverity {
        Unspecified = 0,
        Unknown = 1,
        Warning = 2,
        Error = 3,
    }
    impl ProductIssueSeverity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductIssueSeverity::Unspecified => "UNSPECIFIED",
                ProductIssueSeverity::Unknown => "UNKNOWN",
                ProductIssueSeverity::Warning => "WARNING",
                ProductIssueSeverity::Error => "ERROR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WARNING" => Some(Self::Warning),
                "ERROR" => Some(Self::Error),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductStatusEnum {}
/// Nested message and enum types in `ProductStatusEnum`.
pub mod product_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductStatus {
        Unspecified = 0,
        Unknown = 1,
        NotEligible = 2,
        EligibleLimited = 3,
        Eligible = 4,
    }
    impl ProductStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductStatus::Unspecified => "UNSPECIFIED",
                ProductStatus::Unknown => "UNKNOWN",
                ProductStatus::NotEligible => "NOT_ELIGIBLE",
                ProductStatus::EligibleLimited => "ELIGIBLE_LIMITED",
                ProductStatus::Eligible => "ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "ELIGIBLE_LIMITED" => Some(Self::EligibleLimited),
                "ELIGIBLE" => Some(Self::Eligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalTypeEnum {}
/// Nested message and enum types in `AccountBudgetProposalTypeEnum`.
pub mod account_budget_proposal_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalType {
        Unspecified = 0,
        Unknown = 1,
        Create = 2,
        Update = 3,
        End = 4,
        Remove = 5,
    }
    impl AccountBudgetProposalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountBudgetProposalType::Unspecified => "UNSPECIFIED",
                AccountBudgetProposalType::Unknown => "UNKNOWN",
                AccountBudgetProposalType::Create => "CREATE",
                AccountBudgetProposalType::Update => "UPDATE",
                AccountBudgetProposalType::End => "END",
                AccountBudgetProposalType::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "END" => Some(Self::End),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetStatusEnum {}
/// Nested message and enum types in `AccountBudgetStatusEnum`.
pub mod account_budget_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Approved = 3,
        Cancelled = 4,
    }
    impl AccountBudgetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountBudgetStatus::Unspecified => "UNSPECIFIED",
                AccountBudgetStatus::Unknown => "UNKNOWN",
                AccountBudgetStatus::Pending => "PENDING",
                AccountBudgetStatus::Approved => "APPROVED",
                AccountBudgetStatus::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SpendingLimitTypeEnum {}
/// Nested message and enum types in `SpendingLimitTypeEnum`.
pub mod spending_limit_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SpendingLimitType {
        Unspecified = 0,
        Unknown = 1,
        Infinite = 2,
    }
    impl SpendingLimitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SpendingLimitType::Unspecified => "UNSPECIFIED",
                SpendingLimitType::Unknown => "UNKNOWN",
                SpendingLimitType::Infinite => "INFINITE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INFINITE" => Some(Self::Infinite),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TimeTypeEnum {}
/// Nested message and enum types in `TimeTypeEnum`.
pub mod time_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TimeType {
        Unspecified = 0,
        Unknown = 1,
        Now = 2,
        Forever = 3,
    }
    impl TimeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TimeType::Unspecified => "UNSPECIFIED",
                TimeType::Unknown => "UNKNOWN",
                TimeType::Now => "NOW",
                TimeType::Forever => "FOREVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOW" => Some(Self::Now),
                "FOREVER" => Some(Self::Forever),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentMetricEnum {}
/// Nested message and enum types in `ExperimentMetricEnum`.
pub mod experiment_metric_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentMetric {
        Unspecified = 0,
        Unknown = 1,
        Clicks = 2,
        Impressions = 3,
        Cost = 4,
        ConversionsPerInteractionRate = 5,
        CostPerConversion = 6,
        ConversionsValuePerCost = 7,
        AverageCpc = 8,
        Ctr = 9,
        IncrementalConversions = 10,
        CompletedVideoViews = 11,
        CustomAlgorithms = 12,
        Conversions = 13,
        ConversionValue = 14,
    }
    impl ExperimentMetric {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentMetric::Unspecified => "UNSPECIFIED",
                ExperimentMetric::Unknown => "UNKNOWN",
                ExperimentMetric::Clicks => "CLICKS",
                ExperimentMetric::Impressions => "IMPRESSIONS",
                ExperimentMetric::Cost => "COST",
                ExperimentMetric::ConversionsPerInteractionRate => {
                    "CONVERSIONS_PER_INTERACTION_RATE"
                }
                ExperimentMetric::CostPerConversion => "COST_PER_CONVERSION",
                ExperimentMetric::ConversionsValuePerCost => "CONVERSIONS_VALUE_PER_COST",
                ExperimentMetric::AverageCpc => "AVERAGE_CPC",
                ExperimentMetric::Ctr => "CTR",
                ExperimentMetric::IncrementalConversions => "INCREMENTAL_CONVERSIONS",
                ExperimentMetric::CompletedVideoViews => "COMPLETED_VIDEO_VIEWS",
                ExperimentMetric::CustomAlgorithms => "CUSTOM_ALGORITHMS",
                ExperimentMetric::Conversions => "CONVERSIONS",
                ExperimentMetric::ConversionValue => "CONVERSION_VALUE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICKS" => Some(Self::Clicks),
                "IMPRESSIONS" => Some(Self::Impressions),
                "COST" => Some(Self::Cost),
                "CONVERSIONS_PER_INTERACTION_RATE" => {
                    Some(Self::ConversionsPerInteractionRate)
                }
                "COST_PER_CONVERSION" => Some(Self::CostPerConversion),
                "CONVERSIONS_VALUE_PER_COST" => Some(Self::ConversionsValuePerCost),
                "AVERAGE_CPC" => Some(Self::AverageCpc),
                "CTR" => Some(Self::Ctr),
                "INCREMENTAL_CONVERSIONS" => Some(Self::IncrementalConversions),
                "COMPLETED_VIDEO_VIEWS" => Some(Self::CompletedVideoViews),
                "CUSTOM_ALGORITHMS" => Some(Self::CustomAlgorithms),
                "CONVERSIONS" => Some(Self::Conversions),
                "CONVERSION_VALUE" => Some(Self::ConversionValue),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentMetricDirectionEnum {}
/// Nested message and enum types in `ExperimentMetricDirectionEnum`.
pub mod experiment_metric_direction_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentMetricDirection {
        Unspecified = 0,
        Unknown = 1,
        NoChange = 2,
        Increase = 3,
        Decrease = 4,
        NoChangeOrIncrease = 5,
        NoChangeOrDecrease = 6,
    }
    impl ExperimentMetricDirection {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentMetricDirection::Unspecified => "UNSPECIFIED",
                ExperimentMetricDirection::Unknown => "UNKNOWN",
                ExperimentMetricDirection::NoChange => "NO_CHANGE",
                ExperimentMetricDirection::Increase => "INCREASE",
                ExperimentMetricDirection::Decrease => "DECREASE",
                ExperimentMetricDirection::NoChangeOrIncrease => "NO_CHANGE_OR_INCREASE",
                ExperimentMetricDirection::NoChangeOrDecrease => "NO_CHANGE_OR_DECREASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_CHANGE" => Some(Self::NoChange),
                "INCREASE" => Some(Self::Increase),
                "DECREASE" => Some(Self::Decrease),
                "NO_CHANGE_OR_INCREASE" => Some(Self::NoChangeOrIncrease),
                "NO_CHANGE_OR_DECREASE" => Some(Self::NoChangeOrDecrease),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsyncActionStatusEnum {}
/// Nested message and enum types in `AsyncActionStatusEnum`.
pub mod async_action_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AsyncActionStatus {
        Unspecified = 0,
        Unknown = 1,
        NotStarted = 2,
        InProgress = 3,
        Completed = 4,
        Failed = 5,
        CompletedWithWarning = 6,
    }
    impl AsyncActionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AsyncActionStatus::Unspecified => "UNSPECIFIED",
                AsyncActionStatus::Unknown => "UNKNOWN",
                AsyncActionStatus::NotStarted => "NOT_STARTED",
                AsyncActionStatus::InProgress => "IN_PROGRESS",
                AsyncActionStatus::Completed => "COMPLETED",
                AsyncActionStatus::Failed => "FAILED",
                AsyncActionStatus::CompletedWithWarning => "COMPLETED_WITH_WARNING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_STARTED" => Some(Self::NotStarted),
                "IN_PROGRESS" => Some(Self::InProgress),
                "COMPLETED" => Some(Self::Completed),
                "FAILED" => Some(Self::Failed),
                "COMPLETED_WITH_WARNING" => Some(Self::CompletedWithWarning),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentStatusEnum {}
/// Nested message and enum types in `ExperimentStatusEnum`.
pub mod experiment_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Halted = 4,
        Promoted = 5,
        Setup = 6,
        Initiated = 7,
        Graduated = 8,
    }
    impl ExperimentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentStatus::Unspecified => "UNSPECIFIED",
                ExperimentStatus::Unknown => "UNKNOWN",
                ExperimentStatus::Enabled => "ENABLED",
                ExperimentStatus::Removed => "REMOVED",
                ExperimentStatus::Halted => "HALTED",
                ExperimentStatus::Promoted => "PROMOTED",
                ExperimentStatus::Setup => "SETUP",
                ExperimentStatus::Initiated => "INITIATED",
                ExperimentStatus::Graduated => "GRADUATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "HALTED" => Some(Self::Halted),
                "PROMOTED" => Some(Self::Promoted),
                "SETUP" => Some(Self::Setup),
                "INITIATED" => Some(Self::Initiated),
                "GRADUATED" => Some(Self::Graduated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExperimentTypeEnum {}
/// Nested message and enum types in `ExperimentTypeEnum`.
pub mod experiment_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExperimentType {
        Unspecified = 0,
        Unknown = 1,
        DisplayAndVideo360 = 2,
        AdVariation = 3,
        YoutubeCustom = 5,
        DisplayCustom = 6,
        SearchCustom = 7,
        DisplayAutomatedBiddingStrategy = 8,
        SearchAutomatedBiddingStrategy = 9,
        ShoppingAutomatedBiddingStrategy = 10,
        SmartMatching = 11,
        HotelCustom = 12,
    }
    impl ExperimentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExperimentType::Unspecified => "UNSPECIFIED",
                ExperimentType::Unknown => "UNKNOWN",
                ExperimentType::DisplayAndVideo360 => "DISPLAY_AND_VIDEO_360",
                ExperimentType::AdVariation => "AD_VARIATION",
                ExperimentType::YoutubeCustom => "YOUTUBE_CUSTOM",
                ExperimentType::DisplayCustom => "DISPLAY_CUSTOM",
                ExperimentType::SearchCustom => "SEARCH_CUSTOM",
                ExperimentType::DisplayAutomatedBiddingStrategy => {
                    "DISPLAY_AUTOMATED_BIDDING_STRATEGY"
                }
                ExperimentType::SearchAutomatedBiddingStrategy => {
                    "SEARCH_AUTOMATED_BIDDING_STRATEGY"
                }
                ExperimentType::ShoppingAutomatedBiddingStrategy => {
                    "SHOPPING_AUTOMATED_BIDDING_STRATEGY"
                }
                ExperimentType::SmartMatching => "SMART_MATCHING",
                ExperimentType::HotelCustom => "HOTEL_CUSTOM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISPLAY_AND_VIDEO_360" => Some(Self::DisplayAndVideo360),
                "AD_VARIATION" => Some(Self::AdVariation),
                "YOUTUBE_CUSTOM" => Some(Self::YoutubeCustom),
                "DISPLAY_CUSTOM" => Some(Self::DisplayCustom),
                "SEARCH_CUSTOM" => Some(Self::SearchCustom),
                "DISPLAY_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::DisplayAutomatedBiddingStrategy)
                }
                "SEARCH_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::SearchAutomatedBiddingStrategy)
                }
                "SHOPPING_AUTOMATED_BIDDING_STRATEGY" => {
                    Some(Self::ShoppingAutomatedBiddingStrategy)
                }
                "SMART_MATCHING" => Some(Self::SmartMatching),
                "HOTEL_CUSTOM" => Some(Self::HotelCustom),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineConversionDiagnosticStatusEnum {}
/// Nested message and enum types in `OfflineConversionDiagnosticStatusEnum`.
pub mod offline_conversion_diagnostic_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineConversionDiagnosticStatus {
        Unspecified = 0,
        Unknown = 1,
        Excellent = 2,
        Good = 3,
        NeedsAttention = 4,
        NoRecentUpload = 6,
    }
    impl OfflineConversionDiagnosticStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineConversionDiagnosticStatus::Unspecified => "UNSPECIFIED",
                OfflineConversionDiagnosticStatus::Unknown => "UNKNOWN",
                OfflineConversionDiagnosticStatus::Excellent => "EXCELLENT",
                OfflineConversionDiagnosticStatus::Good => "GOOD",
                OfflineConversionDiagnosticStatus::NeedsAttention => "NEEDS_ATTENTION",
                OfflineConversionDiagnosticStatus::NoRecentUpload => "NO_RECENT_UPLOAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXCELLENT" => Some(Self::Excellent),
                "GOOD" => Some(Self::Good),
                "NEEDS_ATTENTION" => Some(Self::NeedsAttention),
                "NO_RECENT_UPLOAD" => Some(Self::NoRecentUpload),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineEventUploadClientEnum {}
/// Nested message and enum types in `OfflineEventUploadClientEnum`.
pub mod offline_event_upload_client_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineEventUploadClient {
        Unspecified = 0,
        Unknown = 1,
        GoogleAdsApi = 2,
        GoogleAdsWebClient = 3,
        AdsDataConnector = 4,
    }
    impl OfflineEventUploadClient {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineEventUploadClient::Unspecified => "UNSPECIFIED",
                OfflineEventUploadClient::Unknown => "UNKNOWN",
                OfflineEventUploadClient::GoogleAdsApi => "GOOGLE_ADS_API",
                OfflineEventUploadClient::GoogleAdsWebClient => "GOOGLE_ADS_WEB_CLIENT",
                OfflineEventUploadClient::AdsDataConnector => "ADS_DATA_CONNECTOR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_ADS_API" => Some(Self::GoogleAdsApi),
                "GOOGLE_ADS_WEB_CLIENT" => Some(Self::GoogleAdsWebClient),
                "ADS_DATA_CONNECTOR" => Some(Self::AdsDataConnector),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeTypeEnum {}
/// Nested message and enum types in `CustomizerAttributeTypeEnum`.
pub mod customizer_attribute_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeType {
        Unspecified = 0,
        Unknown = 1,
        Text = 2,
        Number = 3,
        Price = 4,
        Percent = 5,
    }
    impl CustomizerAttributeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomizerAttributeType::Unspecified => "UNSPECIFIED",
                CustomizerAttributeType::Unknown => "UNKNOWN",
                CustomizerAttributeType::Text => "TEXT",
                CustomizerAttributeType::Number => "NUMBER",
                CustomizerAttributeType::Price => "PRICE",
                CustomizerAttributeType::Percent => "PERCENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "NUMBER" => Some(Self::Number),
                "PRICE" => Some(Self::Price),
                "PERCENT" => Some(Self::Percent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerValueStatusEnum {}
/// Nested message and enum types in `CustomizerValueStatusEnum`.
pub mod customizer_value_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerValueStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CustomizerValueStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomizerValueStatus::Unspecified => "UNSPECIFIED",
                CustomizerValueStatus::Unknown => "UNKNOWN",
                CustomizerValueStatus::Enabled => "ENABLED",
                CustomizerValueStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServedAssetFieldTypeEnum {}
/// Nested message and enum types in `ServedAssetFieldTypeEnum`.
pub mod served_asset_field_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServedAssetFieldType {
        Unspecified = 0,
        Unknown = 1,
        Headline1 = 2,
        Headline2 = 3,
        Headline3 = 4,
        Description1 = 5,
        Description2 = 6,
        Headline = 7,
        HeadlineInPortrait = 8,
        LongHeadline = 9,
        Description = 10,
        DescriptionInPortrait = 11,
        BusinessNameInPortrait = 12,
        BusinessName = 13,
        MarketingImage = 14,
        MarketingImageInPortrait = 15,
        SquareMarketingImage = 16,
        PortraitMarketingImage = 17,
        Logo = 18,
        LandscapeLogo = 19,
        CallToAction = 20,
        YouTubeVideo = 21,
        Sitelink = 22,
        Call = 23,
        MobileApp = 24,
        Callout = 25,
        StructuredSnippet = 26,
        Price = 27,
        Promotion = 28,
        AdImage = 29,
        LeadForm = 30,
        BusinessLogo = 31,
    }
    impl ServedAssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ServedAssetFieldType::Unspecified => "UNSPECIFIED",
                ServedAssetFieldType::Unknown => "UNKNOWN",
                ServedAssetFieldType::Headline1 => "HEADLINE_1",
                ServedAssetFieldType::Headline2 => "HEADLINE_2",
                ServedAssetFieldType::Headline3 => "HEADLINE_3",
                ServedAssetFieldType::Description1 => "DESCRIPTION_1",
                ServedAssetFieldType::Description2 => "DESCRIPTION_2",
                ServedAssetFieldType::Headline => "HEADLINE",
                ServedAssetFieldType::HeadlineInPortrait => "HEADLINE_IN_PORTRAIT",
                ServedAssetFieldType::LongHeadline => "LONG_HEADLINE",
                ServedAssetFieldType::Description => "DESCRIPTION",
                ServedAssetFieldType::DescriptionInPortrait => "DESCRIPTION_IN_PORTRAIT",
                ServedAssetFieldType::BusinessNameInPortrait => {
                    "BUSINESS_NAME_IN_PORTRAIT"
                }
                ServedAssetFieldType::BusinessName => "BUSINESS_NAME",
                ServedAssetFieldType::MarketingImage => "MARKETING_IMAGE",
                ServedAssetFieldType::MarketingImageInPortrait => {
                    "MARKETING_IMAGE_IN_PORTRAIT"
                }
                ServedAssetFieldType::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                ServedAssetFieldType::PortraitMarketingImage => {
                    "PORTRAIT_MARKETING_IMAGE"
                }
                ServedAssetFieldType::Logo => "LOGO",
                ServedAssetFieldType::LandscapeLogo => "LANDSCAPE_LOGO",
                ServedAssetFieldType::CallToAction => "CALL_TO_ACTION",
                ServedAssetFieldType::YouTubeVideo => "YOU_TUBE_VIDEO",
                ServedAssetFieldType::Sitelink => "SITELINK",
                ServedAssetFieldType::Call => "CALL",
                ServedAssetFieldType::MobileApp => "MOBILE_APP",
                ServedAssetFieldType::Callout => "CALLOUT",
                ServedAssetFieldType::StructuredSnippet => "STRUCTURED_SNIPPET",
                ServedAssetFieldType::Price => "PRICE",
                ServedAssetFieldType::Promotion => "PROMOTION",
                ServedAssetFieldType::AdImage => "AD_IMAGE",
                ServedAssetFieldType::LeadForm => "LEAD_FORM",
                ServedAssetFieldType::BusinessLogo => "BUSINESS_LOGO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE_1" => Some(Self::Headline1),
                "HEADLINE_2" => Some(Self::Headline2),
                "HEADLINE_3" => Some(Self::Headline3),
                "DESCRIPTION_1" => Some(Self::Description1),
                "DESCRIPTION_2" => Some(Self::Description2),
                "HEADLINE" => Some(Self::Headline),
                "HEADLINE_IN_PORTRAIT" => Some(Self::HeadlineInPortrait),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "DESCRIPTION" => Some(Self::Description),
                "DESCRIPTION_IN_PORTRAIT" => Some(Self::DescriptionInPortrait),
                "BUSINESS_NAME_IN_PORTRAIT" => Some(Self::BusinessNameInPortrait),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MARKETING_IMAGE_IN_PORTRAIT" => Some(Self::MarketingImageInPortrait),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "YOU_TUBE_VIDEO" => Some(Self::YouTubeVideo),
                "SITELINK" => Some(Self::Sitelink),
                "CALL" => Some(Self::Call),
                "MOBILE_APP" => Some(Self::MobileApp),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "AD_IMAGE" => Some(Self::AdImage),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetLinkStatusEnum {}
/// Nested message and enum types in `AssetSetLinkStatusEnum`.
pub mod asset_set_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AssetSetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetLinkStatus::Unspecified => "UNSPECIFIED",
                AssetSetLinkStatus::Unknown => "UNKNOWN",
                AssetSetLinkStatus::Enabled => "ENABLED",
                AssetSetLinkStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SimulationModificationMethodEnum {}
/// Nested message and enum types in `SimulationModificationMethodEnum`.
pub mod simulation_modification_method_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SimulationModificationMethod {
        Unspecified = 0,
        Unknown = 1,
        Uniform = 2,
        Default = 3,
        Scaling = 4,
    }
    impl SimulationModificationMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SimulationModificationMethod::Unspecified => "UNSPECIFIED",
                SimulationModificationMethod::Unknown => "UNKNOWN",
                SimulationModificationMethod::Uniform => "UNIFORM",
                SimulationModificationMethod::Default => "DEFAULT",
                SimulationModificationMethod::Scaling => "SCALING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNIFORM" => Some(Self::Uniform),
                "DEFAULT" => Some(Self::Default),
                "SCALING" => Some(Self::Scaling),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SimulationTypeEnum {}
/// Nested message and enum types in `SimulationTypeEnum`.
pub mod simulation_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SimulationType {
        Unspecified = 0,
        Unknown = 1,
        CpcBid = 2,
        CpvBid = 3,
        TargetCpa = 4,
        BidModifier = 5,
        TargetRoas = 6,
        PercentCpcBid = 7,
        TargetImpressionShare = 8,
        Budget = 9,
    }
    impl SimulationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SimulationType::Unspecified => "UNSPECIFIED",
                SimulationType::Unknown => "UNKNOWN",
                SimulationType::CpcBid => "CPC_BID",
                SimulationType::CpvBid => "CPV_BID",
                SimulationType::TargetCpa => "TARGET_CPA",
                SimulationType::BidModifier => "BID_MODIFIER",
                SimulationType::TargetRoas => "TARGET_ROAS",
                SimulationType::PercentCpcBid => "PERCENT_CPC_BID",
                SimulationType::TargetImpressionShare => "TARGET_IMPRESSION_SHARE",
                SimulationType::Budget => "BUDGET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CPC_BID" => Some(Self::CpcBid),
                "CPV_BID" => Some(Self::CpvBid),
                "TARGET_CPA" => Some(Self::TargetCpa),
                "BID_MODIFIER" => Some(Self::BidModifier),
                "TARGET_ROAS" => Some(Self::TargetRoas),
                "PERCENT_CPC_BID" => Some(Self::PercentCpcBid),
                "TARGET_IMPRESSION_SHARE" => Some(Self::TargetImpressionShare),
                "BUDGET" => Some(Self::Budget),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantStatusEnum {}
/// Nested message and enum types in `GeoTargetConstantStatusEnum`.
pub mod geo_target_constant_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetConstantStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        RemovalPlanned = 3,
    }
    impl GeoTargetConstantStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GeoTargetConstantStatus::Unspecified => "UNSPECIFIED",
                GeoTargetConstantStatus::Unknown => "UNKNOWN",
                GeoTargetConstantStatus::Enabled => "ENABLED",
                GeoTargetConstantStatus::RemovalPlanned => "REMOVAL_PLANNED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVAL_PLANNED" => Some(Self::RemovalPlanned),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AgeRangeTypeEnum {}
/// Nested message and enum types in `AgeRangeTypeEnum`.
pub mod age_range_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AgeRangeType {
        Unspecified = 0,
        Unknown = 1,
        AgeRange1824 = 503001,
        AgeRange2534 = 503002,
        AgeRange3544 = 503003,
        AgeRange4554 = 503004,
        AgeRange5564 = 503005,
        AgeRange65Up = 503006,
        AgeRangeUndetermined = 503999,
    }
    impl AgeRangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AgeRangeType::Unspecified => "UNSPECIFIED",
                AgeRangeType::Unknown => "UNKNOWN",
                AgeRangeType::AgeRange1824 => "AGE_RANGE_18_24",
                AgeRangeType::AgeRange2534 => "AGE_RANGE_25_34",
                AgeRangeType::AgeRange3544 => "AGE_RANGE_35_44",
                AgeRangeType::AgeRange4554 => "AGE_RANGE_45_54",
                AgeRangeType::AgeRange5564 => "AGE_RANGE_55_64",
                AgeRangeType::AgeRange65Up => "AGE_RANGE_65_UP",
                AgeRangeType::AgeRangeUndetermined => "AGE_RANGE_UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AGE_RANGE_18_24" => Some(Self::AgeRange1824),
                "AGE_RANGE_25_34" => Some(Self::AgeRange2534),
                "AGE_RANGE_35_44" => Some(Self::AgeRange3544),
                "AGE_RANGE_45_54" => Some(Self::AgeRange4554),
                "AGE_RANGE_55_64" => Some(Self::AgeRange5564),
                "AGE_RANGE_65_UP" => Some(Self::AgeRange65Up),
                "AGE_RANGE_UNDETERMINED" => Some(Self::AgeRangeUndetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppPaymentModelTypeEnum {}
/// Nested message and enum types in `AppPaymentModelTypeEnum`.
pub mod app_payment_model_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppPaymentModelType {
        Unspecified = 0,
        Unknown = 1,
        Paid = 30,
    }
    impl AppPaymentModelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppPaymentModelType::Unspecified => "UNSPECIFIED",
                AppPaymentModelType::Unknown => "UNKNOWN",
                AppPaymentModelType::Paid => "PAID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAID" => Some(Self::Paid),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandRequestRejectionReasonEnum {}
/// Nested message and enum types in `BrandRequestRejectionReasonEnum`.
pub mod brand_request_rejection_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandRequestRejectionReason {
        Unspecified = 0,
        Unknown = 1,
        ExistingBrand = 2,
        ExistingBrandVariant = 3,
        IncorrectInformation = 4,
        NotABrand = 5,
    }
    impl BrandRequestRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BrandRequestRejectionReason::Unspecified => "UNSPECIFIED",
                BrandRequestRejectionReason::Unknown => "UNKNOWN",
                BrandRequestRejectionReason::ExistingBrand => "EXISTING_BRAND",
                BrandRequestRejectionReason::ExistingBrandVariant => {
                    "EXISTING_BRAND_VARIANT"
                }
                BrandRequestRejectionReason::IncorrectInformation => {
                    "INCORRECT_INFORMATION"
                }
                BrandRequestRejectionReason::NotABrand => "NOT_A_BRAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXISTING_BRAND" => Some(Self::ExistingBrand),
                "EXISTING_BRAND_VARIANT" => Some(Self::ExistingBrandVariant),
                "INCORRECT_INFORMATION" => Some(Self::IncorrectInformation),
                "NOT_A_BRAND" => Some(Self::NotABrand),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandStateEnum {}
/// Nested message and enum types in `BrandStateEnum`.
pub mod brand_state_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandState {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Deprecated = 3,
        Unverified = 4,
        Approved = 5,
        Cancelled = 6,
        Rejected = 7,
    }
    impl BrandState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BrandState::Unspecified => "UNSPECIFIED",
                BrandState::Unknown => "UNKNOWN",
                BrandState::Enabled => "ENABLED",
                BrandState::Deprecated => "DEPRECATED",
                BrandState::Unverified => "UNVERIFIED",
                BrandState::Approved => "APPROVED",
                BrandState::Cancelled => "CANCELLED",
                BrandState::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "DEPRECATED" => Some(Self::Deprecated),
                "UNVERIFIED" => Some(Self::Unverified),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ContentLabelTypeEnum {}
/// Nested message and enum types in `ContentLabelTypeEnum`.
pub mod content_label_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ContentLabelType {
        Unspecified = 0,
        Unknown = 1,
        SexuallySuggestive = 2,
        BelowTheFold = 3,
        ParkedDomain = 4,
        Juvenile = 6,
        Profanity = 7,
        Tragedy = 8,
        Video = 9,
        VideoRatingDvG = 10,
        VideoRatingDvPg = 11,
        VideoRatingDvT = 12,
        VideoRatingDvMa = 13,
        VideoNotYetRated = 14,
        EmbeddedVideo = 15,
        LiveStreamingVideo = 16,
        SocialIssues = 17,
        BrandSuitabilityContentForFamilies = 18,
        BrandSuitabilityGamesFighting = 19,
        BrandSuitabilityGamesMature = 20,
        BrandSuitabilityHealthSensitive = 21,
        BrandSuitabilityHealthSourceUndetermined = 22,
        BrandSuitabilityNewsRecent = 23,
        BrandSuitabilityNewsSensitive = 24,
        BrandSuitabilityNewsSourceNotFeatured = 25,
        BrandSuitabilityPolitics = 26,
        BrandSuitabilityReligion = 27,
    }
    impl ContentLabelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ContentLabelType::Unspecified => "UNSPECIFIED",
                ContentLabelType::Unknown => "UNKNOWN",
                ContentLabelType::SexuallySuggestive => "SEXUALLY_SUGGESTIVE",
                ContentLabelType::BelowTheFold => "BELOW_THE_FOLD",
                ContentLabelType::ParkedDomain => "PARKED_DOMAIN",
                ContentLabelType::Juvenile => "JUVENILE",
                ContentLabelType::Profanity => "PROFANITY",
                ContentLabelType::Tragedy => "TRAGEDY",
                ContentLabelType::Video => "VIDEO",
                ContentLabelType::VideoRatingDvG => "VIDEO_RATING_DV_G",
                ContentLabelType::VideoRatingDvPg => "VIDEO_RATING_DV_PG",
                ContentLabelType::VideoRatingDvT => "VIDEO_RATING_DV_T",
                ContentLabelType::VideoRatingDvMa => "VIDEO_RATING_DV_MA",
                ContentLabelType::VideoNotYetRated => "VIDEO_NOT_YET_RATED",
                ContentLabelType::EmbeddedVideo => "EMBEDDED_VIDEO",
                ContentLabelType::LiveStreamingVideo => "LIVE_STREAMING_VIDEO",
                ContentLabelType::SocialIssues => "SOCIAL_ISSUES",
                ContentLabelType::BrandSuitabilityContentForFamilies => {
                    "BRAND_SUITABILITY_CONTENT_FOR_FAMILIES"
                }
                ContentLabelType::BrandSuitabilityGamesFighting => {
                    "BRAND_SUITABILITY_GAMES_FIGHTING"
                }
                ContentLabelType::BrandSuitabilityGamesMature => {
                    "BRAND_SUITABILITY_GAMES_MATURE"
                }
                ContentLabelType::BrandSuitabilityHealthSensitive => {
                    "BRAND_SUITABILITY_HEALTH_SENSITIVE"
                }
                ContentLabelType::BrandSuitabilityHealthSourceUndetermined => {
                    "BRAND_SUITABILITY_HEALTH_SOURCE_UNDETERMINED"
                }
                ContentLabelType::BrandSuitabilityNewsRecent => {
                    "BRAND_SUITABILITY_NEWS_RECENT"
                }
                ContentLabelType::BrandSuitabilityNewsSensitive => {
                    "BRAND_SUITABILITY_NEWS_SENSITIVE"
                }
                ContentLabelType::BrandSuitabilityNewsSourceNotFeatured => {
                    "BRAND_SUITABILITY_NEWS_SOURCE_NOT_FEATURED"
                }
                ContentLabelType::BrandSuitabilityPolitics => {
                    "BRAND_SUITABILITY_POLITICS"
                }
                ContentLabelType::BrandSuitabilityReligion => {
                    "BRAND_SUITABILITY_RELIGION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEXUALLY_SUGGESTIVE" => Some(Self::SexuallySuggestive),
                "BELOW_THE_FOLD" => Some(Self::BelowTheFold),
                "PARKED_DOMAIN" => Some(Self::ParkedDomain),
                "JUVENILE" => Some(Self::Juvenile),
                "PROFANITY" => Some(Self::Profanity),
                "TRAGEDY" => Some(Self::Tragedy),
                "VIDEO" => Some(Self::Video),
                "VIDEO_RATING_DV_G" => Some(Self::VideoRatingDvG),
                "VIDEO_RATING_DV_PG" => Some(Self::VideoRatingDvPg),
                "VIDEO_RATING_DV_T" => Some(Self::VideoRatingDvT),
                "VIDEO_RATING_DV_MA" => Some(Self::VideoRatingDvMa),
                "VIDEO_NOT_YET_RATED" => Some(Self::VideoNotYetRated),
                "EMBEDDED_VIDEO" => Some(Self::EmbeddedVideo),
                "LIVE_STREAMING_VIDEO" => Some(Self::LiveStreamingVideo),
                "SOCIAL_ISSUES" => Some(Self::SocialIssues),
                "BRAND_SUITABILITY_CONTENT_FOR_FAMILIES" => {
                    Some(Self::BrandSuitabilityContentForFamilies)
                }
                "BRAND_SUITABILITY_GAMES_FIGHTING" => {
                    Some(Self::BrandSuitabilityGamesFighting)
                }
                "BRAND_SUITABILITY_GAMES_MATURE" => {
                    Some(Self::BrandSuitabilityGamesMature)
                }
                "BRAND_SUITABILITY_HEALTH_SENSITIVE" => {
                    Some(Self::BrandSuitabilityHealthSensitive)
                }
                "BRAND_SUITABILITY_HEALTH_SOURCE_UNDETERMINED" => {
                    Some(Self::BrandSuitabilityHealthSourceUndetermined)
                }
                "BRAND_SUITABILITY_NEWS_RECENT" => Some(Self::BrandSuitabilityNewsRecent),
                "BRAND_SUITABILITY_NEWS_SENSITIVE" => {
                    Some(Self::BrandSuitabilityNewsSensitive)
                }
                "BRAND_SUITABILITY_NEWS_SOURCE_NOT_FEATURED" => {
                    Some(Self::BrandSuitabilityNewsSourceNotFeatured)
                }
                "BRAND_SUITABILITY_POLITICS" => Some(Self::BrandSuitabilityPolitics),
                "BRAND_SUITABILITY_RELIGION" => Some(Self::BrandSuitabilityReligion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DayOfWeekEnum {}
/// Nested message and enum types in `DayOfWeekEnum`.
pub mod day_of_week_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DayOfWeek {
        Unspecified = 0,
        Unknown = 1,
        Monday = 2,
        Tuesday = 3,
        Wednesday = 4,
        Thursday = 5,
        Friday = 6,
        Saturday = 7,
        Sunday = 8,
    }
    impl DayOfWeek {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DayOfWeek::Unspecified => "UNSPECIFIED",
                DayOfWeek::Unknown => "UNKNOWN",
                DayOfWeek::Monday => "MONDAY",
                DayOfWeek::Tuesday => "TUESDAY",
                DayOfWeek::Wednesday => "WEDNESDAY",
                DayOfWeek::Thursday => "THURSDAY",
                DayOfWeek::Friday => "FRIDAY",
                DayOfWeek::Saturday => "SATURDAY",
                DayOfWeek::Sunday => "SUNDAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MONDAY" => Some(Self::Monday),
                "TUESDAY" => Some(Self::Tuesday),
                "WEDNESDAY" => Some(Self::Wednesday),
                "THURSDAY" => Some(Self::Thursday),
                "FRIDAY" => Some(Self::Friday),
                "SATURDAY" => Some(Self::Saturday),
                "SUNDAY" => Some(Self::Sunday),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenderTypeEnum {}
/// Nested message and enum types in `GenderTypeEnum`.
pub mod gender_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GenderType {
        Unspecified = 0,
        Unknown = 1,
        Male = 10,
        Female = 11,
        Undetermined = 20,
    }
    impl GenderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GenderType::Unspecified => "UNSPECIFIED",
                GenderType::Unknown => "UNKNOWN",
                GenderType::Male => "MALE",
                GenderType::Female => "FEMALE",
                GenderType::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MALE" => Some(Self::Male),
                "FEMALE" => Some(Self::Female),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelDateSelectionTypeEnum {}
/// Nested message and enum types in `HotelDateSelectionTypeEnum`.
pub mod hotel_date_selection_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelDateSelectionType {
        Unspecified = 0,
        Unknown = 1,
        DefaultSelection = 50,
        UserSelected = 51,
    }
    impl HotelDateSelectionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelDateSelectionType::Unspecified => "UNSPECIFIED",
                HotelDateSelectionType::Unknown => "UNKNOWN",
                HotelDateSelectionType::DefaultSelection => "DEFAULT_SELECTION",
                HotelDateSelectionType::UserSelected => "USER_SELECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT_SELECTION" => Some(Self::DefaultSelection),
                "USER_SELECTED" => Some(Self::UserSelected),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IncomeRangeTypeEnum {}
/// Nested message and enum types in `IncomeRangeTypeEnum`.
pub mod income_range_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IncomeRangeType {
        Unspecified = 0,
        Unknown = 1,
        IncomeRange050 = 510001,
        IncomeRange5060 = 510002,
        IncomeRange6070 = 510003,
        IncomeRange7080 = 510004,
        IncomeRange8090 = 510005,
        IncomeRange90Up = 510006,
        IncomeRangeUndetermined = 510000,
    }
    impl IncomeRangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IncomeRangeType::Unspecified => "UNSPECIFIED",
                IncomeRangeType::Unknown => "UNKNOWN",
                IncomeRangeType::IncomeRange050 => "INCOME_RANGE_0_50",
                IncomeRangeType::IncomeRange5060 => "INCOME_RANGE_50_60",
                IncomeRangeType::IncomeRange6070 => "INCOME_RANGE_60_70",
                IncomeRangeType::IncomeRange7080 => "INCOME_RANGE_70_80",
                IncomeRangeType::IncomeRange8090 => "INCOME_RANGE_80_90",
                IncomeRangeType::IncomeRange90Up => "INCOME_RANGE_90_UP",
                IncomeRangeType::IncomeRangeUndetermined => "INCOME_RANGE_UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INCOME_RANGE_0_50" => Some(Self::IncomeRange050),
                "INCOME_RANGE_50_60" => Some(Self::IncomeRange5060),
                "INCOME_RANGE_60_70" => Some(Self::IncomeRange6070),
                "INCOME_RANGE_70_80" => Some(Self::IncomeRange7080),
                "INCOME_RANGE_80_90" => Some(Self::IncomeRange8090),
                "INCOME_RANGE_90_UP" => Some(Self::IncomeRange90Up),
                "INCOME_RANGE_UNDETERMINED" => Some(Self::IncomeRangeUndetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionTypeEnum {}
/// Nested message and enum types in `InteractionTypeEnum`.
pub mod interaction_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionType {
        Unspecified = 0,
        Unknown = 1,
        Calls = 8000,
    }
    impl InteractionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InteractionType::Unspecified => "UNSPECIFIED",
                InteractionType::Unknown => "UNKNOWN",
                InteractionType::Calls => "CALLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALLS" => Some(Self::Calls),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordMatchTypeEnum {}
/// Nested message and enum types in `KeywordMatchTypeEnum`.
pub mod keyword_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordMatchType {
        Unspecified = 0,
        Unknown = 1,
        Exact = 2,
        Phrase = 3,
        Broad = 4,
    }
    impl KeywordMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordMatchType::Unspecified => "UNSPECIFIED",
                KeywordMatchType::Unknown => "UNKNOWN",
                KeywordMatchType::Exact => "EXACT",
                KeywordMatchType::Phrase => "PHRASE",
                KeywordMatchType::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                "PHRASE" => Some(Self::Phrase),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupTypeEnum {}
/// Nested message and enum types in `ListingGroupTypeEnum`.
pub mod listing_group_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupType {
        Unspecified = 0,
        Unknown = 1,
        Subdivision = 2,
        Unit = 3,
    }
    impl ListingGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupType::Unspecified => "UNSPECIFIED",
                ListingGroupType::Unknown => "UNKNOWN",
                ListingGroupType::Subdivision => "SUBDIVISION",
                ListingGroupType::Unit => "UNIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT" => Some(Self::Unit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationGroupRadiusUnitsEnum {}
/// Nested message and enum types in `LocationGroupRadiusUnitsEnum`.
pub mod location_group_radius_units_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationGroupRadiusUnits {
        Unspecified = 0,
        Unknown = 1,
        Meters = 2,
        Miles = 3,
        MilliMiles = 4,
    }
    impl LocationGroupRadiusUnits {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationGroupRadiusUnits::Unspecified => "UNSPECIFIED",
                LocationGroupRadiusUnits::Unknown => "UNKNOWN",
                LocationGroupRadiusUnits::Meters => "METERS",
                LocationGroupRadiusUnits::Miles => "MILES",
                LocationGroupRadiusUnits::MilliMiles => "MILLI_MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "METERS" => Some(Self::Meters),
                "MILES" => Some(Self::Miles),
                "MILLI_MILES" => Some(Self::MilliMiles),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinuteOfHourEnum {}
/// Nested message and enum types in `MinuteOfHourEnum`.
pub mod minute_of_hour_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinuteOfHour {
        Unspecified = 0,
        Unknown = 1,
        Zero = 2,
        Fifteen = 3,
        Thirty = 4,
        FortyFive = 5,
    }
    impl MinuteOfHour {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinuteOfHour::Unspecified => "UNSPECIFIED",
                MinuteOfHour::Unknown => "UNKNOWN",
                MinuteOfHour::Zero => "ZERO",
                MinuteOfHour::Fifteen => "FIFTEEN",
                MinuteOfHour::Thirty => "THIRTY",
                MinuteOfHour::FortyFive => "FORTY_FIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ZERO" => Some(Self::Zero),
                "FIFTEEN" => Some(Self::Fifteen),
                "THIRTY" => Some(Self::Thirty),
                "FORTY_FIVE" => Some(Self::FortyFive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ParentalStatusTypeEnum {}
/// Nested message and enum types in `ParentalStatusTypeEnum`.
pub mod parental_status_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParentalStatusType {
        Unspecified = 0,
        Unknown = 1,
        Parent = 300,
        NotAParent = 301,
        Undetermined = 302,
    }
    impl ParentalStatusType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ParentalStatusType::Unspecified => "UNSPECIFIED",
                ParentalStatusType::Unknown => "UNKNOWN",
                ParentalStatusType::Parent => "PARENT",
                ParentalStatusType::NotAParent => "NOT_A_PARENT",
                ParentalStatusType::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PARENT" => Some(Self::Parent),
                "NOT_A_PARENT" => Some(Self::NotAParent),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCategoryLevelEnum {}
/// Nested message and enum types in `ProductCategoryLevelEnum`.
pub mod product_category_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCategoryLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ProductCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductCategoryLevel::Unspecified => "UNSPECIFIED",
                ProductCategoryLevel::Unknown => "UNKNOWN",
                ProductCategoryLevel::Level1 => "LEVEL1",
                ProductCategoryLevel::Level2 => "LEVEL2",
                ProductCategoryLevel::Level3 => "LEVEL3",
                ProductCategoryLevel::Level4 => "LEVEL4",
                ProductCategoryLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCustomAttributeIndexEnum {}
/// Nested message and enum types in `ProductCustomAttributeIndexEnum`.
pub mod product_custom_attribute_index_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCustomAttributeIndex {
        Unspecified = 0,
        Unknown = 1,
        Index0 = 7,
        Index1 = 8,
        Index2 = 9,
        Index3 = 10,
        Index4 = 11,
    }
    impl ProductCustomAttributeIndex {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductCustomAttributeIndex::Unspecified => "UNSPECIFIED",
                ProductCustomAttributeIndex::Unknown => "UNKNOWN",
                ProductCustomAttributeIndex::Index0 => "INDEX0",
                ProductCustomAttributeIndex::Index1 => "INDEX1",
                ProductCustomAttributeIndex::Index2 => "INDEX2",
                ProductCustomAttributeIndex::Index3 => "INDEX3",
                ProductCustomAttributeIndex::Index4 => "INDEX4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INDEX0" => Some(Self::Index0),
                "INDEX1" => Some(Self::Index1),
                "INDEX2" => Some(Self::Index2),
                "INDEX3" => Some(Self::Index3),
                "INDEX4" => Some(Self::Index4),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductTypeLevelEnum {}
/// Nested message and enum types in `ProductTypeLevelEnum`.
pub mod product_type_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductTypeLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 7,
        Level2 = 8,
        Level3 = 9,
        Level4 = 10,
        Level5 = 11,
    }
    impl ProductTypeLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductTypeLevel::Unspecified => "UNSPECIFIED",
                ProductTypeLevel::Unknown => "UNKNOWN",
                ProductTypeLevel::Level1 => "LEVEL1",
                ProductTypeLevel::Level2 => "LEVEL2",
                ProductTypeLevel::Level3 => "LEVEL3",
                ProductTypeLevel::Level4 => "LEVEL4",
                ProductTypeLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProximityRadiusUnitsEnum {}
/// Nested message and enum types in `ProximityRadiusUnitsEnum`.
pub mod proximity_radius_units_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProximityRadiusUnits {
        Unspecified = 0,
        Unknown = 1,
        Miles = 2,
        Kilometers = 3,
    }
    impl ProximityRadiusUnits {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProximityRadiusUnits::Unspecified => "UNSPECIFIED",
                ProximityRadiusUnits::Unknown => "UNKNOWN",
                ProximityRadiusUnits::Miles => "MILES",
                ProximityRadiusUnits::Kilometers => "KILOMETERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MILES" => Some(Self::Miles),
                "KILOMETERS" => Some(Self::Kilometers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperandEnum {}
/// Nested message and enum types in `WebpageConditionOperandEnum`.
pub mod webpage_condition_operand_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperand {
        Unspecified = 0,
        Unknown = 1,
        Url = 2,
        Category = 3,
        PageTitle = 4,
        PageContent = 5,
        CustomLabel = 6,
    }
    impl WebpageConditionOperand {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WebpageConditionOperand::Unspecified => "UNSPECIFIED",
                WebpageConditionOperand::Unknown => "UNKNOWN",
                WebpageConditionOperand::Url => "URL",
                WebpageConditionOperand::Category => "CATEGORY",
                WebpageConditionOperand::PageTitle => "PAGE_TITLE",
                WebpageConditionOperand::PageContent => "PAGE_CONTENT",
                WebpageConditionOperand::CustomLabel => "CUSTOM_LABEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "URL" => Some(Self::Url),
                "CATEGORY" => Some(Self::Category),
                "PAGE_TITLE" => Some(Self::PageTitle),
                "PAGE_CONTENT" => Some(Self::PageContent),
                "CUSTOM_LABEL" => Some(Self::CustomLabel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperatorEnum {}
/// Nested message and enum types in `WebpageConditionOperatorEnum`.
pub mod webpage_condition_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperator {
        Unspecified = 0,
        Unknown = 1,
        Equals = 2,
        Contains = 3,
    }
    impl WebpageConditionOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WebpageConditionOperator::Unspecified => "UNSPECIFIED",
                WebpageConditionOperator::Unknown => "UNKNOWN",
                WebpageConditionOperator::Equals => "EQUALS",
                WebpageConditionOperator::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS" => Some(Self::Equals),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppStoreEnum {}
/// Nested message and enum types in `AppStoreEnum`.
pub mod app_store_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppStore {
        Unspecified = 0,
        Unknown = 1,
        AppleItunes = 2,
        GooglePlay = 3,
    }
    impl AppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppStore::Unspecified => "UNSPECIFIED",
                AppStore::Unknown => "UNKNOWN",
                AppStore::AppleItunes => "APPLE_ITUNES",
                AppStore::GooglePlay => "GOOGLE_PLAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_ITUNES" => Some(Self::AppleItunes),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallConversionReportingStateEnum {}
/// Nested message and enum types in `CallConversionReportingStateEnum`.
pub mod call_conversion_reporting_state_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallConversionReportingState {
        Unspecified = 0,
        Unknown = 1,
        Disabled = 2,
        UseAccountLevelCallConversionAction = 3,
        UseResourceLevelCallConversionAction = 4,
    }
    impl CallConversionReportingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallConversionReportingState::Unspecified => "UNSPECIFIED",
                CallConversionReportingState::Unknown => "UNKNOWN",
                CallConversionReportingState::Disabled => "DISABLED",
                CallConversionReportingState::UseAccountLevelCallConversionAction => {
                    "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION"
                }
                CallConversionReportingState::UseResourceLevelCallConversionAction => {
                    "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISABLED" => Some(Self::Disabled),
                "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseAccountLevelCallConversionAction)
                }
                "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseResourceLevelCallConversionAction)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionPriceQualifierEnum {}
/// Nested message and enum types in `PriceExtensionPriceQualifierEnum`.
pub mod price_extension_price_qualifier_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionPriceQualifier {
        Unspecified = 0,
        Unknown = 1,
        From = 2,
        UpTo = 3,
        Average = 4,
    }
    impl PriceExtensionPriceQualifier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PriceExtensionPriceQualifier::Unspecified => "UNSPECIFIED",
                PriceExtensionPriceQualifier::Unknown => "UNKNOWN",
                PriceExtensionPriceQualifier::From => "FROM",
                PriceExtensionPriceQualifier::UpTo => "UP_TO",
                PriceExtensionPriceQualifier::Average => "AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FROM" => Some(Self::From),
                "UP_TO" => Some(Self::UpTo),
                "AVERAGE" => Some(Self::Average),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionPriceUnitEnum {}
/// Nested message and enum types in `PriceExtensionPriceUnitEnum`.
pub mod price_extension_price_unit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionPriceUnit {
        Unspecified = 0,
        Unknown = 1,
        PerHour = 2,
        PerDay = 3,
        PerWeek = 4,
        PerMonth = 5,
        PerYear = 6,
        PerNight = 7,
    }
    impl PriceExtensionPriceUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PriceExtensionPriceUnit::Unspecified => "UNSPECIFIED",
                PriceExtensionPriceUnit::Unknown => "UNKNOWN",
                PriceExtensionPriceUnit::PerHour => "PER_HOUR",
                PriceExtensionPriceUnit::PerDay => "PER_DAY",
                PriceExtensionPriceUnit::PerWeek => "PER_WEEK",
                PriceExtensionPriceUnit::PerMonth => "PER_MONTH",
                PriceExtensionPriceUnit::PerYear => "PER_YEAR",
                PriceExtensionPriceUnit::PerNight => "PER_NIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PER_HOUR" => Some(Self::PerHour),
                "PER_DAY" => Some(Self::PerDay),
                "PER_WEEK" => Some(Self::PerWeek),
                "PER_MONTH" => Some(Self::PerMonth),
                "PER_YEAR" => Some(Self::PerYear),
                "PER_NIGHT" => Some(Self::PerNight),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PriceExtensionTypeEnum {}
/// Nested message and enum types in `PriceExtensionTypeEnum`.
pub mod price_extension_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PriceExtensionType {
        Unspecified = 0,
        Unknown = 1,
        Brands = 2,
        Events = 3,
        Locations = 4,
        Neighborhoods = 5,
        ProductCategories = 6,
        ProductTiers = 7,
        Services = 8,
        ServiceCategories = 9,
        ServiceTiers = 10,
    }
    impl PriceExtensionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PriceExtensionType::Unspecified => "UNSPECIFIED",
                PriceExtensionType::Unknown => "UNKNOWN",
                PriceExtensionType::Brands => "BRANDS",
                PriceExtensionType::Events => "EVENTS",
                PriceExtensionType::Locations => "LOCATIONS",
                PriceExtensionType::Neighborhoods => "NEIGHBORHOODS",
                PriceExtensionType::ProductCategories => "PRODUCT_CATEGORIES",
                PriceExtensionType::ProductTiers => "PRODUCT_TIERS",
                PriceExtensionType::Services => "SERVICES",
                PriceExtensionType::ServiceCategories => "SERVICE_CATEGORIES",
                PriceExtensionType::ServiceTiers => "SERVICE_TIERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BRANDS" => Some(Self::Brands),
                "EVENTS" => Some(Self::Events),
                "LOCATIONS" => Some(Self::Locations),
                "NEIGHBORHOODS" => Some(Self::Neighborhoods),
                "PRODUCT_CATEGORIES" => Some(Self::ProductCategories),
                "PRODUCT_TIERS" => Some(Self::ProductTiers),
                "SERVICES" => Some(Self::Services),
                "SERVICE_CATEGORIES" => Some(Self::ServiceCategories),
                "SERVICE_TIERS" => Some(Self::ServiceTiers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionExtensionDiscountModifierEnum {}
/// Nested message and enum types in `PromotionExtensionDiscountModifierEnum`.
pub mod promotion_extension_discount_modifier_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionExtensionDiscountModifier {
        Unspecified = 0,
        Unknown = 1,
        UpTo = 2,
    }
    impl PromotionExtensionDiscountModifier {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PromotionExtensionDiscountModifier::Unspecified => "UNSPECIFIED",
                PromotionExtensionDiscountModifier::Unknown => "UNKNOWN",
                PromotionExtensionDiscountModifier::UpTo => "UP_TO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UP_TO" => Some(Self::UpTo),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionExtensionOccasionEnum {}
/// Nested message and enum types in `PromotionExtensionOccasionEnum`.
pub mod promotion_extension_occasion_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionExtensionOccasion {
        Unspecified = 0,
        Unknown = 1,
        NewYears = 2,
        ChineseNewYear = 3,
        ValentinesDay = 4,
        Easter = 5,
        MothersDay = 6,
        FathersDay = 7,
        LaborDay = 8,
        BackToSchool = 9,
        Halloween = 10,
        BlackFriday = 11,
        CyberMonday = 12,
        Christmas = 13,
        BoxingDay = 14,
        IndependenceDay = 15,
        NationalDay = 16,
        EndOfSeason = 17,
        WinterSale = 18,
        SummerSale = 19,
        FallSale = 20,
        SpringSale = 21,
        Ramadan = 22,
        EidAlFitr = 23,
        EidAlAdha = 24,
        SinglesDay = 25,
        WomensDay = 26,
        Holi = 27,
        ParentsDay = 28,
        StNicholasDay = 29,
        Carnival = 30,
        Epiphany = 31,
        RoshHashanah = 32,
        Passover = 33,
        Hanukkah = 34,
        Diwali = 35,
        Navratri = 36,
        Songkran = 37,
        YearEndGift = 38,
    }
    impl PromotionExtensionOccasion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PromotionExtensionOccasion::Unspecified => "UNSPECIFIED",
                PromotionExtensionOccasion::Unknown => "UNKNOWN",
                PromotionExtensionOccasion::NewYears => "NEW_YEARS",
                PromotionExtensionOccasion::ChineseNewYear => "CHINESE_NEW_YEAR",
                PromotionExtensionOccasion::ValentinesDay => "VALENTINES_DAY",
                PromotionExtensionOccasion::Easter => "EASTER",
                PromotionExtensionOccasion::MothersDay => "MOTHERS_DAY",
                PromotionExtensionOccasion::FathersDay => "FATHERS_DAY",
                PromotionExtensionOccasion::LaborDay => "LABOR_DAY",
                PromotionExtensionOccasion::BackToSchool => "BACK_TO_SCHOOL",
                PromotionExtensionOccasion::Halloween => "HALLOWEEN",
                PromotionExtensionOccasion::BlackFriday => "BLACK_FRIDAY",
                PromotionExtensionOccasion::CyberMonday => "CYBER_MONDAY",
                PromotionExtensionOccasion::Christmas => "CHRISTMAS",
                PromotionExtensionOccasion::BoxingDay => "BOXING_DAY",
                PromotionExtensionOccasion::IndependenceDay => "INDEPENDENCE_DAY",
                PromotionExtensionOccasion::NationalDay => "NATIONAL_DAY",
                PromotionExtensionOccasion::EndOfSeason => "END_OF_SEASON",
                PromotionExtensionOccasion::WinterSale => "WINTER_SALE",
                PromotionExtensionOccasion::SummerSale => "SUMMER_SALE",
                PromotionExtensionOccasion::FallSale => "FALL_SALE",
                PromotionExtensionOccasion::SpringSale => "SPRING_SALE",
                PromotionExtensionOccasion::Ramadan => "RAMADAN",
                PromotionExtensionOccasion::EidAlFitr => "EID_AL_FITR",
                PromotionExtensionOccasion::EidAlAdha => "EID_AL_ADHA",
                PromotionExtensionOccasion::SinglesDay => "SINGLES_DAY",
                PromotionExtensionOccasion::WomensDay => "WOMENS_DAY",
                PromotionExtensionOccasion::Holi => "HOLI",
                PromotionExtensionOccasion::ParentsDay => "PARENTS_DAY",
                PromotionExtensionOccasion::StNicholasDay => "ST_NICHOLAS_DAY",
                PromotionExtensionOccasion::Carnival => "CARNIVAL",
                PromotionExtensionOccasion::Epiphany => "EPIPHANY",
                PromotionExtensionOccasion::RoshHashanah => "ROSH_HASHANAH",
                PromotionExtensionOccasion::Passover => "PASSOVER",
                PromotionExtensionOccasion::Hanukkah => "HANUKKAH",
                PromotionExtensionOccasion::Diwali => "DIWALI",
                PromotionExtensionOccasion::Navratri => "NAVRATRI",
                PromotionExtensionOccasion::Songkran => "SONGKRAN",
                PromotionExtensionOccasion::YearEndGift => "YEAR_END_GIFT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW_YEARS" => Some(Self::NewYears),
                "CHINESE_NEW_YEAR" => Some(Self::ChineseNewYear),
                "VALENTINES_DAY" => Some(Self::ValentinesDay),
                "EASTER" => Some(Self::Easter),
                "MOTHERS_DAY" => Some(Self::MothersDay),
                "FATHERS_DAY" => Some(Self::FathersDay),
                "LABOR_DAY" => Some(Self::LaborDay),
                "BACK_TO_SCHOOL" => Some(Self::BackToSchool),
                "HALLOWEEN" => Some(Self::Halloween),
                "BLACK_FRIDAY" => Some(Self::BlackFriday),
                "CYBER_MONDAY" => Some(Self::CyberMonday),
                "CHRISTMAS" => Some(Self::Christmas),
                "BOXING_DAY" => Some(Self::BoxingDay),
                "INDEPENDENCE_DAY" => Some(Self::IndependenceDay),
                "NATIONAL_DAY" => Some(Self::NationalDay),
                "END_OF_SEASON" => Some(Self::EndOfSeason),
                "WINTER_SALE" => Some(Self::WinterSale),
                "SUMMER_SALE" => Some(Self::SummerSale),
                "FALL_SALE" => Some(Self::FallSale),
                "SPRING_SALE" => Some(Self::SpringSale),
                "RAMADAN" => Some(Self::Ramadan),
                "EID_AL_FITR" => Some(Self::EidAlFitr),
                "EID_AL_ADHA" => Some(Self::EidAlAdha),
                "SINGLES_DAY" => Some(Self::SinglesDay),
                "WOMENS_DAY" => Some(Self::WomensDay),
                "HOLI" => Some(Self::Holi),
                "PARENTS_DAY" => Some(Self::ParentsDay),
                "ST_NICHOLAS_DAY" => Some(Self::StNicholasDay),
                "CARNIVAL" => Some(Self::Carnival),
                "EPIPHANY" => Some(Self::Epiphany),
                "ROSH_HASHANAH" => Some(Self::RoshHashanah),
                "PASSOVER" => Some(Self::Passover),
                "HANUKKAH" => Some(Self::Hanukkah),
                "DIWALI" => Some(Self::Diwali),
                "NAVRATRI" => Some(Self::Navratri),
                "SONGKRAN" => Some(Self::Songkran),
                "YEAR_END_GIFT" => Some(Self::YearEndGift),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionTypeEnum {}
/// Nested message and enum types in `ExtensionTypeEnum`.
pub mod extension_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionType {
        Unspecified = 0,
        Unknown = 1,
        None = 2,
        App = 3,
        Call = 4,
        Callout = 5,
        Message = 6,
        Price = 7,
        Promotion = 8,
        Sitelink = 10,
        StructuredSnippet = 11,
        Location = 12,
        AffiliateLocation = 13,
        HotelCallout = 15,
        Image = 16,
    }
    impl ExtensionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtensionType::Unspecified => "UNSPECIFIED",
                ExtensionType::Unknown => "UNKNOWN",
                ExtensionType::None => "NONE",
                ExtensionType::App => "APP",
                ExtensionType::Call => "CALL",
                ExtensionType::Callout => "CALLOUT",
                ExtensionType::Message => "MESSAGE",
                ExtensionType::Price => "PRICE",
                ExtensionType::Promotion => "PROMOTION",
                ExtensionType::Sitelink => "SITELINK",
                ExtensionType::StructuredSnippet => "STRUCTURED_SNIPPET",
                ExtensionType::Location => "LOCATION",
                ExtensionType::AffiliateLocation => "AFFILIATE_LOCATION",
                ExtensionType::HotelCallout => "HOTEL_CALLOUT",
                ExtensionType::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NONE" => Some(Self::None),
                "APP" => Some(Self::App),
                "CALL" => Some(Self::Call),
                "CALLOUT" => Some(Self::Callout),
                "MESSAGE" => Some(Self::Message),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "SITELINK" => Some(Self::Sitelink),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "LOCATION" => Some(Self::Location),
                "AFFILIATE_LOCATION" => Some(Self::AffiliateLocation),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemStatusEnum {}
/// Nested message and enum types in `FeedItemStatusEnum`.
pub mod feed_item_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedItemStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemStatus::Unspecified => "UNSPECIFIED",
                FeedItemStatus::Unknown => "UNKNOWN",
                FeedItemStatus::Enabled => "ENABLED",
                FeedItemStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetDeviceEnum {}
/// Nested message and enum types in `FeedItemTargetDeviceEnum`.
pub mod feed_item_target_device_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetDevice {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
    }
    impl FeedItemTargetDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemTargetDevice::Unspecified => "UNSPECIFIED",
                FeedItemTargetDevice::Unknown => "UNKNOWN",
                FeedItemTargetDevice::Mobile => "MOBILE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountBudgetProposalStatusEnum {}
/// Nested message and enum types in `AccountBudgetProposalStatusEnum`.
pub mod account_budget_proposal_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountBudgetProposalStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        ApprovedHeld = 3,
        Approved = 4,
        Cancelled = 5,
        Rejected = 6,
    }
    impl AccountBudgetProposalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountBudgetProposalStatus::Unspecified => "UNSPECIFIED",
                AccountBudgetProposalStatus::Unknown => "UNKNOWN",
                AccountBudgetProposalStatus::Pending => "PENDING",
                AccountBudgetProposalStatus::ApprovedHeld => "APPROVED_HELD",
                AccountBudgetProposalStatus::Approved => "APPROVED",
                AccountBudgetProposalStatus::Cancelled => "CANCELLED",
                AccountBudgetProposalStatus::Rejected => "REJECTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED_HELD" => Some(Self::ApprovedHeld),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                "REJECTED" => Some(Self::Rejected),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesBusinessRegistrationCheckRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesBusinessRegistrationCheckRejectionReasonEnum`.
pub mod local_services_business_registration_check_rejection_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesBusinessRegistrationCheckRejectionReason {
        Unspecified = 0,
        Unknown = 1,
        BusinessNameMismatch = 2,
        BusinessDetailsMismatch = 3,
        IdNotFound = 4,
        PoorDocumentImageQuality = 5,
        DocumentExpired = 6,
        DocumentInvalid = 7,
        DocumentTypeMismatch = 8,
        DocumentUnverifiable = 9,
        Other = 10,
    }
    impl LocalServicesBusinessRegistrationCheckRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesBusinessRegistrationCheckRejectionReason::Unspecified => {
                    "UNSPECIFIED"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::Unknown => {
                    "UNKNOWN"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::BusinessNameMismatch => {
                    "BUSINESS_NAME_MISMATCH"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::BusinessDetailsMismatch => {
                    "BUSINESS_DETAILS_MISMATCH"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::IdNotFound => {
                    "ID_NOT_FOUND"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::PoorDocumentImageQuality => {
                    "POOR_DOCUMENT_IMAGE_QUALITY"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::DocumentExpired => {
                    "DOCUMENT_EXPIRED"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::DocumentInvalid => {
                    "DOCUMENT_INVALID"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::DocumentTypeMismatch => {
                    "DOCUMENT_TYPE_MISMATCH"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::DocumentUnverifiable => {
                    "DOCUMENT_UNVERIFIABLE"
                }
                LocalServicesBusinessRegistrationCheckRejectionReason::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "BUSINESS_DETAILS_MISMATCH" => Some(Self::BusinessDetailsMismatch),
                "ID_NOT_FOUND" => Some(Self::IdNotFound),
                "POOR_DOCUMENT_IMAGE_QUALITY" => Some(Self::PoorDocumentImageQuality),
                "DOCUMENT_EXPIRED" => Some(Self::DocumentExpired),
                "DOCUMENT_INVALID" => Some(Self::DocumentInvalid),
                "DOCUMENT_TYPE_MISMATCH" => Some(Self::DocumentTypeMismatch),
                "DOCUMENT_UNVERIFIABLE" => Some(Self::DocumentUnverifiable),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesBusinessRegistrationTypeEnum {}
/// Nested message and enum types in `LocalServicesBusinessRegistrationTypeEnum`.
pub mod local_services_business_registration_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesBusinessRegistrationType {
        Unspecified = 0,
        Unknown = 1,
        Number = 2,
        Document = 3,
    }
    impl LocalServicesBusinessRegistrationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesBusinessRegistrationType::Unspecified => "UNSPECIFIED",
                LocalServicesBusinessRegistrationType::Unknown => "UNKNOWN",
                LocalServicesBusinessRegistrationType::Number => "NUMBER",
                LocalServicesBusinessRegistrationType::Document => "DOCUMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NUMBER" => Some(Self::Number),
                "DOCUMENT" => Some(Self::Document),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesInsuranceRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesInsuranceRejectionReasonEnum`.
pub mod local_services_insurance_rejection_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesInsuranceRejectionReason {
        Unspecified = 0,
        Unknown = 1,
        BusinessNameMismatch = 2,
        InsuranceAmountInsufficient = 3,
        Expired = 4,
        NoSignature = 5,
        NoPolicyNumber = 6,
        NoCommercialGeneralLiability = 7,
        EditableFormat = 8,
        CategoryMismatch = 9,
        MissingExpirationDate = 10,
        PoorQuality = 11,
        PotentiallyEdited = 12,
        WrongDocumentType = 13,
        NonFinal = 14,
        Other = 15,
    }
    impl LocalServicesInsuranceRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesInsuranceRejectionReason::Unspecified => "UNSPECIFIED",
                LocalServicesInsuranceRejectionReason::Unknown => "UNKNOWN",
                LocalServicesInsuranceRejectionReason::BusinessNameMismatch => {
                    "BUSINESS_NAME_MISMATCH"
                }
                LocalServicesInsuranceRejectionReason::InsuranceAmountInsufficient => {
                    "INSURANCE_AMOUNT_INSUFFICIENT"
                }
                LocalServicesInsuranceRejectionReason::Expired => "EXPIRED",
                LocalServicesInsuranceRejectionReason::NoSignature => "NO_SIGNATURE",
                LocalServicesInsuranceRejectionReason::NoPolicyNumber => {
                    "NO_POLICY_NUMBER"
                }
                LocalServicesInsuranceRejectionReason::NoCommercialGeneralLiability => {
                    "NO_COMMERCIAL_GENERAL_LIABILITY"
                }
                LocalServicesInsuranceRejectionReason::EditableFormat => {
                    "EDITABLE_FORMAT"
                }
                LocalServicesInsuranceRejectionReason::CategoryMismatch => {
                    "CATEGORY_MISMATCH"
                }
                LocalServicesInsuranceRejectionReason::MissingExpirationDate => {
                    "MISSING_EXPIRATION_DATE"
                }
                LocalServicesInsuranceRejectionReason::PoorQuality => "POOR_QUALITY",
                LocalServicesInsuranceRejectionReason::PotentiallyEdited => {
                    "POTENTIALLY_EDITED"
                }
                LocalServicesInsuranceRejectionReason::WrongDocumentType => {
                    "WRONG_DOCUMENT_TYPE"
                }
                LocalServicesInsuranceRejectionReason::NonFinal => "NON_FINAL",
                LocalServicesInsuranceRejectionReason::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "INSURANCE_AMOUNT_INSUFFICIENT" => {
                    Some(Self::InsuranceAmountInsufficient)
                }
                "EXPIRED" => Some(Self::Expired),
                "NO_SIGNATURE" => Some(Self::NoSignature),
                "NO_POLICY_NUMBER" => Some(Self::NoPolicyNumber),
                "NO_COMMERCIAL_GENERAL_LIABILITY" => {
                    Some(Self::NoCommercialGeneralLiability)
                }
                "EDITABLE_FORMAT" => Some(Self::EditableFormat),
                "CATEGORY_MISMATCH" => Some(Self::CategoryMismatch),
                "MISSING_EXPIRATION_DATE" => Some(Self::MissingExpirationDate),
                "POOR_QUALITY" => Some(Self::PoorQuality),
                "POTENTIALLY_EDITED" => Some(Self::PotentiallyEdited),
                "WRONG_DOCUMENT_TYPE" => Some(Self::WrongDocumentType),
                "NON_FINAL" => Some(Self::NonFinal),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLicenseRejectionReasonEnum {}
/// Nested message and enum types in `LocalServicesLicenseRejectionReasonEnum`.
pub mod local_services_license_rejection_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesLicenseRejectionReason {
        Unspecified = 0,
        Unknown = 1,
        BusinessNameMismatch = 2,
        Unauthorized = 3,
        Expired = 4,
        PoorQuality = 5,
        Unverifiable = 6,
        WrongDocumentOrId = 7,
        Other = 8,
    }
    impl LocalServicesLicenseRejectionReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesLicenseRejectionReason::Unspecified => "UNSPECIFIED",
                LocalServicesLicenseRejectionReason::Unknown => "UNKNOWN",
                LocalServicesLicenseRejectionReason::BusinessNameMismatch => {
                    "BUSINESS_NAME_MISMATCH"
                }
                LocalServicesLicenseRejectionReason::Unauthorized => "UNAUTHORIZED",
                LocalServicesLicenseRejectionReason::Expired => "EXPIRED",
                LocalServicesLicenseRejectionReason::PoorQuality => "POOR_QUALITY",
                LocalServicesLicenseRejectionReason::Unverifiable => "UNVERIFIABLE",
                LocalServicesLicenseRejectionReason::WrongDocumentOrId => {
                    "WRONG_DOCUMENT_OR_ID"
                }
                LocalServicesLicenseRejectionReason::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME_MISMATCH" => Some(Self::BusinessNameMismatch),
                "UNAUTHORIZED" => Some(Self::Unauthorized),
                "EXPIRED" => Some(Self::Expired),
                "POOR_QUALITY" => Some(Self::PoorQuality),
                "UNVERIFIABLE" => Some(Self::Unverifiable),
                "WRONG_DOCUMENT_OR_ID" => Some(Self::WrongDocumentOrId),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationArtifactStatusEnum {}
/// Nested message and enum types in `LocalServicesVerificationArtifactStatusEnum`.
pub mod local_services_verification_artifact_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationArtifactStatus {
        Unspecified = 0,
        Unknown = 1,
        Passed = 2,
        Failed = 3,
        Pending = 4,
        NoSubmission = 5,
        Cancelled = 6,
    }
    impl LocalServicesVerificationArtifactStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesVerificationArtifactStatus::Unspecified => "UNSPECIFIED",
                LocalServicesVerificationArtifactStatus::Unknown => "UNKNOWN",
                LocalServicesVerificationArtifactStatus::Passed => "PASSED",
                LocalServicesVerificationArtifactStatus::Failed => "FAILED",
                LocalServicesVerificationArtifactStatus::Pending => "PENDING",
                LocalServicesVerificationArtifactStatus::NoSubmission => "NO_SUBMISSION",
                LocalServicesVerificationArtifactStatus::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PASSED" => Some(Self::Passed),
                "FAILED" => Some(Self::Failed),
                "PENDING" => Some(Self::Pending),
                "NO_SUBMISSION" => Some(Self::NoSubmission),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationArtifactTypeEnum {}
/// Nested message and enum types in `LocalServicesVerificationArtifactTypeEnum`.
pub mod local_services_verification_artifact_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationArtifactType {
        Unspecified = 0,
        Unknown = 1,
        BackgroundCheck = 2,
        Insurance = 3,
        License = 4,
        BusinessRegistrationCheck = 5,
    }
    impl LocalServicesVerificationArtifactType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesVerificationArtifactType::Unspecified => "UNSPECIFIED",
                LocalServicesVerificationArtifactType::Unknown => "UNKNOWN",
                LocalServicesVerificationArtifactType::BackgroundCheck => {
                    "BACKGROUND_CHECK"
                }
                LocalServicesVerificationArtifactType::Insurance => "INSURANCE",
                LocalServicesVerificationArtifactType::License => "LICENSE",
                LocalServicesVerificationArtifactType::BusinessRegistrationCheck => {
                    "BUSINESS_REGISTRATION_CHECK"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BACKGROUND_CHECK" => Some(Self::BackgroundCheck),
                "INSURANCE" => Some(Self::Insurance),
                "LICENSE" => Some(Self::License),
                "BUSINESS_REGISTRATION_CHECK" => Some(Self::BusinessRegistrationCheck),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExtensionSettingDeviceEnum {}
/// Nested message and enum types in `ExtensionSettingDeviceEnum`.
pub mod extension_setting_device_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExtensionSettingDevice {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
        Desktop = 3,
    }
    impl ExtensionSettingDevice {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExtensionSettingDevice::Unspecified => "UNSPECIFIED",
                ExtensionSettingDevice::Unknown => "UNKNOWN",
                ExtensionSettingDevice::Mobile => "MOBILE",
                ExtensionSettingDevice::Desktop => "DESKTOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "DESKTOP" => Some(Self::Desktop),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchingFunctionContextTypeEnum {}
/// Nested message and enum types in `MatchingFunctionContextTypeEnum`.
pub mod matching_function_context_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchingFunctionContextType {
        Unspecified = 0,
        Unknown = 1,
        FeedItemId = 2,
        DeviceName = 3,
        FeedItemSetId = 4,
    }
    impl MatchingFunctionContextType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MatchingFunctionContextType::Unspecified => "UNSPECIFIED",
                MatchingFunctionContextType::Unknown => "UNKNOWN",
                MatchingFunctionContextType::FeedItemId => "FEED_ITEM_ID",
                MatchingFunctionContextType::DeviceName => "DEVICE_NAME",
                MatchingFunctionContextType::FeedItemSetId => "FEED_ITEM_SET_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FEED_ITEM_ID" => Some(Self::FeedItemId),
                "DEVICE_NAME" => Some(Self::DeviceName),
                "FEED_ITEM_SET_ID" => Some(Self::FeedItemSetId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MatchingFunctionOperatorEnum {}
/// Nested message and enum types in `MatchingFunctionOperatorEnum`.
pub mod matching_function_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MatchingFunctionOperator {
        Unspecified = 0,
        Unknown = 1,
        In = 2,
        Identity = 3,
        Equals = 4,
        And = 5,
        ContainsAny = 6,
    }
    impl MatchingFunctionOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MatchingFunctionOperator::Unspecified => "UNSPECIFIED",
                MatchingFunctionOperator::Unknown => "UNKNOWN",
                MatchingFunctionOperator::In => "IN",
                MatchingFunctionOperator::Identity => "IDENTITY",
                MatchingFunctionOperator::Equals => "EQUALS",
                MatchingFunctionOperator::And => "AND",
                MatchingFunctionOperator::ContainsAny => "CONTAINS_ANY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IN" => Some(Self::In),
                "IDENTITY" => Some(Self::Identity),
                "EQUALS" => Some(Self::Equals),
                "AND" => Some(Self::And),
                "CONTAINS_ANY" => Some(Self::ContainsAny),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedLinkStatusEnum {}
/// Nested message and enum types in `FeedLinkStatusEnum`.
pub mod feed_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedLinkStatus::Unspecified => "UNSPECIFIED",
                FeedLinkStatus::Unknown => "UNKNOWN",
                FeedLinkStatus::Enabled => "ENABLED",
                FeedLinkStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlaceholderTypeEnum {}
/// Nested message and enum types in `PlaceholderTypeEnum`.
pub mod placeholder_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlaceholderType {
        Unspecified = 0,
        Unknown = 1,
        Sitelink = 2,
        Call = 3,
        App = 4,
        Location = 5,
        AffiliateLocation = 6,
        Callout = 7,
        StructuredSnippet = 8,
        Message = 9,
        Price = 10,
        Promotion = 11,
        AdCustomizer = 12,
        DynamicEducation = 13,
        DynamicFlight = 14,
        DynamicCustom = 15,
        DynamicHotel = 16,
        DynamicRealEstate = 17,
        DynamicTravel = 18,
        DynamicLocal = 19,
        DynamicJob = 20,
        Image = 21,
    }
    impl PlaceholderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PlaceholderType::Unspecified => "UNSPECIFIED",
                PlaceholderType::Unknown => "UNKNOWN",
                PlaceholderType::Sitelink => "SITELINK",
                PlaceholderType::Call => "CALL",
                PlaceholderType::App => "APP",
                PlaceholderType::Location => "LOCATION",
                PlaceholderType::AffiliateLocation => "AFFILIATE_LOCATION",
                PlaceholderType::Callout => "CALLOUT",
                PlaceholderType::StructuredSnippet => "STRUCTURED_SNIPPET",
                PlaceholderType::Message => "MESSAGE",
                PlaceholderType::Price => "PRICE",
                PlaceholderType::Promotion => "PROMOTION",
                PlaceholderType::AdCustomizer => "AD_CUSTOMIZER",
                PlaceholderType::DynamicEducation => "DYNAMIC_EDUCATION",
                PlaceholderType::DynamicFlight => "DYNAMIC_FLIGHT",
                PlaceholderType::DynamicCustom => "DYNAMIC_CUSTOM",
                PlaceholderType::DynamicHotel => "DYNAMIC_HOTEL",
                PlaceholderType::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                PlaceholderType::DynamicTravel => "DYNAMIC_TRAVEL",
                PlaceholderType::DynamicLocal => "DYNAMIC_LOCAL",
                PlaceholderType::DynamicJob => "DYNAMIC_JOB",
                PlaceholderType::Image => "IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SITELINK" => Some(Self::Sitelink),
                "CALL" => Some(Self::Call),
                "APP" => Some(Self::App),
                "LOCATION" => Some(Self::Location),
                "AFFILIATE_LOCATION" => Some(Self::AffiliateLocation),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "MESSAGE" => Some(Self::Message),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "AD_CUSTOMIZER" => Some(Self::AdCustomizer),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "DYNAMIC_FLIGHT" => Some(Self::DynamicFlight),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTEL" => Some(Self::DynamicHotel),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOB" => Some(Self::DynamicJob),
                "IMAGE" => Some(Self::Image),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyTypeEnum {}
/// Nested message and enum types in `BiddingStrategyTypeEnum`.
pub mod bidding_strategy_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyType {
        Unspecified = 0,
        Unknown = 1,
        Commission = 16,
        EnhancedCpc = 2,
        FixedCpm = 19,
        Invalid = 17,
        ManualCpa = 18,
        ManualCpc = 3,
        ManualCpm = 4,
        ManualCpv = 13,
        MaximizeConversions = 10,
        MaximizeConversionValue = 11,
        PageOnePromoted = 5,
        PercentCpc = 12,
        TargetCpa = 6,
        TargetCpm = 14,
        TargetCpv = 20,
        TargetImpressionShare = 15,
        TargetOutrankShare = 7,
        TargetRoas = 8,
        TargetSpend = 9,
    }
    impl BiddingStrategyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategyType::Unspecified => "UNSPECIFIED",
                BiddingStrategyType::Unknown => "UNKNOWN",
                BiddingStrategyType::Commission => "COMMISSION",
                BiddingStrategyType::EnhancedCpc => "ENHANCED_CPC",
                BiddingStrategyType::FixedCpm => "FIXED_CPM",
                BiddingStrategyType::Invalid => "INVALID",
                BiddingStrategyType::ManualCpa => "MANUAL_CPA",
                BiddingStrategyType::ManualCpc => "MANUAL_CPC",
                BiddingStrategyType::ManualCpm => "MANUAL_CPM",
                BiddingStrategyType::ManualCpv => "MANUAL_CPV",
                BiddingStrategyType::MaximizeConversions => "MAXIMIZE_CONVERSIONS",
                BiddingStrategyType::MaximizeConversionValue => {
                    "MAXIMIZE_CONVERSION_VALUE"
                }
                BiddingStrategyType::PageOnePromoted => "PAGE_ONE_PROMOTED",
                BiddingStrategyType::PercentCpc => "PERCENT_CPC",
                BiddingStrategyType::TargetCpa => "TARGET_CPA",
                BiddingStrategyType::TargetCpm => "TARGET_CPM",
                BiddingStrategyType::TargetCpv => "TARGET_CPV",
                BiddingStrategyType::TargetImpressionShare => "TARGET_IMPRESSION_SHARE",
                BiddingStrategyType::TargetOutrankShare => "TARGET_OUTRANK_SHARE",
                BiddingStrategyType::TargetRoas => "TARGET_ROAS",
                BiddingStrategyType::TargetSpend => "TARGET_SPEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "COMMISSION" => Some(Self::Commission),
                "ENHANCED_CPC" => Some(Self::EnhancedCpc),
                "FIXED_CPM" => Some(Self::FixedCpm),
                "INVALID" => Some(Self::Invalid),
                "MANUAL_CPA" => Some(Self::ManualCpa),
                "MANUAL_CPC" => Some(Self::ManualCpc),
                "MANUAL_CPM" => Some(Self::ManualCpm),
                "MANUAL_CPV" => Some(Self::ManualCpv),
                "MAXIMIZE_CONVERSIONS" => Some(Self::MaximizeConversions),
                "MAXIMIZE_CONVERSION_VALUE" => Some(Self::MaximizeConversionValue),
                "PAGE_ONE_PROMOTED" => Some(Self::PageOnePromoted),
                "PERCENT_CPC" => Some(Self::PercentCpc),
                "TARGET_CPA" => Some(Self::TargetCpa),
                "TARGET_CPM" => Some(Self::TargetCpm),
                "TARGET_CPV" => Some(Self::TargetCpv),
                "TARGET_IMPRESSION_SHARE" => Some(Self::TargetImpressionShare),
                "TARGET_OUTRANK_SHARE" => Some(Self::TargetOutrankShare),
                "TARGET_ROAS" => Some(Self::TargetRoas),
                "TARGET_SPEND" => Some(Self::TargetSpend),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetImpressionShareLocationEnum {}
/// Nested message and enum types in `TargetImpressionShareLocationEnum`.
pub mod target_impression_share_location_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetImpressionShareLocation {
        Unspecified = 0,
        Unknown = 1,
        AnywhereOnPage = 2,
        TopOfPage = 3,
        AbsoluteTopOfPage = 4,
    }
    impl TargetImpressionShareLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetImpressionShareLocation::Unspecified => "UNSPECIFIED",
                TargetImpressionShareLocation::Unknown => "UNKNOWN",
                TargetImpressionShareLocation::AnywhereOnPage => "ANYWHERE_ON_PAGE",
                TargetImpressionShareLocation::TopOfPage => "TOP_OF_PAGE",
                TargetImpressionShareLocation::AbsoluteTopOfPage => {
                    "ABSOLUTE_TOP_OF_PAGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ANYWHERE_ON_PAGE" => Some(Self::AnywhereOnPage),
                "TOP_OF_PAGE" => Some(Self::TopOfPage),
                "ABSOLUTE_TOP_OF_PAGE" => Some(Self::AbsoluteTopOfPage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelSubTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelSubTypeEnum`.
pub mod advertising_channel_sub_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelSubType {
        Unspecified = 0,
        Unknown = 1,
        SearchMobileApp = 2,
        DisplayMobileApp = 3,
        SearchExpress = 4,
        DisplayExpress = 5,
        ShoppingSmartAds = 6,
        DisplayGmailAd = 7,
        DisplaySmartCampaign = 8,
        VideoOutstream = 9,
        VideoAction = 10,
        VideoNonSkippable = 11,
        AppCampaign = 12,
        AppCampaignForEngagement = 13,
        LocalCampaign = 14,
        ShoppingComparisonListingAds = 15,
        SmartCampaign = 16,
        VideoSequence = 17,
        AppCampaignForPreRegistration = 18,
        VideoReachTargetFrequency = 19,
        TravelActivities = 20,
    }
    impl AdvertisingChannelSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisingChannelSubType::Unspecified => "UNSPECIFIED",
                AdvertisingChannelSubType::Unknown => "UNKNOWN",
                AdvertisingChannelSubType::SearchMobileApp => "SEARCH_MOBILE_APP",
                AdvertisingChannelSubType::DisplayMobileApp => "DISPLAY_MOBILE_APP",
                AdvertisingChannelSubType::SearchExpress => "SEARCH_EXPRESS",
                AdvertisingChannelSubType::DisplayExpress => "DISPLAY_EXPRESS",
                AdvertisingChannelSubType::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                AdvertisingChannelSubType::DisplayGmailAd => "DISPLAY_GMAIL_AD",
                AdvertisingChannelSubType::DisplaySmartCampaign => {
                    "DISPLAY_SMART_CAMPAIGN"
                }
                AdvertisingChannelSubType::VideoOutstream => "VIDEO_OUTSTREAM",
                AdvertisingChannelSubType::VideoAction => "VIDEO_ACTION",
                AdvertisingChannelSubType::VideoNonSkippable => "VIDEO_NON_SKIPPABLE",
                AdvertisingChannelSubType::AppCampaign => "APP_CAMPAIGN",
                AdvertisingChannelSubType::AppCampaignForEngagement => {
                    "APP_CAMPAIGN_FOR_ENGAGEMENT"
                }
                AdvertisingChannelSubType::LocalCampaign => "LOCAL_CAMPAIGN",
                AdvertisingChannelSubType::ShoppingComparisonListingAds => {
                    "SHOPPING_COMPARISON_LISTING_ADS"
                }
                AdvertisingChannelSubType::SmartCampaign => "SMART_CAMPAIGN",
                AdvertisingChannelSubType::VideoSequence => "VIDEO_SEQUENCE",
                AdvertisingChannelSubType::AppCampaignForPreRegistration => {
                    "APP_CAMPAIGN_FOR_PRE_REGISTRATION"
                }
                AdvertisingChannelSubType::VideoReachTargetFrequency => {
                    "VIDEO_REACH_TARGET_FREQUENCY"
                }
                AdvertisingChannelSubType::TravelActivities => "TRAVEL_ACTIVITIES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_MOBILE_APP" => Some(Self::SearchMobileApp),
                "DISPLAY_MOBILE_APP" => Some(Self::DisplayMobileApp),
                "SEARCH_EXPRESS" => Some(Self::SearchExpress),
                "DISPLAY_EXPRESS" => Some(Self::DisplayExpress),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "DISPLAY_GMAIL_AD" => Some(Self::DisplayGmailAd),
                "DISPLAY_SMART_CAMPAIGN" => Some(Self::DisplaySmartCampaign),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "VIDEO_ACTION" => Some(Self::VideoAction),
                "VIDEO_NON_SKIPPABLE" => Some(Self::VideoNonSkippable),
                "APP_CAMPAIGN" => Some(Self::AppCampaign),
                "APP_CAMPAIGN_FOR_ENGAGEMENT" => Some(Self::AppCampaignForEngagement),
                "LOCAL_CAMPAIGN" => Some(Self::LocalCampaign),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "SMART_CAMPAIGN" => Some(Self::SmartCampaign),
                "VIDEO_SEQUENCE" => Some(Self::VideoSequence),
                "APP_CAMPAIGN_FOR_PRE_REGISTRATION" => {
                    Some(Self::AppCampaignForPreRegistration)
                }
                "VIDEO_REACH_TARGET_FREQUENCY" => Some(Self::VideoReachTargetFrequency),
                "TRAVEL_ACTIVITIES" => Some(Self::TravelActivities),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionCategoryChannelAvailabilityModeEnum {}
/// Nested message and enum types in `CriterionCategoryChannelAvailabilityModeEnum`.
pub mod criterion_category_channel_availability_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionCategoryChannelAvailabilityMode {
        Unspecified = 0,
        Unknown = 1,
        AllChannels = 2,
        ChannelTypeAndAllSubtypes = 3,
        ChannelTypeAndSubsetSubtypes = 4,
    }
    impl CriterionCategoryChannelAvailabilityMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionCategoryChannelAvailabilityMode::Unspecified => "UNSPECIFIED",
                CriterionCategoryChannelAvailabilityMode::Unknown => "UNKNOWN",
                CriterionCategoryChannelAvailabilityMode::AllChannels => "ALL_CHANNELS",
                CriterionCategoryChannelAvailabilityMode::ChannelTypeAndAllSubtypes => {
                    "CHANNEL_TYPE_AND_ALL_SUBTYPES"
                }
                CriterionCategoryChannelAvailabilityMode::ChannelTypeAndSubsetSubtypes => {
                    "CHANNEL_TYPE_AND_SUBSET_SUBTYPES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_CHANNELS" => Some(Self::AllChannels),
                "CHANNEL_TYPE_AND_ALL_SUBTYPES" => Some(Self::ChannelTypeAndAllSubtypes),
                "CHANNEL_TYPE_AND_SUBSET_SUBTYPES" => {
                    Some(Self::ChannelTypeAndSubsetSubtypes)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionCategoryLocaleAvailabilityModeEnum {}
/// Nested message and enum types in `CriterionCategoryLocaleAvailabilityModeEnum`.
pub mod criterion_category_locale_availability_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionCategoryLocaleAvailabilityMode {
        Unspecified = 0,
        Unknown = 1,
        AllLocales = 2,
        CountryAndAllLanguages = 3,
        LanguageAndAllCountries = 4,
        CountryAndLanguage = 5,
    }
    impl CriterionCategoryLocaleAvailabilityMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionCategoryLocaleAvailabilityMode::Unspecified => "UNSPECIFIED",
                CriterionCategoryLocaleAvailabilityMode::Unknown => "UNKNOWN",
                CriterionCategoryLocaleAvailabilityMode::AllLocales => "ALL_LOCALES",
                CriterionCategoryLocaleAvailabilityMode::CountryAndAllLanguages => {
                    "COUNTRY_AND_ALL_LANGUAGES"
                }
                CriterionCategoryLocaleAvailabilityMode::LanguageAndAllCountries => {
                    "LANGUAGE_AND_ALL_COUNTRIES"
                }
                CriterionCategoryLocaleAvailabilityMode::CountryAndLanguage => {
                    "COUNTRY_AND_LANGUAGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_LOCALES" => Some(Self::AllLocales),
                "COUNTRY_AND_ALL_LANGUAGES" => Some(Self::CountryAndAllLanguages),
                "LANGUAGE_AND_ALL_COUNTRIES" => Some(Self::LanguageAndAllCountries),
                "COUNTRY_AND_LANGUAGE" => Some(Self::CountryAndLanguage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserInterestTaxonomyTypeEnum {}
/// Nested message and enum types in `UserInterestTaxonomyTypeEnum`.
pub mod user_interest_taxonomy_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserInterestTaxonomyType {
        Unspecified = 0,
        Unknown = 1,
        Affinity = 2,
        InMarket = 3,
        MobileAppInstallUser = 4,
        VerticalGeo = 5,
        NewSmartPhoneUser = 6,
    }
    impl UserInterestTaxonomyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserInterestTaxonomyType::Unspecified => "UNSPECIFIED",
                UserInterestTaxonomyType::Unknown => "UNKNOWN",
                UserInterestTaxonomyType::Affinity => "AFFINITY",
                UserInterestTaxonomyType::InMarket => "IN_MARKET",
                UserInterestTaxonomyType::MobileAppInstallUser => {
                    "MOBILE_APP_INSTALL_USER"
                }
                UserInterestTaxonomyType::VerticalGeo => "VERTICAL_GEO",
                UserInterestTaxonomyType::NewSmartPhoneUser => "NEW_SMART_PHONE_USER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AFFINITY" => Some(Self::Affinity),
                "IN_MARKET" => Some(Self::InMarket),
                "MOBILE_APP_INSTALL_USER" => Some(Self::MobileAppInstallUser),
                "VERTICAL_GEO" => Some(Self::VerticalGeo),
                "NEW_SMART_PHONE_USER" => Some(Self::NewSmartPhoneUser),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetStringFilterTypeEnum {}
/// Nested message and enum types in `FeedItemSetStringFilterTypeEnum`.
pub mod feed_item_set_string_filter_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetStringFilterType {
        Unspecified = 0,
        Unknown = 1,
        Exact = 2,
    }
    impl FeedItemSetStringFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemSetStringFilterType::Unspecified => "UNSPECIFIED",
                FeedItemSetStringFilterType::Unknown => "UNKNOWN",
                FeedItemSetStringFilterType::Exact => "EXACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemSetStatusEnum {}
/// Nested message and enum types in `FeedItemSetStatusEnum`.
pub mod feed_item_set_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemSetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedItemSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemSetStatus::Unspecified => "UNSPECIFIED",
                FeedItemSetStatus::Unknown => "UNKNOWN",
                FeedItemSetStatus::Enabled => "ENABLED",
                FeedItemSetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessRoleEnum {}
/// Nested message and enum types in `AccessRoleEnum`.
pub mod access_role_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessRole {
        Unspecified = 0,
        Unknown = 1,
        Admin = 2,
        Standard = 3,
        ReadOnly = 4,
        EmailOnly = 5,
    }
    impl AccessRole {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccessRole::Unspecified => "UNSPECIFIED",
                AccessRole::Unknown => "UNKNOWN",
                AccessRole::Admin => "ADMIN",
                AccessRole::Standard => "STANDARD",
                AccessRole::ReadOnly => "READ_ONLY",
                AccessRole::EmailOnly => "EMAIL_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADMIN" => Some(Self::Admin),
                "STANDARD" => Some(Self::Standard),
                "READ_ONLY" => Some(Self::ReadOnly),
                "EMAIL_ONLY" => Some(Self::EmailOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomizerAttributeStatusEnum {}
/// Nested message and enum types in `CustomizerAttributeStatusEnum`.
pub mod customizer_attribute_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomizerAttributeStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CustomizerAttributeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomizerAttributeStatus::Unspecified => "UNSPECIFIED",
                CustomizerAttributeStatus::Unknown => "UNKNOWN",
                CustomizerAttributeStatus::Enabled => "ENABLED",
                CustomizerAttributeStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidPrivacyInteractionTypeEnum {}
/// Nested message and enum types in `AndroidPrivacyInteractionTypeEnum`.
pub mod android_privacy_interaction_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AndroidPrivacyInteractionType {
        Unspecified = 0,
        Unknown = 1,
        Click = 2,
        EngagedView = 3,
        View = 4,
    }
    impl AndroidPrivacyInteractionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AndroidPrivacyInteractionType::Unspecified => "UNSPECIFIED",
                AndroidPrivacyInteractionType::Unknown => "UNKNOWN",
                AndroidPrivacyInteractionType::Click => "CLICK",
                AndroidPrivacyInteractionType::EngagedView => "ENGAGED_VIEW",
                AndroidPrivacyInteractionType::View => "VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICK" => Some(Self::Click),
                "ENGAGED_VIEW" => Some(Self::EngagedView),
                "VIEW" => Some(Self::View),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AndroidPrivacyNetworkTypeEnum {}
/// Nested message and enum types in `AndroidPrivacyNetworkTypeEnum`.
pub mod android_privacy_network_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AndroidPrivacyNetworkType {
        Unspecified = 0,
        Unknown = 1,
        Search = 2,
        Display = 3,
        Youtube = 4,
    }
    impl AndroidPrivacyNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AndroidPrivacyNetworkType::Unspecified => "UNSPECIFIED",
                AndroidPrivacyNetworkType::Unknown => "UNKNOWN",
                AndroidPrivacyNetworkType::Search => "SEARCH",
                AndroidPrivacyNetworkType::Display => "DISPLAY",
                AndroidPrivacyNetworkType::Youtube => "YOUTUBE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "DISPLAY" => Some(Self::Display),
                "YOUTUBE" => Some(Self::Youtube),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemQualityApprovalStatusEnum {}
/// Nested message and enum types in `FeedItemQualityApprovalStatusEnum`.
pub mod feed_item_quality_approval_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemQualityApprovalStatus {
        Unspecified = 0,
        Unknown = 1,
        Approved = 2,
        Disapproved = 3,
    }
    impl FeedItemQualityApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemQualityApprovalStatus::Unspecified => "UNSPECIFIED",
                FeedItemQualityApprovalStatus::Unknown => "UNKNOWN",
                FeedItemQualityApprovalStatus::Approved => "APPROVED",
                FeedItemQualityApprovalStatus::Disapproved => "DISAPPROVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemQualityDisapprovalReasonEnum {}
/// Nested message and enum types in `FeedItemQualityDisapprovalReasonEnum`.
pub mod feed_item_quality_disapproval_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemQualityDisapprovalReason {
        Unspecified = 0,
        Unknown = 1,
        PriceTableRepetitiveHeaders = 2,
        PriceTableRepetitiveDescription = 3,
        PriceTableInconsistentRows = 4,
        PriceDescriptionHasPriceQualifiers = 5,
        PriceUnsupportedLanguage = 6,
        PriceTableRowHeaderTableTypeMismatch = 7,
        PriceTableRowHeaderHasPromotionalText = 8,
        PriceTableRowDescriptionNotRelevant = 9,
        PriceTableRowDescriptionHasPromotionalText = 10,
        PriceTableRowHeaderDescriptionRepetitive = 11,
        PriceTableRowUnrateable = 12,
        PriceTableRowPriceInvalid = 13,
        PriceTableRowUrlInvalid = 14,
        PriceHeaderOrDescriptionHasPrice = 15,
        StructuredSnippetsHeaderPolicyViolated = 16,
        StructuredSnippetsRepeatedValues = 17,
        StructuredSnippetsEditorialGuidelines = 18,
        StructuredSnippetsHasPromotionalText = 19,
    }
    impl FeedItemQualityDisapprovalReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemQualityDisapprovalReason::Unspecified => "UNSPECIFIED",
                FeedItemQualityDisapprovalReason::Unknown => "UNKNOWN",
                FeedItemQualityDisapprovalReason::PriceTableRepetitiveHeaders => {
                    "PRICE_TABLE_REPETITIVE_HEADERS"
                }
                FeedItemQualityDisapprovalReason::PriceTableRepetitiveDescription => {
                    "PRICE_TABLE_REPETITIVE_DESCRIPTION"
                }
                FeedItemQualityDisapprovalReason::PriceTableInconsistentRows => {
                    "PRICE_TABLE_INCONSISTENT_ROWS"
                }
                FeedItemQualityDisapprovalReason::PriceDescriptionHasPriceQualifiers => {
                    "PRICE_DESCRIPTION_HAS_PRICE_QUALIFIERS"
                }
                FeedItemQualityDisapprovalReason::PriceUnsupportedLanguage => {
                    "PRICE_UNSUPPORTED_LANGUAGE"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowHeaderTableTypeMismatch => {
                    "PRICE_TABLE_ROW_HEADER_TABLE_TYPE_MISMATCH"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowHeaderHasPromotionalText => {
                    "PRICE_TABLE_ROW_HEADER_HAS_PROMOTIONAL_TEXT"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowDescriptionNotRelevant => {
                    "PRICE_TABLE_ROW_DESCRIPTION_NOT_RELEVANT"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowDescriptionHasPromotionalText => {
                    "PRICE_TABLE_ROW_DESCRIPTION_HAS_PROMOTIONAL_TEXT"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowHeaderDescriptionRepetitive => {
                    "PRICE_TABLE_ROW_HEADER_DESCRIPTION_REPETITIVE"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowUnrateable => {
                    "PRICE_TABLE_ROW_UNRATEABLE"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowPriceInvalid => {
                    "PRICE_TABLE_ROW_PRICE_INVALID"
                }
                FeedItemQualityDisapprovalReason::PriceTableRowUrlInvalid => {
                    "PRICE_TABLE_ROW_URL_INVALID"
                }
                FeedItemQualityDisapprovalReason::PriceHeaderOrDescriptionHasPrice => {
                    "PRICE_HEADER_OR_DESCRIPTION_HAS_PRICE"
                }
                FeedItemQualityDisapprovalReason::StructuredSnippetsHeaderPolicyViolated => {
                    "STRUCTURED_SNIPPETS_HEADER_POLICY_VIOLATED"
                }
                FeedItemQualityDisapprovalReason::StructuredSnippetsRepeatedValues => {
                    "STRUCTURED_SNIPPETS_REPEATED_VALUES"
                }
                FeedItemQualityDisapprovalReason::StructuredSnippetsEditorialGuidelines => {
                    "STRUCTURED_SNIPPETS_EDITORIAL_GUIDELINES"
                }
                FeedItemQualityDisapprovalReason::StructuredSnippetsHasPromotionalText => {
                    "STRUCTURED_SNIPPETS_HAS_PROMOTIONAL_TEXT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRICE_TABLE_REPETITIVE_HEADERS" => {
                    Some(Self::PriceTableRepetitiveHeaders)
                }
                "PRICE_TABLE_REPETITIVE_DESCRIPTION" => {
                    Some(Self::PriceTableRepetitiveDescription)
                }
                "PRICE_TABLE_INCONSISTENT_ROWS" => Some(Self::PriceTableInconsistentRows),
                "PRICE_DESCRIPTION_HAS_PRICE_QUALIFIERS" => {
                    Some(Self::PriceDescriptionHasPriceQualifiers)
                }
                "PRICE_UNSUPPORTED_LANGUAGE" => Some(Self::PriceUnsupportedLanguage),
                "PRICE_TABLE_ROW_HEADER_TABLE_TYPE_MISMATCH" => {
                    Some(Self::PriceTableRowHeaderTableTypeMismatch)
                }
                "PRICE_TABLE_ROW_HEADER_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::PriceTableRowHeaderHasPromotionalText)
                }
                "PRICE_TABLE_ROW_DESCRIPTION_NOT_RELEVANT" => {
                    Some(Self::PriceTableRowDescriptionNotRelevant)
                }
                "PRICE_TABLE_ROW_DESCRIPTION_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::PriceTableRowDescriptionHasPromotionalText)
                }
                "PRICE_TABLE_ROW_HEADER_DESCRIPTION_REPETITIVE" => {
                    Some(Self::PriceTableRowHeaderDescriptionRepetitive)
                }
                "PRICE_TABLE_ROW_UNRATEABLE" => Some(Self::PriceTableRowUnrateable),
                "PRICE_TABLE_ROW_PRICE_INVALID" => Some(Self::PriceTableRowPriceInvalid),
                "PRICE_TABLE_ROW_URL_INVALID" => Some(Self::PriceTableRowUrlInvalid),
                "PRICE_HEADER_OR_DESCRIPTION_HAS_PRICE" => {
                    Some(Self::PriceHeaderOrDescriptionHasPrice)
                }
                "STRUCTURED_SNIPPETS_HEADER_POLICY_VIOLATED" => {
                    Some(Self::StructuredSnippetsHeaderPolicyViolated)
                }
                "STRUCTURED_SNIPPETS_REPEATED_VALUES" => {
                    Some(Self::StructuredSnippetsRepeatedValues)
                }
                "STRUCTURED_SNIPPETS_EDITORIAL_GUIDELINES" => {
                    Some(Self::StructuredSnippetsEditorialGuidelines)
                }
                "STRUCTURED_SNIPPETS_HAS_PROMOTIONAL_TEXT" => {
                    Some(Self::StructuredSnippetsHasPromotionalText)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemValidationStatusEnum {}
/// Nested message and enum types in `FeedItemValidationStatusEnum`.
pub mod feed_item_validation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemValidationStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Invalid = 3,
        Valid = 4,
    }
    impl FeedItemValidationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemValidationStatus::Unspecified => "UNSPECIFIED",
                FeedItemValidationStatus::Unknown => "UNKNOWN",
                FeedItemValidationStatus::Pending => "PENDING",
                FeedItemValidationStatus::Invalid => "INVALID",
                FeedItemValidationStatus::Valid => "VALID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "INVALID" => Some(Self::Invalid),
                "VALID" => Some(Self::Valid),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetingRestrictionEnum {}
/// Nested message and enum types in `GeoTargetingRestrictionEnum`.
pub mod geo_targeting_restriction_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetingRestriction {
        Unspecified = 0,
        Unknown = 1,
        LocationOfPresence = 2,
    }
    impl GeoTargetingRestriction {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GeoTargetingRestriction::Unspecified => "UNSPECIFIED",
                GeoTargetingRestriction::Unknown => "UNKNOWN",
                GeoTargetingRestriction::LocationOfPresence => "LOCATION_OF_PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionCategoryEnum {}
/// Nested message and enum types in `ConversionActionCategoryEnum`.
pub mod conversion_action_category_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionCategory {
        Unspecified = 0,
        Unknown = 1,
        Default = 2,
        PageView = 3,
        Purchase = 4,
        Signup = 5,
        Download = 7,
        AddToCart = 8,
        BeginCheckout = 9,
        SubscribePaid = 10,
        PhoneCallLead = 11,
        ImportedLead = 12,
        SubmitLeadForm = 13,
        BookAppointment = 14,
        RequestQuote = 15,
        GetDirections = 16,
        OutboundClick = 17,
        Contact = 18,
        Engagement = 19,
        StoreVisit = 20,
        StoreSale = 21,
        QualifiedLead = 22,
        ConvertedLead = 23,
    }
    impl ConversionActionCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionCategory::Unspecified => "UNSPECIFIED",
                ConversionActionCategory::Unknown => "UNKNOWN",
                ConversionActionCategory::Default => "DEFAULT",
                ConversionActionCategory::PageView => "PAGE_VIEW",
                ConversionActionCategory::Purchase => "PURCHASE",
                ConversionActionCategory::Signup => "SIGNUP",
                ConversionActionCategory::Download => "DOWNLOAD",
                ConversionActionCategory::AddToCart => "ADD_TO_CART",
                ConversionActionCategory::BeginCheckout => "BEGIN_CHECKOUT",
                ConversionActionCategory::SubscribePaid => "SUBSCRIBE_PAID",
                ConversionActionCategory::PhoneCallLead => "PHONE_CALL_LEAD",
                ConversionActionCategory::ImportedLead => "IMPORTED_LEAD",
                ConversionActionCategory::SubmitLeadForm => "SUBMIT_LEAD_FORM",
                ConversionActionCategory::BookAppointment => "BOOK_APPOINTMENT",
                ConversionActionCategory::RequestQuote => "REQUEST_QUOTE",
                ConversionActionCategory::GetDirections => "GET_DIRECTIONS",
                ConversionActionCategory::OutboundClick => "OUTBOUND_CLICK",
                ConversionActionCategory::Contact => "CONTACT",
                ConversionActionCategory::Engagement => "ENGAGEMENT",
                ConversionActionCategory::StoreVisit => "STORE_VISIT",
                ConversionActionCategory::StoreSale => "STORE_SALE",
                ConversionActionCategory::QualifiedLead => "QUALIFIED_LEAD",
                ConversionActionCategory::ConvertedLead => "CONVERTED_LEAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT" => Some(Self::Default),
                "PAGE_VIEW" => Some(Self::PageView),
                "PURCHASE" => Some(Self::Purchase),
                "SIGNUP" => Some(Self::Signup),
                "DOWNLOAD" => Some(Self::Download),
                "ADD_TO_CART" => Some(Self::AddToCart),
                "BEGIN_CHECKOUT" => Some(Self::BeginCheckout),
                "SUBSCRIBE_PAID" => Some(Self::SubscribePaid),
                "PHONE_CALL_LEAD" => Some(Self::PhoneCallLead),
                "IMPORTED_LEAD" => Some(Self::ImportedLead),
                "SUBMIT_LEAD_FORM" => Some(Self::SubmitLeadForm),
                "BOOK_APPOINTMENT" => Some(Self::BookAppointment),
                "REQUEST_QUOTE" => Some(Self::RequestQuote),
                "GET_DIRECTIONS" => Some(Self::GetDirections),
                "OUTBOUND_CLICK" => Some(Self::OutboundClick),
                "CONTACT" => Some(Self::Contact),
                "ENGAGEMENT" => Some(Self::Engagement),
                "STORE_VISIT" => Some(Self::StoreVisit),
                "STORE_SALE" => Some(Self::StoreSale),
                "QUALIFIED_LEAD" => Some(Self::QualifiedLead),
                "CONVERTED_LEAD" => Some(Self::ConvertedLead),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleSetStatusEnum {}
/// Nested message and enum types in `ConversionValueRuleSetStatusEnum`.
pub mod conversion_value_rule_set_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleSetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Paused = 4,
    }
    impl ConversionValueRuleSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionValueRuleSetStatus::Unspecified => "UNSPECIFIED",
                ConversionValueRuleSetStatus::Unknown => "UNKNOWN",
                ConversionValueRuleSetStatus::Enabled => "ENABLED",
                ConversionValueRuleSetStatus::Removed => "REMOVED",
                ConversionValueRuleSetStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleSetAttachmentTypeEnum {}
/// Nested message and enum types in `ValueRuleSetAttachmentTypeEnum`.
pub mod value_rule_set_attachment_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleSetAttachmentType {
        Unspecified = 0,
        Unknown = 1,
        Customer = 2,
        Campaign = 3,
    }
    impl ValueRuleSetAttachmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueRuleSetAttachmentType::Unspecified => "UNSPECIFIED",
                ValueRuleSetAttachmentType::Unknown => "UNKNOWN",
                ValueRuleSetAttachmentType::Customer => "CUSTOMER",
                ValueRuleSetAttachmentType::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleSetDimensionEnum {}
/// Nested message and enum types in `ValueRuleSetDimensionEnum`.
pub mod value_rule_set_dimension_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleSetDimension {
        Unspecified = 0,
        Unknown = 1,
        GeoLocation = 2,
        Device = 3,
        Audience = 4,
        NoCondition = 5,
    }
    impl ValueRuleSetDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueRuleSetDimension::Unspecified => "UNSPECIFIED",
                ValueRuleSetDimension::Unknown => "UNKNOWN",
                ValueRuleSetDimension::GeoLocation => "GEO_LOCATION",
                ValueRuleSetDimension::Device => "DEVICE",
                ValueRuleSetDimension::Audience => "AUDIENCE",
                ValueRuleSetDimension::NoCondition => "NO_CONDITION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GEO_LOCATION" => Some(Self::GeoLocation),
                "DEVICE" => Some(Self::Device),
                "AUDIENCE" => Some(Self::Audience),
                "NO_CONDITION" => Some(Self::NoCondition),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallToActionTypeEnum {}
/// Nested message and enum types in `CallToActionTypeEnum`.
pub mod call_to_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallToActionType {
        Unspecified = 0,
        Unknown = 1,
        LearnMore = 2,
        GetQuote = 3,
        ApplyNow = 4,
        SignUp = 5,
        ContactUs = 6,
        Subscribe = 7,
        Download = 8,
        BookNow = 9,
        ShopNow = 10,
        BuyNow = 11,
        DonateNow = 12,
        OrderNow = 13,
        PlayNow = 14,
        SeeMore = 15,
        StartNow = 16,
        VisitSite = 17,
        WatchNow = 18,
    }
    impl CallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallToActionType::Unspecified => "UNSPECIFIED",
                CallToActionType::Unknown => "UNKNOWN",
                CallToActionType::LearnMore => "LEARN_MORE",
                CallToActionType::GetQuote => "GET_QUOTE",
                CallToActionType::ApplyNow => "APPLY_NOW",
                CallToActionType::SignUp => "SIGN_UP",
                CallToActionType::ContactUs => "CONTACT_US",
                CallToActionType::Subscribe => "SUBSCRIBE",
                CallToActionType::Download => "DOWNLOAD",
                CallToActionType::BookNow => "BOOK_NOW",
                CallToActionType::ShopNow => "SHOP_NOW",
                CallToActionType::BuyNow => "BUY_NOW",
                CallToActionType::DonateNow => "DONATE_NOW",
                CallToActionType::OrderNow => "ORDER_NOW",
                CallToActionType::PlayNow => "PLAY_NOW",
                CallToActionType::SeeMore => "SEE_MORE",
                CallToActionType::StartNow => "START_NOW",
                CallToActionType::VisitSite => "VISIT_SITE",
                CallToActionType::WatchNow => "WATCH_NOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEARN_MORE" => Some(Self::LearnMore),
                "GET_QUOTE" => Some(Self::GetQuote),
                "APPLY_NOW" => Some(Self::ApplyNow),
                "SIGN_UP" => Some(Self::SignUp),
                "CONTACT_US" => Some(Self::ContactUs),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "DOWNLOAD" => Some(Self::Download),
                "BOOK_NOW" => Some(Self::BookNow),
                "SHOP_NOW" => Some(Self::ShopNow),
                "BUY_NOW" => Some(Self::BuyNow),
                "DONATE_NOW" => Some(Self::DonateNow),
                "ORDER_NOW" => Some(Self::OrderNow),
                "PLAY_NOW" => Some(Self::PlayNow),
                "SEE_MORE" => Some(Self::SeeMore),
                "START_NOW" => Some(Self::StartNow),
                "VISIT_SITE" => Some(Self::VisitSite),
                "WATCH_NOW" => Some(Self::WatchNow),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormCallToActionTypeEnum {}
/// Nested message and enum types in `LeadFormCallToActionTypeEnum`.
pub mod lead_form_call_to_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormCallToActionType {
        Unspecified = 0,
        Unknown = 1,
        LearnMore = 2,
        GetQuote = 3,
        ApplyNow = 4,
        SignUp = 5,
        ContactUs = 6,
        Subscribe = 7,
        Download = 8,
        BookNow = 9,
        GetOffer = 10,
        Register = 11,
        GetInfo = 12,
        RequestDemo = 13,
        JoinNow = 14,
        GetStarted = 15,
    }
    impl LeadFormCallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadFormCallToActionType::Unspecified => "UNSPECIFIED",
                LeadFormCallToActionType::Unknown => "UNKNOWN",
                LeadFormCallToActionType::LearnMore => "LEARN_MORE",
                LeadFormCallToActionType::GetQuote => "GET_QUOTE",
                LeadFormCallToActionType::ApplyNow => "APPLY_NOW",
                LeadFormCallToActionType::SignUp => "SIGN_UP",
                LeadFormCallToActionType::ContactUs => "CONTACT_US",
                LeadFormCallToActionType::Subscribe => "SUBSCRIBE",
                LeadFormCallToActionType::Download => "DOWNLOAD",
                LeadFormCallToActionType::BookNow => "BOOK_NOW",
                LeadFormCallToActionType::GetOffer => "GET_OFFER",
                LeadFormCallToActionType::Register => "REGISTER",
                LeadFormCallToActionType::GetInfo => "GET_INFO",
                LeadFormCallToActionType::RequestDemo => "REQUEST_DEMO",
                LeadFormCallToActionType::JoinNow => "JOIN_NOW",
                LeadFormCallToActionType::GetStarted => "GET_STARTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEARN_MORE" => Some(Self::LearnMore),
                "GET_QUOTE" => Some(Self::GetQuote),
                "APPLY_NOW" => Some(Self::ApplyNow),
                "SIGN_UP" => Some(Self::SignUp),
                "CONTACT_US" => Some(Self::ContactUs),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "DOWNLOAD" => Some(Self::Download),
                "BOOK_NOW" => Some(Self::BookNow),
                "GET_OFFER" => Some(Self::GetOffer),
                "REGISTER" => Some(Self::Register),
                "GET_INFO" => Some(Self::GetInfo),
                "REQUEST_DEMO" => Some(Self::RequestDemo),
                "JOIN_NOW" => Some(Self::JoinNow),
                "GET_STARTED" => Some(Self::GetStarted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormDesiredIntentEnum {}
/// Nested message and enum types in `LeadFormDesiredIntentEnum`.
pub mod lead_form_desired_intent_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormDesiredIntent {
        Unspecified = 0,
        Unknown = 1,
        LowIntent = 2,
        HighIntent = 3,
    }
    impl LeadFormDesiredIntent {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadFormDesiredIntent::Unspecified => "UNSPECIFIED",
                LeadFormDesiredIntent::Unknown => "UNKNOWN",
                LeadFormDesiredIntent::LowIntent => "LOW_INTENT",
                LeadFormDesiredIntent::HighIntent => "HIGH_INTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOW_INTENT" => Some(Self::LowIntent),
                "HIGH_INTENT" => Some(Self::HighIntent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormFieldUserInputTypeEnum {}
/// Nested message and enum types in `LeadFormFieldUserInputTypeEnum`.
pub mod lead_form_field_user_input_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormFieldUserInputType {
        Unspecified = 0,
        Unknown = 1,
        FullName = 2,
        Email = 3,
        PhoneNumber = 4,
        PostalCode = 5,
        StreetAddress = 8,
        City = 9,
        Region = 10,
        Country = 11,
        WorkEmail = 12,
        CompanyName = 13,
        WorkPhone = 14,
        JobTitle = 15,
        GovernmentIssuedIdCpfBr = 16,
        GovernmentIssuedIdDniAr = 17,
        GovernmentIssuedIdDniPe = 18,
        GovernmentIssuedIdRutCl = 19,
        GovernmentIssuedIdCcCo = 20,
        GovernmentIssuedIdCiEc = 21,
        GovernmentIssuedIdRfcMx = 22,
        FirstName = 23,
        LastName = 24,
        VehicleModel = 1001,
        VehicleType = 1002,
        PreferredDealership = 1003,
        VehiclePurchaseTimeline = 1004,
        VehicleOwnership = 1005,
        VehiclePaymentType = 1009,
        VehicleCondition = 1010,
        CompanySize = 1006,
        AnnualSales = 1007,
        YearsInBusiness = 1008,
        JobDepartment = 1011,
        JobRole = 1012,
        Over18Age = 1078,
        Over19Age = 1079,
        Over20Age = 1080,
        Over21Age = 1081,
        Over22Age = 1082,
        Over23Age = 1083,
        Over24Age = 1084,
        Over25Age = 1085,
        Over26Age = 1086,
        Over27Age = 1087,
        Over28Age = 1088,
        Over29Age = 1089,
        Over30Age = 1090,
        Over31Age = 1091,
        Over32Age = 1092,
        Over33Age = 1093,
        Over34Age = 1094,
        Over35Age = 1095,
        Over36Age = 1096,
        Over37Age = 1097,
        Over38Age = 1098,
        Over39Age = 1099,
        Over40Age = 1100,
        Over41Age = 1101,
        Over42Age = 1102,
        Over43Age = 1103,
        Over44Age = 1104,
        Over45Age = 1105,
        Over46Age = 1106,
        Over47Age = 1107,
        Over48Age = 1108,
        Over49Age = 1109,
        Over50Age = 1110,
        Over51Age = 1111,
        Over52Age = 1112,
        Over53Age = 1113,
        Over54Age = 1114,
        Over55Age = 1115,
        Over56Age = 1116,
        Over57Age = 1117,
        Over58Age = 1118,
        Over59Age = 1119,
        Over60Age = 1120,
        Over61Age = 1121,
        Over62Age = 1122,
        Over63Age = 1123,
        Over64Age = 1124,
        Over65Age = 1125,
        EducationProgram = 1013,
        EducationCourse = 1014,
        Product = 1016,
        Service = 1017,
        Offer = 1018,
        Category = 1019,
        PreferredContactMethod = 1020,
        PreferredLocation = 1021,
        PreferredContactTime = 1022,
        PurchaseTimeline = 1023,
        YearsOfExperience = 1048,
        JobIndustry = 1049,
        LevelOfEducation = 1050,
        PropertyType = 1024,
        RealtorHelpGoal = 1025,
        PropertyCommunity = 1026,
        PriceRange = 1027,
        NumberOfBedrooms = 1028,
        FurnishedProperty = 1029,
        PetsAllowedProperty = 1030,
        NextPlannedPurchase = 1031,
        EventSignupInterest = 1033,
        PreferredShoppingPlaces = 1034,
        FavoriteBrand = 1035,
        TransportationCommercialLicenseType = 1036,
        EventBookingInterest = 1038,
        DestinationCountry = 1039,
        DestinationCity = 1040,
        DepartureCountry = 1041,
        DepartureCity = 1042,
        DepartureDate = 1043,
        ReturnDate = 1044,
        NumberOfTravelers = 1045,
        TravelBudget = 1046,
        TravelAccommodation = 1047,
    }
    impl LeadFormFieldUserInputType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadFormFieldUserInputType::Unspecified => "UNSPECIFIED",
                LeadFormFieldUserInputType::Unknown => "UNKNOWN",
                LeadFormFieldUserInputType::FullName => "FULL_NAME",
                LeadFormFieldUserInputType::Email => "EMAIL",
                LeadFormFieldUserInputType::PhoneNumber => "PHONE_NUMBER",
                LeadFormFieldUserInputType::PostalCode => "POSTAL_CODE",
                LeadFormFieldUserInputType::StreetAddress => "STREET_ADDRESS",
                LeadFormFieldUserInputType::City => "CITY",
                LeadFormFieldUserInputType::Region => "REGION",
                LeadFormFieldUserInputType::Country => "COUNTRY",
                LeadFormFieldUserInputType::WorkEmail => "WORK_EMAIL",
                LeadFormFieldUserInputType::CompanyName => "COMPANY_NAME",
                LeadFormFieldUserInputType::WorkPhone => "WORK_PHONE",
                LeadFormFieldUserInputType::JobTitle => "JOB_TITLE",
                LeadFormFieldUserInputType::GovernmentIssuedIdCpfBr => {
                    "GOVERNMENT_ISSUED_ID_CPF_BR"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdDniAr => {
                    "GOVERNMENT_ISSUED_ID_DNI_AR"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdDniPe => {
                    "GOVERNMENT_ISSUED_ID_DNI_PE"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdRutCl => {
                    "GOVERNMENT_ISSUED_ID_RUT_CL"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdCcCo => {
                    "GOVERNMENT_ISSUED_ID_CC_CO"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdCiEc => {
                    "GOVERNMENT_ISSUED_ID_CI_EC"
                }
                LeadFormFieldUserInputType::GovernmentIssuedIdRfcMx => {
                    "GOVERNMENT_ISSUED_ID_RFC_MX"
                }
                LeadFormFieldUserInputType::FirstName => "FIRST_NAME",
                LeadFormFieldUserInputType::LastName => "LAST_NAME",
                LeadFormFieldUserInputType::VehicleModel => "VEHICLE_MODEL",
                LeadFormFieldUserInputType::VehicleType => "VEHICLE_TYPE",
                LeadFormFieldUserInputType::PreferredDealership => "PREFERRED_DEALERSHIP",
                LeadFormFieldUserInputType::VehiclePurchaseTimeline => {
                    "VEHICLE_PURCHASE_TIMELINE"
                }
                LeadFormFieldUserInputType::VehicleOwnership => "VEHICLE_OWNERSHIP",
                LeadFormFieldUserInputType::VehiclePaymentType => "VEHICLE_PAYMENT_TYPE",
                LeadFormFieldUserInputType::VehicleCondition => "VEHICLE_CONDITION",
                LeadFormFieldUserInputType::CompanySize => "COMPANY_SIZE",
                LeadFormFieldUserInputType::AnnualSales => "ANNUAL_SALES",
                LeadFormFieldUserInputType::YearsInBusiness => "YEARS_IN_BUSINESS",
                LeadFormFieldUserInputType::JobDepartment => "JOB_DEPARTMENT",
                LeadFormFieldUserInputType::JobRole => "JOB_ROLE",
                LeadFormFieldUserInputType::Over18Age => "OVER_18_AGE",
                LeadFormFieldUserInputType::Over19Age => "OVER_19_AGE",
                LeadFormFieldUserInputType::Over20Age => "OVER_20_AGE",
                LeadFormFieldUserInputType::Over21Age => "OVER_21_AGE",
                LeadFormFieldUserInputType::Over22Age => "OVER_22_AGE",
                LeadFormFieldUserInputType::Over23Age => "OVER_23_AGE",
                LeadFormFieldUserInputType::Over24Age => "OVER_24_AGE",
                LeadFormFieldUserInputType::Over25Age => "OVER_25_AGE",
                LeadFormFieldUserInputType::Over26Age => "OVER_26_AGE",
                LeadFormFieldUserInputType::Over27Age => "OVER_27_AGE",
                LeadFormFieldUserInputType::Over28Age => "OVER_28_AGE",
                LeadFormFieldUserInputType::Over29Age => "OVER_29_AGE",
                LeadFormFieldUserInputType::Over30Age => "OVER_30_AGE",
                LeadFormFieldUserInputType::Over31Age => "OVER_31_AGE",
                LeadFormFieldUserInputType::Over32Age => "OVER_32_AGE",
                LeadFormFieldUserInputType::Over33Age => "OVER_33_AGE",
                LeadFormFieldUserInputType::Over34Age => "OVER_34_AGE",
                LeadFormFieldUserInputType::Over35Age => "OVER_35_AGE",
                LeadFormFieldUserInputType::Over36Age => "OVER_36_AGE",
                LeadFormFieldUserInputType::Over37Age => "OVER_37_AGE",
                LeadFormFieldUserInputType::Over38Age => "OVER_38_AGE",
                LeadFormFieldUserInputType::Over39Age => "OVER_39_AGE",
                LeadFormFieldUserInputType::Over40Age => "OVER_40_AGE",
                LeadFormFieldUserInputType::Over41Age => "OVER_41_AGE",
                LeadFormFieldUserInputType::Over42Age => "OVER_42_AGE",
                LeadFormFieldUserInputType::Over43Age => "OVER_43_AGE",
                LeadFormFieldUserInputType::Over44Age => "OVER_44_AGE",
                LeadFormFieldUserInputType::Over45Age => "OVER_45_AGE",
                LeadFormFieldUserInputType::Over46Age => "OVER_46_AGE",
                LeadFormFieldUserInputType::Over47Age => "OVER_47_AGE",
                LeadFormFieldUserInputType::Over48Age => "OVER_48_AGE",
                LeadFormFieldUserInputType::Over49Age => "OVER_49_AGE",
                LeadFormFieldUserInputType::Over50Age => "OVER_50_AGE",
                LeadFormFieldUserInputType::Over51Age => "OVER_51_AGE",
                LeadFormFieldUserInputType::Over52Age => "OVER_52_AGE",
                LeadFormFieldUserInputType::Over53Age => "OVER_53_AGE",
                LeadFormFieldUserInputType::Over54Age => "OVER_54_AGE",
                LeadFormFieldUserInputType::Over55Age => "OVER_55_AGE",
                LeadFormFieldUserInputType::Over56Age => "OVER_56_AGE",
                LeadFormFieldUserInputType::Over57Age => "OVER_57_AGE",
                LeadFormFieldUserInputType::Over58Age => "OVER_58_AGE",
                LeadFormFieldUserInputType::Over59Age => "OVER_59_AGE",
                LeadFormFieldUserInputType::Over60Age => "OVER_60_AGE",
                LeadFormFieldUserInputType::Over61Age => "OVER_61_AGE",
                LeadFormFieldUserInputType::Over62Age => "OVER_62_AGE",
                LeadFormFieldUserInputType::Over63Age => "OVER_63_AGE",
                LeadFormFieldUserInputType::Over64Age => "OVER_64_AGE",
                LeadFormFieldUserInputType::Over65Age => "OVER_65_AGE",
                LeadFormFieldUserInputType::EducationProgram => "EDUCATION_PROGRAM",
                LeadFormFieldUserInputType::EducationCourse => "EDUCATION_COURSE",
                LeadFormFieldUserInputType::Product => "PRODUCT",
                LeadFormFieldUserInputType::Service => "SERVICE",
                LeadFormFieldUserInputType::Offer => "OFFER",
                LeadFormFieldUserInputType::Category => "CATEGORY",
                LeadFormFieldUserInputType::PreferredContactMethod => {
                    "PREFERRED_CONTACT_METHOD"
                }
                LeadFormFieldUserInputType::PreferredLocation => "PREFERRED_LOCATION",
                LeadFormFieldUserInputType::PreferredContactTime => {
                    "PREFERRED_CONTACT_TIME"
                }
                LeadFormFieldUserInputType::PurchaseTimeline => "PURCHASE_TIMELINE",
                LeadFormFieldUserInputType::YearsOfExperience => "YEARS_OF_EXPERIENCE",
                LeadFormFieldUserInputType::JobIndustry => "JOB_INDUSTRY",
                LeadFormFieldUserInputType::LevelOfEducation => "LEVEL_OF_EDUCATION",
                LeadFormFieldUserInputType::PropertyType => "PROPERTY_TYPE",
                LeadFormFieldUserInputType::RealtorHelpGoal => "REALTOR_HELP_GOAL",
                LeadFormFieldUserInputType::PropertyCommunity => "PROPERTY_COMMUNITY",
                LeadFormFieldUserInputType::PriceRange => "PRICE_RANGE",
                LeadFormFieldUserInputType::NumberOfBedrooms => "NUMBER_OF_BEDROOMS",
                LeadFormFieldUserInputType::FurnishedProperty => "FURNISHED_PROPERTY",
                LeadFormFieldUserInputType::PetsAllowedProperty => {
                    "PETS_ALLOWED_PROPERTY"
                }
                LeadFormFieldUserInputType::NextPlannedPurchase => {
                    "NEXT_PLANNED_PURCHASE"
                }
                LeadFormFieldUserInputType::EventSignupInterest => {
                    "EVENT_SIGNUP_INTEREST"
                }
                LeadFormFieldUserInputType::PreferredShoppingPlaces => {
                    "PREFERRED_SHOPPING_PLACES"
                }
                LeadFormFieldUserInputType::FavoriteBrand => "FAVORITE_BRAND",
                LeadFormFieldUserInputType::TransportationCommercialLicenseType => {
                    "TRANSPORTATION_COMMERCIAL_LICENSE_TYPE"
                }
                LeadFormFieldUserInputType::EventBookingInterest => {
                    "EVENT_BOOKING_INTEREST"
                }
                LeadFormFieldUserInputType::DestinationCountry => "DESTINATION_COUNTRY",
                LeadFormFieldUserInputType::DestinationCity => "DESTINATION_CITY",
                LeadFormFieldUserInputType::DepartureCountry => "DEPARTURE_COUNTRY",
                LeadFormFieldUserInputType::DepartureCity => "DEPARTURE_CITY",
                LeadFormFieldUserInputType::DepartureDate => "DEPARTURE_DATE",
                LeadFormFieldUserInputType::ReturnDate => "RETURN_DATE",
                LeadFormFieldUserInputType::NumberOfTravelers => "NUMBER_OF_TRAVELERS",
                LeadFormFieldUserInputType::TravelBudget => "TRAVEL_BUDGET",
                LeadFormFieldUserInputType::TravelAccommodation => "TRAVEL_ACCOMMODATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FULL_NAME" => Some(Self::FullName),
                "EMAIL" => Some(Self::Email),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "STREET_ADDRESS" => Some(Self::StreetAddress),
                "CITY" => Some(Self::City),
                "REGION" => Some(Self::Region),
                "COUNTRY" => Some(Self::Country),
                "WORK_EMAIL" => Some(Self::WorkEmail),
                "COMPANY_NAME" => Some(Self::CompanyName),
                "WORK_PHONE" => Some(Self::WorkPhone),
                "JOB_TITLE" => Some(Self::JobTitle),
                "GOVERNMENT_ISSUED_ID_CPF_BR" => Some(Self::GovernmentIssuedIdCpfBr),
                "GOVERNMENT_ISSUED_ID_DNI_AR" => Some(Self::GovernmentIssuedIdDniAr),
                "GOVERNMENT_ISSUED_ID_DNI_PE" => Some(Self::GovernmentIssuedIdDniPe),
                "GOVERNMENT_ISSUED_ID_RUT_CL" => Some(Self::GovernmentIssuedIdRutCl),
                "GOVERNMENT_ISSUED_ID_CC_CO" => Some(Self::GovernmentIssuedIdCcCo),
                "GOVERNMENT_ISSUED_ID_CI_EC" => Some(Self::GovernmentIssuedIdCiEc),
                "GOVERNMENT_ISSUED_ID_RFC_MX" => Some(Self::GovernmentIssuedIdRfcMx),
                "FIRST_NAME" => Some(Self::FirstName),
                "LAST_NAME" => Some(Self::LastName),
                "VEHICLE_MODEL" => Some(Self::VehicleModel),
                "VEHICLE_TYPE" => Some(Self::VehicleType),
                "PREFERRED_DEALERSHIP" => Some(Self::PreferredDealership),
                "VEHICLE_PURCHASE_TIMELINE" => Some(Self::VehiclePurchaseTimeline),
                "VEHICLE_OWNERSHIP" => Some(Self::VehicleOwnership),
                "VEHICLE_PAYMENT_TYPE" => Some(Self::VehiclePaymentType),
                "VEHICLE_CONDITION" => Some(Self::VehicleCondition),
                "COMPANY_SIZE" => Some(Self::CompanySize),
                "ANNUAL_SALES" => Some(Self::AnnualSales),
                "YEARS_IN_BUSINESS" => Some(Self::YearsInBusiness),
                "JOB_DEPARTMENT" => Some(Self::JobDepartment),
                "JOB_ROLE" => Some(Self::JobRole),
                "OVER_18_AGE" => Some(Self::Over18Age),
                "OVER_19_AGE" => Some(Self::Over19Age),
                "OVER_20_AGE" => Some(Self::Over20Age),
                "OVER_21_AGE" => Some(Self::Over21Age),
                "OVER_22_AGE" => Some(Self::Over22Age),
                "OVER_23_AGE" => Some(Self::Over23Age),
                "OVER_24_AGE" => Some(Self::Over24Age),
                "OVER_25_AGE" => Some(Self::Over25Age),
                "OVER_26_AGE" => Some(Self::Over26Age),
                "OVER_27_AGE" => Some(Self::Over27Age),
                "OVER_28_AGE" => Some(Self::Over28Age),
                "OVER_29_AGE" => Some(Self::Over29Age),
                "OVER_30_AGE" => Some(Self::Over30Age),
                "OVER_31_AGE" => Some(Self::Over31Age),
                "OVER_32_AGE" => Some(Self::Over32Age),
                "OVER_33_AGE" => Some(Self::Over33Age),
                "OVER_34_AGE" => Some(Self::Over34Age),
                "OVER_35_AGE" => Some(Self::Over35Age),
                "OVER_36_AGE" => Some(Self::Over36Age),
                "OVER_37_AGE" => Some(Self::Over37Age),
                "OVER_38_AGE" => Some(Self::Over38Age),
                "OVER_39_AGE" => Some(Self::Over39Age),
                "OVER_40_AGE" => Some(Self::Over40Age),
                "OVER_41_AGE" => Some(Self::Over41Age),
                "OVER_42_AGE" => Some(Self::Over42Age),
                "OVER_43_AGE" => Some(Self::Over43Age),
                "OVER_44_AGE" => Some(Self::Over44Age),
                "OVER_45_AGE" => Some(Self::Over45Age),
                "OVER_46_AGE" => Some(Self::Over46Age),
                "OVER_47_AGE" => Some(Self::Over47Age),
                "OVER_48_AGE" => Some(Self::Over48Age),
                "OVER_49_AGE" => Some(Self::Over49Age),
                "OVER_50_AGE" => Some(Self::Over50Age),
                "OVER_51_AGE" => Some(Self::Over51Age),
                "OVER_52_AGE" => Some(Self::Over52Age),
                "OVER_53_AGE" => Some(Self::Over53Age),
                "OVER_54_AGE" => Some(Self::Over54Age),
                "OVER_55_AGE" => Some(Self::Over55Age),
                "OVER_56_AGE" => Some(Self::Over56Age),
                "OVER_57_AGE" => Some(Self::Over57Age),
                "OVER_58_AGE" => Some(Self::Over58Age),
                "OVER_59_AGE" => Some(Self::Over59Age),
                "OVER_60_AGE" => Some(Self::Over60Age),
                "OVER_61_AGE" => Some(Self::Over61Age),
                "OVER_62_AGE" => Some(Self::Over62Age),
                "OVER_63_AGE" => Some(Self::Over63Age),
                "OVER_64_AGE" => Some(Self::Over64Age),
                "OVER_65_AGE" => Some(Self::Over65Age),
                "EDUCATION_PROGRAM" => Some(Self::EducationProgram),
                "EDUCATION_COURSE" => Some(Self::EducationCourse),
                "PRODUCT" => Some(Self::Product),
                "SERVICE" => Some(Self::Service),
                "OFFER" => Some(Self::Offer),
                "CATEGORY" => Some(Self::Category),
                "PREFERRED_CONTACT_METHOD" => Some(Self::PreferredContactMethod),
                "PREFERRED_LOCATION" => Some(Self::PreferredLocation),
                "PREFERRED_CONTACT_TIME" => Some(Self::PreferredContactTime),
                "PURCHASE_TIMELINE" => Some(Self::PurchaseTimeline),
                "YEARS_OF_EXPERIENCE" => Some(Self::YearsOfExperience),
                "JOB_INDUSTRY" => Some(Self::JobIndustry),
                "LEVEL_OF_EDUCATION" => Some(Self::LevelOfEducation),
                "PROPERTY_TYPE" => Some(Self::PropertyType),
                "REALTOR_HELP_GOAL" => Some(Self::RealtorHelpGoal),
                "PROPERTY_COMMUNITY" => Some(Self::PropertyCommunity),
                "PRICE_RANGE" => Some(Self::PriceRange),
                "NUMBER_OF_BEDROOMS" => Some(Self::NumberOfBedrooms),
                "FURNISHED_PROPERTY" => Some(Self::FurnishedProperty),
                "PETS_ALLOWED_PROPERTY" => Some(Self::PetsAllowedProperty),
                "NEXT_PLANNED_PURCHASE" => Some(Self::NextPlannedPurchase),
                "EVENT_SIGNUP_INTEREST" => Some(Self::EventSignupInterest),
                "PREFERRED_SHOPPING_PLACES" => Some(Self::PreferredShoppingPlaces),
                "FAVORITE_BRAND" => Some(Self::FavoriteBrand),
                "TRANSPORTATION_COMMERCIAL_LICENSE_TYPE" => {
                    Some(Self::TransportationCommercialLicenseType)
                }
                "EVENT_BOOKING_INTEREST" => Some(Self::EventBookingInterest),
                "DESTINATION_COUNTRY" => Some(Self::DestinationCountry),
                "DESTINATION_CITY" => Some(Self::DestinationCity),
                "DEPARTURE_COUNTRY" => Some(Self::DepartureCountry),
                "DEPARTURE_CITY" => Some(Self::DepartureCity),
                "DEPARTURE_DATE" => Some(Self::DepartureDate),
                "RETURN_DATE" => Some(Self::ReturnDate),
                "NUMBER_OF_TRAVELERS" => Some(Self::NumberOfTravelers),
                "TRAVEL_BUDGET" => Some(Self::TravelBudget),
                "TRAVEL_ACCOMMODATION" => Some(Self::TravelAccommodation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LeadFormPostSubmitCallToActionTypeEnum {}
/// Nested message and enum types in `LeadFormPostSubmitCallToActionTypeEnum`.
pub mod lead_form_post_submit_call_to_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadFormPostSubmitCallToActionType {
        Unspecified = 0,
        Unknown = 1,
        VisitSite = 2,
        Download = 3,
        LearnMore = 4,
        ShopNow = 5,
    }
    impl LeadFormPostSubmitCallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadFormPostSubmitCallToActionType::Unspecified => "UNSPECIFIED",
                LeadFormPostSubmitCallToActionType::Unknown => "UNKNOWN",
                LeadFormPostSubmitCallToActionType::VisitSite => "VISIT_SITE",
                LeadFormPostSubmitCallToActionType::Download => "DOWNLOAD",
                LeadFormPostSubmitCallToActionType::LearnMore => "LEARN_MORE",
                LeadFormPostSubmitCallToActionType::ShopNow => "SHOP_NOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VISIT_SITE" => Some(Self::VisitSite),
                "DOWNLOAD" => Some(Self::Download),
                "LEARN_MORE" => Some(Self::LearnMore),
                "SHOP_NOW" => Some(Self::ShopNow),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationOwnershipTypeEnum {}
/// Nested message and enum types in `LocationOwnershipTypeEnum`.
pub mod location_ownership_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationOwnershipType {
        Unspecified = 0,
        Unknown = 1,
        BusinessOwner = 2,
        Affiliate = 3,
    }
    impl LocationOwnershipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationOwnershipType::Unspecified => "UNSPECIFIED",
                LocationOwnershipType::Unknown => "UNKNOWN",
                LocationOwnershipType::BusinessOwner => "BUSINESS_OWNER",
                LocationOwnershipType::Affiliate => "AFFILIATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_OWNER" => Some(Self::BusinessOwner),
                "AFFILIATE" => Some(Self::Affiliate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MimeTypeEnum {}
/// Nested message and enum types in `MimeTypeEnum`.
pub mod mime_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MimeType {
        Unspecified = 0,
        Unknown = 1,
        ImageJpeg = 2,
        ImageGif = 3,
        ImagePng = 4,
        Flash = 5,
        TextHtml = 6,
        Pdf = 7,
        Msword = 8,
        Msexcel = 9,
        Rtf = 10,
        AudioWav = 11,
        AudioMp3 = 12,
        Html5AdZip = 13,
    }
    impl MimeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MimeType::Unspecified => "UNSPECIFIED",
                MimeType::Unknown => "UNKNOWN",
                MimeType::ImageJpeg => "IMAGE_JPEG",
                MimeType::ImageGif => "IMAGE_GIF",
                MimeType::ImagePng => "IMAGE_PNG",
                MimeType::Flash => "FLASH",
                MimeType::TextHtml => "TEXT_HTML",
                MimeType::Pdf => "PDF",
                MimeType::Msword => "MSWORD",
                MimeType::Msexcel => "MSEXCEL",
                MimeType::Rtf => "RTF",
                MimeType::AudioWav => "AUDIO_WAV",
                MimeType::AudioMp3 => "AUDIO_MP3",
                MimeType::Html5AdZip => "HTML5_AD_ZIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGE_JPEG" => Some(Self::ImageJpeg),
                "IMAGE_GIF" => Some(Self::ImageGif),
                "IMAGE_PNG" => Some(Self::ImagePng),
                "FLASH" => Some(Self::Flash),
                "TEXT_HTML" => Some(Self::TextHtml),
                "PDF" => Some(Self::Pdf),
                "MSWORD" => Some(Self::Msword),
                "MSEXCEL" => Some(Self::Msexcel),
                "RTF" => Some(Self::Rtf),
                "AUDIO_WAV" => Some(Self::AudioWav),
                "AUDIO_MP3" => Some(Self::AudioMp3),
                "HTML5_AD_ZIP" => Some(Self::Html5AdZip),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MobileAppVendorEnum {}
/// Nested message and enum types in `MobileAppVendorEnum`.
pub mod mobile_app_vendor_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MobileAppVendor {
        Unspecified = 0,
        Unknown = 1,
        AppleAppStore = 2,
        GoogleAppStore = 3,
    }
    impl MobileAppVendor {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MobileAppVendor::Unspecified => "UNSPECIFIED",
                MobileAppVendor::Unknown => "UNKNOWN",
                MobileAppVendor::AppleAppStore => "APPLE_APP_STORE",
                MobileAppVendor::GoogleAppStore => "GOOGLE_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_APP_STORE" => Some(Self::GoogleAppStore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetTypeEnum {}
/// Nested message and enum types in `AssetTypeEnum`.
pub mod asset_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetType {
        Unspecified = 0,
        Unknown = 1,
        YoutubeVideo = 2,
        MediaBundle = 3,
        Image = 4,
        Text = 5,
        LeadForm = 6,
        BookOnGoogle = 7,
        Promotion = 8,
        Callout = 9,
        StructuredSnippet = 10,
        Sitelink = 11,
        PageFeed = 12,
        DynamicEducation = 13,
        MobileApp = 14,
        HotelCallout = 15,
        Call = 16,
        Price = 17,
        CallToAction = 18,
        DynamicRealEstate = 19,
        DynamicCustom = 20,
        DynamicHotelsAndRentals = 21,
        DynamicFlights = 22,
        DiscoveryCarouselCard = 23,
        DynamicTravel = 24,
        DynamicLocal = 25,
        DynamicJobs = 26,
        Location = 27,
        HotelProperty = 28,
    }
    impl AssetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetType::Unspecified => "UNSPECIFIED",
                AssetType::Unknown => "UNKNOWN",
                AssetType::YoutubeVideo => "YOUTUBE_VIDEO",
                AssetType::MediaBundle => "MEDIA_BUNDLE",
                AssetType::Image => "IMAGE",
                AssetType::Text => "TEXT",
                AssetType::LeadForm => "LEAD_FORM",
                AssetType::BookOnGoogle => "BOOK_ON_GOOGLE",
                AssetType::Promotion => "PROMOTION",
                AssetType::Callout => "CALLOUT",
                AssetType::StructuredSnippet => "STRUCTURED_SNIPPET",
                AssetType::Sitelink => "SITELINK",
                AssetType::PageFeed => "PAGE_FEED",
                AssetType::DynamicEducation => "DYNAMIC_EDUCATION",
                AssetType::MobileApp => "MOBILE_APP",
                AssetType::HotelCallout => "HOTEL_CALLOUT",
                AssetType::Call => "CALL",
                AssetType::Price => "PRICE",
                AssetType::CallToAction => "CALL_TO_ACTION",
                AssetType::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                AssetType::DynamicCustom => "DYNAMIC_CUSTOM",
                AssetType::DynamicHotelsAndRentals => "DYNAMIC_HOTELS_AND_RENTALS",
                AssetType::DynamicFlights => "DYNAMIC_FLIGHTS",
                AssetType::DiscoveryCarouselCard => "DISCOVERY_CAROUSEL_CARD",
                AssetType::DynamicTravel => "DYNAMIC_TRAVEL",
                AssetType::DynamicLocal => "DYNAMIC_LOCAL",
                AssetType::DynamicJobs => "DYNAMIC_JOBS",
                AssetType::Location => "LOCATION",
                AssetType::HotelProperty => "HOTEL_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "IMAGE" => Some(Self::Image),
                "TEXT" => Some(Self::Text),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "PAGE_FEED" => Some(Self::PageFeed),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTELS_AND_RENTALS" => Some(Self::DynamicHotelsAndRentals),
                "DYNAMIC_FLIGHTS" => Some(Self::DynamicFlights),
                "DISCOVERY_CAROUSEL_CARD" => Some(Self::DiscoveryCarouselCard),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOBS" => Some(Self::DynamicJobs),
                "LOCATION" => Some(Self::Location),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionOriginEnum {}
/// Nested message and enum types in `ConversionOriginEnum`.
pub mod conversion_origin_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionOrigin {
        Unspecified = 0,
        Unknown = 1,
        Website = 2,
        GoogleHosted = 3,
        App = 4,
        CallFromAds = 5,
        Store = 6,
        YoutubeHosted = 7,
    }
    impl ConversionOrigin {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionOrigin::Unspecified => "UNSPECIFIED",
                ConversionOrigin::Unknown => "UNKNOWN",
                ConversionOrigin::Website => "WEBSITE",
                ConversionOrigin::GoogleHosted => "GOOGLE_HOSTED",
                ConversionOrigin::App => "APP",
                ConversionOrigin::CallFromAds => "CALL_FROM_ADS",
                ConversionOrigin::Store => "STORE",
                ConversionOrigin::YoutubeHosted => "YOUTUBE_HOSTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBSITE" => Some(Self::Website),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "APP" => Some(Self::App),
                "CALL_FROM_ADS" => Some(Self::CallFromAds),
                "STORE" => Some(Self::Store),
                "YOUTUBE_HOSTED" => Some(Self::YoutubeHosted),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AffiliateLocationFeedRelationshipTypeEnum {}
/// Nested message and enum types in `AffiliateLocationFeedRelationshipTypeEnum`.
pub mod affiliate_location_feed_relationship_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AffiliateLocationFeedRelationshipType {
        Unspecified = 0,
        Unknown = 1,
        GeneralRetailer = 2,
    }
    impl AffiliateLocationFeedRelationshipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AffiliateLocationFeedRelationshipType::Unspecified => "UNSPECIFIED",
                AffiliateLocationFeedRelationshipType::Unknown => "UNKNOWN",
                AffiliateLocationFeedRelationshipType::GeneralRetailer => {
                    "GENERAL_RETAILER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GENERAL_RETAILER" => Some(Self::GeneralRetailer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedAttributeTypeEnum {}
/// Nested message and enum types in `FeedAttributeTypeEnum`.
pub mod feed_attribute_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedAttributeType {
        Unspecified = 0,
        Unknown = 1,
        Int64 = 2,
        Double = 3,
        String = 4,
        Boolean = 5,
        Url = 6,
        DateTime = 7,
        Int64List = 8,
        DoubleList = 9,
        StringList = 10,
        BooleanList = 11,
        UrlList = 12,
        DateTimeList = 13,
        Price = 14,
    }
    impl FeedAttributeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedAttributeType::Unspecified => "UNSPECIFIED",
                FeedAttributeType::Unknown => "UNKNOWN",
                FeedAttributeType::Int64 => "INT64",
                FeedAttributeType::Double => "DOUBLE",
                FeedAttributeType::String => "STRING",
                FeedAttributeType::Boolean => "BOOLEAN",
                FeedAttributeType::Url => "URL",
                FeedAttributeType::DateTime => "DATE_TIME",
                FeedAttributeType::Int64List => "INT64_LIST",
                FeedAttributeType::DoubleList => "DOUBLE_LIST",
                FeedAttributeType::StringList => "STRING_LIST",
                FeedAttributeType::BooleanList => "BOOLEAN_LIST",
                FeedAttributeType::UrlList => "URL_LIST",
                FeedAttributeType::DateTimeList => "DATE_TIME_LIST",
                FeedAttributeType::Price => "PRICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INT64" => Some(Self::Int64),
                "DOUBLE" => Some(Self::Double),
                "STRING" => Some(Self::String),
                "BOOLEAN" => Some(Self::Boolean),
                "URL" => Some(Self::Url),
                "DATE_TIME" => Some(Self::DateTime),
                "INT64_LIST" => Some(Self::Int64List),
                "DOUBLE_LIST" => Some(Self::DoubleList),
                "STRING_LIST" => Some(Self::StringList),
                "BOOLEAN_LIST" => Some(Self::BooleanList),
                "URL_LIST" => Some(Self::UrlList),
                "DATE_TIME_LIST" => Some(Self::DateTimeList),
                "PRICE" => Some(Self::Price),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedOriginEnum {}
/// Nested message and enum types in `FeedOriginEnum`.
pub mod feed_origin_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedOrigin {
        Unspecified = 0,
        Unknown = 1,
        User = 2,
        Google = 3,
    }
    impl FeedOrigin {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedOrigin::Unspecified => "UNSPECIFIED",
                FeedOrigin::Unknown => "UNKNOWN",
                FeedOrigin::User => "USER",
                FeedOrigin::Google => "GOOGLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "USER" => Some(Self::User),
                "GOOGLE" => Some(Self::Google),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedStatusEnum {}
/// Nested message and enum types in `FeedStatusEnum`.
pub mod feed_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedStatus::Unspecified => "UNSPECIFIED",
                FeedStatus::Unknown => "UNKNOWN",
                FeedStatus::Enabled => "ENABLED",
                FeedStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListCustomerTypeCategoryEnum {}
/// Nested message and enum types in `UserListCustomerTypeCategoryEnum`.
pub mod user_list_customer_type_category_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListCustomerTypeCategory {
        Unspecified = 0,
        Unknown = 1,
        AllCustomers = 2,
        Purchasers = 3,
        HighValueCustomers = 4,
        DisengagedCustomers = 5,
        QualifiedLeads = 6,
        ConvertedLeads = 7,
        PaidSubscribers = 8,
        LoyaltySignUps = 9,
        CartAbandoners = 10,
        LoyaltyTier1Members = 11,
        LoyaltyTier2Members = 12,
        LoyaltyTier3Members = 13,
        LoyaltyTier4Members = 14,
        LoyaltyTier5Members = 15,
        LoyaltyTier6Members = 16,
        LoyaltyTier7Members = 17,
    }
    impl UserListCustomerTypeCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListCustomerTypeCategory::Unspecified => "UNSPECIFIED",
                UserListCustomerTypeCategory::Unknown => "UNKNOWN",
                UserListCustomerTypeCategory::AllCustomers => "ALL_CUSTOMERS",
                UserListCustomerTypeCategory::Purchasers => "PURCHASERS",
                UserListCustomerTypeCategory::HighValueCustomers => {
                    "HIGH_VALUE_CUSTOMERS"
                }
                UserListCustomerTypeCategory::DisengagedCustomers => {
                    "DISENGAGED_CUSTOMERS"
                }
                UserListCustomerTypeCategory::QualifiedLeads => "QUALIFIED_LEADS",
                UserListCustomerTypeCategory::ConvertedLeads => "CONVERTED_LEADS",
                UserListCustomerTypeCategory::PaidSubscribers => "PAID_SUBSCRIBERS",
                UserListCustomerTypeCategory::LoyaltySignUps => "LOYALTY_SIGN_UPS",
                UserListCustomerTypeCategory::CartAbandoners => "CART_ABANDONERS",
                UserListCustomerTypeCategory::LoyaltyTier1Members => {
                    "LOYALTY_TIER_1_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier2Members => {
                    "LOYALTY_TIER_2_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier3Members => {
                    "LOYALTY_TIER_3_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier4Members => {
                    "LOYALTY_TIER_4_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier5Members => {
                    "LOYALTY_TIER_5_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier6Members => {
                    "LOYALTY_TIER_6_MEMBERS"
                }
                UserListCustomerTypeCategory::LoyaltyTier7Members => {
                    "LOYALTY_TIER_7_MEMBERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_CUSTOMERS" => Some(Self::AllCustomers),
                "PURCHASERS" => Some(Self::Purchasers),
                "HIGH_VALUE_CUSTOMERS" => Some(Self::HighValueCustomers),
                "DISENGAGED_CUSTOMERS" => Some(Self::DisengagedCustomers),
                "QUALIFIED_LEADS" => Some(Self::QualifiedLeads),
                "CONVERTED_LEADS" => Some(Self::ConvertedLeads),
                "PAID_SUBSCRIBERS" => Some(Self::PaidSubscribers),
                "LOYALTY_SIGN_UPS" => Some(Self::LoyaltySignUps),
                "CART_ABANDONERS" => Some(Self::CartAbandoners),
                "LOYALTY_TIER_1_MEMBERS" => Some(Self::LoyaltyTier1Members),
                "LOYALTY_TIER_2_MEMBERS" => Some(Self::LoyaltyTier2Members),
                "LOYALTY_TIER_3_MEMBERS" => Some(Self::LoyaltyTier3Members),
                "LOYALTY_TIER_4_MEMBERS" => Some(Self::LoyaltyTier4Members),
                "LOYALTY_TIER_5_MEMBERS" => Some(Self::LoyaltyTier5Members),
                "LOYALTY_TIER_6_MEMBERS" => Some(Self::LoyaltyTier6Members),
                "LOYALTY_TIER_7_MEMBERS" => Some(Self::LoyaltyTier7Members),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdStrengthEnum {}
/// Nested message and enum types in `AdStrengthEnum`.
pub mod ad_strength_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdStrength {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        NoAds = 3,
        Poor = 4,
        Average = 5,
        Good = 6,
        Excellent = 7,
    }
    impl AdStrength {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdStrength::Unspecified => "UNSPECIFIED",
                AdStrength::Unknown => "UNKNOWN",
                AdStrength::Pending => "PENDING",
                AdStrength::NoAds => "NO_ADS",
                AdStrength::Poor => "POOR",
                AdStrength::Average => "AVERAGE",
                AdStrength::Good => "GOOD",
                AdStrength::Excellent => "EXCELLENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "NO_ADS" => Some(Self::NoAds),
                "POOR" => Some(Self::Poor),
                "AVERAGE" => Some(Self::Average),
                "GOOD" => Some(Self::Good),
                "EXCELLENT" => Some(Self::Excellent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppBiddingGoalEnum {}
/// Nested message and enum types in `AppBiddingGoalEnum`.
pub mod app_bidding_goal_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppBiddingGoal {
        Unspecified = 0,
        Unknown = 1,
        OptimizeForInstallConversionVolume = 2,
        OptimizeForInAppConversionVolume = 3,
        OptimizeForTotalConversionValue = 4,
        OptimizeForTargetInAppConversion = 5,
        OptimizeForReturnOnAdvertisingSpend = 6,
        OptimizeForInstallConversionVolumeWithoutTargetCpi = 7,
        OptimizeForPreRegistrationConversionVolume = 8,
    }
    impl AppBiddingGoal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppBiddingGoal::Unspecified => "UNSPECIFIED",
                AppBiddingGoal::Unknown => "UNKNOWN",
                AppBiddingGoal::OptimizeForInstallConversionVolume => {
                    "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME"
                }
                AppBiddingGoal::OptimizeForInAppConversionVolume => {
                    "OPTIMIZE_FOR_IN_APP_CONVERSION_VOLUME"
                }
                AppBiddingGoal::OptimizeForTotalConversionValue => {
                    "OPTIMIZE_FOR_TOTAL_CONVERSION_VALUE"
                }
                AppBiddingGoal::OptimizeForTargetInAppConversion => {
                    "OPTIMIZE_FOR_TARGET_IN_APP_CONVERSION"
                }
                AppBiddingGoal::OptimizeForReturnOnAdvertisingSpend => {
                    "OPTIMIZE_FOR_RETURN_ON_ADVERTISING_SPEND"
                }
                AppBiddingGoal::OptimizeForInstallConversionVolumeWithoutTargetCpi => {
                    "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME_WITHOUT_TARGET_CPI"
                }
                AppBiddingGoal::OptimizeForPreRegistrationConversionVolume => {
                    "OPTIMIZE_FOR_PRE_REGISTRATION_CONVERSION_VOLUME"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForInstallConversionVolume)
                }
                "OPTIMIZE_FOR_IN_APP_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForInAppConversionVolume)
                }
                "OPTIMIZE_FOR_TOTAL_CONVERSION_VALUE" => {
                    Some(Self::OptimizeForTotalConversionValue)
                }
                "OPTIMIZE_FOR_TARGET_IN_APP_CONVERSION" => {
                    Some(Self::OptimizeForTargetInAppConversion)
                }
                "OPTIMIZE_FOR_RETURN_ON_ADVERTISING_SPEND" => {
                    Some(Self::OptimizeForReturnOnAdvertisingSpend)
                }
                "OPTIMIZE_FOR_INSTALL_CONVERSION_VOLUME_WITHOUT_TARGET_CPI" => {
                    Some(Self::OptimizeForInstallConversionVolumeWithoutTargetCpi)
                }
                "OPTIMIZE_FOR_PRE_REGISTRATION_CONVERSION_VOLUME" => {
                    Some(Self::OptimizeForPreRegistrationConversionVolume)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationTypeEnum {}
/// Nested message and enum types in `RecommendationTypeEnum`.
pub mod recommendation_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationType {
        Unspecified = 0,
        Unknown = 1,
        CampaignBudget = 2,
        Keyword = 3,
        TextAd = 4,
        TargetCpaOptIn = 5,
        MaximizeConversionsOptIn = 6,
        EnhancedCpcOptIn = 7,
        SearchPartnersOptIn = 8,
        MaximizeClicksOptIn = 9,
        OptimizeAdRotation = 10,
        KeywordMatchType = 14,
        MoveUnusedBudget = 15,
        ForecastingCampaignBudget = 16,
        TargetRoasOptIn = 17,
        ResponsiveSearchAd = 18,
        MarginalRoiCampaignBudget = 19,
        UseBroadMatchKeyword = 20,
        ResponsiveSearchAdAsset = 21,
        UpgradeSmartShoppingCampaignToPerformanceMax = 22,
        ResponsiveSearchAdImproveAdStrength = 23,
        DisplayExpansionOptIn = 24,
        UpgradeLocalCampaignToPerformanceMax = 25,
        RaiseTargetCpaBidTooLow = 26,
        ForecastingSetTargetRoas = 27,
        CalloutAsset = 28,
        SitelinkAsset = 29,
        CallAsset = 30,
        ShoppingAddAgeGroup = 31,
        ShoppingAddColor = 32,
        ShoppingAddGender = 33,
        ShoppingAddGtin = 34,
        ShoppingAddMoreIdentifiers = 35,
        ShoppingAddSize = 36,
        ShoppingAddProductsToCampaign = 37,
        ShoppingFixDisapprovedProducts = 38,
        ShoppingTargetAllOffers = 39,
        ShoppingFixSuspendedMerchantCenterAccount = 40,
        ShoppingFixMerchantCenterAccountSuspensionWarning = 41,
        ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax = 42,
        DynamicImageExtensionOptIn = 43,
        RaiseTargetCpa = 44,
        LowerTargetRoas = 45,
        PerformanceMaxOptIn = 46,
        ImprovePerformanceMaxAdStrength = 47,
        MigrateDynamicSearchAdsCampaignToPerformanceMax = 48,
        ForecastingSetTargetCpa = 49,
        SetTargetCpa = 50,
        SetTargetRoas = 51,
        MaximizeConversionValueOptIn = 52,
        ImproveGoogleTagCoverage = 53,
        PerformanceMaxFinalUrlOptIn = 54,
        RefreshCustomerMatchList = 55,
        CustomAudienceOptIn = 56,
        LeadFormAsset = 57,
        ImproveDemandGenAdStrength = 58,
    }
    impl RecommendationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecommendationType::Unspecified => "UNSPECIFIED",
                RecommendationType::Unknown => "UNKNOWN",
                RecommendationType::CampaignBudget => "CAMPAIGN_BUDGET",
                RecommendationType::Keyword => "KEYWORD",
                RecommendationType::TextAd => "TEXT_AD",
                RecommendationType::TargetCpaOptIn => "TARGET_CPA_OPT_IN",
                RecommendationType::MaximizeConversionsOptIn => {
                    "MAXIMIZE_CONVERSIONS_OPT_IN"
                }
                RecommendationType::EnhancedCpcOptIn => "ENHANCED_CPC_OPT_IN",
                RecommendationType::SearchPartnersOptIn => "SEARCH_PARTNERS_OPT_IN",
                RecommendationType::MaximizeClicksOptIn => "MAXIMIZE_CLICKS_OPT_IN",
                RecommendationType::OptimizeAdRotation => "OPTIMIZE_AD_ROTATION",
                RecommendationType::KeywordMatchType => "KEYWORD_MATCH_TYPE",
                RecommendationType::MoveUnusedBudget => "MOVE_UNUSED_BUDGET",
                RecommendationType::ForecastingCampaignBudget => {
                    "FORECASTING_CAMPAIGN_BUDGET"
                }
                RecommendationType::TargetRoasOptIn => "TARGET_ROAS_OPT_IN",
                RecommendationType::ResponsiveSearchAd => "RESPONSIVE_SEARCH_AD",
                RecommendationType::MarginalRoiCampaignBudget => {
                    "MARGINAL_ROI_CAMPAIGN_BUDGET"
                }
                RecommendationType::UseBroadMatchKeyword => "USE_BROAD_MATCH_KEYWORD",
                RecommendationType::ResponsiveSearchAdAsset => {
                    "RESPONSIVE_SEARCH_AD_ASSET"
                }
                RecommendationType::UpgradeSmartShoppingCampaignToPerformanceMax => {
                    "UPGRADE_SMART_SHOPPING_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                RecommendationType::ResponsiveSearchAdImproveAdStrength => {
                    "RESPONSIVE_SEARCH_AD_IMPROVE_AD_STRENGTH"
                }
                RecommendationType::DisplayExpansionOptIn => "DISPLAY_EXPANSION_OPT_IN",
                RecommendationType::UpgradeLocalCampaignToPerformanceMax => {
                    "UPGRADE_LOCAL_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                RecommendationType::RaiseTargetCpaBidTooLow => {
                    "RAISE_TARGET_CPA_BID_TOO_LOW"
                }
                RecommendationType::ForecastingSetTargetRoas => {
                    "FORECASTING_SET_TARGET_ROAS"
                }
                RecommendationType::CalloutAsset => "CALLOUT_ASSET",
                RecommendationType::SitelinkAsset => "SITELINK_ASSET",
                RecommendationType::CallAsset => "CALL_ASSET",
                RecommendationType::ShoppingAddAgeGroup => "SHOPPING_ADD_AGE_GROUP",
                RecommendationType::ShoppingAddColor => "SHOPPING_ADD_COLOR",
                RecommendationType::ShoppingAddGender => "SHOPPING_ADD_GENDER",
                RecommendationType::ShoppingAddGtin => "SHOPPING_ADD_GTIN",
                RecommendationType::ShoppingAddMoreIdentifiers => {
                    "SHOPPING_ADD_MORE_IDENTIFIERS"
                }
                RecommendationType::ShoppingAddSize => "SHOPPING_ADD_SIZE",
                RecommendationType::ShoppingAddProductsToCampaign => {
                    "SHOPPING_ADD_PRODUCTS_TO_CAMPAIGN"
                }
                RecommendationType::ShoppingFixDisapprovedProducts => {
                    "SHOPPING_FIX_DISAPPROVED_PRODUCTS"
                }
                RecommendationType::ShoppingTargetAllOffers => {
                    "SHOPPING_TARGET_ALL_OFFERS"
                }
                RecommendationType::ShoppingFixSuspendedMerchantCenterAccount => {
                    "SHOPPING_FIX_SUSPENDED_MERCHANT_CENTER_ACCOUNT"
                }
                RecommendationType::ShoppingFixMerchantCenterAccountSuspensionWarning => {
                    "SHOPPING_FIX_MERCHANT_CENTER_ACCOUNT_SUSPENSION_WARNING"
                }
                RecommendationType::ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax => {
                    "SHOPPING_MIGRATE_REGULAR_SHOPPING_CAMPAIGN_OFFERS_TO_PERFORMANCE_MAX"
                }
                RecommendationType::DynamicImageExtensionOptIn => {
                    "DYNAMIC_IMAGE_EXTENSION_OPT_IN"
                }
                RecommendationType::RaiseTargetCpa => "RAISE_TARGET_CPA",
                RecommendationType::LowerTargetRoas => "LOWER_TARGET_ROAS",
                RecommendationType::PerformanceMaxOptIn => "PERFORMANCE_MAX_OPT_IN",
                RecommendationType::ImprovePerformanceMaxAdStrength => {
                    "IMPROVE_PERFORMANCE_MAX_AD_STRENGTH"
                }
                RecommendationType::MigrateDynamicSearchAdsCampaignToPerformanceMax => {
                    "MIGRATE_DYNAMIC_SEARCH_ADS_CAMPAIGN_TO_PERFORMANCE_MAX"
                }
                RecommendationType::ForecastingSetTargetCpa => {
                    "FORECASTING_SET_TARGET_CPA"
                }
                RecommendationType::SetTargetCpa => "SET_TARGET_CPA",
                RecommendationType::SetTargetRoas => "SET_TARGET_ROAS",
                RecommendationType::MaximizeConversionValueOptIn => {
                    "MAXIMIZE_CONVERSION_VALUE_OPT_IN"
                }
                RecommendationType::ImproveGoogleTagCoverage => {
                    "IMPROVE_GOOGLE_TAG_COVERAGE"
                }
                RecommendationType::PerformanceMaxFinalUrlOptIn => {
                    "PERFORMANCE_MAX_FINAL_URL_OPT_IN"
                }
                RecommendationType::RefreshCustomerMatchList => {
                    "REFRESH_CUSTOMER_MATCH_LIST"
                }
                RecommendationType::CustomAudienceOptIn => "CUSTOM_AUDIENCE_OPT_IN",
                RecommendationType::LeadFormAsset => "LEAD_FORM_ASSET",
                RecommendationType::ImproveDemandGenAdStrength => {
                    "IMPROVE_DEMAND_GEN_AD_STRENGTH"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BUDGET" => Some(Self::CampaignBudget),
                "KEYWORD" => Some(Self::Keyword),
                "TEXT_AD" => Some(Self::TextAd),
                "TARGET_CPA_OPT_IN" => Some(Self::TargetCpaOptIn),
                "MAXIMIZE_CONVERSIONS_OPT_IN" => Some(Self::MaximizeConversionsOptIn),
                "ENHANCED_CPC_OPT_IN" => Some(Self::EnhancedCpcOptIn),
                "SEARCH_PARTNERS_OPT_IN" => Some(Self::SearchPartnersOptIn),
                "MAXIMIZE_CLICKS_OPT_IN" => Some(Self::MaximizeClicksOptIn),
                "OPTIMIZE_AD_ROTATION" => Some(Self::OptimizeAdRotation),
                "KEYWORD_MATCH_TYPE" => Some(Self::KeywordMatchType),
                "MOVE_UNUSED_BUDGET" => Some(Self::MoveUnusedBudget),
                "FORECASTING_CAMPAIGN_BUDGET" => Some(Self::ForecastingCampaignBudget),
                "TARGET_ROAS_OPT_IN" => Some(Self::TargetRoasOptIn),
                "RESPONSIVE_SEARCH_AD" => Some(Self::ResponsiveSearchAd),
                "MARGINAL_ROI_CAMPAIGN_BUDGET" => Some(Self::MarginalRoiCampaignBudget),
                "USE_BROAD_MATCH_KEYWORD" => Some(Self::UseBroadMatchKeyword),
                "RESPONSIVE_SEARCH_AD_ASSET" => Some(Self::ResponsiveSearchAdAsset),
                "UPGRADE_SMART_SHOPPING_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::UpgradeSmartShoppingCampaignToPerformanceMax)
                }
                "RESPONSIVE_SEARCH_AD_IMPROVE_AD_STRENGTH" => {
                    Some(Self::ResponsiveSearchAdImproveAdStrength)
                }
                "DISPLAY_EXPANSION_OPT_IN" => Some(Self::DisplayExpansionOptIn),
                "UPGRADE_LOCAL_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::UpgradeLocalCampaignToPerformanceMax)
                }
                "RAISE_TARGET_CPA_BID_TOO_LOW" => Some(Self::RaiseTargetCpaBidTooLow),
                "FORECASTING_SET_TARGET_ROAS" => Some(Self::ForecastingSetTargetRoas),
                "CALLOUT_ASSET" => Some(Self::CalloutAsset),
                "SITELINK_ASSET" => Some(Self::SitelinkAsset),
                "CALL_ASSET" => Some(Self::CallAsset),
                "SHOPPING_ADD_AGE_GROUP" => Some(Self::ShoppingAddAgeGroup),
                "SHOPPING_ADD_COLOR" => Some(Self::ShoppingAddColor),
                "SHOPPING_ADD_GENDER" => Some(Self::ShoppingAddGender),
                "SHOPPING_ADD_GTIN" => Some(Self::ShoppingAddGtin),
                "SHOPPING_ADD_MORE_IDENTIFIERS" => Some(Self::ShoppingAddMoreIdentifiers),
                "SHOPPING_ADD_SIZE" => Some(Self::ShoppingAddSize),
                "SHOPPING_ADD_PRODUCTS_TO_CAMPAIGN" => {
                    Some(Self::ShoppingAddProductsToCampaign)
                }
                "SHOPPING_FIX_DISAPPROVED_PRODUCTS" => {
                    Some(Self::ShoppingFixDisapprovedProducts)
                }
                "SHOPPING_TARGET_ALL_OFFERS" => Some(Self::ShoppingTargetAllOffers),
                "SHOPPING_FIX_SUSPENDED_MERCHANT_CENTER_ACCOUNT" => {
                    Some(Self::ShoppingFixSuspendedMerchantCenterAccount)
                }
                "SHOPPING_FIX_MERCHANT_CENTER_ACCOUNT_SUSPENSION_WARNING" => {
                    Some(Self::ShoppingFixMerchantCenterAccountSuspensionWarning)
                }
                "SHOPPING_MIGRATE_REGULAR_SHOPPING_CAMPAIGN_OFFERS_TO_PERFORMANCE_MAX" => {
                    Some(
                        Self::ShoppingMigrateRegularShoppingCampaignOffersToPerformanceMax,
                    )
                }
                "DYNAMIC_IMAGE_EXTENSION_OPT_IN" => {
                    Some(Self::DynamicImageExtensionOptIn)
                }
                "RAISE_TARGET_CPA" => Some(Self::RaiseTargetCpa),
                "LOWER_TARGET_ROAS" => Some(Self::LowerTargetRoas),
                "PERFORMANCE_MAX_OPT_IN" => Some(Self::PerformanceMaxOptIn),
                "IMPROVE_PERFORMANCE_MAX_AD_STRENGTH" => {
                    Some(Self::ImprovePerformanceMaxAdStrength)
                }
                "MIGRATE_DYNAMIC_SEARCH_ADS_CAMPAIGN_TO_PERFORMANCE_MAX" => {
                    Some(Self::MigrateDynamicSearchAdsCampaignToPerformanceMax)
                }
                "FORECASTING_SET_TARGET_CPA" => Some(Self::ForecastingSetTargetCpa),
                "SET_TARGET_CPA" => Some(Self::SetTargetCpa),
                "SET_TARGET_ROAS" => Some(Self::SetTargetRoas),
                "MAXIMIZE_CONVERSION_VALUE_OPT_IN" => {
                    Some(Self::MaximizeConversionValueOptIn)
                }
                "IMPROVE_GOOGLE_TAG_COVERAGE" => Some(Self::ImproveGoogleTagCoverage),
                "PERFORMANCE_MAX_FINAL_URL_OPT_IN" => {
                    Some(Self::PerformanceMaxFinalUrlOptIn)
                }
                "REFRESH_CUSTOMER_MATCH_LIST" => Some(Self::RefreshCustomerMatchList),
                "CUSTOM_AUDIENCE_OPT_IN" => Some(Self::CustomAudienceOptIn),
                "LEAD_FORM_ASSET" => Some(Self::LeadFormAsset),
                "IMPROVE_DEMAND_GEN_AD_STRENGTH" => {
                    Some(Self::ImproveDemandGenAdStrength)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ShoppingAddProductsToCampaignRecommendationEnum {}
/// Nested message and enum types in `ShoppingAddProductsToCampaignRecommendationEnum`.
pub mod shopping_add_products_to_campaign_recommendation_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Reason {
        Unspecified = 0,
        Unknown = 1,
        MerchantCenterAccountHasNoSubmittedProducts = 2,
        MerchantCenterAccountHasNoSubmittedProductsInFeed = 3,
        AdsAccountExcludesOffersFromCampaign = 4,
        AllProductsAreExcludedFromCampaign = 5,
    }
    impl Reason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Reason::Unspecified => "UNSPECIFIED",
                Reason::Unknown => "UNKNOWN",
                Reason::MerchantCenterAccountHasNoSubmittedProducts => {
                    "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS"
                }
                Reason::MerchantCenterAccountHasNoSubmittedProductsInFeed => {
                    "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS_IN_FEED"
                }
                Reason::AdsAccountExcludesOffersFromCampaign => {
                    "ADS_ACCOUNT_EXCLUDES_OFFERS_FROM_CAMPAIGN"
                }
                Reason::AllProductsAreExcludedFromCampaign => {
                    "ALL_PRODUCTS_ARE_EXCLUDED_FROM_CAMPAIGN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS" => {
                    Some(Self::MerchantCenterAccountHasNoSubmittedProducts)
                }
                "MERCHANT_CENTER_ACCOUNT_HAS_NO_SUBMITTED_PRODUCTS_IN_FEED" => {
                    Some(Self::MerchantCenterAccountHasNoSubmittedProductsInFeed)
                }
                "ADS_ACCOUNT_EXCLUDES_OFFERS_FROM_CAMPAIGN" => {
                    Some(Self::AdsAccountExcludesOffersFromCampaign)
                }
                "ALL_PRODUCTS_ARE_EXCLUDED_FROM_CAMPAIGN" => {
                    Some(Self::AllProductsAreExcludedFromCampaign)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetCpaOptInRecommendationGoalEnum {}
/// Nested message and enum types in `TargetCpaOptInRecommendationGoalEnum`.
pub mod target_cpa_opt_in_recommendation_goal_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetCpaOptInRecommendationGoal {
        Unspecified = 0,
        Unknown = 1,
        SameCost = 2,
        SameConversions = 3,
        SameCpa = 4,
        ClosestCpa = 5,
    }
    impl TargetCpaOptInRecommendationGoal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetCpaOptInRecommendationGoal::Unspecified => "UNSPECIFIED",
                TargetCpaOptInRecommendationGoal::Unknown => "UNKNOWN",
                TargetCpaOptInRecommendationGoal::SameCost => "SAME_COST",
                TargetCpaOptInRecommendationGoal::SameConversions => "SAME_CONVERSIONS",
                TargetCpaOptInRecommendationGoal::SameCpa => "SAME_CPA",
                TargetCpaOptInRecommendationGoal::ClosestCpa => "CLOSEST_CPA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SAME_COST" => Some(Self::SameCost),
                "SAME_CONVERSIONS" => Some(Self::SameConversions),
                "SAME_CPA" => Some(Self::SameCpa),
                "CLOSEST_CPA" => Some(Self::ClosestCpa),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetPerformanceLabelEnum {}
/// Nested message and enum types in `AssetPerformanceLabelEnum`.
pub mod asset_performance_label_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetPerformanceLabel {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Learning = 3,
        Low = 4,
        Good = 5,
        Best = 6,
    }
    impl AssetPerformanceLabel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetPerformanceLabel::Unspecified => "UNSPECIFIED",
                AssetPerformanceLabel::Unknown => "UNKNOWN",
                AssetPerformanceLabel::Pending => "PENDING",
                AssetPerformanceLabel::Learning => "LEARNING",
                AssetPerformanceLabel::Low => "LOW",
                AssetPerformanceLabel::Good => "GOOD",
                AssetPerformanceLabel::Best => "BEST",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "LEARNING" => Some(Self::Learning),
                "LOW" => Some(Self::Low),
                "GOOD" => Some(Self::Good),
                "BEST" => Some(Self::Best),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayAdFormatSettingEnum {}
/// Nested message and enum types in `DisplayAdFormatSettingEnum`.
pub mod display_ad_format_setting_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayAdFormatSetting {
        Unspecified = 0,
        Unknown = 1,
        AllFormats = 2,
        NonNative = 3,
        Native = 4,
    }
    impl DisplayAdFormatSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayAdFormatSetting::Unspecified => "UNSPECIFIED",
                DisplayAdFormatSetting::Unknown => "UNKNOWN",
                DisplayAdFormatSetting::AllFormats => "ALL_FORMATS",
                DisplayAdFormatSetting::NonNative => "NON_NATIVE",
                DisplayAdFormatSetting::Native => "NATIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL_FORMATS" => Some(Self::AllFormats),
                "NON_NATIVE" => Some(Self::NonNative),
                "NATIVE" => Some(Self::Native),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DisplayUploadProductTypeEnum {}
/// Nested message and enum types in `DisplayUploadProductTypeEnum`.
pub mod display_upload_product_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DisplayUploadProductType {
        Unspecified = 0,
        Unknown = 1,
        Html5UploadAd = 2,
        DynamicHtml5EducationAd = 3,
        DynamicHtml5FlightAd = 4,
        DynamicHtml5HotelRentalAd = 5,
        DynamicHtml5JobAd = 6,
        DynamicHtml5LocalAd = 7,
        DynamicHtml5RealEstateAd = 8,
        DynamicHtml5CustomAd = 9,
        DynamicHtml5TravelAd = 10,
        DynamicHtml5HotelAd = 11,
    }
    impl DisplayUploadProductType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DisplayUploadProductType::Unspecified => "UNSPECIFIED",
                DisplayUploadProductType::Unknown => "UNKNOWN",
                DisplayUploadProductType::Html5UploadAd => "HTML5_UPLOAD_AD",
                DisplayUploadProductType::DynamicHtml5EducationAd => {
                    "DYNAMIC_HTML5_EDUCATION_AD"
                }
                DisplayUploadProductType::DynamicHtml5FlightAd => {
                    "DYNAMIC_HTML5_FLIGHT_AD"
                }
                DisplayUploadProductType::DynamicHtml5HotelRentalAd => {
                    "DYNAMIC_HTML5_HOTEL_RENTAL_AD"
                }
                DisplayUploadProductType::DynamicHtml5JobAd => "DYNAMIC_HTML5_JOB_AD",
                DisplayUploadProductType::DynamicHtml5LocalAd => "DYNAMIC_HTML5_LOCAL_AD",
                DisplayUploadProductType::DynamicHtml5RealEstateAd => {
                    "DYNAMIC_HTML5_REAL_ESTATE_AD"
                }
                DisplayUploadProductType::DynamicHtml5CustomAd => {
                    "DYNAMIC_HTML5_CUSTOM_AD"
                }
                DisplayUploadProductType::DynamicHtml5TravelAd => {
                    "DYNAMIC_HTML5_TRAVEL_AD"
                }
                DisplayUploadProductType::DynamicHtml5HotelAd => "DYNAMIC_HTML5_HOTEL_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HTML5_UPLOAD_AD" => Some(Self::Html5UploadAd),
                "DYNAMIC_HTML5_EDUCATION_AD" => Some(Self::DynamicHtml5EducationAd),
                "DYNAMIC_HTML5_FLIGHT_AD" => Some(Self::DynamicHtml5FlightAd),
                "DYNAMIC_HTML5_HOTEL_RENTAL_AD" => Some(Self::DynamicHtml5HotelRentalAd),
                "DYNAMIC_HTML5_JOB_AD" => Some(Self::DynamicHtml5JobAd),
                "DYNAMIC_HTML5_LOCAL_AD" => Some(Self::DynamicHtml5LocalAd),
                "DYNAMIC_HTML5_REAL_ESTATE_AD" => Some(Self::DynamicHtml5RealEstateAd),
                "DYNAMIC_HTML5_CUSTOM_AD" => Some(Self::DynamicHtml5CustomAd),
                "DYNAMIC_HTML5_TRAVEL_AD" => Some(Self::DynamicHtml5TravelAd),
                "DYNAMIC_HTML5_HOTEL_AD" => Some(Self::DynamicHtml5HotelAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LegacyAppInstallAdAppStoreEnum {}
/// Nested message and enum types in `LegacyAppInstallAdAppStoreEnum`.
pub mod legacy_app_install_ad_app_store_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LegacyAppInstallAdAppStore {
        Unspecified = 0,
        Unknown = 1,
        AppleAppStore = 2,
        GooglePlay = 3,
        WindowsStore = 4,
        WindowsPhoneStore = 5,
        CnAppStore = 6,
    }
    impl LegacyAppInstallAdAppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LegacyAppInstallAdAppStore::Unspecified => "UNSPECIFIED",
                LegacyAppInstallAdAppStore::Unknown => "UNKNOWN",
                LegacyAppInstallAdAppStore::AppleAppStore => "APPLE_APP_STORE",
                LegacyAppInstallAdAppStore::GooglePlay => "GOOGLE_PLAY",
                LegacyAppInstallAdAppStore::WindowsStore => "WINDOWS_STORE",
                LegacyAppInstallAdAppStore::WindowsPhoneStore => "WINDOWS_PHONE_STORE",
                LegacyAppInstallAdAppStore::CnAppStore => "CN_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                "WINDOWS_STORE" => Some(Self::WindowsStore),
                "WINDOWS_PHONE_STORE" => Some(Self::WindowsPhoneStore),
                "CN_APP_STORE" => Some(Self::CnAppStore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VideoThumbnailEnum {}
/// Nested message and enum types in `VideoThumbnailEnum`.
pub mod video_thumbnail_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VideoThumbnail {
        Unspecified = 0,
        Unknown = 1,
        DefaultThumbnail = 2,
        Thumbnail1 = 3,
        Thumbnail2 = 4,
        Thumbnail3 = 5,
    }
    impl VideoThumbnail {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VideoThumbnail::Unspecified => "UNSPECIFIED",
                VideoThumbnail::Unknown => "UNKNOWN",
                VideoThumbnail::DefaultThumbnail => "DEFAULT_THUMBNAIL",
                VideoThumbnail::Thumbnail1 => "THUMBNAIL_1",
                VideoThumbnail::Thumbnail2 => "THUMBNAIL_2",
                VideoThumbnail::Thumbnail3 => "THUMBNAIL_3",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT_THUMBNAIL" => Some(Self::DefaultThumbnail),
                "THUMBNAIL_1" => Some(Self::Thumbnail1),
                "THUMBNAIL_2" => Some(Self::Thumbnail2),
                "THUMBNAIL_3" => Some(Self::Thumbnail3),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppUrlOperatingSystemTypeEnum {}
/// Nested message and enum types in `AppUrlOperatingSystemTypeEnum`.
pub mod app_url_operating_system_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppUrlOperatingSystemType {
        Unspecified = 0,
        Unknown = 1,
        Ios = 2,
        Android = 3,
    }
    impl AppUrlOperatingSystemType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppUrlOperatingSystemType::Unspecified => "UNSPECIFIED",
                AppUrlOperatingSystemType::Unknown => "UNKNOWN",
                AppUrlOperatingSystemType::Ios => "IOS",
                AppUrlOperatingSystemType::Android => "ANDROID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IOS" => Some(Self::Ios),
                "ANDROID" => Some(Self::Android),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdTypeEnum {}
/// Nested message and enum types in `AdTypeEnum`.
pub mod ad_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdType {
        Unspecified = 0,
        Unknown = 1,
        TextAd = 2,
        ExpandedTextAd = 3,
        ExpandedDynamicSearchAd = 7,
        HotelAd = 8,
        ShoppingSmartAd = 9,
        ShoppingProductAd = 10,
        VideoAd = 12,
        ImageAd = 14,
        ResponsiveSearchAd = 15,
        LegacyResponsiveDisplayAd = 16,
        AppAd = 17,
        LegacyAppInstallAd = 18,
        ResponsiveDisplayAd = 19,
        LocalAd = 20,
        Html5UploadAd = 21,
        DynamicHtml5Ad = 22,
        AppEngagementAd = 23,
        ShoppingComparisonListingAd = 24,
        VideoBumperAd = 25,
        VideoNonSkippableInStreamAd = 26,
        VideoOutstreamAd = 27,
        VideoTrueviewInStreamAd = 29,
        VideoResponsiveAd = 30,
        SmartCampaignAd = 31,
        CallAd = 32,
        AppPreRegistrationAd = 33,
        InFeedVideoAd = 34,
        DemandGenMultiAssetAd = 40,
        DemandGenCarouselAd = 41,
        TravelAd = 37,
        DemandGenVideoResponsiveAd = 42,
        DemandGenProductAd = 39,
    }
    impl AdType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdType::Unspecified => "UNSPECIFIED",
                AdType::Unknown => "UNKNOWN",
                AdType::TextAd => "TEXT_AD",
                AdType::ExpandedTextAd => "EXPANDED_TEXT_AD",
                AdType::ExpandedDynamicSearchAd => "EXPANDED_DYNAMIC_SEARCH_AD",
                AdType::HotelAd => "HOTEL_AD",
                AdType::ShoppingSmartAd => "SHOPPING_SMART_AD",
                AdType::ShoppingProductAd => "SHOPPING_PRODUCT_AD",
                AdType::VideoAd => "VIDEO_AD",
                AdType::ImageAd => "IMAGE_AD",
                AdType::ResponsiveSearchAd => "RESPONSIVE_SEARCH_AD",
                AdType::LegacyResponsiveDisplayAd => "LEGACY_RESPONSIVE_DISPLAY_AD",
                AdType::AppAd => "APP_AD",
                AdType::LegacyAppInstallAd => "LEGACY_APP_INSTALL_AD",
                AdType::ResponsiveDisplayAd => "RESPONSIVE_DISPLAY_AD",
                AdType::LocalAd => "LOCAL_AD",
                AdType::Html5UploadAd => "HTML5_UPLOAD_AD",
                AdType::DynamicHtml5Ad => "DYNAMIC_HTML5_AD",
                AdType::AppEngagementAd => "APP_ENGAGEMENT_AD",
                AdType::ShoppingComparisonListingAd => "SHOPPING_COMPARISON_LISTING_AD",
                AdType::VideoBumperAd => "VIDEO_BUMPER_AD",
                AdType::VideoNonSkippableInStreamAd => "VIDEO_NON_SKIPPABLE_IN_STREAM_AD",
                AdType::VideoOutstreamAd => "VIDEO_OUTSTREAM_AD",
                AdType::VideoTrueviewInStreamAd => "VIDEO_TRUEVIEW_IN_STREAM_AD",
                AdType::VideoResponsiveAd => "VIDEO_RESPONSIVE_AD",
                AdType::SmartCampaignAd => "SMART_CAMPAIGN_AD",
                AdType::CallAd => "CALL_AD",
                AdType::AppPreRegistrationAd => "APP_PRE_REGISTRATION_AD",
                AdType::InFeedVideoAd => "IN_FEED_VIDEO_AD",
                AdType::DemandGenMultiAssetAd => "DEMAND_GEN_MULTI_ASSET_AD",
                AdType::DemandGenCarouselAd => "DEMAND_GEN_CAROUSEL_AD",
                AdType::TravelAd => "TRAVEL_AD",
                AdType::DemandGenVideoResponsiveAd => "DEMAND_GEN_VIDEO_RESPONSIVE_AD",
                AdType::DemandGenProductAd => "DEMAND_GEN_PRODUCT_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT_AD" => Some(Self::TextAd),
                "EXPANDED_TEXT_AD" => Some(Self::ExpandedTextAd),
                "EXPANDED_DYNAMIC_SEARCH_AD" => Some(Self::ExpandedDynamicSearchAd),
                "HOTEL_AD" => Some(Self::HotelAd),
                "SHOPPING_SMART_AD" => Some(Self::ShoppingSmartAd),
                "SHOPPING_PRODUCT_AD" => Some(Self::ShoppingProductAd),
                "VIDEO_AD" => Some(Self::VideoAd),
                "IMAGE_AD" => Some(Self::ImageAd),
                "RESPONSIVE_SEARCH_AD" => Some(Self::ResponsiveSearchAd),
                "LEGACY_RESPONSIVE_DISPLAY_AD" => Some(Self::LegacyResponsiveDisplayAd),
                "APP_AD" => Some(Self::AppAd),
                "LEGACY_APP_INSTALL_AD" => Some(Self::LegacyAppInstallAd),
                "RESPONSIVE_DISPLAY_AD" => Some(Self::ResponsiveDisplayAd),
                "LOCAL_AD" => Some(Self::LocalAd),
                "HTML5_UPLOAD_AD" => Some(Self::Html5UploadAd),
                "DYNAMIC_HTML5_AD" => Some(Self::DynamicHtml5Ad),
                "APP_ENGAGEMENT_AD" => Some(Self::AppEngagementAd),
                "SHOPPING_COMPARISON_LISTING_AD" => {
                    Some(Self::ShoppingComparisonListingAd)
                }
                "VIDEO_BUMPER_AD" => Some(Self::VideoBumperAd),
                "VIDEO_NON_SKIPPABLE_IN_STREAM_AD" => {
                    Some(Self::VideoNonSkippableInStreamAd)
                }
                "VIDEO_OUTSTREAM_AD" => Some(Self::VideoOutstreamAd),
                "VIDEO_TRUEVIEW_IN_STREAM_AD" => Some(Self::VideoTrueviewInStreamAd),
                "VIDEO_RESPONSIVE_AD" => Some(Self::VideoResponsiveAd),
                "SMART_CAMPAIGN_AD" => Some(Self::SmartCampaignAd),
                "CALL_AD" => Some(Self::CallAd),
                "APP_PRE_REGISTRATION_AD" => Some(Self::AppPreRegistrationAd),
                "IN_FEED_VIDEO_AD" => Some(Self::InFeedVideoAd),
                "DEMAND_GEN_MULTI_ASSET_AD" => Some(Self::DemandGenMultiAssetAd),
                "DEMAND_GEN_CAROUSEL_AD" => Some(Self::DemandGenCarouselAd),
                "TRAVEL_AD" => Some(Self::TravelAd),
                "DEMAND_GEN_VIDEO_RESPONSIVE_AD" => {
                    Some(Self::DemandGenVideoResponsiveAd)
                }
                "DEMAND_GEN_PRODUCT_AD" => Some(Self::DemandGenProductAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SystemManagedResourceSourceEnum {}
/// Nested message and enum types in `SystemManagedResourceSourceEnum`.
pub mod system_managed_resource_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SystemManagedResourceSource {
        Unspecified = 0,
        Unknown = 1,
        AdVariations = 2,
    }
    impl SystemManagedResourceSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SystemManagedResourceSource::Unspecified => "UNSPECIFIED",
                SystemManagedResourceSource::Unknown => "UNKNOWN",
                SystemManagedResourceSource::AdVariations => "AD_VARIATIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_VARIATIONS" => Some(Self::AdVariations),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignDraftStatusEnum {}
/// Nested message and enum types in `CampaignDraftStatusEnum`.
pub mod campaign_draft_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignDraftStatus {
        Unspecified = 0,
        Unknown = 1,
        Proposed = 2,
        Removed = 3,
        Promoting = 5,
        Promoted = 4,
        PromoteFailed = 6,
    }
    impl CampaignDraftStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignDraftStatus::Unspecified => "UNSPECIFIED",
                CampaignDraftStatus::Unknown => "UNKNOWN",
                CampaignDraftStatus::Proposed => "PROPOSED",
                CampaignDraftStatus::Removed => "REMOVED",
                CampaignDraftStatus::Promoting => "PROMOTING",
                CampaignDraftStatus::Promoted => "PROMOTED",
                CampaignDraftStatus::PromoteFailed => "PROMOTE_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROPOSED" => Some(Self::Proposed),
                "REMOVED" => Some(Self::Removed),
                "PROMOTING" => Some(Self::Promoting),
                "PROMOTED" => Some(Self::Promoted),
                "PROMOTE_FAILED" => Some(Self::PromoteFailed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessInvitationStatusEnum {}
/// Nested message and enum types in `AccessInvitationStatusEnum`.
pub mod access_invitation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessInvitationStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Declined = 3,
        Expired = 4,
    }
    impl AccessInvitationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccessInvitationStatus::Unspecified => "UNSPECIFIED",
                AccessInvitationStatus::Unknown => "UNKNOWN",
                AccessInvitationStatus::Pending => "PENDING",
                AccessInvitationStatus::Declined => "DECLINED",
                AccessInvitationStatus::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "DECLINED" => Some(Self::Declined),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadConversationTypeEnum {}
/// Nested message and enum types in `LocalServicesLeadConversationTypeEnum`.
pub mod local_services_lead_conversation_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversationType {
        Unspecified = 0,
        Unknown = 1,
        Email = 2,
        Message = 3,
        PhoneCall = 4,
        Sms = 5,
        Booking = 6,
        Whatsapp = 7,
        AdsApi = 8,
    }
    impl ConversationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversationType::Unspecified => "UNSPECIFIED",
                ConversationType::Unknown => "UNKNOWN",
                ConversationType::Email => "EMAIL",
                ConversationType::Message => "MESSAGE",
                ConversationType::PhoneCall => "PHONE_CALL",
                ConversationType::Sms => "SMS",
                ConversationType::Booking => "BOOKING",
                ConversationType::Whatsapp => "WHATSAPP",
                ConversationType::AdsApi => "ADS_API",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EMAIL" => Some(Self::Email),
                "MESSAGE" => Some(Self::Message),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "SMS" => Some(Self::Sms),
                "BOOKING" => Some(Self::Booking),
                "WHATSAPP" => Some(Self::Whatsapp),
                "ADS_API" => Some(Self::AdsApi),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesParticipantTypeEnum {}
/// Nested message and enum types in `LocalServicesParticipantTypeEnum`.
pub mod local_services_participant_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ParticipantType {
        Unspecified = 0,
        Unknown = 1,
        Advertiser = 2,
        Consumer = 3,
    }
    impl ParticipantType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ParticipantType::Unspecified => "UNSPECIFIED",
                ParticipantType::Unknown => "UNKNOWN",
                ParticipantType::Advertiser => "ADVERTISER",
                ParticipantType::Consumer => "CONSUMER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER" => Some(Self::Advertiser),
                "CONSUMER" => Some(Self::Consumer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestMemberTypeEnum {}
/// Nested message and enum types in `CustomInterestMemberTypeEnum`.
pub mod custom_interest_member_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestMemberType {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Url = 3,
    }
    impl CustomInterestMemberType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomInterestMemberType::Unspecified => "UNSPECIFIED",
                CustomInterestMemberType::Unknown => "UNKNOWN",
                CustomInterestMemberType::Keyword => "KEYWORD",
                CustomInterestMemberType::Url => "URL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "URL" => Some(Self::Url),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestStatusEnum {}
/// Nested message and enum types in `CustomInterestStatusEnum`.
pub mod custom_interest_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CustomInterestStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomInterestStatus::Unspecified => "UNSPECIFIED",
                CustomInterestStatus::Unknown => "UNKNOWN",
                CustomInterestStatus::Enabled => "ENABLED",
                CustomInterestStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomInterestTypeEnum {}
/// Nested message and enum types in `CustomInterestTypeEnum`.
pub mod custom_interest_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomInterestType {
        Unspecified = 0,
        Unknown = 1,
        CustomAffinity = 2,
        CustomIntent = 3,
    }
    impl CustomInterestType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomInterestType::Unspecified => "UNSPECIFIED",
                CustomInterestType::Unknown => "UNKNOWN",
                CustomInterestType::CustomAffinity => "CUSTOM_AFFINITY",
                CustomInterestType::CustomIntent => "CUSTOM_INTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOM_AFFINITY" => Some(Self::CustomAffinity),
                "CUSTOM_INTENT" => Some(Self::CustomIntent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductCategoryStateEnum {}
/// Nested message and enum types in `ProductCategoryStateEnum`.
pub mod product_category_state_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCategoryState {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Obsolete = 3,
    }
    impl ProductCategoryState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductCategoryState::Unspecified => "UNSPECIFIED",
                ProductCategoryState::Unknown => "UNKNOWN",
                ProductCategoryState::Enabled => "ENABLED",
                ProductCategoryState::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetStatusEnum {}
/// Nested message and enum types in `SharedSetStatusEnum`.
pub mod shared_set_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl SharedSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SharedSetStatus::Unspecified => "UNSPECIFIED",
                SharedSetStatus::Unknown => "UNKNOWN",
                SharedSetStatus::Enabled => "ENABLED",
                SharedSetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SharedSetTypeEnum {}
/// Nested message and enum types in `SharedSetTypeEnum`.
pub mod shared_set_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SharedSetType {
        Unspecified = 0,
        Unknown = 1,
        NegativeKeywords = 2,
        NegativePlacements = 3,
        AccountLevelNegativeKeywords = 4,
        Brands = 5,
    }
    impl SharedSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SharedSetType::Unspecified => "UNSPECIFIED",
                SharedSetType::Unknown => "UNKNOWN",
                SharedSetType::NegativeKeywords => "NEGATIVE_KEYWORDS",
                SharedSetType::NegativePlacements => "NEGATIVE_PLACEMENTS",
                SharedSetType::AccountLevelNegativeKeywords => {
                    "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS"
                }
                SharedSetType::Brands => "BRANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEGATIVE_KEYWORDS" => Some(Self::NegativeKeywords),
                "NEGATIVE_PLACEMENTS" => Some(Self::NegativePlacements),
                "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS" => {
                    Some(Self::AccountLevelNegativeKeywords)
                }
                "BRANDS" => Some(Self::Brands),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeClientTypeEnum {}
/// Nested message and enum types in `ChangeClientTypeEnum`.
pub mod change_client_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeClientType {
        Unspecified = 0,
        Unknown = 1,
        GoogleAdsWebClient = 2,
        GoogleAdsAutomatedRule = 3,
        GoogleAdsScripts = 4,
        GoogleAdsBulkUpload = 5,
        GoogleAdsApi = 6,
        GoogleAdsEditor = 7,
        GoogleAdsMobileApp = 8,
        GoogleAdsRecommendations = 9,
        SearchAds360Sync = 10,
        SearchAds360Post = 11,
        InternalTool = 12,
        Other = 13,
        GoogleAdsRecommendationsSubscription = 14,
    }
    impl ChangeClientType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeClientType::Unspecified => "UNSPECIFIED",
                ChangeClientType::Unknown => "UNKNOWN",
                ChangeClientType::GoogleAdsWebClient => "GOOGLE_ADS_WEB_CLIENT",
                ChangeClientType::GoogleAdsAutomatedRule => "GOOGLE_ADS_AUTOMATED_RULE",
                ChangeClientType::GoogleAdsScripts => "GOOGLE_ADS_SCRIPTS",
                ChangeClientType::GoogleAdsBulkUpload => "GOOGLE_ADS_BULK_UPLOAD",
                ChangeClientType::GoogleAdsApi => "GOOGLE_ADS_API",
                ChangeClientType::GoogleAdsEditor => "GOOGLE_ADS_EDITOR",
                ChangeClientType::GoogleAdsMobileApp => "GOOGLE_ADS_MOBILE_APP",
                ChangeClientType::GoogleAdsRecommendations => {
                    "GOOGLE_ADS_RECOMMENDATIONS"
                }
                ChangeClientType::SearchAds360Sync => "SEARCH_ADS_360_SYNC",
                ChangeClientType::SearchAds360Post => "SEARCH_ADS_360_POST",
                ChangeClientType::InternalTool => "INTERNAL_TOOL",
                ChangeClientType::Other => "OTHER",
                ChangeClientType::GoogleAdsRecommendationsSubscription => {
                    "GOOGLE_ADS_RECOMMENDATIONS_SUBSCRIPTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_ADS_WEB_CLIENT" => Some(Self::GoogleAdsWebClient),
                "GOOGLE_ADS_AUTOMATED_RULE" => Some(Self::GoogleAdsAutomatedRule),
                "GOOGLE_ADS_SCRIPTS" => Some(Self::GoogleAdsScripts),
                "GOOGLE_ADS_BULK_UPLOAD" => Some(Self::GoogleAdsBulkUpload),
                "GOOGLE_ADS_API" => Some(Self::GoogleAdsApi),
                "GOOGLE_ADS_EDITOR" => Some(Self::GoogleAdsEditor),
                "GOOGLE_ADS_MOBILE_APP" => Some(Self::GoogleAdsMobileApp),
                "GOOGLE_ADS_RECOMMENDATIONS" => Some(Self::GoogleAdsRecommendations),
                "SEARCH_ADS_360_SYNC" => Some(Self::SearchAds360Sync),
                "SEARCH_ADS_360_POST" => Some(Self::SearchAds360Post),
                "INTERNAL_TOOL" => Some(Self::InternalTool),
                "OTHER" => Some(Self::Other),
                "GOOGLE_ADS_RECOMMENDATIONS_SUBSCRIPTION" => {
                    Some(Self::GoogleAdsRecommendationsSubscription)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeEventResourceTypeEnum {}
/// Nested message and enum types in `ChangeEventResourceTypeEnum`.
pub mod change_event_resource_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeEventResourceType {
        Unspecified = 0,
        Unknown = 1,
        Ad = 2,
        AdGroup = 3,
        AdGroupCriterion = 4,
        Campaign = 5,
        CampaignBudget = 6,
        AdGroupBidModifier = 7,
        CampaignCriterion = 8,
        Feed = 9,
        FeedItem = 10,
        CampaignFeed = 11,
        AdGroupFeed = 12,
        AdGroupAd = 13,
        Asset = 14,
        CustomerAsset = 15,
        CampaignAsset = 16,
        AdGroupAsset = 17,
        AssetSet = 18,
        AssetSetAsset = 19,
        CampaignAssetSet = 20,
    }
    impl ChangeEventResourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeEventResourceType::Unspecified => "UNSPECIFIED",
                ChangeEventResourceType::Unknown => "UNKNOWN",
                ChangeEventResourceType::Ad => "AD",
                ChangeEventResourceType::AdGroup => "AD_GROUP",
                ChangeEventResourceType::AdGroupCriterion => "AD_GROUP_CRITERION",
                ChangeEventResourceType::Campaign => "CAMPAIGN",
                ChangeEventResourceType::CampaignBudget => "CAMPAIGN_BUDGET",
                ChangeEventResourceType::AdGroupBidModifier => "AD_GROUP_BID_MODIFIER",
                ChangeEventResourceType::CampaignCriterion => "CAMPAIGN_CRITERION",
                ChangeEventResourceType::Feed => "FEED",
                ChangeEventResourceType::FeedItem => "FEED_ITEM",
                ChangeEventResourceType::CampaignFeed => "CAMPAIGN_FEED",
                ChangeEventResourceType::AdGroupFeed => "AD_GROUP_FEED",
                ChangeEventResourceType::AdGroupAd => "AD_GROUP_AD",
                ChangeEventResourceType::Asset => "ASSET",
                ChangeEventResourceType::CustomerAsset => "CUSTOMER_ASSET",
                ChangeEventResourceType::CampaignAsset => "CAMPAIGN_ASSET",
                ChangeEventResourceType::AdGroupAsset => "AD_GROUP_ASSET",
                ChangeEventResourceType::AssetSet => "ASSET_SET",
                ChangeEventResourceType::AssetSetAsset => "ASSET_SET_ASSET",
                ChangeEventResourceType::CampaignAssetSet => "CAMPAIGN_ASSET_SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD" => Some(Self::Ad),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                "CAMPAIGN" => Some(Self::Campaign),
                "CAMPAIGN_BUDGET" => Some(Self::CampaignBudget),
                "AD_GROUP_BID_MODIFIER" => Some(Self::AdGroupBidModifier),
                "CAMPAIGN_CRITERION" => Some(Self::CampaignCriterion),
                "FEED" => Some(Self::Feed),
                "FEED_ITEM" => Some(Self::FeedItem),
                "CAMPAIGN_FEED" => Some(Self::CampaignFeed),
                "AD_GROUP_FEED" => Some(Self::AdGroupFeed),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "ASSET" => Some(Self::Asset),
                "CUSTOMER_ASSET" => Some(Self::CustomerAsset),
                "CAMPAIGN_ASSET" => Some(Self::CampaignAsset),
                "AD_GROUP_ASSET" => Some(Self::AdGroupAsset),
                "ASSET_SET" => Some(Self::AssetSet),
                "ASSET_SET_ASSET" => Some(Self::AssetSetAsset),
                "CAMPAIGN_ASSET_SET" => Some(Self::CampaignAssetSet),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceChangeOperationEnum {}
/// Nested message and enum types in `ResourceChangeOperationEnum`.
pub mod resource_change_operation_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceChangeOperation {
        Unspecified = 0,
        Unknown = 1,
        Create = 2,
        Update = 3,
        Remove = 4,
    }
    impl ResourceChangeOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceChangeOperation::Unspecified => "UNSPECIFIED",
                ResourceChangeOperation::Unknown => "UNKNOWN",
                ResourceChangeOperation::Create => "CREATE",
                ResourceChangeOperation::Update => "UPDATE",
                ResourceChangeOperation::Remove => "REMOVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREATE" => Some(Self::Create),
                "UPDATE" => Some(Self::Update),
                "REMOVE" => Some(Self::Remove),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetingDimensionEnum {}
/// Nested message and enum types in `TargetingDimensionEnum`.
pub mod targeting_dimension_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetingDimension {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Audience = 3,
        Topic = 4,
        Gender = 5,
        AgeRange = 6,
        Placement = 7,
        ParentalStatus = 8,
        IncomeRange = 9,
    }
    impl TargetingDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetingDimension::Unspecified => "UNSPECIFIED",
                TargetingDimension::Unknown => "UNKNOWN",
                TargetingDimension::Keyword => "KEYWORD",
                TargetingDimension::Audience => "AUDIENCE",
                TargetingDimension::Topic => "TOPIC",
                TargetingDimension::Gender => "GENDER",
                TargetingDimension::AgeRange => "AGE_RANGE",
                TargetingDimension::Placement => "PLACEMENT",
                TargetingDimension::ParentalStatus => "PARENTAL_STATUS",
                TargetingDimension::IncomeRange => "INCOME_RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "AUDIENCE" => Some(Self::Audience),
                "TOPIC" => Some(Self::Topic),
                "GENDER" => Some(Self::Gender),
                "AGE_RANGE" => Some(Self::AgeRange),
                "PLACEMENT" => Some(Self::Placement),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdRotationModeEnum {}
/// Nested message and enum types in `AdGroupAdRotationModeEnum`.
pub mod ad_group_ad_rotation_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdRotationMode {
        Unspecified = 0,
        Unknown = 1,
        Optimize = 2,
        RotateForever = 3,
    }
    impl AdGroupAdRotationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdRotationMode::Unspecified => "UNSPECIFIED",
                AdGroupAdRotationMode::Unknown => "UNKNOWN",
                AdGroupAdRotationMode::Optimize => "OPTIMIZE",
                AdGroupAdRotationMode::RotateForever => "ROTATE_FOREVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "ROTATE_FOREVER" => Some(Self::RotateForever),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupPrimaryStatusEnum {}
/// Nested message and enum types in `AdGroupPrimaryStatusEnum`.
pub mod ad_group_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        Pending = 5,
        NotEligible = 6,
        Limited = 7,
    }
    impl AdGroupPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupPrimaryStatus::Unspecified => "UNSPECIFIED",
                AdGroupPrimaryStatus::Unknown => "UNKNOWN",
                AdGroupPrimaryStatus::Eligible => "ELIGIBLE",
                AdGroupPrimaryStatus::Paused => "PAUSED",
                AdGroupPrimaryStatus::Removed => "REMOVED",
                AdGroupPrimaryStatus::Pending => "PENDING",
                AdGroupPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
                AdGroupPrimaryStatus::Limited => "LIMITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "LIMITED" => Some(Self::Limited),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AdGroupPrimaryStatusReasonEnum`.
pub mod ad_group_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        CampaignRemoved = 2,
        CampaignPaused = 3,
        CampaignPending = 4,
        CampaignEnded = 5,
        AdGroupPaused = 6,
        AdGroupRemoved = 7,
        AdGroupIncomplete = 8,
        KeywordsPaused = 9,
        NoKeywords = 10,
        AdGroupAdsPaused = 11,
        NoAdGroupAds = 12,
        HasAdsDisapproved = 13,
        HasAdsLimitedByPolicy = 14,
        MostAdsUnderReview = 15,
        CampaignDraft = 16,
        AdGroupPausedDueToLowActivity = 19,
    }
    impl AdGroupPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                AdGroupPrimaryStatusReason::Unknown => "UNKNOWN",
                AdGroupPrimaryStatusReason::CampaignRemoved => "CAMPAIGN_REMOVED",
                AdGroupPrimaryStatusReason::CampaignPaused => "CAMPAIGN_PAUSED",
                AdGroupPrimaryStatusReason::CampaignPending => "CAMPAIGN_PENDING",
                AdGroupPrimaryStatusReason::CampaignEnded => "CAMPAIGN_ENDED",
                AdGroupPrimaryStatusReason::AdGroupPaused => "AD_GROUP_PAUSED",
                AdGroupPrimaryStatusReason::AdGroupRemoved => "AD_GROUP_REMOVED",
                AdGroupPrimaryStatusReason::AdGroupIncomplete => "AD_GROUP_INCOMPLETE",
                AdGroupPrimaryStatusReason::KeywordsPaused => "KEYWORDS_PAUSED",
                AdGroupPrimaryStatusReason::NoKeywords => "NO_KEYWORDS",
                AdGroupPrimaryStatusReason::AdGroupAdsPaused => "AD_GROUP_ADS_PAUSED",
                AdGroupPrimaryStatusReason::NoAdGroupAds => "NO_AD_GROUP_ADS",
                AdGroupPrimaryStatusReason::HasAdsDisapproved => "HAS_ADS_DISAPPROVED",
                AdGroupPrimaryStatusReason::HasAdsLimitedByPolicy => {
                    "HAS_ADS_LIMITED_BY_POLICY"
                }
                AdGroupPrimaryStatusReason::MostAdsUnderReview => "MOST_ADS_UNDER_REVIEW",
                AdGroupPrimaryStatusReason::CampaignDraft => "CAMPAIGN_DRAFT",
                AdGroupPrimaryStatusReason::AdGroupPausedDueToLowActivity => {
                    "AD_GROUP_PAUSED_DUE_TO_LOW_ACTIVITY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_INCOMPLETE" => Some(Self::AdGroupIncomplete),
                "KEYWORDS_PAUSED" => Some(Self::KeywordsPaused),
                "NO_KEYWORDS" => Some(Self::NoKeywords),
                "AD_GROUP_ADS_PAUSED" => Some(Self::AdGroupAdsPaused),
                "NO_AD_GROUP_ADS" => Some(Self::NoAdGroupAds),
                "HAS_ADS_DISAPPROVED" => Some(Self::HasAdsDisapproved),
                "HAS_ADS_LIMITED_BY_POLICY" => Some(Self::HasAdsLimitedByPolicy),
                "MOST_ADS_UNDER_REVIEW" => Some(Self::MostAdsUnderReview),
                "CAMPAIGN_DRAFT" => Some(Self::CampaignDraft),
                "AD_GROUP_PAUSED_DUE_TO_LOW_ACTIVITY" => {
                    Some(Self::AdGroupPausedDueToLowActivity)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupStatusEnum {}
/// Nested message and enum types in `AdGroupStatusEnum`.
pub mod ad_group_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupStatus::Unspecified => "UNSPECIFIED",
                AdGroupStatus::Unknown => "UNKNOWN",
                AdGroupStatus::Enabled => "ENABLED",
                AdGroupStatus::Paused => "PAUSED",
                AdGroupStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupTypeEnum {}
/// Nested message and enum types in `AdGroupTypeEnum`.
pub mod ad_group_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupType {
        Unspecified = 0,
        Unknown = 1,
        SearchStandard = 2,
        DisplayStandard = 3,
        ShoppingProductAds = 4,
        HotelAds = 6,
        ShoppingSmartAds = 7,
        VideoBumper = 8,
        VideoTrueViewInStream = 9,
        VideoTrueViewInDisplay = 10,
        VideoNonSkippableInStream = 11,
        VideoOutstream = 12,
        SearchDynamicAds = 13,
        ShoppingComparisonListingAds = 14,
        PromotedHotelAds = 15,
        VideoResponsive = 16,
        VideoEfficientReach = 17,
        SmartCampaignAds = 18,
        TravelAds = 19,
    }
    impl AdGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupType::Unspecified => "UNSPECIFIED",
                AdGroupType::Unknown => "UNKNOWN",
                AdGroupType::SearchStandard => "SEARCH_STANDARD",
                AdGroupType::DisplayStandard => "DISPLAY_STANDARD",
                AdGroupType::ShoppingProductAds => "SHOPPING_PRODUCT_ADS",
                AdGroupType::HotelAds => "HOTEL_ADS",
                AdGroupType::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                AdGroupType::VideoBumper => "VIDEO_BUMPER",
                AdGroupType::VideoTrueViewInStream => "VIDEO_TRUE_VIEW_IN_STREAM",
                AdGroupType::VideoTrueViewInDisplay => "VIDEO_TRUE_VIEW_IN_DISPLAY",
                AdGroupType::VideoNonSkippableInStream => "VIDEO_NON_SKIPPABLE_IN_STREAM",
                AdGroupType::VideoOutstream => "VIDEO_OUTSTREAM",
                AdGroupType::SearchDynamicAds => "SEARCH_DYNAMIC_ADS",
                AdGroupType::ShoppingComparisonListingAds => {
                    "SHOPPING_COMPARISON_LISTING_ADS"
                }
                AdGroupType::PromotedHotelAds => "PROMOTED_HOTEL_ADS",
                AdGroupType::VideoResponsive => "VIDEO_RESPONSIVE",
                AdGroupType::VideoEfficientReach => "VIDEO_EFFICIENT_REACH",
                AdGroupType::SmartCampaignAds => "SMART_CAMPAIGN_ADS",
                AdGroupType::TravelAds => "TRAVEL_ADS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_STANDARD" => Some(Self::SearchStandard),
                "DISPLAY_STANDARD" => Some(Self::DisplayStandard),
                "SHOPPING_PRODUCT_ADS" => Some(Self::ShoppingProductAds),
                "HOTEL_ADS" => Some(Self::HotelAds),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "VIDEO_BUMPER" => Some(Self::VideoBumper),
                "VIDEO_TRUE_VIEW_IN_STREAM" => Some(Self::VideoTrueViewInStream),
                "VIDEO_TRUE_VIEW_IN_DISPLAY" => Some(Self::VideoTrueViewInDisplay),
                "VIDEO_NON_SKIPPABLE_IN_STREAM" => Some(Self::VideoNonSkippableInStream),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "SEARCH_DYNAMIC_ADS" => Some(Self::SearchDynamicAds),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "PROMOTED_HOTEL_ADS" => Some(Self::PromotedHotelAds),
                "VIDEO_RESPONSIVE" => Some(Self::VideoResponsive),
                "VIDEO_EFFICIENT_REACH" => Some(Self::VideoEfficientReach),
                "SMART_CAMPAIGN_ADS" => Some(Self::SmartCampaignAds),
                "TRAVEL_ADS" => Some(Self::TravelAds),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetTypeEnum {}
/// Nested message and enum types in `AssetSetTypeEnum`.
pub mod asset_set_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetType {
        Unspecified = 0,
        Unknown = 1,
        PageFeed = 2,
        DynamicEducation = 3,
        MerchantCenterFeed = 4,
        DynamicRealEstate = 5,
        DynamicCustom = 6,
        DynamicHotelsAndRentals = 7,
        DynamicFlights = 8,
        DynamicTravel = 9,
        DynamicLocal = 10,
        DynamicJobs = 11,
        LocationSync = 12,
        BusinessProfileDynamicLocationGroup = 13,
        ChainDynamicLocationGroup = 14,
        StaticLocationGroup = 15,
        HotelProperty = 16,
    }
    impl AssetSetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetType::Unspecified => "UNSPECIFIED",
                AssetSetType::Unknown => "UNKNOWN",
                AssetSetType::PageFeed => "PAGE_FEED",
                AssetSetType::DynamicEducation => "DYNAMIC_EDUCATION",
                AssetSetType::MerchantCenterFeed => "MERCHANT_CENTER_FEED",
                AssetSetType::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                AssetSetType::DynamicCustom => "DYNAMIC_CUSTOM",
                AssetSetType::DynamicHotelsAndRentals => "DYNAMIC_HOTELS_AND_RENTALS",
                AssetSetType::DynamicFlights => "DYNAMIC_FLIGHTS",
                AssetSetType::DynamicTravel => "DYNAMIC_TRAVEL",
                AssetSetType::DynamicLocal => "DYNAMIC_LOCAL",
                AssetSetType::DynamicJobs => "DYNAMIC_JOBS",
                AssetSetType::LocationSync => "LOCATION_SYNC",
                AssetSetType::BusinessProfileDynamicLocationGroup => {
                    "BUSINESS_PROFILE_DYNAMIC_LOCATION_GROUP"
                }
                AssetSetType::ChainDynamicLocationGroup => "CHAIN_DYNAMIC_LOCATION_GROUP",
                AssetSetType::StaticLocationGroup => "STATIC_LOCATION_GROUP",
                AssetSetType::HotelProperty => "HOTEL_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAGE_FEED" => Some(Self::PageFeed),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "MERCHANT_CENTER_FEED" => Some(Self::MerchantCenterFeed),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTELS_AND_RENTALS" => Some(Self::DynamicHotelsAndRentals),
                "DYNAMIC_FLIGHTS" => Some(Self::DynamicFlights),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOBS" => Some(Self::DynamicJobs),
                "LOCATION_SYNC" => Some(Self::LocationSync),
                "BUSINESS_PROFILE_DYNAMIC_LOCATION_GROUP" => {
                    Some(Self::BusinessProfileDynamicLocationGroup)
                }
                "CHAIN_DYNAMIC_LOCATION_GROUP" => Some(Self::ChainDynamicLocationGroup),
                "STATIC_LOCATION_GROUP" => Some(Self::StaticLocationGroup),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingSourceEnum {}
/// Nested message and enum types in `BiddingSourceEnum`.
pub mod bidding_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingSource {
        Unspecified = 0,
        Unknown = 1,
        CampaignBiddingStrategy = 5,
        AdGroup = 6,
        AdGroupCriterion = 7,
    }
    impl BiddingSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingSource::Unspecified => "UNSPECIFIED",
                BiddingSource::Unknown => "UNKNOWN",
                BiddingSource::CampaignBiddingStrategy => "CAMPAIGN_BIDDING_STRATEGY",
                BiddingSource::AdGroup => "AD_GROUP",
                BiddingSource::AdGroupCriterion => "AD_GROUP_CRITERION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_BIDDING_STRATEGY" => Some(Self::CampaignBiddingStrategy),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdPrimaryStatusEnum {}
/// Nested message and enum types in `AdGroupAdPrimaryStatusEnum`.
pub mod ad_group_ad_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        Pending = 5,
        Limited = 6,
        NotEligible = 7,
    }
    impl AdGroupAdPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdPrimaryStatus::Unspecified => "UNSPECIFIED",
                AdGroupAdPrimaryStatus::Unknown => "UNKNOWN",
                AdGroupAdPrimaryStatus::Eligible => "ELIGIBLE",
                AdGroupAdPrimaryStatus::Paused => "PAUSED",
                AdGroupAdPrimaryStatus::Removed => "REMOVED",
                AdGroupAdPrimaryStatus::Pending => "PENDING",
                AdGroupAdPrimaryStatus::Limited => "LIMITED",
                AdGroupAdPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "LIMITED" => Some(Self::Limited),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AdGroupAdPrimaryStatusReasonEnum`.
pub mod ad_group_ad_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        CampaignRemoved = 2,
        CampaignPaused = 3,
        CampaignPending = 4,
        CampaignEnded = 5,
        AdGroupPaused = 6,
        AdGroupRemoved = 7,
        AdGroupAdPaused = 8,
        AdGroupAdRemoved = 9,
        AdGroupAdDisapproved = 10,
        AdGroupAdUnderReview = 11,
        AdGroupAdPoorQuality = 12,
        AdGroupAdNoAds = 13,
        AdGroupAdApprovedLabeled = 14,
        AdGroupAdAreaOfInterestOnly = 15,
        AdGroupAdUnderAppeal = 16,
    }
    impl AdGroupAdPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                AdGroupAdPrimaryStatusReason::Unknown => "UNKNOWN",
                AdGroupAdPrimaryStatusReason::CampaignRemoved => "CAMPAIGN_REMOVED",
                AdGroupAdPrimaryStatusReason::CampaignPaused => "CAMPAIGN_PAUSED",
                AdGroupAdPrimaryStatusReason::CampaignPending => "CAMPAIGN_PENDING",
                AdGroupAdPrimaryStatusReason::CampaignEnded => "CAMPAIGN_ENDED",
                AdGroupAdPrimaryStatusReason::AdGroupPaused => "AD_GROUP_PAUSED",
                AdGroupAdPrimaryStatusReason::AdGroupRemoved => "AD_GROUP_REMOVED",
                AdGroupAdPrimaryStatusReason::AdGroupAdPaused => "AD_GROUP_AD_PAUSED",
                AdGroupAdPrimaryStatusReason::AdGroupAdRemoved => "AD_GROUP_AD_REMOVED",
                AdGroupAdPrimaryStatusReason::AdGroupAdDisapproved => {
                    "AD_GROUP_AD_DISAPPROVED"
                }
                AdGroupAdPrimaryStatusReason::AdGroupAdUnderReview => {
                    "AD_GROUP_AD_UNDER_REVIEW"
                }
                AdGroupAdPrimaryStatusReason::AdGroupAdPoorQuality => {
                    "AD_GROUP_AD_POOR_QUALITY"
                }
                AdGroupAdPrimaryStatusReason::AdGroupAdNoAds => "AD_GROUP_AD_NO_ADS",
                AdGroupAdPrimaryStatusReason::AdGroupAdApprovedLabeled => {
                    "AD_GROUP_AD_APPROVED_LABELED"
                }
                AdGroupAdPrimaryStatusReason::AdGroupAdAreaOfInterestOnly => {
                    "AD_GROUP_AD_AREA_OF_INTEREST_ONLY"
                }
                AdGroupAdPrimaryStatusReason::AdGroupAdUnderAppeal => {
                    "AD_GROUP_AD_UNDER_APPEAL"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_AD_PAUSED" => Some(Self::AdGroupAdPaused),
                "AD_GROUP_AD_REMOVED" => Some(Self::AdGroupAdRemoved),
                "AD_GROUP_AD_DISAPPROVED" => Some(Self::AdGroupAdDisapproved),
                "AD_GROUP_AD_UNDER_REVIEW" => Some(Self::AdGroupAdUnderReview),
                "AD_GROUP_AD_POOR_QUALITY" => Some(Self::AdGroupAdPoorQuality),
                "AD_GROUP_AD_NO_ADS" => Some(Self::AdGroupAdNoAds),
                "AD_GROUP_AD_APPROVED_LABELED" => Some(Self::AdGroupAdApprovedLabeled),
                "AD_GROUP_AD_AREA_OF_INTEREST_ONLY" => {
                    Some(Self::AdGroupAdAreaOfInterestOnly)
                }
                "AD_GROUP_AD_UNDER_APPEAL" => Some(Self::AdGroupAdUnderAppeal),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdStatusEnum {}
/// Nested message and enum types in `AdGroupAdStatusEnum`.
pub mod ad_group_ad_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupAdStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdStatus::Unspecified => "UNSPECIFIED",
                AdGroupAdStatus::Unknown => "UNKNOWN",
                AdGroupAdStatus::Enabled => "ENABLED",
                AdGroupAdStatus::Paused => "PAUSED",
                AdGroupAdStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BidModifierSourceEnum {}
/// Nested message and enum types in `BidModifierSourceEnum`.
pub mod bid_modifier_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BidModifierSource {
        Unspecified = 0,
        Unknown = 1,
        Campaign = 2,
        AdGroup = 3,
    }
    impl BidModifierSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BidModifierSource::Unspecified => "UNSPECIFIED",
                BidModifierSource::Unknown => "UNKNOWN",
                BidModifierSource::Campaign => "CAMPAIGN",
                BidModifierSource::AdGroup => "AD_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN" => Some(Self::Campaign),
                "AD_GROUP" => Some(Self::AdGroup),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionApprovalStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionApprovalStatusEnum`.
pub mod ad_group_criterion_approval_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionApprovalStatus {
        Unspecified = 0,
        Unknown = 1,
        Approved = 2,
        Disapproved = 3,
        PendingReview = 4,
        UnderReview = 5,
    }
    impl AdGroupCriterionApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionApprovalStatus::Unspecified => "UNSPECIFIED",
                AdGroupCriterionApprovalStatus::Unknown => "UNKNOWN",
                AdGroupCriterionApprovalStatus::Approved => "APPROVED",
                AdGroupCriterionApprovalStatus::Disapproved => "DISAPPROVED",
                AdGroupCriterionApprovalStatus::PendingReview => "PENDING_REVIEW",
                AdGroupCriterionApprovalStatus::UnderReview => "UNDER_REVIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "DISAPPROVED" => Some(Self::Disapproved),
                "PENDING_REVIEW" => Some(Self::PendingReview),
                "UNDER_REVIEW" => Some(Self::UnderReview),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionPrimaryStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionPrimaryStatusEnum`.
pub mod ad_group_criterion_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        Pending = 5,
        NotEligible = 6,
    }
    impl AdGroupCriterionPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionPrimaryStatus::Unspecified => "UNSPECIFIED",
                AdGroupCriterionPrimaryStatus::Unknown => "UNKNOWN",
                AdGroupCriterionPrimaryStatus::Eligible => "ELIGIBLE",
                AdGroupCriterionPrimaryStatus::Paused => "PAUSED",
                AdGroupCriterionPrimaryStatus::Removed => "REMOVED",
                AdGroupCriterionPrimaryStatus::Pending => "PENDING",
                AdGroupCriterionPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "PENDING" => Some(Self::Pending),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AdGroupCriterionPrimaryStatusReasonEnum`.
pub mod ad_group_criterion_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        CampaignPending = 2,
        CampaignCriterionNegative = 3,
        CampaignPaused = 4,
        CampaignRemoved = 5,
        CampaignEnded = 6,
        AdGroupPaused = 7,
        AdGroupRemoved = 8,
        AdGroupCriterionDisapproved = 9,
        AdGroupCriterionRarelyServed = 10,
        AdGroupCriterionLowQuality = 11,
        AdGroupCriterionUnderReview = 12,
        AdGroupCriterionPendingReview = 13,
        AdGroupCriterionBelowFirstPageBid = 14,
        AdGroupCriterionNegative = 15,
        AdGroupCriterionRestricted = 16,
        AdGroupCriterionPaused = 17,
        AdGroupCriterionPausedDueToLowActivity = 18,
        AdGroupCriterionRemoved = 19,
    }
    impl AdGroupCriterionPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                AdGroupCriterionPrimaryStatusReason::Unknown => "UNKNOWN",
                AdGroupCriterionPrimaryStatusReason::CampaignPending => {
                    "CAMPAIGN_PENDING"
                }
                AdGroupCriterionPrimaryStatusReason::CampaignCriterionNegative => {
                    "CAMPAIGN_CRITERION_NEGATIVE"
                }
                AdGroupCriterionPrimaryStatusReason::CampaignPaused => "CAMPAIGN_PAUSED",
                AdGroupCriterionPrimaryStatusReason::CampaignRemoved => {
                    "CAMPAIGN_REMOVED"
                }
                AdGroupCriterionPrimaryStatusReason::CampaignEnded => "CAMPAIGN_ENDED",
                AdGroupCriterionPrimaryStatusReason::AdGroupPaused => "AD_GROUP_PAUSED",
                AdGroupCriterionPrimaryStatusReason::AdGroupRemoved => "AD_GROUP_REMOVED",
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionDisapproved => {
                    "AD_GROUP_CRITERION_DISAPPROVED"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionRarelyServed => {
                    "AD_GROUP_CRITERION_RARELY_SERVED"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionLowQuality => {
                    "AD_GROUP_CRITERION_LOW_QUALITY"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionUnderReview => {
                    "AD_GROUP_CRITERION_UNDER_REVIEW"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionPendingReview => {
                    "AD_GROUP_CRITERION_PENDING_REVIEW"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionBelowFirstPageBid => {
                    "AD_GROUP_CRITERION_BELOW_FIRST_PAGE_BID"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionNegative => {
                    "AD_GROUP_CRITERION_NEGATIVE"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionRestricted => {
                    "AD_GROUP_CRITERION_RESTRICTED"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionPaused => {
                    "AD_GROUP_CRITERION_PAUSED"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionPausedDueToLowActivity => {
                    "AD_GROUP_CRITERION_PAUSED_DUE_TO_LOW_ACTIVITY"
                }
                AdGroupCriterionPrimaryStatusReason::AdGroupCriterionRemoved => {
                    "AD_GROUP_CRITERION_REMOVED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_CRITERION_NEGATIVE" => Some(Self::CampaignCriterionNegative),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_CRITERION_DISAPPROVED" => {
                    Some(Self::AdGroupCriterionDisapproved)
                }
                "AD_GROUP_CRITERION_RARELY_SERVED" => {
                    Some(Self::AdGroupCriterionRarelyServed)
                }
                "AD_GROUP_CRITERION_LOW_QUALITY" => {
                    Some(Self::AdGroupCriterionLowQuality)
                }
                "AD_GROUP_CRITERION_UNDER_REVIEW" => {
                    Some(Self::AdGroupCriterionUnderReview)
                }
                "AD_GROUP_CRITERION_PENDING_REVIEW" => {
                    Some(Self::AdGroupCriterionPendingReview)
                }
                "AD_GROUP_CRITERION_BELOW_FIRST_PAGE_BID" => {
                    Some(Self::AdGroupCriterionBelowFirstPageBid)
                }
                "AD_GROUP_CRITERION_NEGATIVE" => Some(Self::AdGroupCriterionNegative),
                "AD_GROUP_CRITERION_RESTRICTED" => Some(Self::AdGroupCriterionRestricted),
                "AD_GROUP_CRITERION_PAUSED" => Some(Self::AdGroupCriterionPaused),
                "AD_GROUP_CRITERION_PAUSED_DUE_TO_LOW_ACTIVITY" => {
                    Some(Self::AdGroupCriterionPausedDueToLowActivity)
                }
                "AD_GROUP_CRITERION_REMOVED" => Some(Self::AdGroupCriterionRemoved),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionStatusEnum`.
pub mod ad_group_criterion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionStatus::Unspecified => "UNSPECIFIED",
                AdGroupCriterionStatus::Unknown => "UNKNOWN",
                AdGroupCriterionStatus::Enabled => "ENABLED",
                AdGroupCriterionStatus::Paused => "PAUSED",
                AdGroupCriterionStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionSystemServingStatusEnum {}
/// Nested message and enum types in `CriterionSystemServingStatusEnum`.
pub mod criterion_system_serving_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionSystemServingStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        RarelyServed = 3,
    }
    impl CriterionSystemServingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionSystemServingStatus::Unspecified => "UNSPECIFIED",
                CriterionSystemServingStatus::Unknown => "UNKNOWN",
                CriterionSystemServingStatus::Eligible => "ELIGIBLE",
                CriterionSystemServingStatus::RarelyServed => "RARELY_SERVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "RARELY_SERVED" => Some(Self::RarelyServed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionTypeEnum {}
/// Nested message and enum types in `CriterionTypeEnum`.
pub mod criterion_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionType {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Placement = 3,
        MobileAppCategory = 4,
        MobileApplication = 5,
        Device = 6,
        Location = 7,
        ListingGroup = 8,
        AdSchedule = 9,
        AgeRange = 10,
        Gender = 11,
        IncomeRange = 12,
        ParentalStatus = 13,
        YoutubeVideo = 14,
        YoutubeChannel = 15,
        UserList = 16,
        Proximity = 17,
        Topic = 18,
        ListingScope = 19,
        Language = 20,
        IpBlock = 21,
        ContentLabel = 22,
        Carrier = 23,
        UserInterest = 24,
        Webpage = 25,
        OperatingSystemVersion = 26,
        AppPaymentModel = 27,
        MobileDevice = 28,
        CustomAffinity = 29,
        CustomIntent = 30,
        LocationGroup = 31,
        CustomAudience = 32,
        CombinedAudience = 33,
        KeywordTheme = 34,
        Audience = 35,
        NegativeKeywordList = 36,
        LocalServiceId = 37,
        SearchTheme = 38,
        Brand = 39,
        BrandList = 40,
        LifeEvent = 41,
    }
    impl CriterionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionType::Unspecified => "UNSPECIFIED",
                CriterionType::Unknown => "UNKNOWN",
                CriterionType::Keyword => "KEYWORD",
                CriterionType::Placement => "PLACEMENT",
                CriterionType::MobileAppCategory => "MOBILE_APP_CATEGORY",
                CriterionType::MobileApplication => "MOBILE_APPLICATION",
                CriterionType::Device => "DEVICE",
                CriterionType::Location => "LOCATION",
                CriterionType::ListingGroup => "LISTING_GROUP",
                CriterionType::AdSchedule => "AD_SCHEDULE",
                CriterionType::AgeRange => "AGE_RANGE",
                CriterionType::Gender => "GENDER",
                CriterionType::IncomeRange => "INCOME_RANGE",
                CriterionType::ParentalStatus => "PARENTAL_STATUS",
                CriterionType::YoutubeVideo => "YOUTUBE_VIDEO",
                CriterionType::YoutubeChannel => "YOUTUBE_CHANNEL",
                CriterionType::UserList => "USER_LIST",
                CriterionType::Proximity => "PROXIMITY",
                CriterionType::Topic => "TOPIC",
                CriterionType::ListingScope => "LISTING_SCOPE",
                CriterionType::Language => "LANGUAGE",
                CriterionType::IpBlock => "IP_BLOCK",
                CriterionType::ContentLabel => "CONTENT_LABEL",
                CriterionType::Carrier => "CARRIER",
                CriterionType::UserInterest => "USER_INTEREST",
                CriterionType::Webpage => "WEBPAGE",
                CriterionType::OperatingSystemVersion => "OPERATING_SYSTEM_VERSION",
                CriterionType::AppPaymentModel => "APP_PAYMENT_MODEL",
                CriterionType::MobileDevice => "MOBILE_DEVICE",
                CriterionType::CustomAffinity => "CUSTOM_AFFINITY",
                CriterionType::CustomIntent => "CUSTOM_INTENT",
                CriterionType::LocationGroup => "LOCATION_GROUP",
                CriterionType::CustomAudience => "CUSTOM_AUDIENCE",
                CriterionType::CombinedAudience => "COMBINED_AUDIENCE",
                CriterionType::KeywordTheme => "KEYWORD_THEME",
                CriterionType::Audience => "AUDIENCE",
                CriterionType::NegativeKeywordList => "NEGATIVE_KEYWORD_LIST",
                CriterionType::LocalServiceId => "LOCAL_SERVICE_ID",
                CriterionType::SearchTheme => "SEARCH_THEME",
                CriterionType::Brand => "BRAND",
                CriterionType::BrandList => "BRAND_LIST",
                CriterionType::LifeEvent => "LIFE_EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "PLACEMENT" => Some(Self::Placement),
                "MOBILE_APP_CATEGORY" => Some(Self::MobileAppCategory),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                "DEVICE" => Some(Self::Device),
                "LOCATION" => Some(Self::Location),
                "LISTING_GROUP" => Some(Self::ListingGroup),
                "AD_SCHEDULE" => Some(Self::AdSchedule),
                "AGE_RANGE" => Some(Self::AgeRange),
                "GENDER" => Some(Self::Gender),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "USER_LIST" => Some(Self::UserList),
                "PROXIMITY" => Some(Self::Proximity),
                "TOPIC" => Some(Self::Topic),
                "LISTING_SCOPE" => Some(Self::ListingScope),
                "LANGUAGE" => Some(Self::Language),
                "IP_BLOCK" => Some(Self::IpBlock),
                "CONTENT_LABEL" => Some(Self::ContentLabel),
                "CARRIER" => Some(Self::Carrier),
                "USER_INTEREST" => Some(Self::UserInterest),
                "WEBPAGE" => Some(Self::Webpage),
                "OPERATING_SYSTEM_VERSION" => Some(Self::OperatingSystemVersion),
                "APP_PAYMENT_MODEL" => Some(Self::AppPaymentModel),
                "MOBILE_DEVICE" => Some(Self::MobileDevice),
                "CUSTOM_AFFINITY" => Some(Self::CustomAffinity),
                "CUSTOM_INTENT" => Some(Self::CustomIntent),
                "LOCATION_GROUP" => Some(Self::LocationGroup),
                "CUSTOM_AUDIENCE" => Some(Self::CustomAudience),
                "COMBINED_AUDIENCE" => Some(Self::CombinedAudience),
                "KEYWORD_THEME" => Some(Self::KeywordTheme),
                "AUDIENCE" => Some(Self::Audience),
                "NEGATIVE_KEYWORD_LIST" => Some(Self::NegativeKeywordList),
                "LOCAL_SERVICE_ID" => Some(Self::LocalServiceId),
                "SEARCH_THEME" => Some(Self::SearchTheme),
                "BRAND" => Some(Self::Brand),
                "BRAND_LIST" => Some(Self::BrandList),
                "LIFE_EVENT" => Some(Self::LifeEvent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QualityScoreBucketEnum {}
/// Nested message and enum types in `QualityScoreBucketEnum`.
pub mod quality_score_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QualityScoreBucket {
        Unspecified = 0,
        Unknown = 1,
        BelowAverage = 2,
        Average = 3,
        AboveAverage = 4,
    }
    impl QualityScoreBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QualityScoreBucket::Unspecified => "UNSPECIFIED",
                QualityScoreBucket::Unknown => "UNKNOWN",
                QualityScoreBucket::BelowAverage => "BELOW_AVERAGE",
                QualityScoreBucket::Average => "AVERAGE",
                QualityScoreBucket::AboveAverage => "ABOVE_AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BELOW_AVERAGE" => Some(Self::BelowAverage),
                "AVERAGE" => Some(Self::Average),
                "ABOVE_AVERAGE" => Some(Self::AboveAverage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChainRelationshipTypeEnum {}
/// Nested message and enum types in `ChainRelationshipTypeEnum`.
pub mod chain_relationship_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChainRelationshipType {
        Unspecified = 0,
        Unknown = 1,
        AutoDealers = 2,
        GeneralRetailers = 3,
    }
    impl ChainRelationshipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChainRelationshipType::Unspecified => "UNSPECIFIED",
                ChainRelationshipType::Unknown => "UNKNOWN",
                ChainRelationshipType::AutoDealers => "AUTO_DEALERS",
                ChainRelationshipType::GeneralRetailers => "GENERAL_RETAILERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTO_DEALERS" => Some(Self::AutoDealers),
                "GENERAL_RETAILERS" => Some(Self::GeneralRetailers),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationStringFilterTypeEnum {}
/// Nested message and enum types in `LocationStringFilterTypeEnum`.
pub mod location_string_filter_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationStringFilterType {
        Unspecified = 0,
        Unknown = 1,
        Exact = 2,
    }
    impl LocationStringFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationStringFilterType::Unspecified => "UNSPECIFIED",
                LocationStringFilterType::Unknown => "UNKNOWN",
                LocationStringFilterType::Exact => "EXACT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetStatusEnum {}
/// Nested message and enum types in `AssetSetStatusEnum`.
pub mod asset_set_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AssetSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetStatus::Unspecified => "UNSPECIFIED",
                AssetSetStatus::Unknown => "UNKNOWN",
                AssetSetStatus::Enabled => "ENABLED",
                AssetSetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetAssetStatusEnum {}
/// Nested message and enum types in `AssetSetAssetStatusEnum`.
pub mod asset_set_asset_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetAssetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AssetSetAssetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetAssetStatus::Unspecified => "UNSPECIFIED",
                AssetSetAssetStatus::Unknown => "UNKNOWN",
                AssetSetAssetStatus::Enabled => "ENABLED",
                AssetSetAssetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FixedCpmGoalEnum {}
/// Nested message and enum types in `FixedCpmGoalEnum`.
pub mod fixed_cpm_goal_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FixedCpmGoal {
        Unspecified = 0,
        Unknown = 1,
        Reach = 2,
        TargetFrequency = 3,
    }
    impl FixedCpmGoal {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FixedCpmGoal::Unspecified => "UNSPECIFIED",
                FixedCpmGoal::Unknown => "UNKNOWN",
                FixedCpmGoal::Reach => "REACH",
                FixedCpmGoal::TargetFrequency => "TARGET_FREQUENCY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REACH" => Some(Self::Reach),
                "TARGET_FREQUENCY" => Some(Self::TargetFrequency),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FixedCpmTargetFrequencyTimeUnitEnum {}
/// Nested message and enum types in `FixedCpmTargetFrequencyTimeUnitEnum`.
pub mod fixed_cpm_target_frequency_time_unit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FixedCpmTargetFrequencyTimeUnit {
        Unspecified = 0,
        Unknown = 1,
        Monthly = 2,
    }
    impl FixedCpmTargetFrequencyTimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FixedCpmTargetFrequencyTimeUnit::Unspecified => "UNSPECIFIED",
                FixedCpmTargetFrequencyTimeUnit::Unknown => "UNKNOWN",
                FixedCpmTargetFrequencyTimeUnit::Monthly => "MONTHLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MONTHLY" => Some(Self::Monthly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetFrequencyTimeUnitEnum {}
/// Nested message and enum types in `TargetFrequencyTimeUnitEnum`.
pub mod target_frequency_time_unit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetFrequencyTimeUnit {
        Unspecified = 0,
        Unknown = 1,
        Weekly = 2,
    }
    impl TargetFrequencyTimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetFrequencyTimeUnit::Unspecified => "UNSPECIFIED",
                TargetFrequencyTimeUnit::Unknown => "UNKNOWN",
                TargetFrequencyTimeUnit::Weekly => "WEEKLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEEKLY" => Some(Self::Weekly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapEventTypeEnum {}
/// Nested message and enum types in `FrequencyCapEventTypeEnum`.
pub mod frequency_cap_event_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapEventType {
        Unspecified = 0,
        Unknown = 1,
        Impression = 2,
        VideoView = 3,
    }
    impl FrequencyCapEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FrequencyCapEventType::Unspecified => "UNSPECIFIED",
                FrequencyCapEventType::Unknown => "UNKNOWN",
                FrequencyCapEventType::Impression => "IMPRESSION",
                FrequencyCapEventType::VideoView => "VIDEO_VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMPRESSION" => Some(Self::Impression),
                "VIDEO_VIEW" => Some(Self::VideoView),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapLevelEnum {}
/// Nested message and enum types in `FrequencyCapLevelEnum`.
pub mod frequency_cap_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapLevel {
        Unspecified = 0,
        Unknown = 1,
        AdGroupAd = 2,
        AdGroup = 3,
        Campaign = 4,
    }
    impl FrequencyCapLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FrequencyCapLevel::Unspecified => "UNSPECIFIED",
                FrequencyCapLevel::Unknown => "UNKNOWN",
                FrequencyCapLevel::AdGroupAd => "AD_GROUP_AD",
                FrequencyCapLevel::AdGroup => "AD_GROUP",
                FrequencyCapLevel::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "AD_GROUP" => Some(Self::AdGroup),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FrequencyCapTimeUnitEnum {}
/// Nested message and enum types in `FrequencyCapTimeUnitEnum`.
pub mod frequency_cap_time_unit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FrequencyCapTimeUnit {
        Unspecified = 0,
        Unknown = 1,
        Day = 2,
        Week = 3,
        Month = 4,
    }
    impl FrequencyCapTimeUnit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FrequencyCapTimeUnit::Unspecified => "UNSPECIFIED",
                FrequencyCapTimeUnit::Unknown => "UNKNOWN",
                FrequencyCapTimeUnit::Day => "DAY",
                FrequencyCapTimeUnit::Week => "WEEK",
                FrequencyCapTimeUnit::Month => "MONTH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DAY" => Some(Self::Day),
                "WEEK" => Some(Self::Week),
                "MONTH" => Some(Self::Month),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdServingOptimizationStatusEnum {}
/// Nested message and enum types in `AdServingOptimizationStatusEnum`.
pub mod ad_serving_optimization_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdServingOptimizationStatus {
        Unspecified = 0,
        Unknown = 1,
        Optimize = 2,
        ConversionOptimize = 3,
        Rotate = 4,
        RotateIndefinitely = 5,
        Unavailable = 6,
    }
    impl AdServingOptimizationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdServingOptimizationStatus::Unspecified => "UNSPECIFIED",
                AdServingOptimizationStatus::Unknown => "UNKNOWN",
                AdServingOptimizationStatus::Optimize => "OPTIMIZE",
                AdServingOptimizationStatus::ConversionOptimize => "CONVERSION_OPTIMIZE",
                AdServingOptimizationStatus::Rotate => "ROTATE",
                AdServingOptimizationStatus::RotateIndefinitely => "ROTATE_INDEFINITELY",
                AdServingOptimizationStatus::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "CONVERSION_OPTIMIZE" => Some(Self::ConversionOptimize),
                "ROTATE" => Some(Self::Rotate),
                "ROTATE_INDEFINITELY" => Some(Self::RotateIndefinitely),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppCampaignAppStoreEnum {}
/// Nested message and enum types in `AppCampaignAppStoreEnum`.
pub mod app_campaign_app_store_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppCampaignAppStore {
        Unspecified = 0,
        Unknown = 1,
        AppleAppStore = 2,
        GoogleAppStore = 3,
    }
    impl AppCampaignAppStore {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppCampaignAppStore::Unspecified => "UNSPECIFIED",
                AppCampaignAppStore::Unknown => "UNKNOWN",
                AppCampaignAppStore::AppleAppStore => "APPLE_APP_STORE",
                AppCampaignAppStore::GoogleAppStore => "GOOGLE_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_APP_STORE" => Some(Self::GoogleAppStore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppCampaignBiddingStrategyGoalTypeEnum {}
/// Nested message and enum types in `AppCampaignBiddingStrategyGoalTypeEnum`.
pub mod app_campaign_bidding_strategy_goal_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppCampaignBiddingStrategyGoalType {
        Unspecified = 0,
        Unknown = 1,
        OptimizeInstallsTargetInstallCost = 2,
        OptimizeInAppConversionsTargetInstallCost = 3,
        OptimizeInAppConversionsTargetConversionCost = 4,
        OptimizeReturnOnAdvertisingSpend = 5,
        OptimizePreRegistrationConversionVolume = 6,
        OptimizeInstallsWithoutTargetInstallCost = 7,
    }
    impl AppCampaignBiddingStrategyGoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppCampaignBiddingStrategyGoalType::Unspecified => "UNSPECIFIED",
                AppCampaignBiddingStrategyGoalType::Unknown => "UNKNOWN",
                AppCampaignBiddingStrategyGoalType::OptimizeInstallsTargetInstallCost => {
                    "OPTIMIZE_INSTALLS_TARGET_INSTALL_COST"
                }
                AppCampaignBiddingStrategyGoalType::OptimizeInAppConversionsTargetInstallCost => {
                    "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_INSTALL_COST"
                }
                AppCampaignBiddingStrategyGoalType::OptimizeInAppConversionsTargetConversionCost => {
                    "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_CONVERSION_COST"
                }
                AppCampaignBiddingStrategyGoalType::OptimizeReturnOnAdvertisingSpend => {
                    "OPTIMIZE_RETURN_ON_ADVERTISING_SPEND"
                }
                AppCampaignBiddingStrategyGoalType::OptimizePreRegistrationConversionVolume => {
                    "OPTIMIZE_PRE_REGISTRATION_CONVERSION_VOLUME"
                }
                AppCampaignBiddingStrategyGoalType::OptimizeInstallsWithoutTargetInstallCost => {
                    "OPTIMIZE_INSTALLS_WITHOUT_TARGET_INSTALL_COST"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE_INSTALLS_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInstallsTargetInstallCost)
                }
                "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInAppConversionsTargetInstallCost)
                }
                "OPTIMIZE_IN_APP_CONVERSIONS_TARGET_CONVERSION_COST" => {
                    Some(Self::OptimizeInAppConversionsTargetConversionCost)
                }
                "OPTIMIZE_RETURN_ON_ADVERTISING_SPEND" => {
                    Some(Self::OptimizeReturnOnAdvertisingSpend)
                }
                "OPTIMIZE_PRE_REGISTRATION_CONVERSION_VOLUME" => {
                    Some(Self::OptimizePreRegistrationConversionVolume)
                }
                "OPTIMIZE_INSTALLS_WITHOUT_TARGET_INSTALL_COST" => {
                    Some(Self::OptimizeInstallsWithoutTargetInstallCost)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetAutomationStatusEnum {}
/// Nested message and enum types in `AssetAutomationStatusEnum`.
pub mod asset_automation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetAutomationStatus {
        Unspecified = 0,
        Unknown = 1,
        OptedIn = 2,
        OptedOut = 3,
    }
    impl AssetAutomationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetAutomationStatus::Unspecified => "UNSPECIFIED",
                AssetAutomationStatus::Unknown => "UNKNOWN",
                AssetAutomationStatus::OptedIn => "OPTED_IN",
                AssetAutomationStatus::OptedOut => "OPTED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTED_IN" => Some(Self::OptedIn),
                "OPTED_OUT" => Some(Self::OptedOut),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetAutomationTypeEnum {}
/// Nested message and enum types in `AssetAutomationTypeEnum`.
pub mod asset_automation_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetAutomationType {
        Unspecified = 0,
        Unknown = 1,
        TextAssetAutomation = 2,
    }
    impl AssetAutomationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetAutomationType::Unspecified => "UNSPECIFIED",
                AssetAutomationType::Unknown => "UNKNOWN",
                AssetAutomationType::TextAssetAutomation => "TEXT_ASSET_AUTOMATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT_ASSET_AUTOMATION" => Some(Self::TextAssetAutomation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategySystemStatusEnum {}
/// Nested message and enum types in `BiddingStrategySystemStatusEnum`.
pub mod bidding_strategy_system_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategySystemStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        LearningNew = 3,
        LearningSettingChange = 4,
        LearningBudgetChange = 5,
        LearningCompositionChange = 6,
        LearningConversionTypeChange = 7,
        LearningConversionSettingChange = 8,
        LimitedByCpcBidCeiling = 9,
        LimitedByCpcBidFloor = 10,
        LimitedByData = 11,
        LimitedByBudget = 12,
        LimitedByLowPrioritySpend = 13,
        LimitedByLowQuality = 14,
        LimitedByInventory = 15,
        MisconfiguredZeroEligibility = 16,
        MisconfiguredConversionTypes = 17,
        MisconfiguredConversionSettings = 18,
        MisconfiguredSharedBudget = 19,
        MisconfiguredStrategyType = 20,
        Paused = 21,
        Unavailable = 22,
        MultipleLearning = 23,
        MultipleLimited = 24,
        MultipleMisconfigured = 25,
        Multiple = 26,
    }
    impl BiddingStrategySystemStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategySystemStatus::Unspecified => "UNSPECIFIED",
                BiddingStrategySystemStatus::Unknown => "UNKNOWN",
                BiddingStrategySystemStatus::Enabled => "ENABLED",
                BiddingStrategySystemStatus::LearningNew => "LEARNING_NEW",
                BiddingStrategySystemStatus::LearningSettingChange => {
                    "LEARNING_SETTING_CHANGE"
                }
                BiddingStrategySystemStatus::LearningBudgetChange => {
                    "LEARNING_BUDGET_CHANGE"
                }
                BiddingStrategySystemStatus::LearningCompositionChange => {
                    "LEARNING_COMPOSITION_CHANGE"
                }
                BiddingStrategySystemStatus::LearningConversionTypeChange => {
                    "LEARNING_CONVERSION_TYPE_CHANGE"
                }
                BiddingStrategySystemStatus::LearningConversionSettingChange => {
                    "LEARNING_CONVERSION_SETTING_CHANGE"
                }
                BiddingStrategySystemStatus::LimitedByCpcBidCeiling => {
                    "LIMITED_BY_CPC_BID_CEILING"
                }
                BiddingStrategySystemStatus::LimitedByCpcBidFloor => {
                    "LIMITED_BY_CPC_BID_FLOOR"
                }
                BiddingStrategySystemStatus::LimitedByData => "LIMITED_BY_DATA",
                BiddingStrategySystemStatus::LimitedByBudget => "LIMITED_BY_BUDGET",
                BiddingStrategySystemStatus::LimitedByLowPrioritySpend => {
                    "LIMITED_BY_LOW_PRIORITY_SPEND"
                }
                BiddingStrategySystemStatus::LimitedByLowQuality => {
                    "LIMITED_BY_LOW_QUALITY"
                }
                BiddingStrategySystemStatus::LimitedByInventory => "LIMITED_BY_INVENTORY",
                BiddingStrategySystemStatus::MisconfiguredZeroEligibility => {
                    "MISCONFIGURED_ZERO_ELIGIBILITY"
                }
                BiddingStrategySystemStatus::MisconfiguredConversionTypes => {
                    "MISCONFIGURED_CONVERSION_TYPES"
                }
                BiddingStrategySystemStatus::MisconfiguredConversionSettings => {
                    "MISCONFIGURED_CONVERSION_SETTINGS"
                }
                BiddingStrategySystemStatus::MisconfiguredSharedBudget => {
                    "MISCONFIGURED_SHARED_BUDGET"
                }
                BiddingStrategySystemStatus::MisconfiguredStrategyType => {
                    "MISCONFIGURED_STRATEGY_TYPE"
                }
                BiddingStrategySystemStatus::Paused => "PAUSED",
                BiddingStrategySystemStatus::Unavailable => "UNAVAILABLE",
                BiddingStrategySystemStatus::MultipleLearning => "MULTIPLE_LEARNING",
                BiddingStrategySystemStatus::MultipleLimited => "MULTIPLE_LIMITED",
                BiddingStrategySystemStatus::MultipleMisconfigured => {
                    "MULTIPLE_MISCONFIGURED"
                }
                BiddingStrategySystemStatus::Multiple => "MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "LEARNING_NEW" => Some(Self::LearningNew),
                "LEARNING_SETTING_CHANGE" => Some(Self::LearningSettingChange),
                "LEARNING_BUDGET_CHANGE" => Some(Self::LearningBudgetChange),
                "LEARNING_COMPOSITION_CHANGE" => Some(Self::LearningCompositionChange),
                "LEARNING_CONVERSION_TYPE_CHANGE" => {
                    Some(Self::LearningConversionTypeChange)
                }
                "LEARNING_CONVERSION_SETTING_CHANGE" => {
                    Some(Self::LearningConversionSettingChange)
                }
                "LIMITED_BY_CPC_BID_CEILING" => Some(Self::LimitedByCpcBidCeiling),
                "LIMITED_BY_CPC_BID_FLOOR" => Some(Self::LimitedByCpcBidFloor),
                "LIMITED_BY_DATA" => Some(Self::LimitedByData),
                "LIMITED_BY_BUDGET" => Some(Self::LimitedByBudget),
                "LIMITED_BY_LOW_PRIORITY_SPEND" => Some(Self::LimitedByLowPrioritySpend),
                "LIMITED_BY_LOW_QUALITY" => Some(Self::LimitedByLowQuality),
                "LIMITED_BY_INVENTORY" => Some(Self::LimitedByInventory),
                "MISCONFIGURED_ZERO_ELIGIBILITY" => {
                    Some(Self::MisconfiguredZeroEligibility)
                }
                "MISCONFIGURED_CONVERSION_TYPES" => {
                    Some(Self::MisconfiguredConversionTypes)
                }
                "MISCONFIGURED_CONVERSION_SETTINGS" => {
                    Some(Self::MisconfiguredConversionSettings)
                }
                "MISCONFIGURED_SHARED_BUDGET" => Some(Self::MisconfiguredSharedBudget),
                "MISCONFIGURED_STRATEGY_TYPE" => Some(Self::MisconfiguredStrategyType),
                "PAUSED" => Some(Self::Paused),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "MULTIPLE_LEARNING" => Some(Self::MultipleLearning),
                "MULTIPLE_LIMITED" => Some(Self::MultipleLimited),
                "MULTIPLE_MISCONFIGURED" => Some(Self::MultipleMisconfigured),
                "MULTIPLE" => Some(Self::Multiple),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BrandSafetySuitabilityEnum {}
/// Nested message and enum types in `BrandSafetySuitabilityEnum`.
pub mod brand_safety_suitability_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BrandSafetySuitability {
        Unspecified = 0,
        Unknown = 1,
        ExpandedInventory = 2,
        StandardInventory = 3,
        LimitedInventory = 4,
    }
    impl BrandSafetySuitability {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BrandSafetySuitability::Unspecified => "UNSPECIFIED",
                BrandSafetySuitability::Unknown => "UNKNOWN",
                BrandSafetySuitability::ExpandedInventory => "EXPANDED_INVENTORY",
                BrandSafetySuitability::StandardInventory => "STANDARD_INVENTORY",
                BrandSafetySuitability::LimitedInventory => "LIMITED_INVENTORY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXPANDED_INVENTORY" => Some(Self::ExpandedInventory),
                "STANDARD_INVENTORY" => Some(Self::StandardInventory),
                "LIMITED_INVENTORY" => Some(Self::LimitedInventory),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignExperimentTypeEnum {}
/// Nested message and enum types in `CampaignExperimentTypeEnum`.
pub mod campaign_experiment_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignExperimentType {
        Unspecified = 0,
        Unknown = 1,
        Base = 2,
        Draft = 3,
        Experiment = 4,
    }
    impl CampaignExperimentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignExperimentType::Unspecified => "UNSPECIFIED",
                CampaignExperimentType::Unknown => "UNKNOWN",
                CampaignExperimentType::Base => "BASE",
                CampaignExperimentType::Draft => "DRAFT",
                CampaignExperimentType::Experiment => "EXPERIMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BASE" => Some(Self::Base),
                "DRAFT" => Some(Self::Draft),
                "EXPERIMENT" => Some(Self::Experiment),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignKeywordMatchTypeEnum {}
/// Nested message and enum types in `CampaignKeywordMatchTypeEnum`.
pub mod campaign_keyword_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignKeywordMatchType {
        Unspecified = 0,
        Unknown = 1,
        Broad = 2,
    }
    impl CampaignKeywordMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignKeywordMatchType::Unspecified => "UNSPECIFIED",
                CampaignKeywordMatchType::Unknown => "UNKNOWN",
                CampaignKeywordMatchType::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignPrimaryStatusEnum {}
/// Nested message and enum types in `CampaignPrimaryStatusEnum`.
pub mod campaign_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        Ended = 5,
        Pending = 6,
        Misconfigured = 7,
        Limited = 8,
        Learning = 9,
        NotEligible = 10,
    }
    impl CampaignPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignPrimaryStatus::Unspecified => "UNSPECIFIED",
                CampaignPrimaryStatus::Unknown => "UNKNOWN",
                CampaignPrimaryStatus::Eligible => "ELIGIBLE",
                CampaignPrimaryStatus::Paused => "PAUSED",
                CampaignPrimaryStatus::Removed => "REMOVED",
                CampaignPrimaryStatus::Ended => "ENDED",
                CampaignPrimaryStatus::Pending => "PENDING",
                CampaignPrimaryStatus::Misconfigured => "MISCONFIGURED",
                CampaignPrimaryStatus::Limited => "LIMITED",
                CampaignPrimaryStatus::Learning => "LEARNING",
                CampaignPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "ENDED" => Some(Self::Ended),
                "PENDING" => Some(Self::Pending),
                "MISCONFIGURED" => Some(Self::Misconfigured),
                "LIMITED" => Some(Self::Limited),
                "LEARNING" => Some(Self::Learning),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignPrimaryStatusReasonEnum {}
/// Nested message and enum types in `CampaignPrimaryStatusReasonEnum`.
pub mod campaign_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        CampaignRemoved = 2,
        CampaignPaused = 3,
        CampaignPending = 4,
        CampaignEnded = 5,
        CampaignDraft = 6,
        BiddingStrategyMisconfigured = 7,
        BiddingStrategyLimited = 8,
        BiddingStrategyLearning = 9,
        BiddingStrategyConstrained = 10,
        BudgetConstrained = 11,
        BudgetMisconfigured = 12,
        SearchVolumeLimited = 13,
        AdGroupsPaused = 14,
        NoAdGroups = 15,
        KeywordsPaused = 16,
        NoKeywords = 17,
        AdGroupAdsPaused = 18,
        NoAdGroupAds = 19,
        HasAdsLimitedByPolicy = 20,
        HasAdsDisapproved = 21,
        MostAdsUnderReview = 22,
        MissingLeadFormExtension = 23,
        MissingCallExtension = 24,
        LeadFormExtensionUnderReview = 25,
        LeadFormExtensionDisapproved = 26,
        CallExtensionUnderReview = 27,
        CallExtensionDisapproved = 28,
        NoMobileApplicationAdGroupCriteria = 29,
        CampaignGroupPaused = 30,
        CampaignGroupAllGroupBudgetsEnded = 31,
        AppNotReleased = 32,
        AppPartiallyReleased = 33,
        HasAssetGroupsDisapproved = 34,
        HasAssetGroupsLimitedByPolicy = 35,
        MostAssetGroupsUnderReview = 36,
        NoAssetGroups = 37,
        AssetGroupsPaused = 38,
    }
    impl CampaignPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                CampaignPrimaryStatusReason::Unknown => "UNKNOWN",
                CampaignPrimaryStatusReason::CampaignRemoved => "CAMPAIGN_REMOVED",
                CampaignPrimaryStatusReason::CampaignPaused => "CAMPAIGN_PAUSED",
                CampaignPrimaryStatusReason::CampaignPending => "CAMPAIGN_PENDING",
                CampaignPrimaryStatusReason::CampaignEnded => "CAMPAIGN_ENDED",
                CampaignPrimaryStatusReason::CampaignDraft => "CAMPAIGN_DRAFT",
                CampaignPrimaryStatusReason::BiddingStrategyMisconfigured => {
                    "BIDDING_STRATEGY_MISCONFIGURED"
                }
                CampaignPrimaryStatusReason::BiddingStrategyLimited => {
                    "BIDDING_STRATEGY_LIMITED"
                }
                CampaignPrimaryStatusReason::BiddingStrategyLearning => {
                    "BIDDING_STRATEGY_LEARNING"
                }
                CampaignPrimaryStatusReason::BiddingStrategyConstrained => {
                    "BIDDING_STRATEGY_CONSTRAINED"
                }
                CampaignPrimaryStatusReason::BudgetConstrained => "BUDGET_CONSTRAINED",
                CampaignPrimaryStatusReason::BudgetMisconfigured => {
                    "BUDGET_MISCONFIGURED"
                }
                CampaignPrimaryStatusReason::SearchVolumeLimited => {
                    "SEARCH_VOLUME_LIMITED"
                }
                CampaignPrimaryStatusReason::AdGroupsPaused => "AD_GROUPS_PAUSED",
                CampaignPrimaryStatusReason::NoAdGroups => "NO_AD_GROUPS",
                CampaignPrimaryStatusReason::KeywordsPaused => "KEYWORDS_PAUSED",
                CampaignPrimaryStatusReason::NoKeywords => "NO_KEYWORDS",
                CampaignPrimaryStatusReason::AdGroupAdsPaused => "AD_GROUP_ADS_PAUSED",
                CampaignPrimaryStatusReason::NoAdGroupAds => "NO_AD_GROUP_ADS",
                CampaignPrimaryStatusReason::HasAdsLimitedByPolicy => {
                    "HAS_ADS_LIMITED_BY_POLICY"
                }
                CampaignPrimaryStatusReason::HasAdsDisapproved => "HAS_ADS_DISAPPROVED",
                CampaignPrimaryStatusReason::MostAdsUnderReview => {
                    "MOST_ADS_UNDER_REVIEW"
                }
                CampaignPrimaryStatusReason::MissingLeadFormExtension => {
                    "MISSING_LEAD_FORM_EXTENSION"
                }
                CampaignPrimaryStatusReason::MissingCallExtension => {
                    "MISSING_CALL_EXTENSION"
                }
                CampaignPrimaryStatusReason::LeadFormExtensionUnderReview => {
                    "LEAD_FORM_EXTENSION_UNDER_REVIEW"
                }
                CampaignPrimaryStatusReason::LeadFormExtensionDisapproved => {
                    "LEAD_FORM_EXTENSION_DISAPPROVED"
                }
                CampaignPrimaryStatusReason::CallExtensionUnderReview => {
                    "CALL_EXTENSION_UNDER_REVIEW"
                }
                CampaignPrimaryStatusReason::CallExtensionDisapproved => {
                    "CALL_EXTENSION_DISAPPROVED"
                }
                CampaignPrimaryStatusReason::NoMobileApplicationAdGroupCriteria => {
                    "NO_MOBILE_APPLICATION_AD_GROUP_CRITERIA"
                }
                CampaignPrimaryStatusReason::CampaignGroupPaused => {
                    "CAMPAIGN_GROUP_PAUSED"
                }
                CampaignPrimaryStatusReason::CampaignGroupAllGroupBudgetsEnded => {
                    "CAMPAIGN_GROUP_ALL_GROUP_BUDGETS_ENDED"
                }
                CampaignPrimaryStatusReason::AppNotReleased => "APP_NOT_RELEASED",
                CampaignPrimaryStatusReason::AppPartiallyReleased => {
                    "APP_PARTIALLY_RELEASED"
                }
                CampaignPrimaryStatusReason::HasAssetGroupsDisapproved => {
                    "HAS_ASSET_GROUPS_DISAPPROVED"
                }
                CampaignPrimaryStatusReason::HasAssetGroupsLimitedByPolicy => {
                    "HAS_ASSET_GROUPS_LIMITED_BY_POLICY"
                }
                CampaignPrimaryStatusReason::MostAssetGroupsUnderReview => {
                    "MOST_ASSET_GROUPS_UNDER_REVIEW"
                }
                CampaignPrimaryStatusReason::NoAssetGroups => "NO_ASSET_GROUPS",
                CampaignPrimaryStatusReason::AssetGroupsPaused => "ASSET_GROUPS_PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "CAMPAIGN_DRAFT" => Some(Self::CampaignDraft),
                "BIDDING_STRATEGY_MISCONFIGURED" => {
                    Some(Self::BiddingStrategyMisconfigured)
                }
                "BIDDING_STRATEGY_LIMITED" => Some(Self::BiddingStrategyLimited),
                "BIDDING_STRATEGY_LEARNING" => Some(Self::BiddingStrategyLearning),
                "BIDDING_STRATEGY_CONSTRAINED" => Some(Self::BiddingStrategyConstrained),
                "BUDGET_CONSTRAINED" => Some(Self::BudgetConstrained),
                "BUDGET_MISCONFIGURED" => Some(Self::BudgetMisconfigured),
                "SEARCH_VOLUME_LIMITED" => Some(Self::SearchVolumeLimited),
                "AD_GROUPS_PAUSED" => Some(Self::AdGroupsPaused),
                "NO_AD_GROUPS" => Some(Self::NoAdGroups),
                "KEYWORDS_PAUSED" => Some(Self::KeywordsPaused),
                "NO_KEYWORDS" => Some(Self::NoKeywords),
                "AD_GROUP_ADS_PAUSED" => Some(Self::AdGroupAdsPaused),
                "NO_AD_GROUP_ADS" => Some(Self::NoAdGroupAds),
                "HAS_ADS_LIMITED_BY_POLICY" => Some(Self::HasAdsLimitedByPolicy),
                "HAS_ADS_DISAPPROVED" => Some(Self::HasAdsDisapproved),
                "MOST_ADS_UNDER_REVIEW" => Some(Self::MostAdsUnderReview),
                "MISSING_LEAD_FORM_EXTENSION" => Some(Self::MissingLeadFormExtension),
                "MISSING_CALL_EXTENSION" => Some(Self::MissingCallExtension),
                "LEAD_FORM_EXTENSION_UNDER_REVIEW" => {
                    Some(Self::LeadFormExtensionUnderReview)
                }
                "LEAD_FORM_EXTENSION_DISAPPROVED" => {
                    Some(Self::LeadFormExtensionDisapproved)
                }
                "CALL_EXTENSION_UNDER_REVIEW" => Some(Self::CallExtensionUnderReview),
                "CALL_EXTENSION_DISAPPROVED" => Some(Self::CallExtensionDisapproved),
                "NO_MOBILE_APPLICATION_AD_GROUP_CRITERIA" => {
                    Some(Self::NoMobileApplicationAdGroupCriteria)
                }
                "CAMPAIGN_GROUP_PAUSED" => Some(Self::CampaignGroupPaused),
                "CAMPAIGN_GROUP_ALL_GROUP_BUDGETS_ENDED" => {
                    Some(Self::CampaignGroupAllGroupBudgetsEnded)
                }
                "APP_NOT_RELEASED" => Some(Self::AppNotReleased),
                "APP_PARTIALLY_RELEASED" => Some(Self::AppPartiallyReleased),
                "HAS_ASSET_GROUPS_DISAPPROVED" => Some(Self::HasAssetGroupsDisapproved),
                "HAS_ASSET_GROUPS_LIMITED_BY_POLICY" => {
                    Some(Self::HasAssetGroupsLimitedByPolicy)
                }
                "MOST_ASSET_GROUPS_UNDER_REVIEW" => {
                    Some(Self::MostAssetGroupsUnderReview)
                }
                "NO_ASSET_GROUPS" => Some(Self::NoAssetGroups),
                "ASSET_GROUPS_PAUSED" => Some(Self::AssetGroupsPaused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignServingStatusEnum {}
/// Nested message and enum types in `CampaignServingStatusEnum`.
pub mod campaign_serving_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignServingStatus {
        Unspecified = 0,
        Unknown = 1,
        Serving = 2,
        None = 3,
        Ended = 4,
        Pending = 5,
        Suspended = 6,
    }
    impl CampaignServingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignServingStatus::Unspecified => "UNSPECIFIED",
                CampaignServingStatus::Unknown => "UNKNOWN",
                CampaignServingStatus::Serving => "SERVING",
                CampaignServingStatus::None => "NONE",
                CampaignServingStatus::Ended => "ENDED",
                CampaignServingStatus::Pending => "PENDING",
                CampaignServingStatus::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SERVING" => Some(Self::Serving),
                "NONE" => Some(Self::None),
                "ENDED" => Some(Self::Ended),
                "PENDING" => Some(Self::Pending),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignStatusEnum {}
/// Nested message and enum types in `CampaignStatusEnum`.
pub mod campaign_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl CampaignStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignStatus::Unspecified => "UNSPECIFIED",
                CampaignStatus::Unknown => "UNKNOWN",
                CampaignStatus::Enabled => "ENABLED",
                CampaignStatus::Paused => "PAUSED",
                CampaignStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingTypeEnum {}
/// Nested message and enum types in `ListingTypeEnum`.
pub mod listing_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingType {
        Unspecified = 0,
        Unknown = 1,
        Vehicles = 2,
    }
    impl ListingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingType::Unspecified => "UNSPECIFIED",
                ListingType::Unknown => "UNKNOWN",
                ListingType::Vehicles => "VEHICLES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VEHICLES" => Some(Self::Vehicles),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationSourceTypeEnum {}
/// Nested message and enum types in `LocationSourceTypeEnum`.
pub mod location_source_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationSourceType {
        Unspecified = 0,
        Unknown = 1,
        GoogleMyBusiness = 2,
        Affiliate = 3,
    }
    impl LocationSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationSourceType::Unspecified => "UNSPECIFIED",
                LocationSourceType::Unknown => "UNKNOWN",
                LocationSourceType::GoogleMyBusiness => "GOOGLE_MY_BUSINESS",
                LocationSourceType::Affiliate => "AFFILIATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GOOGLE_MY_BUSINESS" => Some(Self::GoogleMyBusiness),
                "AFFILIATE" => Some(Self::Affiliate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NegativeGeoTargetTypeEnum {}
/// Nested message and enum types in `NegativeGeoTargetTypeEnum`.
pub mod negative_geo_target_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NegativeGeoTargetType {
        Unspecified = 0,
        Unknown = 1,
        PresenceOrInterest = 4,
        Presence = 5,
    }
    impl NegativeGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NegativeGeoTargetType::Unspecified => "UNSPECIFIED",
                NegativeGeoTargetType::Unknown => "UNKNOWN",
                NegativeGeoTargetType::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                NegativeGeoTargetType::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OptimizationGoalTypeEnum {}
/// Nested message and enum types in `OptimizationGoalTypeEnum`.
pub mod optimization_goal_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptimizationGoalType {
        Unspecified = 0,
        Unknown = 1,
        CallClicks = 2,
        DrivingDirections = 3,
        AppPreRegistration = 4,
    }
    impl OptimizationGoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptimizationGoalType::Unspecified => "UNSPECIFIED",
                OptimizationGoalType::Unknown => "UNKNOWN",
                OptimizationGoalType::CallClicks => "CALL_CLICKS",
                OptimizationGoalType::DrivingDirections => "DRIVING_DIRECTIONS",
                OptimizationGoalType::AppPreRegistration => "APP_PRE_REGISTRATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALL_CLICKS" => Some(Self::CallClicks),
                "DRIVING_DIRECTIONS" => Some(Self::DrivingDirections),
                "APP_PRE_REGISTRATION" => Some(Self::AppPreRegistration),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PaymentModeEnum {}
/// Nested message and enum types in `PaymentModeEnum`.
pub mod payment_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PaymentMode {
        Unspecified = 0,
        Unknown = 1,
        Clicks = 4,
        ConversionValue = 5,
        Conversions = 6,
        GuestStay = 7,
    }
    impl PaymentMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PaymentMode::Unspecified => "UNSPECIFIED",
                PaymentMode::Unknown => "UNKNOWN",
                PaymentMode::Clicks => "CLICKS",
                PaymentMode::ConversionValue => "CONVERSION_VALUE",
                PaymentMode::Conversions => "CONVERSIONS",
                PaymentMode::GuestStay => "GUEST_STAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICKS" => Some(Self::Clicks),
                "CONVERSION_VALUE" => Some(Self::ConversionValue),
                "CONVERSIONS" => Some(Self::Conversions),
                "GUEST_STAY" => Some(Self::GuestStay),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PerformanceMaxUpgradeStatusEnum {}
/// Nested message and enum types in `PerformanceMaxUpgradeStatusEnum`.
pub mod performance_max_upgrade_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PerformanceMaxUpgradeStatus {
        Unspecified = 0,
        Unknown = 1,
        UpgradeInProgress = 3,
        UpgradeComplete = 4,
        UpgradeFailed = 5,
        UpgradeEligible = 6,
    }
    impl PerformanceMaxUpgradeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PerformanceMaxUpgradeStatus::Unspecified => "UNSPECIFIED",
                PerformanceMaxUpgradeStatus::Unknown => "UNKNOWN",
                PerformanceMaxUpgradeStatus::UpgradeInProgress => "UPGRADE_IN_PROGRESS",
                PerformanceMaxUpgradeStatus::UpgradeComplete => "UPGRADE_COMPLETE",
                PerformanceMaxUpgradeStatus::UpgradeFailed => "UPGRADE_FAILED",
                PerformanceMaxUpgradeStatus::UpgradeEligible => "UPGRADE_ELIGIBLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UPGRADE_IN_PROGRESS" => Some(Self::UpgradeInProgress),
                "UPGRADE_COMPLETE" => Some(Self::UpgradeComplete),
                "UPGRADE_FAILED" => Some(Self::UpgradeFailed),
                "UPGRADE_ELIGIBLE" => Some(Self::UpgradeEligible),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositiveGeoTargetTypeEnum {}
/// Nested message and enum types in `PositiveGeoTargetTypeEnum`.
pub mod positive_geo_target_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PositiveGeoTargetType {
        Unspecified = 0,
        Unknown = 1,
        PresenceOrInterest = 5,
        SearchInterest = 6,
        Presence = 7,
    }
    impl PositiveGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PositiveGeoTargetType::Unspecified => "UNSPECIFIED",
                PositiveGeoTargetType::Unknown => "UNKNOWN",
                PositiveGeoTargetType::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                PositiveGeoTargetType::SearchInterest => "SEARCH_INTEREST",
                PositiveGeoTargetType::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "SEARCH_INTEREST" => Some(Self::SearchInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VanityPharmaDisplayUrlModeEnum {}
/// Nested message and enum types in `VanityPharmaDisplayUrlModeEnum`.
pub mod vanity_pharma_display_url_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VanityPharmaDisplayUrlMode {
        Unspecified = 0,
        Unknown = 1,
        ManufacturerWebsiteUrl = 2,
        WebsiteDescription = 3,
    }
    impl VanityPharmaDisplayUrlMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VanityPharmaDisplayUrlMode::Unspecified => "UNSPECIFIED",
                VanityPharmaDisplayUrlMode::Unknown => "UNKNOWN",
                VanityPharmaDisplayUrlMode::ManufacturerWebsiteUrl => {
                    "MANUFACTURER_WEBSITE_URL"
                }
                VanityPharmaDisplayUrlMode::WebsiteDescription => "WEBSITE_DESCRIPTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MANUFACTURER_WEBSITE_URL" => Some(Self::ManufacturerWebsiteUrl),
                "WEBSITE_DESCRIPTION" => Some(Self::WebsiteDescription),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct VanityPharmaTextEnum {}
/// Nested message and enum types in `VanityPharmaTextEnum`.
pub mod vanity_pharma_text_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VanityPharmaText {
        Unspecified = 0,
        Unknown = 1,
        PrescriptionTreatmentWebsiteEn = 2,
        PrescriptionTreatmentWebsiteEs = 3,
        PrescriptionDeviceWebsiteEn = 4,
        PrescriptionDeviceWebsiteEs = 5,
        MedicalDeviceWebsiteEn = 6,
        MedicalDeviceWebsiteEs = 7,
        PreventativeTreatmentWebsiteEn = 8,
        PreventativeTreatmentWebsiteEs = 9,
        PrescriptionContraceptionWebsiteEn = 10,
        PrescriptionContraceptionWebsiteEs = 11,
        PrescriptionVaccineWebsiteEn = 12,
        PrescriptionVaccineWebsiteEs = 13,
    }
    impl VanityPharmaText {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                VanityPharmaText::Unspecified => "UNSPECIFIED",
                VanityPharmaText::Unknown => "UNKNOWN",
                VanityPharmaText::PrescriptionTreatmentWebsiteEn => {
                    "PRESCRIPTION_TREATMENT_WEBSITE_EN"
                }
                VanityPharmaText::PrescriptionTreatmentWebsiteEs => {
                    "PRESCRIPTION_TREATMENT_WEBSITE_ES"
                }
                VanityPharmaText::PrescriptionDeviceWebsiteEn => {
                    "PRESCRIPTION_DEVICE_WEBSITE_EN"
                }
                VanityPharmaText::PrescriptionDeviceWebsiteEs => {
                    "PRESCRIPTION_DEVICE_WEBSITE_ES"
                }
                VanityPharmaText::MedicalDeviceWebsiteEn => "MEDICAL_DEVICE_WEBSITE_EN",
                VanityPharmaText::MedicalDeviceWebsiteEs => "MEDICAL_DEVICE_WEBSITE_ES",
                VanityPharmaText::PreventativeTreatmentWebsiteEn => {
                    "PREVENTATIVE_TREATMENT_WEBSITE_EN"
                }
                VanityPharmaText::PreventativeTreatmentWebsiteEs => {
                    "PREVENTATIVE_TREATMENT_WEBSITE_ES"
                }
                VanityPharmaText::PrescriptionContraceptionWebsiteEn => {
                    "PRESCRIPTION_CONTRACEPTION_WEBSITE_EN"
                }
                VanityPharmaText::PrescriptionContraceptionWebsiteEs => {
                    "PRESCRIPTION_CONTRACEPTION_WEBSITE_ES"
                }
                VanityPharmaText::PrescriptionVaccineWebsiteEn => {
                    "PRESCRIPTION_VACCINE_WEBSITE_EN"
                }
                VanityPharmaText::PrescriptionVaccineWebsiteEs => {
                    "PRESCRIPTION_VACCINE_WEBSITE_ES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESCRIPTION_TREATMENT_WEBSITE_EN" => {
                    Some(Self::PrescriptionTreatmentWebsiteEn)
                }
                "PRESCRIPTION_TREATMENT_WEBSITE_ES" => {
                    Some(Self::PrescriptionTreatmentWebsiteEs)
                }
                "PRESCRIPTION_DEVICE_WEBSITE_EN" => {
                    Some(Self::PrescriptionDeviceWebsiteEn)
                }
                "PRESCRIPTION_DEVICE_WEBSITE_ES" => {
                    Some(Self::PrescriptionDeviceWebsiteEs)
                }
                "MEDICAL_DEVICE_WEBSITE_EN" => Some(Self::MedicalDeviceWebsiteEn),
                "MEDICAL_DEVICE_WEBSITE_ES" => Some(Self::MedicalDeviceWebsiteEs),
                "PREVENTATIVE_TREATMENT_WEBSITE_EN" => {
                    Some(Self::PreventativeTreatmentWebsiteEn)
                }
                "PREVENTATIVE_TREATMENT_WEBSITE_ES" => {
                    Some(Self::PreventativeTreatmentWebsiteEs)
                }
                "PRESCRIPTION_CONTRACEPTION_WEBSITE_EN" => {
                    Some(Self::PrescriptionContraceptionWebsiteEn)
                }
                "PRESCRIPTION_CONTRACEPTION_WEBSITE_ES" => {
                    Some(Self::PrescriptionContraceptionWebsiteEs)
                }
                "PRESCRIPTION_VACCINE_WEBSITE_EN" => {
                    Some(Self::PrescriptionVaccineWebsiteEn)
                }
                "PRESCRIPTION_VACCINE_WEBSITE_ES" => {
                    Some(Self::PrescriptionVaccineWebsiteEs)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetDeliveryMethodEnum {}
/// Nested message and enum types in `BudgetDeliveryMethodEnum`.
pub mod budget_delivery_method_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetDeliveryMethod {
        Unspecified = 0,
        Unknown = 1,
        Standard = 2,
        Accelerated = 3,
    }
    impl BudgetDeliveryMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetDeliveryMethod::Unspecified => "UNSPECIFIED",
                BudgetDeliveryMethod::Unknown => "UNKNOWN",
                BudgetDeliveryMethod::Standard => "STANDARD",
                BudgetDeliveryMethod::Accelerated => "ACCELERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "ACCELERATED" => Some(Self::Accelerated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetPeriodEnum {}
/// Nested message and enum types in `BudgetPeriodEnum`.
pub mod budget_period_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetPeriod {
        Unspecified = 0,
        Unknown = 1,
        Daily = 2,
        CustomPeriod = 5,
    }
    impl BudgetPeriod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetPeriod::Unspecified => "UNSPECIFIED",
                BudgetPeriod::Unknown => "UNKNOWN",
                BudgetPeriod::Daily => "DAILY",
                BudgetPeriod::CustomPeriod => "CUSTOM_PERIOD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DAILY" => Some(Self::Daily),
                "CUSTOM_PERIOD" => Some(Self::CustomPeriod),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetStatusEnum {}
/// Nested message and enum types in `BudgetStatusEnum`.
pub mod budget_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl BudgetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetStatus::Unspecified => "UNSPECIFIED",
                BudgetStatus::Unknown => "UNKNOWN",
                BudgetStatus::Enabled => "ENABLED",
                BudgetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetTypeEnum {}
/// Nested message and enum types in `BudgetTypeEnum`.
pub mod budget_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetType {
        Unspecified = 0,
        Unknown = 1,
        Standard = 2,
        FixedCpa = 4,
        SmartCampaign = 5,
        LocalServices = 6,
    }
    impl BudgetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetType::Unspecified => "UNSPECIFIED",
                BudgetType::Unknown => "UNKNOWN",
                BudgetType::Standard => "STANDARD",
                BudgetType::FixedCpa => "FIXED_CPA",
                BudgetType::SmartCampaign => "SMART_CAMPAIGN",
                BudgetType::LocalServices => "LOCAL_SERVICES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "FIXED_CPA" => Some(Self::FixedCpa),
                "SMART_CAMPAIGN" => Some(Self::SmartCampaign),
                "LOCAL_SERVICES" => Some(Self::LocalServices),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCriterionStatusEnum {}
/// Nested message and enum types in `CampaignCriterionStatusEnum`.
pub mod campaign_criterion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCriterionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl CampaignCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignCriterionStatus::Unspecified => "UNSPECIFIED",
                CampaignCriterionStatus::Unknown => "UNKNOWN",
                CampaignCriterionStatus::Enabled => "ENABLED",
                CampaignCriterionStatus::Paused => "PAUSED",
                CampaignCriterionStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomConversionGoalStatusEnum {}
/// Nested message and enum types in `CustomConversionGoalStatusEnum`.
pub mod custom_conversion_goal_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomConversionGoalStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CustomConversionGoalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomConversionGoalStatus::Unspecified => "UNSPECIFIED",
                CustomConversionGoalStatus::Unknown => "UNKNOWN",
                CustomConversionGoalStatus::Enabled => "ENABLED",
                CustomConversionGoalStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallTrackingDisplayLocationEnum {}
/// Nested message and enum types in `CallTrackingDisplayLocationEnum`.
pub mod call_tracking_display_location_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallTrackingDisplayLocation {
        Unspecified = 0,
        Unknown = 1,
        Ad = 2,
        LandingPage = 3,
    }
    impl CallTrackingDisplayLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallTrackingDisplayLocation::Unspecified => "UNSPECIFIED",
                CallTrackingDisplayLocation::Unknown => "UNKNOWN",
                CallTrackingDisplayLocation::Ad => "AD",
                CallTrackingDisplayLocation::LandingPage => "LANDING_PAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD" => Some(Self::Ad),
                "LANDING_PAGE" => Some(Self::LandingPage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallTypeEnum {}
/// Nested message and enum types in `CallTypeEnum`.
pub mod call_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallType {
        Unspecified = 0,
        Unknown = 1,
        ManuallyDialed = 2,
        HighEndMobileSearch = 3,
    }
    impl CallType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallType::Unspecified => "UNSPECIFIED",
                CallType::Unknown => "UNKNOWN",
                CallType::ManuallyDialed => "MANUALLY_DIALED",
                CallType::HighEndMobileSearch => "HIGH_END_MOBILE_SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MANUALLY_DIALED" => Some(Self::ManuallyDialed),
                "HIGH_END_MOBILE_SEARCH" => Some(Self::HighEndMobileSearch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleVoiceCallStatusEnum {}
/// Nested message and enum types in `GoogleVoiceCallStatusEnum`.
pub mod google_voice_call_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleVoiceCallStatus {
        Unspecified = 0,
        Unknown = 1,
        Missed = 2,
        Received = 3,
    }
    impl GoogleVoiceCallStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoogleVoiceCallStatus::Unspecified => "UNSPECIFIED",
                GoogleVoiceCallStatus::Unknown => "UNKNOWN",
                GoogleVoiceCallStatus::Missed => "MISSED",
                GoogleVoiceCallStatus::Received => "RECEIVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MISSED" => Some(Self::Missed),
                "RECEIVED" => Some(Self::Received),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagerLinkStatusEnum {}
/// Nested message and enum types in `ManagerLinkStatusEnum`.
pub mod manager_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagerLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Active = 2,
        Inactive = 3,
        Pending = 4,
        Refused = 5,
        Canceled = 6,
    }
    impl ManagerLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ManagerLinkStatus::Unspecified => "UNSPECIFIED",
                ManagerLinkStatus::Unknown => "UNKNOWN",
                ManagerLinkStatus::Active => "ACTIVE",
                ManagerLinkStatus::Inactive => "INACTIVE",
                ManagerLinkStatus::Pending => "PENDING",
                ManagerLinkStatus::Refused => "REFUSED",
                ManagerLinkStatus::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "PENDING" => Some(Self::Pending),
                "REFUSED" => Some(Self::Refused),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkCoarseConversionValueEnum {}
/// Nested message and enum types in `SkAdNetworkCoarseConversionValueEnum`.
pub mod sk_ad_network_coarse_conversion_value_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkCoarseConversionValue {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        Low = 3,
        Medium = 4,
        High = 5,
        None = 6,
    }
    impl SkAdNetworkCoarseConversionValue {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SkAdNetworkCoarseConversionValue::Unspecified => "UNSPECIFIED",
                SkAdNetworkCoarseConversionValue::Unknown => "UNKNOWN",
                SkAdNetworkCoarseConversionValue::Unavailable => "UNAVAILABLE",
                SkAdNetworkCoarseConversionValue::Low => "LOW",
                SkAdNetworkCoarseConversionValue::Medium => "MEDIUM",
                SkAdNetworkCoarseConversionValue::High => "HIGH",
                SkAdNetworkCoarseConversionValue::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusOperationEnum {}
/// Nested message and enum types in `ChangeStatusOperationEnum`.
pub mod change_status_operation_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusOperation {
        Unspecified = 0,
        Unknown = 1,
        Added = 2,
        Changed = 3,
        Removed = 4,
    }
    impl ChangeStatusOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeStatusOperation::Unspecified => "UNSPECIFIED",
                ChangeStatusOperation::Unknown => "UNKNOWN",
                ChangeStatusOperation::Added => "ADDED",
                ChangeStatusOperation::Changed => "CHANGED",
                ChangeStatusOperation::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDED" => Some(Self::Added),
                "CHANGED" => Some(Self::Changed),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ChangeStatusResourceTypeEnum {}
/// Nested message and enum types in `ChangeStatusResourceTypeEnum`.
pub mod change_status_resource_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ChangeStatusResourceType {
        Unspecified = 0,
        Unknown = 1,
        AdGroup = 3,
        AdGroupAd = 4,
        AdGroupCriterion = 5,
        Campaign = 6,
        CampaignCriterion = 7,
        Feed = 9,
        FeedItem = 10,
        AdGroupFeed = 11,
        CampaignFeed = 12,
        AdGroupBidModifier = 13,
        SharedSet = 14,
        CampaignSharedSet = 15,
        Asset = 16,
        CustomerAsset = 17,
        CampaignAsset = 18,
        AdGroupAsset = 19,
        CombinedAudience = 20,
        AssetGroup = 21,
    }
    impl ChangeStatusResourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ChangeStatusResourceType::Unspecified => "UNSPECIFIED",
                ChangeStatusResourceType::Unknown => "UNKNOWN",
                ChangeStatusResourceType::AdGroup => "AD_GROUP",
                ChangeStatusResourceType::AdGroupAd => "AD_GROUP_AD",
                ChangeStatusResourceType::AdGroupCriterion => "AD_GROUP_CRITERION",
                ChangeStatusResourceType::Campaign => "CAMPAIGN",
                ChangeStatusResourceType::CampaignCriterion => "CAMPAIGN_CRITERION",
                ChangeStatusResourceType::Feed => "FEED",
                ChangeStatusResourceType::FeedItem => "FEED_ITEM",
                ChangeStatusResourceType::AdGroupFeed => "AD_GROUP_FEED",
                ChangeStatusResourceType::CampaignFeed => "CAMPAIGN_FEED",
                ChangeStatusResourceType::AdGroupBidModifier => "AD_GROUP_BID_MODIFIER",
                ChangeStatusResourceType::SharedSet => "SHARED_SET",
                ChangeStatusResourceType::CampaignSharedSet => "CAMPAIGN_SHARED_SET",
                ChangeStatusResourceType::Asset => "ASSET",
                ChangeStatusResourceType::CustomerAsset => "CUSTOMER_ASSET",
                ChangeStatusResourceType::CampaignAsset => "CAMPAIGN_ASSET",
                ChangeStatusResourceType::AdGroupAsset => "AD_GROUP_ASSET",
                ChangeStatusResourceType::CombinedAudience => "COMBINED_AUDIENCE",
                ChangeStatusResourceType::AssetGroup => "ASSET_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP" => Some(Self::AdGroup),
                "AD_GROUP_AD" => Some(Self::AdGroupAd),
                "AD_GROUP_CRITERION" => Some(Self::AdGroupCriterion),
                "CAMPAIGN" => Some(Self::Campaign),
                "CAMPAIGN_CRITERION" => Some(Self::CampaignCriterion),
                "FEED" => Some(Self::Feed),
                "FEED_ITEM" => Some(Self::FeedItem),
                "AD_GROUP_FEED" => Some(Self::AdGroupFeed),
                "CAMPAIGN_FEED" => Some(Self::CampaignFeed),
                "AD_GROUP_BID_MODIFIER" => Some(Self::AdGroupBidModifier),
                "SHARED_SET" => Some(Self::SharedSet),
                "CAMPAIGN_SHARED_SET" => Some(Self::CampaignSharedSet),
                "ASSET" => Some(Self::Asset),
                "CUSTOMER_ASSET" => Some(Self::CustomerAsset),
                "CAMPAIGN_ASSET" => Some(Self::CampaignAsset),
                "AD_GROUP_ASSET" => Some(Self::AdGroupAsset),
                "COMBINED_AUDIENCE" => Some(Self::CombinedAudience),
                "ASSET_GROUP" => Some(Self::AssetGroup),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BatchJobStatusEnum {}
/// Nested message and enum types in `BatchJobStatusEnum`.
pub mod batch_job_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BatchJobStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Running = 3,
        Done = 4,
    }
    impl BatchJobStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BatchJobStatus::Unspecified => "UNSPECIFIED",
                BatchJobStatus::Unknown => "UNKNOWN",
                BatchJobStatus::Pending => "PENDING",
                BatchJobStatus::Running => "RUNNING",
                BatchJobStatus::Done => "DONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "DONE" => Some(Self::Done),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoalConfigLevelEnum {}
/// Nested message and enum types in `GoalConfigLevelEnum`.
pub mod goal_config_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoalConfigLevel {
        Unspecified = 0,
        Unknown = 1,
        Customer = 2,
        Campaign = 3,
    }
    impl GoalConfigLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoalConfigLevel::Unspecified => "UNSPECIFIED",
                GoalConfigLevel::Unknown => "UNKNOWN",
                GoalConfigLevel::Customer => "CUSTOMER",
                GoalConfigLevel::Campaign => "CAMPAIGN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "CAMPAIGN" => Some(Self::Campaign),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesCreditStateEnum {}
/// Nested message and enum types in `LocalServicesCreditStateEnum`.
pub mod local_services_credit_state_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CreditState {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Credited = 3,
    }
    impl CreditState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CreditState::Unspecified => "UNSPECIFIED",
                CreditState::Unknown => "UNKNOWN",
                CreditState::Pending => "PENDING",
                CreditState::Credited => "CREDITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "CREDITED" => Some(Self::Credited),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadStatusEnum {}
/// Nested message and enum types in `LocalServicesLeadStatusEnum`.
pub mod local_services_lead_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadStatus {
        Unspecified = 0,
        Unknown = 1,
        New = 2,
        Active = 3,
        Booked = 4,
        Declined = 5,
        Expired = 6,
        Disabled = 7,
        ConsumerDeclined = 8,
        WipedOut = 9,
    }
    impl LeadStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadStatus::Unspecified => "UNSPECIFIED",
                LeadStatus::Unknown => "UNKNOWN",
                LeadStatus::New => "NEW",
                LeadStatus::Active => "ACTIVE",
                LeadStatus::Booked => "BOOKED",
                LeadStatus::Declined => "DECLINED",
                LeadStatus::Expired => "EXPIRED",
                LeadStatus::Disabled => "DISABLED",
                LeadStatus::ConsumerDeclined => "CONSUMER_DECLINED",
                LeadStatus::WipedOut => "WIPED_OUT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "ACTIVE" => Some(Self::Active),
                "BOOKED" => Some(Self::Booked),
                "DECLINED" => Some(Self::Declined),
                "EXPIRED" => Some(Self::Expired),
                "DISABLED" => Some(Self::Disabled),
                "CONSUMER_DECLINED" => Some(Self::ConsumerDeclined),
                "WIPED_OUT" => Some(Self::WipedOut),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesLeadTypeEnum {}
/// Nested message and enum types in `LocalServicesLeadTypeEnum`.
pub mod local_services_lead_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LeadType {
        Unspecified = 0,
        Unknown = 1,
        Message = 2,
        PhoneCall = 3,
        Booking = 4,
    }
    impl LeadType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LeadType::Unspecified => "UNSPECIFIED",
                LeadType::Unknown => "UNKNOWN",
                LeadType::Message => "MESSAGE",
                LeadType::PhoneCall => "PHONE_CALL",
                LeadType::Booking => "BOOKING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MESSAGE" => Some(Self::Message),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "BOOKING" => Some(Self::Booking),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetStatusEnum {}
/// Nested message and enum types in `FeedItemTargetStatusEnum`.
pub mod feed_item_target_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedItemTargetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemTargetStatus::Unspecified => "UNSPECIFIED",
                FeedItemTargetStatus::Unknown => "UNKNOWN",
                FeedItemTargetStatus::Enabled => "ENABLED",
                FeedItemTargetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedItemTargetTypeEnum {}
/// Nested message and enum types in `FeedItemTargetTypeEnum`.
pub mod feed_item_target_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedItemTargetType {
        Unspecified = 0,
        Unknown = 1,
        Campaign = 2,
        AdGroup = 3,
        Criterion = 4,
    }
    impl FeedItemTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedItemTargetType::Unspecified => "UNSPECIFIED",
                FeedItemTargetType::Unknown => "UNKNOWN",
                FeedItemTargetType::Campaign => "CAMPAIGN",
                FeedItemTargetType::AdGroup => "AD_GROUP",
                FeedItemTargetType::Criterion => "CRITERION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGN" => Some(Self::Campaign),
                "AD_GROUP" => Some(Self::AdGroup),
                "CRITERION" => Some(Self::Criterion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConsentStatusEnum {}
/// Nested message and enum types in `ConsentStatusEnum`.
pub mod consent_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConsentStatus {
        Unspecified = 0,
        Unknown = 1,
        Granted = 2,
        Denied = 3,
    }
    impl ConsentStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConsentStatus::Unspecified => "UNSPECIFIED",
                ConsentStatus::Unknown => "UNKNOWN",
                ConsentStatus::Granted => "GRANTED",
                ConsentStatus::Denied => "DENIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GRANTED" => Some(Self::Granted),
                "DENIED" => Some(Self::Denied),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserIdentifierSourceEnum {}
/// Nested message and enum types in `UserIdentifierSourceEnum`.
pub mod user_identifier_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserIdentifierSource {
        Unspecified = 0,
        Unknown = 1,
        FirstParty = 2,
        ThirdParty = 3,
    }
    impl UserIdentifierSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserIdentifierSource::Unspecified => "UNSPECIFIED",
                UserIdentifierSource::Unknown => "UNKNOWN",
                UserIdentifierSource::FirstParty => "FIRST_PARTY",
                UserIdentifierSource::ThirdParty => "THIRD_PARTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIRST_PARTY" => Some(Self::FirstParty),
                "THIRD_PARTY" => Some(Self::ThirdParty),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobFailureReasonEnum {}
/// Nested message and enum types in `OfflineUserDataJobFailureReasonEnum`.
pub mod offline_user_data_job_failure_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobFailureReason {
        Unspecified = 0,
        Unknown = 1,
        InsufficientMatchedTransactions = 2,
        InsufficientTransactions = 3,
        HighAverageTransactionValue = 4,
        LowAverageTransactionValue = 5,
        NewlyObservedCurrencyCode = 6,
    }
    impl OfflineUserDataJobFailureReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineUserDataJobFailureReason::Unspecified => "UNSPECIFIED",
                OfflineUserDataJobFailureReason::Unknown => "UNKNOWN",
                OfflineUserDataJobFailureReason::InsufficientMatchedTransactions => {
                    "INSUFFICIENT_MATCHED_TRANSACTIONS"
                }
                OfflineUserDataJobFailureReason::InsufficientTransactions => {
                    "INSUFFICIENT_TRANSACTIONS"
                }
                OfflineUserDataJobFailureReason::HighAverageTransactionValue => {
                    "HIGH_AVERAGE_TRANSACTION_VALUE"
                }
                OfflineUserDataJobFailureReason::LowAverageTransactionValue => {
                    "LOW_AVERAGE_TRANSACTION_VALUE"
                }
                OfflineUserDataJobFailureReason::NewlyObservedCurrencyCode => {
                    "NEWLY_OBSERVED_CURRENCY_CODE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INSUFFICIENT_MATCHED_TRANSACTIONS" => {
                    Some(Self::InsufficientMatchedTransactions)
                }
                "INSUFFICIENT_TRANSACTIONS" => Some(Self::InsufficientTransactions),
                "HIGH_AVERAGE_TRANSACTION_VALUE" => {
                    Some(Self::HighAverageTransactionValue)
                }
                "LOW_AVERAGE_TRANSACTION_VALUE" => Some(Self::LowAverageTransactionValue),
                "NEWLY_OBSERVED_CURRENCY_CODE" => Some(Self::NewlyObservedCurrencyCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobMatchRateRangeEnum {}
/// Nested message and enum types in `OfflineUserDataJobMatchRateRangeEnum`.
pub mod offline_user_data_job_match_rate_range_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobMatchRateRange {
        Unspecified = 0,
        Unknown = 1,
        MatchRangeLessThan20 = 2,
        MatchRange20To30 = 3,
        MatchRange31To40 = 4,
        MatchRange41To50 = 5,
        MatchRange51To60 = 6,
        MatchRange61To70 = 7,
        MatchRange71To80 = 8,
        MatchRange81To90 = 9,
        MatchRange91To100 = 10,
    }
    impl OfflineUserDataJobMatchRateRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineUserDataJobMatchRateRange::Unspecified => "UNSPECIFIED",
                OfflineUserDataJobMatchRateRange::Unknown => "UNKNOWN",
                OfflineUserDataJobMatchRateRange::MatchRangeLessThan20 => {
                    "MATCH_RANGE_LESS_THAN_20"
                }
                OfflineUserDataJobMatchRateRange::MatchRange20To30 => {
                    "MATCH_RANGE_20_TO_30"
                }
                OfflineUserDataJobMatchRateRange::MatchRange31To40 => {
                    "MATCH_RANGE_31_TO_40"
                }
                OfflineUserDataJobMatchRateRange::MatchRange41To50 => {
                    "MATCH_RANGE_41_TO_50"
                }
                OfflineUserDataJobMatchRateRange::MatchRange51To60 => {
                    "MATCH_RANGE_51_TO_60"
                }
                OfflineUserDataJobMatchRateRange::MatchRange61To70 => {
                    "MATCH_RANGE_61_TO_70"
                }
                OfflineUserDataJobMatchRateRange::MatchRange71To80 => {
                    "MATCH_RANGE_71_TO_80"
                }
                OfflineUserDataJobMatchRateRange::MatchRange81To90 => {
                    "MATCH_RANGE_81_TO_90"
                }
                OfflineUserDataJobMatchRateRange::MatchRange91To100 => {
                    "MATCH_RANGE_91_TO_100"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MATCH_RANGE_LESS_THAN_20" => Some(Self::MatchRangeLessThan20),
                "MATCH_RANGE_20_TO_30" => Some(Self::MatchRange20To30),
                "MATCH_RANGE_31_TO_40" => Some(Self::MatchRange31To40),
                "MATCH_RANGE_41_TO_50" => Some(Self::MatchRange41To50),
                "MATCH_RANGE_51_TO_60" => Some(Self::MatchRange51To60),
                "MATCH_RANGE_61_TO_70" => Some(Self::MatchRange61To70),
                "MATCH_RANGE_71_TO_80" => Some(Self::MatchRange71To80),
                "MATCH_RANGE_81_TO_90" => Some(Self::MatchRange81To90),
                "MATCH_RANGE_91_TO_100" => Some(Self::MatchRange91To100),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobStatusEnum {}
/// Nested message and enum types in `OfflineUserDataJobStatusEnum`.
pub mod offline_user_data_job_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        Running = 3,
        Success = 4,
        Failed = 5,
    }
    impl OfflineUserDataJobStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineUserDataJobStatus::Unspecified => "UNSPECIFIED",
                OfflineUserDataJobStatus::Unknown => "UNKNOWN",
                OfflineUserDataJobStatus::Pending => "PENDING",
                OfflineUserDataJobStatus::Running => "RUNNING",
                OfflineUserDataJobStatus::Success => "SUCCESS",
                OfflineUserDataJobStatus::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "RUNNING" => Some(Self::Running),
                "SUCCESS" => Some(Self::Success),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OfflineUserDataJobTypeEnum {}
/// Nested message and enum types in `OfflineUserDataJobTypeEnum`.
pub mod offline_user_data_job_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OfflineUserDataJobType {
        Unspecified = 0,
        Unknown = 1,
        StoreSalesUploadFirstParty = 2,
        StoreSalesUploadThirdParty = 3,
        CustomerMatchUserList = 4,
        CustomerMatchWithAttributes = 5,
    }
    impl OfflineUserDataJobType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OfflineUserDataJobType::Unspecified => "UNSPECIFIED",
                OfflineUserDataJobType::Unknown => "UNKNOWN",
                OfflineUserDataJobType::StoreSalesUploadFirstParty => {
                    "STORE_SALES_UPLOAD_FIRST_PARTY"
                }
                OfflineUserDataJobType::StoreSalesUploadThirdParty => {
                    "STORE_SALES_UPLOAD_THIRD_PARTY"
                }
                OfflineUserDataJobType::CustomerMatchUserList => {
                    "CUSTOMER_MATCH_USER_LIST"
                }
                OfflineUserDataJobType::CustomerMatchWithAttributes => {
                    "CUSTOMER_MATCH_WITH_ATTRIBUTES"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STORE_SALES_UPLOAD_FIRST_PARTY" => {
                    Some(Self::StoreSalesUploadFirstParty)
                }
                "STORE_SALES_UPLOAD_THIRD_PARTY" => {
                    Some(Self::StoreSalesUploadThirdParty)
                }
                "CUSTOMER_MATCH_USER_LIST" => Some(Self::CustomerMatchUserList),
                "CUSTOMER_MATCH_WITH_ATTRIBUTES" => {
                    Some(Self::CustomerMatchWithAttributes)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LabelStatusEnum {}
/// Nested message and enum types in `LabelStatusEnum`.
pub mod label_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LabelStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl LabelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LabelStatus::Unspecified => "UNSPECIFIED",
                LabelStatus::Unknown => "UNKNOWN",
                LabelStatus::Enabled => "ENABLED",
                LabelStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerStatusEnum {}
/// Nested message and enum types in `CustomerStatusEnum`.
pub mod customer_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Canceled = 3,
        Suspended = 4,
        Closed = 5,
    }
    impl CustomerStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerStatus::Unspecified => "UNSPECIFIED",
                CustomerStatus::Unknown => "UNKNOWN",
                CustomerStatus::Enabled => "ENABLED",
                CustomerStatus::Canceled => "CANCELED",
                CustomerStatus::Suspended => "SUSPENDED",
                CustomerStatus::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "CANCELED" => Some(Self::Canceled),
                "SUSPENDED" => Some(Self::Suspended),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesEmployeeStatusEnum {}
/// Nested message and enum types in `LocalServicesEmployeeStatusEnum`.
pub mod local_services_employee_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesEmployeeStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl LocalServicesEmployeeStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesEmployeeStatus::Unspecified => "UNSPECIFIED",
                LocalServicesEmployeeStatus::Unknown => "UNKNOWN",
                LocalServicesEmployeeStatus::Enabled => "ENABLED",
                LocalServicesEmployeeStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesEmployeeTypeEnum {}
/// Nested message and enum types in `LocalServicesEmployeeTypeEnum`.
pub mod local_services_employee_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesEmployeeType {
        Unspecified = 0,
        Unknown = 1,
        BusinessOwner = 2,
        Employee = 3,
    }
    impl LocalServicesEmployeeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesEmployeeType::Unspecified => "UNSPECIFIED",
                LocalServicesEmployeeType::Unknown => "UNKNOWN",
                LocalServicesEmployeeType::BusinessOwner => "BUSINESS_OWNER",
                LocalServicesEmployeeType::Employee => "EMPLOYEE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_OWNER" => Some(Self::BusinessOwner),
                "EMPLOYEE" => Some(Self::Employee),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerMatchUploadKeyTypeEnum {}
/// Nested message and enum types in `CustomerMatchUploadKeyTypeEnum`.
pub mod customer_match_upload_key_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerMatchUploadKeyType {
        Unspecified = 0,
        Unknown = 1,
        ContactInfo = 2,
        CrmId = 3,
        MobileAdvertisingId = 4,
    }
    impl CustomerMatchUploadKeyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerMatchUploadKeyType::Unspecified => "UNSPECIFIED",
                CustomerMatchUploadKeyType::Unknown => "UNKNOWN",
                CustomerMatchUploadKeyType::ContactInfo => "CONTACT_INFO",
                CustomerMatchUploadKeyType::CrmId => "CRM_ID",
                CustomerMatchUploadKeyType::MobileAdvertisingId => {
                    "MOBILE_ADVERTISING_ID"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONTACT_INFO" => Some(Self::ContactInfo),
                "CRM_ID" => Some(Self::CrmId),
                "MOBILE_ADVERTISING_ID" => Some(Self::MobileAdvertisingId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LookalikeExpansionLevelEnum {}
/// Nested message and enum types in `LookalikeExpansionLevelEnum`.
pub mod lookalike_expansion_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LookalikeExpansionLevel {
        Unspecified = 0,
        Unknown = 1,
        Narrow = 2,
        Balanced = 3,
        Broad = 4,
    }
    impl LookalikeExpansionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LookalikeExpansionLevel::Unspecified => "UNSPECIFIED",
                LookalikeExpansionLevel::Unknown => "UNKNOWN",
                LookalikeExpansionLevel::Narrow => "NARROW",
                LookalikeExpansionLevel::Balanced => "BALANCED",
                LookalikeExpansionLevel::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NARROW" => Some(Self::Narrow),
                "BALANCED" => Some(Self::Balanced),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListCrmDataSourceTypeEnum {}
/// Nested message and enum types in `UserListCrmDataSourceTypeEnum`.
pub mod user_list_crm_data_source_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListCrmDataSourceType {
        Unspecified = 0,
        Unknown = 1,
        FirstParty = 2,
        ThirdPartyCreditBureau = 3,
        ThirdPartyVoterFile = 4,
    }
    impl UserListCrmDataSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListCrmDataSourceType::Unspecified => "UNSPECIFIED",
                UserListCrmDataSourceType::Unknown => "UNKNOWN",
                UserListCrmDataSourceType::FirstParty => "FIRST_PARTY",
                UserListCrmDataSourceType::ThirdPartyCreditBureau => {
                    "THIRD_PARTY_CREDIT_BUREAU"
                }
                UserListCrmDataSourceType::ThirdPartyVoterFile => {
                    "THIRD_PARTY_VOTER_FILE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "FIRST_PARTY" => Some(Self::FirstParty),
                "THIRD_PARTY_CREDIT_BUREAU" => Some(Self::ThirdPartyCreditBureau),
                "THIRD_PARTY_VOTER_FILE" => Some(Self::ThirdPartyVoterFile),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListDateRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListDateRuleItemOperatorEnum`.
pub mod user_list_date_rule_item_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListDateRuleItemOperator {
        Unspecified = 0,
        Unknown = 1,
        Equals = 2,
        NotEquals = 3,
        Before = 4,
        After = 5,
    }
    impl UserListDateRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListDateRuleItemOperator::Unspecified => "UNSPECIFIED",
                UserListDateRuleItemOperator::Unknown => "UNKNOWN",
                UserListDateRuleItemOperator::Equals => "EQUALS",
                UserListDateRuleItemOperator::NotEquals => "NOT_EQUALS",
                UserListDateRuleItemOperator::Before => "BEFORE",
                UserListDateRuleItemOperator::After => "AFTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS" => Some(Self::Equals),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "BEFORE" => Some(Self::Before),
                "AFTER" => Some(Self::After),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListFlexibleRuleOperatorEnum {}
/// Nested message and enum types in `UserListFlexibleRuleOperatorEnum`.
pub mod user_list_flexible_rule_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListFlexibleRuleOperator {
        Unspecified = 0,
        Unknown = 1,
        And = 2,
        Or = 3,
    }
    impl UserListFlexibleRuleOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListFlexibleRuleOperator::Unspecified => "UNSPECIFIED",
                UserListFlexibleRuleOperator::Unknown => "UNKNOWN",
                UserListFlexibleRuleOperator::And => "AND",
                UserListFlexibleRuleOperator::Or => "OR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AND" => Some(Self::And),
                "OR" => Some(Self::Or),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListLogicalRuleOperatorEnum {}
/// Nested message and enum types in `UserListLogicalRuleOperatorEnum`.
pub mod user_list_logical_rule_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListLogicalRuleOperator {
        Unspecified = 0,
        Unknown = 1,
        All = 2,
        Any = 3,
        None = 4,
    }
    impl UserListLogicalRuleOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListLogicalRuleOperator::Unspecified => "UNSPECIFIED",
                UserListLogicalRuleOperator::Unknown => "UNKNOWN",
                UserListLogicalRuleOperator::All => "ALL",
                UserListLogicalRuleOperator::Any => "ANY",
                UserListLogicalRuleOperator::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ALL" => Some(Self::All),
                "ANY" => Some(Self::Any),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListNumberRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListNumberRuleItemOperatorEnum`.
pub mod user_list_number_rule_item_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListNumberRuleItemOperator {
        Unspecified = 0,
        Unknown = 1,
        GreaterThan = 2,
        GreaterThanOrEqual = 3,
        Equals = 4,
        NotEquals = 5,
        LessThan = 6,
        LessThanOrEqual = 7,
    }
    impl UserListNumberRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListNumberRuleItemOperator::Unspecified => "UNSPECIFIED",
                UserListNumberRuleItemOperator::Unknown => "UNKNOWN",
                UserListNumberRuleItemOperator::GreaterThan => "GREATER_THAN",
                UserListNumberRuleItemOperator::GreaterThanOrEqual => {
                    "GREATER_THAN_OR_EQUAL"
                }
                UserListNumberRuleItemOperator::Equals => "EQUALS",
                UserListNumberRuleItemOperator::NotEquals => "NOT_EQUALS",
                UserListNumberRuleItemOperator::LessThan => "LESS_THAN",
                UserListNumberRuleItemOperator::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "GREATER_THAN" => Some(Self::GreaterThan),
                "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                "EQUALS" => Some(Self::Equals),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "LESS_THAN" => Some(Self::LessThan),
                "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListPrepopulationStatusEnum {}
/// Nested message and enum types in `UserListPrepopulationStatusEnum`.
pub mod user_list_prepopulation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListPrepopulationStatus {
        Unspecified = 0,
        Unknown = 1,
        Requested = 2,
        Finished = 3,
        Failed = 4,
    }
    impl UserListPrepopulationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListPrepopulationStatus::Unspecified => "UNSPECIFIED",
                UserListPrepopulationStatus::Unknown => "UNKNOWN",
                UserListPrepopulationStatus::Requested => "REQUESTED",
                UserListPrepopulationStatus::Finished => "FINISHED",
                UserListPrepopulationStatus::Failed => "FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REQUESTED" => Some(Self::Requested),
                "FINISHED" => Some(Self::Finished),
                "FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListRuleTypeEnum {}
/// Nested message and enum types in `UserListRuleTypeEnum`.
pub mod user_list_rule_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListRuleType {
        Unspecified = 0,
        Unknown = 1,
        AndOfOrs = 2,
        OrOfAnds = 3,
    }
    impl UserListRuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListRuleType::Unspecified => "UNSPECIFIED",
                UserListRuleType::Unknown => "UNKNOWN",
                UserListRuleType::AndOfOrs => "AND_OF_ORS",
                UserListRuleType::OrOfAnds => "OR_OF_ANDS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AND_OF_ORS" => Some(Self::AndOfOrs),
                "OR_OF_ANDS" => Some(Self::OrOfAnds),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListStringRuleItemOperatorEnum {}
/// Nested message and enum types in `UserListStringRuleItemOperatorEnum`.
pub mod user_list_string_rule_item_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListStringRuleItemOperator {
        Unspecified = 0,
        Unknown = 1,
        Contains = 2,
        Equals = 3,
        StartsWith = 4,
        EndsWith = 5,
        NotEquals = 6,
        NotContains = 7,
        NotStartsWith = 8,
        NotEndsWith = 9,
    }
    impl UserListStringRuleItemOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListStringRuleItemOperator::Unspecified => "UNSPECIFIED",
                UserListStringRuleItemOperator::Unknown => "UNKNOWN",
                UserListStringRuleItemOperator::Contains => "CONTAINS",
                UserListStringRuleItemOperator::Equals => "EQUALS",
                UserListStringRuleItemOperator::StartsWith => "STARTS_WITH",
                UserListStringRuleItemOperator::EndsWith => "ENDS_WITH",
                UserListStringRuleItemOperator::NotEquals => "NOT_EQUALS",
                UserListStringRuleItemOperator::NotContains => "NOT_CONTAINS",
                UserListStringRuleItemOperator::NotStartsWith => "NOT_STARTS_WITH",
                UserListStringRuleItemOperator::NotEndsWith => "NOT_ENDS_WITH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONTAINS" => Some(Self::Contains),
                "EQUALS" => Some(Self::Equals),
                "STARTS_WITH" => Some(Self::StartsWith),
                "ENDS_WITH" => Some(Self::EndsWith),
                "NOT_EQUALS" => Some(Self::NotEquals),
                "NOT_CONTAINS" => Some(Self::NotContains),
                "NOT_STARTS_WITH" => Some(Self::NotStartsWith),
                "NOT_ENDS_WITH" => Some(Self::NotEndsWith),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccessReasonEnum {}
/// Nested message and enum types in `AccessReasonEnum`.
pub mod access_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccessReason {
        Unspecified = 0,
        Unknown = 1,
        Owned = 2,
        Shared = 3,
        Licensed = 4,
        Subscribed = 5,
        Affiliated = 6,
    }
    impl AccessReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccessReason::Unspecified => "UNSPECIFIED",
                AccessReason::Unknown => "UNKNOWN",
                AccessReason::Owned => "OWNED",
                AccessReason::Shared => "SHARED",
                AccessReason::Licensed => "LICENSED",
                AccessReason::Subscribed => "SUBSCRIBED",
                AccessReason::Affiliated => "AFFILIATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OWNED" => Some(Self::Owned),
                "SHARED" => Some(Self::Shared),
                "LICENSED" => Some(Self::Licensed),
                "SUBSCRIBED" => Some(Self::Subscribed),
                "AFFILIATED" => Some(Self::Affiliated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListAccessStatusEnum {}
/// Nested message and enum types in `UserListAccessStatusEnum`.
pub mod user_list_access_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListAccessStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Disabled = 3,
    }
    impl UserListAccessStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListAccessStatus::Unspecified => "UNSPECIFIED",
                UserListAccessStatus::Unknown => "UNKNOWN",
                UserListAccessStatus::Enabled => "ENABLED",
                UserListAccessStatus::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListClosingReasonEnum {}
/// Nested message and enum types in `UserListClosingReasonEnum`.
pub mod user_list_closing_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListClosingReason {
        Unspecified = 0,
        Unknown = 1,
        Unused = 2,
    }
    impl UserListClosingReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListClosingReason::Unspecified => "UNSPECIFIED",
                UserListClosingReason::Unknown => "UNKNOWN",
                UserListClosingReason::Unused => "UNUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNUSED" => Some(Self::Unused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListMembershipStatusEnum {}
/// Nested message and enum types in `UserListMembershipStatusEnum`.
pub mod user_list_membership_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListMembershipStatus {
        Unspecified = 0,
        Unknown = 1,
        Open = 2,
        Closed = 3,
    }
    impl UserListMembershipStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListMembershipStatus::Unspecified => "UNSPECIFIED",
                UserListMembershipStatus::Unknown => "UNKNOWN",
                UserListMembershipStatus::Open => "OPEN",
                UserListMembershipStatus::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListSizeRangeEnum {}
/// Nested message and enum types in `UserListSizeRangeEnum`.
pub mod user_list_size_range_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListSizeRange {
        Unspecified = 0,
        Unknown = 1,
        LessThanFiveHundred = 2,
        LessThanOneThousand = 3,
        OneThousandToTenThousand = 4,
        TenThousandToFiftyThousand = 5,
        FiftyThousandToOneHundredThousand = 6,
        OneHundredThousandToThreeHundredThousand = 7,
        ThreeHundredThousandToFiveHundredThousand = 8,
        FiveHundredThousandToOneMillion = 9,
        OneMillionToTwoMillion = 10,
        TwoMillionToThreeMillion = 11,
        ThreeMillionToFiveMillion = 12,
        FiveMillionToTenMillion = 13,
        TenMillionToTwentyMillion = 14,
        TwentyMillionToThirtyMillion = 15,
        ThirtyMillionToFiftyMillion = 16,
        OverFiftyMillion = 17,
    }
    impl UserListSizeRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListSizeRange::Unspecified => "UNSPECIFIED",
                UserListSizeRange::Unknown => "UNKNOWN",
                UserListSizeRange::LessThanFiveHundred => "LESS_THAN_FIVE_HUNDRED",
                UserListSizeRange::LessThanOneThousand => "LESS_THAN_ONE_THOUSAND",
                UserListSizeRange::OneThousandToTenThousand => {
                    "ONE_THOUSAND_TO_TEN_THOUSAND"
                }
                UserListSizeRange::TenThousandToFiftyThousand => {
                    "TEN_THOUSAND_TO_FIFTY_THOUSAND"
                }
                UserListSizeRange::FiftyThousandToOneHundredThousand => {
                    "FIFTY_THOUSAND_TO_ONE_HUNDRED_THOUSAND"
                }
                UserListSizeRange::OneHundredThousandToThreeHundredThousand => {
                    "ONE_HUNDRED_THOUSAND_TO_THREE_HUNDRED_THOUSAND"
                }
                UserListSizeRange::ThreeHundredThousandToFiveHundredThousand => {
                    "THREE_HUNDRED_THOUSAND_TO_FIVE_HUNDRED_THOUSAND"
                }
                UserListSizeRange::FiveHundredThousandToOneMillion => {
                    "FIVE_HUNDRED_THOUSAND_TO_ONE_MILLION"
                }
                UserListSizeRange::OneMillionToTwoMillion => "ONE_MILLION_TO_TWO_MILLION",
                UserListSizeRange::TwoMillionToThreeMillion => {
                    "TWO_MILLION_TO_THREE_MILLION"
                }
                UserListSizeRange::ThreeMillionToFiveMillion => {
                    "THREE_MILLION_TO_FIVE_MILLION"
                }
                UserListSizeRange::FiveMillionToTenMillion => {
                    "FIVE_MILLION_TO_TEN_MILLION"
                }
                UserListSizeRange::TenMillionToTwentyMillion => {
                    "TEN_MILLION_TO_TWENTY_MILLION"
                }
                UserListSizeRange::TwentyMillionToThirtyMillion => {
                    "TWENTY_MILLION_TO_THIRTY_MILLION"
                }
                UserListSizeRange::ThirtyMillionToFiftyMillion => {
                    "THIRTY_MILLION_TO_FIFTY_MILLION"
                }
                UserListSizeRange::OverFiftyMillion => "OVER_FIFTY_MILLION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LESS_THAN_FIVE_HUNDRED" => Some(Self::LessThanFiveHundred),
                "LESS_THAN_ONE_THOUSAND" => Some(Self::LessThanOneThousand),
                "ONE_THOUSAND_TO_TEN_THOUSAND" => Some(Self::OneThousandToTenThousand),
                "TEN_THOUSAND_TO_FIFTY_THOUSAND" => {
                    Some(Self::TenThousandToFiftyThousand)
                }
                "FIFTY_THOUSAND_TO_ONE_HUNDRED_THOUSAND" => {
                    Some(Self::FiftyThousandToOneHundredThousand)
                }
                "ONE_HUNDRED_THOUSAND_TO_THREE_HUNDRED_THOUSAND" => {
                    Some(Self::OneHundredThousandToThreeHundredThousand)
                }
                "THREE_HUNDRED_THOUSAND_TO_FIVE_HUNDRED_THOUSAND" => {
                    Some(Self::ThreeHundredThousandToFiveHundredThousand)
                }
                "FIVE_HUNDRED_THOUSAND_TO_ONE_MILLION" => {
                    Some(Self::FiveHundredThousandToOneMillion)
                }
                "ONE_MILLION_TO_TWO_MILLION" => Some(Self::OneMillionToTwoMillion),
                "TWO_MILLION_TO_THREE_MILLION" => Some(Self::TwoMillionToThreeMillion),
                "THREE_MILLION_TO_FIVE_MILLION" => Some(Self::ThreeMillionToFiveMillion),
                "FIVE_MILLION_TO_TEN_MILLION" => Some(Self::FiveMillionToTenMillion),
                "TEN_MILLION_TO_TWENTY_MILLION" => Some(Self::TenMillionToTwentyMillion),
                "TWENTY_MILLION_TO_THIRTY_MILLION" => {
                    Some(Self::TwentyMillionToThirtyMillion)
                }
                "THIRTY_MILLION_TO_FIFTY_MILLION" => {
                    Some(Self::ThirtyMillionToFiftyMillion)
                }
                "OVER_FIFTY_MILLION" => Some(Self::OverFiftyMillion),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListTypeEnum {}
/// Nested message and enum types in `UserListTypeEnum`.
pub mod user_list_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListType {
        Unspecified = 0,
        Unknown = 1,
        Remarketing = 2,
        Logical = 3,
        ExternalRemarketing = 4,
        RuleBased = 5,
        Similar = 6,
        CrmBased = 7,
        Lookalike = 9,
    }
    impl UserListType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListType::Unspecified => "UNSPECIFIED",
                UserListType::Unknown => "UNKNOWN",
                UserListType::Remarketing => "REMARKETING",
                UserListType::Logical => "LOGICAL",
                UserListType::ExternalRemarketing => "EXTERNAL_REMARKETING",
                UserListType::RuleBased => "RULE_BASED",
                UserListType::Similar => "SIMILAR",
                UserListType::CrmBased => "CRM_BASED",
                UserListType::Lookalike => "LOOKALIKE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REMARKETING" => Some(Self::Remarketing),
                "LOGICAL" => Some(Self::Logical),
                "EXTERNAL_REMARKETING" => Some(Self::ExternalRemarketing),
                "RULE_BASED" => Some(Self::RuleBased),
                "SIMILAR" => Some(Self::Similar),
                "CRM_BASED" => Some(Self::CrmBased),
                "LOOKALIKE" => Some(Self::Lookalike),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PlacementTypeEnum {}
/// Nested message and enum types in `PlacementTypeEnum`.
pub mod placement_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PlacementType {
        Unspecified = 0,
        Unknown = 1,
        Website = 2,
        MobileAppCategory = 3,
        MobileApplication = 4,
        YoutubeVideo = 5,
        YoutubeChannel = 6,
        GoogleProducts = 7,
    }
    impl PlacementType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PlacementType::Unspecified => "UNSPECIFIED",
                PlacementType::Unknown => "UNKNOWN",
                PlacementType::Website => "WEBSITE",
                PlacementType::MobileAppCategory => "MOBILE_APP_CATEGORY",
                PlacementType::MobileApplication => "MOBILE_APPLICATION",
                PlacementType::YoutubeVideo => "YOUTUBE_VIDEO",
                PlacementType::YoutubeChannel => "YOUTUBE_CHANNEL",
                PlacementType::GoogleProducts => "GOOGLE_PRODUCTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBSITE" => Some(Self::Website),
                "MOBILE_APP_CATEGORY" => Some(Self::MobileAppCategory),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "GOOGLE_PRODUCTS" => Some(Self::GoogleProducts),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MonthOfYearEnum {}
/// Nested message and enum types in `MonthOfYearEnum`.
pub mod month_of_year_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MonthOfYear {
        Unspecified = 0,
        Unknown = 1,
        January = 2,
        February = 3,
        March = 4,
        April = 5,
        May = 6,
        June = 7,
        July = 8,
        August = 9,
        September = 10,
        October = 11,
        November = 12,
        December = 13,
    }
    impl MonthOfYear {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MonthOfYear::Unspecified => "UNSPECIFIED",
                MonthOfYear::Unknown => "UNKNOWN",
                MonthOfYear::January => "JANUARY",
                MonthOfYear::February => "FEBRUARY",
                MonthOfYear::March => "MARCH",
                MonthOfYear::April => "APRIL",
                MonthOfYear::May => "MAY",
                MonthOfYear::June => "JUNE",
                MonthOfYear::July => "JULY",
                MonthOfYear::August => "AUGUST",
                MonthOfYear::September => "SEPTEMBER",
                MonthOfYear::October => "OCTOBER",
                MonthOfYear::November => "NOVEMBER",
                MonthOfYear::December => "DECEMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "JANUARY" => Some(Self::January),
                "FEBRUARY" => Some(Self::February),
                "MARCH" => Some(Self::March),
                "APRIL" => Some(Self::April),
                "MAY" => Some(Self::May),
                "JUNE" => Some(Self::June),
                "JULY" => Some(Self::July),
                "AUGUST" => Some(Self::August),
                "SEPTEMBER" => Some(Self::September),
                "OCTOBER" => Some(Self::October),
                "NOVEMBER" => Some(Self::November),
                "DECEMBER" => Some(Self::December),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InvoiceTypeEnum {}
/// Nested message and enum types in `InvoiceTypeEnum`.
pub mod invoice_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InvoiceType {
        Unspecified = 0,
        Unknown = 1,
        CreditMemo = 2,
        Invoice = 3,
    }
    impl InvoiceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InvoiceType::Unspecified => "UNSPECIFIED",
                InvoiceType::Unknown => "UNKNOWN",
                InvoiceType::CreditMemo => "CREDIT_MEMO",
                InvoiceType::Invoice => "INVOICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CREDIT_MEMO" => Some(Self::CreditMemo),
                "INVOICE" => Some(Self::Invoice),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountLinkStatusEnum {}
/// Nested message and enum types in `AccountLinkStatusEnum`.
pub mod account_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Requested = 4,
        PendingApproval = 5,
        Rejected = 6,
        Revoked = 7,
    }
    impl AccountLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountLinkStatus::Unspecified => "UNSPECIFIED",
                AccountLinkStatus::Unknown => "UNKNOWN",
                AccountLinkStatus::Enabled => "ENABLED",
                AccountLinkStatus::Removed => "REMOVED",
                AccountLinkStatus::Requested => "REQUESTED",
                AccountLinkStatus::PendingApproval => "PENDING_APPROVAL",
                AccountLinkStatus::Rejected => "REJECTED",
                AccountLinkStatus::Revoked => "REVOKED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "REQUESTED" => Some(Self::Requested),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "REJECTED" => Some(Self::Rejected),
                "REVOKED" => Some(Self::Revoked),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LinkedAccountTypeEnum {}
/// Nested message and enum types in `LinkedAccountTypeEnum`.
pub mod linked_account_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LinkedAccountType {
        Unspecified = 0,
        Unknown = 1,
        ThirdPartyAppAnalytics = 2,
    }
    impl LinkedAccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LinkedAccountType::Unspecified => "UNSPECIFIED",
                LinkedAccountType::Unknown => "UNKNOWN",
                LinkedAccountType::ThirdPartyAppAnalytics => "THIRD_PARTY_APP_ANALYTICS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "THIRD_PARTY_APP_ANALYTICS" => Some(Self::ThirdPartyAppAnalytics),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyStatusEnum {}
/// Nested message and enum types in `BiddingStrategyStatusEnum`.
pub mod bidding_strategy_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 4,
    }
    impl BiddingStrategyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategyStatus::Unspecified => "UNSPECIFIED",
                BiddingStrategyStatus::Unknown => "UNKNOWN",
                BiddingStrategyStatus::Enabled => "ENABLED",
                BiddingStrategyStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceScopeEnum {}
/// Nested message and enum types in `AudienceScopeEnum`.
pub mod audience_scope_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceScope {
        Unspecified = 0,
        Unknown = 1,
        Customer = 2,
        AssetGroup = 3,
    }
    impl AudienceScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceScope::Unspecified => "UNSPECIFIED",
                AudienceScope::Unknown => "UNKNOWN",
                AudienceScope::Customer => "CUSTOMER",
                AudienceScope::AssetGroup => "ASSET_GROUP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CUSTOMER" => Some(Self::Customer),
                "ASSET_GROUP" => Some(Self::AssetGroup),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceStatusEnum {}
/// Nested message and enum types in `AudienceStatusEnum`.
pub mod audience_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceStatus::Unspecified => "UNSPECIFIED",
                AudienceStatus::Unknown => "UNKNOWN",
                AudienceStatus::Enabled => "ENABLED",
                AudienceStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackingCodePageFormatEnum {}
/// Nested message and enum types in `TrackingCodePageFormatEnum`.
pub mod tracking_code_page_format_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrackingCodePageFormat {
        Unspecified = 0,
        Unknown = 1,
        Html = 2,
        Amp = 3,
    }
    impl TrackingCodePageFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrackingCodePageFormat::Unspecified => "UNSPECIFIED",
                TrackingCodePageFormat::Unknown => "UNKNOWN",
                TrackingCodePageFormat::Html => "HTML",
                TrackingCodePageFormat::Amp => "AMP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HTML" => Some(Self::Html),
                "AMP" => Some(Self::Amp),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TrackingCodeTypeEnum {}
/// Nested message and enum types in `TrackingCodeTypeEnum`.
pub mod tracking_code_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TrackingCodeType {
        Unspecified = 0,
        Unknown = 1,
        Webpage = 2,
        WebpageOnclick = 3,
        ClickToCall = 4,
        WebsiteCall = 5,
    }
    impl TrackingCodeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TrackingCodeType::Unspecified => "UNSPECIFIED",
                TrackingCodeType::Unknown => "UNKNOWN",
                TrackingCodeType::Webpage => "WEBPAGE",
                TrackingCodeType::WebpageOnclick => "WEBPAGE_ONCLICK",
                TrackingCodeType::ClickToCall => "CLICK_TO_CALL",
                TrackingCodeType::WebsiteCall => "WEBSITE_CALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBPAGE" => Some(Self::Webpage),
                "WEBPAGE_ONCLICK" => Some(Self::WebpageOnclick),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "WEBSITE_CALL" => Some(Self::WebsiteCall),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceMemberTypeEnum {}
/// Nested message and enum types in `CustomAudienceMemberTypeEnum`.
pub mod custom_audience_member_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceMemberType {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Url = 3,
        PlaceCategory = 4,
        App = 5,
    }
    impl CustomAudienceMemberType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomAudienceMemberType::Unspecified => "UNSPECIFIED",
                CustomAudienceMemberType::Unknown => "UNKNOWN",
                CustomAudienceMemberType::Keyword => "KEYWORD",
                CustomAudienceMemberType::Url => "URL",
                CustomAudienceMemberType::PlaceCategory => "PLACE_CATEGORY",
                CustomAudienceMemberType::App => "APP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "URL" => Some(Self::Url),
                "PLACE_CATEGORY" => Some(Self::PlaceCategory),
                "APP" => Some(Self::App),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceStatusEnum {}
/// Nested message and enum types in `CustomAudienceStatusEnum`.
pub mod custom_audience_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CustomAudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomAudienceStatus::Unspecified => "UNSPECIFIED",
                CustomAudienceStatus::Unknown => "UNKNOWN",
                CustomAudienceStatus::Enabled => "ENABLED",
                CustomAudienceStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomAudienceTypeEnum {}
/// Nested message and enum types in `CustomAudienceTypeEnum`.
pub mod custom_audience_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomAudienceType {
        Unspecified = 0,
        Unknown = 1,
        Auto = 2,
        Interest = 3,
        PurchaseIntent = 4,
        Search = 5,
    }
    impl CustomAudienceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomAudienceType::Unspecified => "UNSPECIFIED",
                CustomAudienceType::Unknown => "UNKNOWN",
                CustomAudienceType::Auto => "AUTO",
                CustomAudienceType::Interest => "INTEREST",
                CustomAudienceType::PurchaseIntent => "PURCHASE_INTENT",
                CustomAudienceType::Search => "SEARCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AUTO" => Some(Self::Auto),
                "INTEREST" => Some(Self::Interest),
                "PURCHASE_INTENT" => Some(Self::PurchaseIntent),
                "SEARCH" => Some(Self::Search),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRuleStatusEnum {}
/// Nested message and enum types in `ConversionValueRuleStatusEnum`.
pub mod conversion_value_rule_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRuleStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Paused = 4,
    }
    impl ConversionValueRuleStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionValueRuleStatus::Unspecified => "UNSPECIFIED",
                ConversionValueRuleStatus::Unknown => "UNKNOWN",
                ConversionValueRuleStatus::Enabled => "ENABLED",
                ConversionValueRuleStatus::Removed => "REMOVED",
                ConversionValueRuleStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleDeviceTypeEnum {}
/// Nested message and enum types in `ValueRuleDeviceTypeEnum`.
pub mod value_rule_device_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleDeviceType {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
        Desktop = 3,
        Tablet = 4,
    }
    impl ValueRuleDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueRuleDeviceType::Unspecified => "UNSPECIFIED",
                ValueRuleDeviceType::Unknown => "UNKNOWN",
                ValueRuleDeviceType::Mobile => "MOBILE",
                ValueRuleDeviceType::Desktop => "DESKTOP",
                ValueRuleDeviceType::Tablet => "TABLET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "DESKTOP" => Some(Self::Desktop),
                "TABLET" => Some(Self::Tablet),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleGeoLocationMatchTypeEnum {}
/// Nested message and enum types in `ValueRuleGeoLocationMatchTypeEnum`.
pub mod value_rule_geo_location_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleGeoLocationMatchType {
        Unspecified = 0,
        Unknown = 1,
        Any = 2,
        LocationOfPresence = 3,
    }
    impl ValueRuleGeoLocationMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueRuleGeoLocationMatchType::Unspecified => "UNSPECIFIED",
                ValueRuleGeoLocationMatchType::Unknown => "UNKNOWN",
                ValueRuleGeoLocationMatchType::Any => "ANY",
                ValueRuleGeoLocationMatchType::LocationOfPresence => {
                    "LOCATION_OF_PRESENCE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ANY" => Some(Self::Any),
                "LOCATION_OF_PRESENCE" => Some(Self::LocationOfPresence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ValueRuleOperationEnum {}
/// Nested message and enum types in `ValueRuleOperationEnum`.
pub mod value_rule_operation_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ValueRuleOperation {
        Unspecified = 0,
        Unknown = 1,
        Add = 2,
        Multiply = 3,
        Set = 4,
    }
    impl ValueRuleOperation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ValueRuleOperation::Unspecified => "UNSPECIFIED",
                ValueRuleOperation::Unknown => "UNKNOWN",
                ValueRuleOperation::Add => "ADD",
                ValueRuleOperation::Multiply => "MULTIPLY",
                ValueRuleOperation::Set => "SET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADD" => Some(Self::Add),
                "MULTIPLY" => Some(Self::Multiply),
                "SET" => Some(Self::Set),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignSharedSetStatusEnum {}
/// Nested message and enum types in `CampaignSharedSetStatusEnum`.
pub mod campaign_shared_set_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignSharedSetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CampaignSharedSetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignSharedSetStatus::Unspecified => "UNSPECIFIED",
                CampaignSharedSetStatus::Unknown => "UNKNOWN",
                CampaignSharedSetStatus::Enabled => "ENABLED",
                CampaignSharedSetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermTargetingStatusEnum {}
/// Nested message and enum types in `SearchTermTargetingStatusEnum`.
pub mod search_term_targeting_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermTargetingStatus {
        Unspecified = 0,
        Unknown = 1,
        Added = 2,
        Excluded = 3,
        AddedExcluded = 4,
        None = 5,
    }
    impl SearchTermTargetingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchTermTargetingStatus::Unspecified => "UNSPECIFIED",
                SearchTermTargetingStatus::Unknown => "UNKNOWN",
                SearchTermTargetingStatus::Added => "ADDED",
                SearchTermTargetingStatus::Excluded => "EXCLUDED",
                SearchTermTargetingStatus::AddedExcluded => "ADDED_EXCLUDED",
                SearchTermTargetingStatus::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDED" => Some(Self::Added),
                "EXCLUDED" => Some(Self::Excluded),
                "ADDED_EXCLUDED" => Some(Self::AddedExcluded),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionTrackingStatusEnum {}
/// Nested message and enum types in `ConversionTrackingStatusEnum`.
pub mod conversion_tracking_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionTrackingStatus {
        Unspecified = 0,
        Unknown = 1,
        NotConversionTracked = 2,
        ConversionTrackingManagedBySelf = 3,
        ConversionTrackingManagedByThisManager = 4,
        ConversionTrackingManagedByAnotherManager = 5,
    }
    impl ConversionTrackingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionTrackingStatus::Unspecified => "UNSPECIFIED",
                ConversionTrackingStatus::Unknown => "UNKNOWN",
                ConversionTrackingStatus::NotConversionTracked => {
                    "NOT_CONVERSION_TRACKED"
                }
                ConversionTrackingStatus::ConversionTrackingManagedBySelf => {
                    "CONVERSION_TRACKING_MANAGED_BY_SELF"
                }
                ConversionTrackingStatus::ConversionTrackingManagedByThisManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER"
                }
                ConversionTrackingStatus::ConversionTrackingManagedByAnotherManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_CONVERSION_TRACKED" => Some(Self::NotConversionTracked),
                "CONVERSION_TRACKING_MANAGED_BY_SELF" => {
                    Some(Self::ConversionTrackingManagedBySelf)
                }
                "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByThisManager)
                }
                "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByAnotherManager)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerPayPerConversionEligibilityFailureReasonEnum {}
/// Nested message and enum types in `CustomerPayPerConversionEligibilityFailureReasonEnum`.
pub mod customer_pay_per_conversion_eligibility_failure_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerPayPerConversionEligibilityFailureReason {
        Unspecified = 0,
        Unknown = 1,
        NotEnoughConversions = 2,
        ConversionLagTooHigh = 3,
        HasCampaignWithSharedBudget = 4,
        HasUploadClicksConversion = 5,
        AverageDailySpendTooHigh = 6,
        AnalysisNotComplete = 7,
        Other = 8,
    }
    impl CustomerPayPerConversionEligibilityFailureReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerPayPerConversionEligibilityFailureReason::Unspecified => {
                    "UNSPECIFIED"
                }
                CustomerPayPerConversionEligibilityFailureReason::Unknown => "UNKNOWN",
                CustomerPayPerConversionEligibilityFailureReason::NotEnoughConversions => {
                    "NOT_ENOUGH_CONVERSIONS"
                }
                CustomerPayPerConversionEligibilityFailureReason::ConversionLagTooHigh => {
                    "CONVERSION_LAG_TOO_HIGH"
                }
                CustomerPayPerConversionEligibilityFailureReason::HasCampaignWithSharedBudget => {
                    "HAS_CAMPAIGN_WITH_SHARED_BUDGET"
                }
                CustomerPayPerConversionEligibilityFailureReason::HasUploadClicksConversion => {
                    "HAS_UPLOAD_CLICKS_CONVERSION"
                }
                CustomerPayPerConversionEligibilityFailureReason::AverageDailySpendTooHigh => {
                    "AVERAGE_DAILY_SPEND_TOO_HIGH"
                }
                CustomerPayPerConversionEligibilityFailureReason::AnalysisNotComplete => {
                    "ANALYSIS_NOT_COMPLETE"
                }
                CustomerPayPerConversionEligibilityFailureReason::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_ENOUGH_CONVERSIONS" => Some(Self::NotEnoughConversions),
                "CONVERSION_LAG_TOO_HIGH" => Some(Self::ConversionLagTooHigh),
                "HAS_CAMPAIGN_WITH_SHARED_BUDGET" => {
                    Some(Self::HasCampaignWithSharedBudget)
                }
                "HAS_UPLOAD_CLICKS_CONVERSION" => Some(Self::HasUploadClicksConversion),
                "AVERAGE_DAILY_SPEND_TOO_HIGH" => Some(Self::AverageDailySpendTooHigh),
                "ANALYSIS_NOT_COMPLETE" => Some(Self::AnalysisNotComplete),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalServicesVerificationStatusEnum {}
/// Nested message and enum types in `LocalServicesVerificationStatusEnum`.
pub mod local_services_verification_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalServicesVerificationStatus {
        Unspecified = 0,
        Unknown = 1,
        NeedsReview = 2,
        Failed = 3,
        Passed = 4,
        NotApplicable = 5,
        NoSubmission = 6,
        PartialSubmission = 7,
        PendingEscalation = 8,
    }
    impl LocalServicesVerificationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalServicesVerificationStatus::Unspecified => "UNSPECIFIED",
                LocalServicesVerificationStatus::Unknown => "UNKNOWN",
                LocalServicesVerificationStatus::NeedsReview => "NEEDS_REVIEW",
                LocalServicesVerificationStatus::Failed => "FAILED",
                LocalServicesVerificationStatus::Passed => "PASSED",
                LocalServicesVerificationStatus::NotApplicable => "NOT_APPLICABLE",
                LocalServicesVerificationStatus::NoSubmission => "NO_SUBMISSION",
                LocalServicesVerificationStatus::PartialSubmission => {
                    "PARTIAL_SUBMISSION"
                }
                LocalServicesVerificationStatus::PendingEscalation => {
                    "PENDING_ESCALATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEEDS_REVIEW" => Some(Self::NeedsReview),
                "FAILED" => Some(Self::Failed),
                "PASSED" => Some(Self::Passed),
                "NOT_APPLICABLE" => Some(Self::NotApplicable),
                "NO_SUBMISSION" => Some(Self::NoSubmission),
                "PARTIAL_SUBMISSION" => Some(Self::PartialSubmission),
                "PENDING_ESCALATION" => Some(Self::PendingEscalation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CombinedAudienceStatusEnum {}
/// Nested message and enum types in `CombinedAudienceStatusEnum`.
pub mod combined_audience_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CombinedAudienceStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CombinedAudienceStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CombinedAudienceStatus::Unspecified => "UNSPECIFIED",
                CombinedAudienceStatus::Unknown => "UNKNOWN",
                CombinedAudienceStatus::Enabled => "ENABLED",
                CombinedAudienceStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MediaTypeEnum {}
/// Nested message and enum types in `MediaTypeEnum`.
pub mod media_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MediaType {
        Unspecified = 0,
        Unknown = 1,
        Image = 2,
        Icon = 3,
        MediaBundle = 4,
        Audio = 5,
        Video = 6,
        DynamicImage = 7,
    }
    impl MediaType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MediaType::Unspecified => "UNSPECIFIED",
                MediaType::Unknown => "UNKNOWN",
                MediaType::Image => "IMAGE",
                MediaType::Icon => "ICON",
                MediaType::MediaBundle => "MEDIA_BUNDLE",
                MediaType::Audio => "AUDIO",
                MediaType::Video => "VIDEO",
                MediaType::DynamicImage => "DYNAMIC_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGE" => Some(Self::Image),
                "ICON" => Some(Self::Icon),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "AUDIO" => Some(Self::Audio),
                "VIDEO" => Some(Self::Video),
                "DYNAMIC_IMAGE" => Some(Self::DynamicImage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterCustomAttributeIndexEnum {}
/// Nested message and enum types in `ListingGroupFilterCustomAttributeIndexEnum`.
pub mod listing_group_filter_custom_attribute_index_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterCustomAttributeIndex {
        Unspecified = 0,
        Unknown = 1,
        Index0 = 2,
        Index1 = 3,
        Index2 = 4,
        Index3 = 5,
        Index4 = 6,
    }
    impl ListingGroupFilterCustomAttributeIndex {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterCustomAttributeIndex::Unspecified => "UNSPECIFIED",
                ListingGroupFilterCustomAttributeIndex::Unknown => "UNKNOWN",
                ListingGroupFilterCustomAttributeIndex::Index0 => "INDEX0",
                ListingGroupFilterCustomAttributeIndex::Index1 => "INDEX1",
                ListingGroupFilterCustomAttributeIndex::Index2 => "INDEX2",
                ListingGroupFilterCustomAttributeIndex::Index3 => "INDEX3",
                ListingGroupFilterCustomAttributeIndex::Index4 => "INDEX4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INDEX0" => Some(Self::Index0),
                "INDEX1" => Some(Self::Index1),
                "INDEX2" => Some(Self::Index2),
                "INDEX3" => Some(Self::Index3),
                "INDEX4" => Some(Self::Index4),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterListingSourceEnum {}
/// Nested message and enum types in `ListingGroupFilterListingSourceEnum`.
pub mod listing_group_filter_listing_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterListingSource {
        Unspecified = 0,
        Unknown = 1,
        Shopping = 2,
        Webpage = 3,
    }
    impl ListingGroupFilterListingSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterListingSource::Unspecified => "UNSPECIFIED",
                ListingGroupFilterListingSource::Unknown => "UNKNOWN",
                ListingGroupFilterListingSource::Shopping => "SHOPPING",
                ListingGroupFilterListingSource::Webpage => "WEBPAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SHOPPING" => Some(Self::Shopping),
                "WEBPAGE" => Some(Self::Webpage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductCategoryLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductCategoryLevelEnum`.
pub mod listing_group_filter_product_category_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductCategoryLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ListingGroupFilterProductCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductCategoryLevel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductCategoryLevel::Unknown => "UNKNOWN",
                ListingGroupFilterProductCategoryLevel::Level1 => "LEVEL1",
                ListingGroupFilterProductCategoryLevel::Level2 => "LEVEL2",
                ListingGroupFilterProductCategoryLevel::Level3 => "LEVEL3",
                ListingGroupFilterProductCategoryLevel::Level4 => "LEVEL4",
                ListingGroupFilterProductCategoryLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductChannelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductChannelEnum`.
pub mod listing_group_filter_product_channel_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductChannel {
        Unspecified = 0,
        Unknown = 1,
        Online = 2,
        Local = 3,
    }
    impl ListingGroupFilterProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductChannel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductChannel::Unknown => "UNKNOWN",
                ListingGroupFilterProductChannel::Online => "ONLINE",
                ListingGroupFilterProductChannel::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductConditionEnum {}
/// Nested message and enum types in `ListingGroupFilterProductConditionEnum`.
pub mod listing_group_filter_product_condition_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductCondition {
        Unspecified = 0,
        Unknown = 1,
        New = 2,
        Refurbished = 3,
        Used = 4,
    }
    impl ListingGroupFilterProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductCondition::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductCondition::Unknown => "UNKNOWN",
                ListingGroupFilterProductCondition::New => "NEW",
                ListingGroupFilterProductCondition::Refurbished => "REFURBISHED",
                ListingGroupFilterProductCondition::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductTypeLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductTypeLevelEnum`.
pub mod listing_group_filter_product_type_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductTypeLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ListingGroupFilterProductTypeLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductTypeLevel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductTypeLevel::Unknown => "UNKNOWN",
                ListingGroupFilterProductTypeLevel::Level1 => "LEVEL1",
                ListingGroupFilterProductTypeLevel::Level2 => "LEVEL2",
                ListingGroupFilterProductTypeLevel::Level3 => "LEVEL3",
                ListingGroupFilterProductTypeLevel::Level4 => "LEVEL4",
                ListingGroupFilterProductTypeLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterTypeEnum {}
/// Nested message and enum types in `ListingGroupFilterTypeEnum`.
pub mod listing_group_filter_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterType {
        Unspecified = 0,
        Unknown = 1,
        Subdivision = 2,
        UnitIncluded = 3,
        UnitExcluded = 4,
    }
    impl ListingGroupFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterType::Unspecified => "UNSPECIFIED",
                ListingGroupFilterType::Unknown => "UNKNOWN",
                ListingGroupFilterType::Subdivision => "SUBDIVISION",
                ListingGroupFilterType::UnitIncluded => "UNIT_INCLUDED",
                ListingGroupFilterType::UnitExcluded => "UNIT_EXCLUDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT_INCLUDED" => Some(Self::UnitIncluded),
                "UNIT_EXCLUDED" => Some(Self::UnitExcluded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelReconciliationStatusEnum {}
/// Nested message and enum types in `HotelReconciliationStatusEnum`.
pub mod hotel_reconciliation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelReconciliationStatus {
        Unspecified = 0,
        Unknown = 1,
        ReservationEnabled = 2,
        ReconciliationNeeded = 3,
        Reconciled = 4,
        Canceled = 5,
    }
    impl HotelReconciliationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelReconciliationStatus::Unspecified => "UNSPECIFIED",
                HotelReconciliationStatus::Unknown => "UNKNOWN",
                HotelReconciliationStatus::ReservationEnabled => "RESERVATION_ENABLED",
                HotelReconciliationStatus::ReconciliationNeeded => {
                    "RECONCILIATION_NEEDED"
                }
                HotelReconciliationStatus::Reconciled => "RECONCILED",
                HotelReconciliationStatus::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESERVATION_ENABLED" => Some(Self::ReservationEnabled),
                "RECONCILIATION_NEEDED" => Some(Self::ReconciliationNeeded),
                "RECONCILED" => Some(Self::Reconciled),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupSignalApprovalStatusEnum {}
/// Nested message and enum types in `AssetGroupSignalApprovalStatusEnum`.
pub mod asset_group_signal_approval_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupSignalApprovalStatus {
        Unspecified = 0,
        Unknown = 1,
        Approved = 2,
        Limited = 3,
        Disapproved = 4,
        UnderReview = 5,
    }
    impl AssetGroupSignalApprovalStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupSignalApprovalStatus::Unspecified => "UNSPECIFIED",
                AssetGroupSignalApprovalStatus::Unknown => "UNKNOWN",
                AssetGroupSignalApprovalStatus::Approved => "APPROVED",
                AssetGroupSignalApprovalStatus::Limited => "LIMITED",
                AssetGroupSignalApprovalStatus::Disapproved => "DISAPPROVED",
                AssetGroupSignalApprovalStatus::UnderReview => "UNDER_REVIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPROVED" => Some(Self::Approved),
                "LIMITED" => Some(Self::Limited),
                "DISAPPROVED" => Some(Self::Disapproved),
                "UNDER_REVIEW" => Some(Self::UnderReview),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleAdsFieldCategoryEnum {}
/// Nested message and enum types in `GoogleAdsFieldCategoryEnum`.
pub mod google_ads_field_category_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleAdsFieldCategory {
        Unspecified = 0,
        Unknown = 1,
        Resource = 2,
        Attribute = 3,
        Segment = 5,
        Metric = 6,
    }
    impl GoogleAdsFieldCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoogleAdsFieldCategory::Unspecified => "UNSPECIFIED",
                GoogleAdsFieldCategory::Unknown => "UNKNOWN",
                GoogleAdsFieldCategory::Resource => "RESOURCE",
                GoogleAdsFieldCategory::Attribute => "ATTRIBUTE",
                GoogleAdsFieldCategory::Segment => "SEGMENT",
                GoogleAdsFieldCategory::Metric => "METRIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE" => Some(Self::Resource),
                "ATTRIBUTE" => Some(Self::Attribute),
                "SEGMENT" => Some(Self::Segment),
                "METRIC" => Some(Self::Metric),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GoogleAdsFieldDataTypeEnum {}
/// Nested message and enum types in `GoogleAdsFieldDataTypeEnum`.
pub mod google_ads_field_data_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleAdsFieldDataType {
        Unspecified = 0,
        Unknown = 1,
        Boolean = 2,
        Date = 3,
        Double = 4,
        Enum = 5,
        Float = 6,
        Int32 = 7,
        Int64 = 8,
        Message = 9,
        ResourceName = 10,
        String = 11,
        Uint64 = 12,
    }
    impl GoogleAdsFieldDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoogleAdsFieldDataType::Unspecified => "UNSPECIFIED",
                GoogleAdsFieldDataType::Unknown => "UNKNOWN",
                GoogleAdsFieldDataType::Boolean => "BOOLEAN",
                GoogleAdsFieldDataType::Date => "DATE",
                GoogleAdsFieldDataType::Double => "DOUBLE",
                GoogleAdsFieldDataType::Enum => "ENUM",
                GoogleAdsFieldDataType::Float => "FLOAT",
                GoogleAdsFieldDataType::Int32 => "INT32",
                GoogleAdsFieldDataType::Int64 => "INT64",
                GoogleAdsFieldDataType::Message => "MESSAGE",
                GoogleAdsFieldDataType::ResourceName => "RESOURCE_NAME",
                GoogleAdsFieldDataType::String => "STRING",
                GoogleAdsFieldDataType::Uint64 => "UINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BOOLEAN" => Some(Self::Boolean),
                "DATE" => Some(Self::Date),
                "DOUBLE" => Some(Self::Double),
                "ENUM" => Some(Self::Enum),
                "FLOAT" => Some(Self::Float),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "MESSAGE" => Some(Self::Message),
                "RESOURCE_NAME" => Some(Self::ResourceName),
                "STRING" => Some(Self::String),
                "UINT64" => Some(Self::Uint64),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BillingSetupStatusEnum {}
/// Nested message and enum types in `BillingSetupStatusEnum`.
pub mod billing_setup_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BillingSetupStatus {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        ApprovedHeld = 3,
        Approved = 4,
        Cancelled = 5,
    }
    impl BillingSetupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BillingSetupStatus::Unspecified => "UNSPECIFIED",
                BillingSetupStatus::Unknown => "UNKNOWN",
                BillingSetupStatus::Pending => "PENDING",
                BillingSetupStatus::ApprovedHeld => "APPROVED_HELD",
                BillingSetupStatus::Approved => "APPROVED",
                BillingSetupStatus::Cancelled => "CANCELLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "APPROVED_HELD" => Some(Self::ApprovedHeld),
                "APPROVED" => Some(Self::Approved),
                "CANCELLED" => Some(Self::Cancelled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableStatusEnum {}
/// Nested message and enum types in `ConversionCustomVariableStatusEnum`.
pub mod conversion_custom_variable_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableStatus {
        Unspecified = 0,
        Unknown = 1,
        ActivationNeeded = 2,
        Enabled = 3,
        Paused = 4,
    }
    impl ConversionCustomVariableStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCustomVariableStatus::Unspecified => "UNSPECIFIED",
                ConversionCustomVariableStatus::Unknown => "UNKNOWN",
                ConversionCustomVariableStatus::ActivationNeeded => "ACTIVATION_NEEDED",
                ConversionCustomVariableStatus::Enabled => "ENABLED",
                ConversionCustomVariableStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVATION_NEEDED" => Some(Self::ActivationNeeded),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductLinkInvitationStatusEnum {}
/// Nested message and enum types in `ProductLinkInvitationStatusEnum`.
pub mod product_link_invitation_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductLinkInvitationStatus {
        Unspecified = 0,
        Unknown = 1,
        Accepted = 2,
        Requested = 3,
        PendingApproval = 4,
        Revoked = 5,
        Rejected = 6,
        Expired = 7,
    }
    impl ProductLinkInvitationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductLinkInvitationStatus::Unspecified => "UNSPECIFIED",
                ProductLinkInvitationStatus::Unknown => "UNKNOWN",
                ProductLinkInvitationStatus::Accepted => "ACCEPTED",
                ProductLinkInvitationStatus::Requested => "REQUESTED",
                ProductLinkInvitationStatus::PendingApproval => "PENDING_APPROVAL",
                ProductLinkInvitationStatus::Revoked => "REVOKED",
                ProductLinkInvitationStatus::Rejected => "REJECTED",
                ProductLinkInvitationStatus::Expired => "EXPIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCEPTED" => Some(Self::Accepted),
                "REQUESTED" => Some(Self::Requested),
                "PENDING_APPROVAL" => Some(Self::PendingApproval),
                "REVOKED" => Some(Self::Revoked),
                "REJECTED" => Some(Self::Rejected),
                "EXPIRED" => Some(Self::Expired),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignGroupStatusEnum {}
/// Nested message and enum types in `CampaignGroupStatusEnum`.
pub mod campaign_group_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignGroupStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl CampaignGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignGroupStatus::Unspecified => "UNSPECIFIED",
                CampaignGroupStatus::Unknown => "UNKNOWN",
                CampaignGroupStatus::Enabled => "ENABLED",
                CampaignGroupStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OperatingSystemVersionOperatorTypeEnum {}
/// Nested message and enum types in `OperatingSystemVersionOperatorTypeEnum`.
pub mod operating_system_version_operator_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OperatingSystemVersionOperatorType {
        Unspecified = 0,
        Unknown = 1,
        EqualsTo = 2,
        GreaterThanEqualsTo = 4,
    }
    impl OperatingSystemVersionOperatorType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OperatingSystemVersionOperatorType::Unspecified => "UNSPECIFIED",
                OperatingSystemVersionOperatorType::Unknown => "UNKNOWN",
                OperatingSystemVersionOperatorType::EqualsTo => "EQUALS_TO",
                OperatingSystemVersionOperatorType::GreaterThanEqualsTo => {
                    "GREATER_THAN_EQUALS_TO"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS_TO" => Some(Self::EqualsTo),
                "GREATER_THAN_EQUALS_TO" => Some(Self::GreaterThanEqualsTo),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdCustomizerPlaceholderFieldEnum {}
/// Nested message and enum types in `AdCustomizerPlaceholderFieldEnum`.
pub mod ad_customizer_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdCustomizerPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Integer = 2,
        Price = 3,
        Date = 4,
        String = 5,
    }
    impl AdCustomizerPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdCustomizerPlaceholderField::Unspecified => "UNSPECIFIED",
                AdCustomizerPlaceholderField::Unknown => "UNKNOWN",
                AdCustomizerPlaceholderField::Integer => "INTEGER",
                AdCustomizerPlaceholderField::Price => "PRICE",
                AdCustomizerPlaceholderField::Date => "DATE",
                AdCustomizerPlaceholderField::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INTEGER" => Some(Self::Integer),
                "PRICE" => Some(Self::Price),
                "DATE" => Some(Self::Date),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AffiliateLocationPlaceholderFieldEnum {}
/// Nested message and enum types in `AffiliateLocationPlaceholderFieldEnum`.
pub mod affiliate_location_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AffiliateLocationPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        BusinessName = 2,
        AddressLine1 = 3,
        AddressLine2 = 4,
        City = 5,
        Province = 6,
        PostalCode = 7,
        CountryCode = 8,
        PhoneNumber = 9,
        LanguageCode = 10,
        ChainId = 11,
        ChainName = 12,
    }
    impl AffiliateLocationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AffiliateLocationPlaceholderField::Unspecified => "UNSPECIFIED",
                AffiliateLocationPlaceholderField::Unknown => "UNKNOWN",
                AffiliateLocationPlaceholderField::BusinessName => "BUSINESS_NAME",
                AffiliateLocationPlaceholderField::AddressLine1 => "ADDRESS_LINE_1",
                AffiliateLocationPlaceholderField::AddressLine2 => "ADDRESS_LINE_2",
                AffiliateLocationPlaceholderField::City => "CITY",
                AffiliateLocationPlaceholderField::Province => "PROVINCE",
                AffiliateLocationPlaceholderField::PostalCode => "POSTAL_CODE",
                AffiliateLocationPlaceholderField::CountryCode => "COUNTRY_CODE",
                AffiliateLocationPlaceholderField::PhoneNumber => "PHONE_NUMBER",
                AffiliateLocationPlaceholderField::LanguageCode => "LANGUAGE_CODE",
                AffiliateLocationPlaceholderField::ChainId => "CHAIN_ID",
                AffiliateLocationPlaceholderField::ChainName => "CHAIN_NAME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "LANGUAGE_CODE" => Some(Self::LanguageCode),
                "CHAIN_ID" => Some(Self::ChainId),
                "CHAIN_NAME" => Some(Self::ChainName),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AppPlaceholderFieldEnum {}
/// Nested message and enum types in `AppPlaceholderFieldEnum`.
pub mod app_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AppPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Store = 2,
        Id = 3,
        LinkText = 4,
        Url = 5,
        FinalUrls = 6,
        FinalMobileUrls = 7,
        TrackingUrl = 8,
        FinalUrlSuffix = 9,
    }
    impl AppPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AppPlaceholderField::Unspecified => "UNSPECIFIED",
                AppPlaceholderField::Unknown => "UNKNOWN",
                AppPlaceholderField::Store => "STORE",
                AppPlaceholderField::Id => "ID",
                AppPlaceholderField::LinkText => "LINK_TEXT",
                AppPlaceholderField::Url => "URL",
                AppPlaceholderField::FinalUrls => "FINAL_URLS",
                AppPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                AppPlaceholderField::TrackingUrl => "TRACKING_URL",
                AppPlaceholderField::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STORE" => Some(Self::Store),
                "ID" => Some(Self::Id),
                "LINK_TEXT" => Some(Self::LinkText),
                "URL" => Some(Self::Url),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallPlaceholderFieldEnum {}
/// Nested message and enum types in `CallPlaceholderFieldEnum`.
pub mod call_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        PhoneNumber = 2,
        CountryCode = 3,
        Tracked = 4,
        ConversionTypeId = 5,
        ConversionReportingState = 6,
    }
    impl CallPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallPlaceholderField::Unspecified => "UNSPECIFIED",
                CallPlaceholderField::Unknown => "UNKNOWN",
                CallPlaceholderField::PhoneNumber => "PHONE_NUMBER",
                CallPlaceholderField::CountryCode => "COUNTRY_CODE",
                CallPlaceholderField::Tracked => "TRACKED",
                CallPlaceholderField::ConversionTypeId => "CONVERSION_TYPE_ID",
                CallPlaceholderField::ConversionReportingState => {
                    "CONVERSION_REPORTING_STATE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "TRACKED" => Some(Self::Tracked),
                "CONVERSION_TYPE_ID" => Some(Self::ConversionTypeId),
                "CONVERSION_REPORTING_STATE" => Some(Self::ConversionReportingState),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CalloutPlaceholderFieldEnum {}
/// Nested message and enum types in `CalloutPlaceholderFieldEnum`.
pub mod callout_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CalloutPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        CalloutText = 2,
    }
    impl CalloutPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CalloutPlaceholderField::Unspecified => "UNSPECIFIED",
                CalloutPlaceholderField::Unknown => "UNKNOWN",
                CalloutPlaceholderField::CalloutText => "CALLOUT_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALLOUT_TEXT" => Some(Self::CalloutText),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomPlaceholderFieldEnum {}
/// Nested message and enum types in `CustomPlaceholderFieldEnum`.
pub mod custom_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Id = 2,
        Id2 = 3,
        ItemTitle = 4,
        ItemSubtitle = 5,
        ItemDescription = 6,
        ItemAddress = 7,
        Price = 8,
        FormattedPrice = 9,
        SalePrice = 10,
        FormattedSalePrice = 11,
        ImageUrl = 12,
        ItemCategory = 13,
        FinalUrls = 14,
        FinalMobileUrls = 15,
        TrackingUrl = 16,
        ContextualKeywords = 17,
        AndroidAppLink = 18,
        SimilarIds = 19,
        IosAppLink = 20,
        IosAppStoreId = 21,
    }
    impl CustomPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomPlaceholderField::Unspecified => "UNSPECIFIED",
                CustomPlaceholderField::Unknown => "UNKNOWN",
                CustomPlaceholderField::Id => "ID",
                CustomPlaceholderField::Id2 => "ID2",
                CustomPlaceholderField::ItemTitle => "ITEM_TITLE",
                CustomPlaceholderField::ItemSubtitle => "ITEM_SUBTITLE",
                CustomPlaceholderField::ItemDescription => "ITEM_DESCRIPTION",
                CustomPlaceholderField::ItemAddress => "ITEM_ADDRESS",
                CustomPlaceholderField::Price => "PRICE",
                CustomPlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                CustomPlaceholderField::SalePrice => "SALE_PRICE",
                CustomPlaceholderField::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                CustomPlaceholderField::ImageUrl => "IMAGE_URL",
                CustomPlaceholderField::ItemCategory => "ITEM_CATEGORY",
                CustomPlaceholderField::FinalUrls => "FINAL_URLS",
                CustomPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                CustomPlaceholderField::TrackingUrl => "TRACKING_URL",
                CustomPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                CustomPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                CustomPlaceholderField::SimilarIds => "SIMILAR_IDS",
                CustomPlaceholderField::IosAppLink => "IOS_APP_LINK",
                CustomPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ID" => Some(Self::Id),
                "ID2" => Some(Self::Id2),
                "ITEM_TITLE" => Some(Self::ItemTitle),
                "ITEM_SUBTITLE" => Some(Self::ItemSubtitle),
                "ITEM_DESCRIPTION" => Some(Self::ItemDescription),
                "ITEM_ADDRESS" => Some(Self::ItemAddress),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "ITEM_CATEGORY" => Some(Self::ItemCategory),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_IDS" => Some(Self::SimilarIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DsaPageFeedCriterionFieldEnum {}
/// Nested message and enum types in `DsaPageFeedCriterionFieldEnum`.
pub mod dsa_page_feed_criterion_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DsaPageFeedCriterionField {
        Unspecified = 0,
        Unknown = 1,
        PageUrl = 2,
        Label = 3,
    }
    impl DsaPageFeedCriterionField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DsaPageFeedCriterionField::Unspecified => "UNSPECIFIED",
                DsaPageFeedCriterionField::Unknown => "UNKNOWN",
                DsaPageFeedCriterionField::PageUrl => "PAGE_URL",
                DsaPageFeedCriterionField::Label => "LABEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAGE_URL" => Some(Self::PageUrl),
                "LABEL" => Some(Self::Label),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct EducationPlaceholderFieldEnum {}
/// Nested message and enum types in `EducationPlaceholderFieldEnum`.
pub mod education_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EducationPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        ProgramId = 2,
        LocationId = 3,
        ProgramName = 4,
        AreaOfStudy = 5,
        ProgramDescription = 6,
        SchoolName = 7,
        Address = 8,
        ThumbnailImageUrl = 9,
        AlternativeThumbnailImageUrl = 10,
        FinalUrls = 11,
        FinalMobileUrls = 12,
        TrackingUrl = 13,
        ContextualKeywords = 14,
        AndroidAppLink = 15,
        SimilarProgramIds = 16,
        IosAppLink = 17,
        IosAppStoreId = 18,
    }
    impl EducationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                EducationPlaceholderField::Unspecified => "UNSPECIFIED",
                EducationPlaceholderField::Unknown => "UNKNOWN",
                EducationPlaceholderField::ProgramId => "PROGRAM_ID",
                EducationPlaceholderField::LocationId => "LOCATION_ID",
                EducationPlaceholderField::ProgramName => "PROGRAM_NAME",
                EducationPlaceholderField::AreaOfStudy => "AREA_OF_STUDY",
                EducationPlaceholderField::ProgramDescription => "PROGRAM_DESCRIPTION",
                EducationPlaceholderField::SchoolName => "SCHOOL_NAME",
                EducationPlaceholderField::Address => "ADDRESS",
                EducationPlaceholderField::ThumbnailImageUrl => "THUMBNAIL_IMAGE_URL",
                EducationPlaceholderField::AlternativeThumbnailImageUrl => {
                    "ALTERNATIVE_THUMBNAIL_IMAGE_URL"
                }
                EducationPlaceholderField::FinalUrls => "FINAL_URLS",
                EducationPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                EducationPlaceholderField::TrackingUrl => "TRACKING_URL",
                EducationPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                EducationPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                EducationPlaceholderField::SimilarProgramIds => "SIMILAR_PROGRAM_IDS",
                EducationPlaceholderField::IosAppLink => "IOS_APP_LINK",
                EducationPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROGRAM_ID" => Some(Self::ProgramId),
                "LOCATION_ID" => Some(Self::LocationId),
                "PROGRAM_NAME" => Some(Self::ProgramName),
                "AREA_OF_STUDY" => Some(Self::AreaOfStudy),
                "PROGRAM_DESCRIPTION" => Some(Self::ProgramDescription),
                "SCHOOL_NAME" => Some(Self::SchoolName),
                "ADDRESS" => Some(Self::Address),
                "THUMBNAIL_IMAGE_URL" => Some(Self::ThumbnailImageUrl),
                "ALTERNATIVE_THUMBNAIL_IMAGE_URL" => {
                    Some(Self::AlternativeThumbnailImageUrl)
                }
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_PROGRAM_IDS" => Some(Self::SimilarProgramIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingCriterionTypeEnum {}
/// Nested message and enum types in `FeedMappingCriterionTypeEnum`.
pub mod feed_mapping_criterion_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingCriterionType {
        Unspecified = 0,
        Unknown = 1,
        LocationExtensionTargeting = 4,
        DsaPageFeed = 3,
    }
    impl FeedMappingCriterionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedMappingCriterionType::Unspecified => "UNSPECIFIED",
                FeedMappingCriterionType::Unknown => "UNKNOWN",
                FeedMappingCriterionType::LocationExtensionTargeting => {
                    "LOCATION_EXTENSION_TARGETING"
                }
                FeedMappingCriterionType::DsaPageFeed => "DSA_PAGE_FEED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOCATION_EXTENSION_TARGETING" => Some(Self::LocationExtensionTargeting),
                "DSA_PAGE_FEED" => Some(Self::DsaPageFeed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FeedMappingStatusEnum {}
/// Nested message and enum types in `FeedMappingStatusEnum`.
pub mod feed_mapping_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FeedMappingStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl FeedMappingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FeedMappingStatus::Unspecified => "UNSPECIFIED",
                FeedMappingStatus::Unknown => "UNKNOWN",
                FeedMappingStatus::Enabled => "ENABLED",
                FeedMappingStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FlightPlaceholderFieldEnum {}
/// Nested message and enum types in `FlightPlaceholderFieldEnum`.
pub mod flight_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FlightPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        DestinationId = 2,
        OriginId = 3,
        FlightDescription = 4,
        OriginName = 5,
        DestinationName = 6,
        FlightPrice = 7,
        FormattedPrice = 8,
        FlightSalePrice = 9,
        FormattedSalePrice = 10,
        ImageUrl = 11,
        FinalUrls = 12,
        FinalMobileUrls = 13,
        TrackingUrl = 14,
        AndroidAppLink = 15,
        SimilarDestinationIds = 16,
        IosAppLink = 17,
        IosAppStoreId = 18,
    }
    impl FlightPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FlightPlaceholderField::Unspecified => "UNSPECIFIED",
                FlightPlaceholderField::Unknown => "UNKNOWN",
                FlightPlaceholderField::DestinationId => "DESTINATION_ID",
                FlightPlaceholderField::OriginId => "ORIGIN_ID",
                FlightPlaceholderField::FlightDescription => "FLIGHT_DESCRIPTION",
                FlightPlaceholderField::OriginName => "ORIGIN_NAME",
                FlightPlaceholderField::DestinationName => "DESTINATION_NAME",
                FlightPlaceholderField::FlightPrice => "FLIGHT_PRICE",
                FlightPlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                FlightPlaceholderField::FlightSalePrice => "FLIGHT_SALE_PRICE",
                FlightPlaceholderField::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                FlightPlaceholderField::ImageUrl => "IMAGE_URL",
                FlightPlaceholderField::FinalUrls => "FINAL_URLS",
                FlightPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                FlightPlaceholderField::TrackingUrl => "TRACKING_URL",
                FlightPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                FlightPlaceholderField::SimilarDestinationIds => {
                    "SIMILAR_DESTINATION_IDS"
                }
                FlightPlaceholderField::IosAppLink => "IOS_APP_LINK",
                FlightPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESTINATION_ID" => Some(Self::DestinationId),
                "ORIGIN_ID" => Some(Self::OriginId),
                "FLIGHT_DESCRIPTION" => Some(Self::FlightDescription),
                "ORIGIN_NAME" => Some(Self::OriginName),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "FLIGHT_PRICE" => Some(Self::FlightPrice),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "FLIGHT_SALE_PRICE" => Some(Self::FlightSalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DESTINATION_IDS" => Some(Self::SimilarDestinationIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelPlaceholderFieldEnum {}
/// Nested message and enum types in `HotelPlaceholderFieldEnum`.
pub mod hotel_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        PropertyId = 2,
        PropertyName = 3,
        DestinationName = 4,
        Description = 5,
        Address = 6,
        Price = 7,
        FormattedPrice = 8,
        SalePrice = 9,
        FormattedSalePrice = 10,
        ImageUrl = 11,
        Category = 12,
        StarRating = 13,
        ContextualKeywords = 14,
        FinalUrls = 15,
        FinalMobileUrls = 16,
        TrackingUrl = 17,
        AndroidAppLink = 18,
        SimilarPropertyIds = 19,
        IosAppLink = 20,
        IosAppStoreId = 21,
    }
    impl HotelPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelPlaceholderField::Unspecified => "UNSPECIFIED",
                HotelPlaceholderField::Unknown => "UNKNOWN",
                HotelPlaceholderField::PropertyId => "PROPERTY_ID",
                HotelPlaceholderField::PropertyName => "PROPERTY_NAME",
                HotelPlaceholderField::DestinationName => "DESTINATION_NAME",
                HotelPlaceholderField::Description => "DESCRIPTION",
                HotelPlaceholderField::Address => "ADDRESS",
                HotelPlaceholderField::Price => "PRICE",
                HotelPlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                HotelPlaceholderField::SalePrice => "SALE_PRICE",
                HotelPlaceholderField::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                HotelPlaceholderField::ImageUrl => "IMAGE_URL",
                HotelPlaceholderField::Category => "CATEGORY",
                HotelPlaceholderField::StarRating => "STAR_RATING",
                HotelPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                HotelPlaceholderField::FinalUrls => "FINAL_URLS",
                HotelPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                HotelPlaceholderField::TrackingUrl => "TRACKING_URL",
                HotelPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                HotelPlaceholderField::SimilarPropertyIds => "SIMILAR_PROPERTY_IDS",
                HotelPlaceholderField::IosAppLink => "IOS_APP_LINK",
                HotelPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROPERTY_ID" => Some(Self::PropertyId),
                "PROPERTY_NAME" => Some(Self::PropertyName),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "DESCRIPTION" => Some(Self::Description),
                "ADDRESS" => Some(Self::Address),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "STAR_RATING" => Some(Self::StarRating),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_PROPERTY_IDS" => Some(Self::SimilarPropertyIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ImagePlaceholderFieldEnum {}
/// Nested message and enum types in `ImagePlaceholderFieldEnum`.
pub mod image_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ImagePlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        AssetId = 2,
    }
    impl ImagePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ImagePlaceholderField::Unspecified => "UNSPECIFIED",
                ImagePlaceholderField::Unknown => "UNKNOWN",
                ImagePlaceholderField::AssetId => "ASSET_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_ID" => Some(Self::AssetId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct JobPlaceholderFieldEnum {}
/// Nested message and enum types in `JobPlaceholderFieldEnum`.
pub mod job_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JobPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        JobId = 2,
        LocationId = 3,
        Title = 4,
        Subtitle = 5,
        Description = 6,
        ImageUrl = 7,
        Category = 8,
        ContextualKeywords = 9,
        Address = 10,
        Salary = 11,
        FinalUrls = 12,
        FinalMobileUrls = 14,
        TrackingUrl = 15,
        AndroidAppLink = 16,
        SimilarJobIds = 17,
        IosAppLink = 18,
        IosAppStoreId = 19,
    }
    impl JobPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                JobPlaceholderField::Unspecified => "UNSPECIFIED",
                JobPlaceholderField::Unknown => "UNKNOWN",
                JobPlaceholderField::JobId => "JOB_ID",
                JobPlaceholderField::LocationId => "LOCATION_ID",
                JobPlaceholderField::Title => "TITLE",
                JobPlaceholderField::Subtitle => "SUBTITLE",
                JobPlaceholderField::Description => "DESCRIPTION",
                JobPlaceholderField::ImageUrl => "IMAGE_URL",
                JobPlaceholderField::Category => "CATEGORY",
                JobPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                JobPlaceholderField::Address => "ADDRESS",
                JobPlaceholderField::Salary => "SALARY",
                JobPlaceholderField::FinalUrls => "FINAL_URLS",
                JobPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                JobPlaceholderField::TrackingUrl => "TRACKING_URL",
                JobPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                JobPlaceholderField::SimilarJobIds => "SIMILAR_JOB_IDS",
                JobPlaceholderField::IosAppLink => "IOS_APP_LINK",
                JobPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "JOB_ID" => Some(Self::JobId),
                "LOCATION_ID" => Some(Self::LocationId),
                "TITLE" => Some(Self::Title),
                "SUBTITLE" => Some(Self::Subtitle),
                "DESCRIPTION" => Some(Self::Description),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "ADDRESS" => Some(Self::Address),
                "SALARY" => Some(Self::Salary),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_JOB_IDS" => Some(Self::SimilarJobIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocalPlaceholderFieldEnum {}
/// Nested message and enum types in `LocalPlaceholderFieldEnum`.
pub mod local_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocalPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        DealId = 2,
        DealName = 3,
        Subtitle = 4,
        Description = 5,
        Price = 6,
        FormattedPrice = 7,
        SalePrice = 8,
        FormattedSalePrice = 9,
        ImageUrl = 10,
        Address = 11,
        Category = 12,
        ContextualKeywords = 13,
        FinalUrls = 14,
        FinalMobileUrls = 15,
        TrackingUrl = 16,
        AndroidAppLink = 17,
        SimilarDealIds = 18,
        IosAppLink = 19,
        IosAppStoreId = 20,
    }
    impl LocalPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocalPlaceholderField::Unspecified => "UNSPECIFIED",
                LocalPlaceholderField::Unknown => "UNKNOWN",
                LocalPlaceholderField::DealId => "DEAL_ID",
                LocalPlaceholderField::DealName => "DEAL_NAME",
                LocalPlaceholderField::Subtitle => "SUBTITLE",
                LocalPlaceholderField::Description => "DESCRIPTION",
                LocalPlaceholderField::Price => "PRICE",
                LocalPlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                LocalPlaceholderField::SalePrice => "SALE_PRICE",
                LocalPlaceholderField::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                LocalPlaceholderField::ImageUrl => "IMAGE_URL",
                LocalPlaceholderField::Address => "ADDRESS",
                LocalPlaceholderField::Category => "CATEGORY",
                LocalPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                LocalPlaceholderField::FinalUrls => "FINAL_URLS",
                LocalPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                LocalPlaceholderField::TrackingUrl => "TRACKING_URL",
                LocalPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                LocalPlaceholderField::SimilarDealIds => "SIMILAR_DEAL_IDS",
                LocalPlaceholderField::IosAppLink => "IOS_APP_LINK",
                LocalPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEAL_ID" => Some(Self::DealId),
                "DEAL_NAME" => Some(Self::DealName),
                "SUBTITLE" => Some(Self::Subtitle),
                "DESCRIPTION" => Some(Self::Description),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "ADDRESS" => Some(Self::Address),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DEAL_IDS" => Some(Self::SimilarDealIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationExtensionTargetingCriterionFieldEnum {}
/// Nested message and enum types in `LocationExtensionTargetingCriterionFieldEnum`.
pub mod location_extension_targeting_criterion_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationExtensionTargetingCriterionField {
        Unspecified = 0,
        Unknown = 1,
        AddressLine1 = 2,
        AddressLine2 = 3,
        City = 4,
        Province = 5,
        PostalCode = 6,
        CountryCode = 7,
    }
    impl LocationExtensionTargetingCriterionField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationExtensionTargetingCriterionField::Unspecified => "UNSPECIFIED",
                LocationExtensionTargetingCriterionField::Unknown => "UNKNOWN",
                LocationExtensionTargetingCriterionField::AddressLine1 => {
                    "ADDRESS_LINE_1"
                }
                LocationExtensionTargetingCriterionField::AddressLine2 => {
                    "ADDRESS_LINE_2"
                }
                LocationExtensionTargetingCriterionField::City => "CITY",
                LocationExtensionTargetingCriterionField::Province => "PROVINCE",
                LocationExtensionTargetingCriterionField::PostalCode => "POSTAL_CODE",
                LocationExtensionTargetingCriterionField::CountryCode => "COUNTRY_CODE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationPlaceholderFieldEnum {}
/// Nested message and enum types in `LocationPlaceholderFieldEnum`.
pub mod location_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        BusinessName = 2,
        AddressLine1 = 3,
        AddressLine2 = 4,
        City = 5,
        Province = 6,
        PostalCode = 7,
        CountryCode = 8,
        PhoneNumber = 9,
    }
    impl LocationPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationPlaceholderField::Unspecified => "UNSPECIFIED",
                LocationPlaceholderField::Unknown => "UNKNOWN",
                LocationPlaceholderField::BusinessName => "BUSINESS_NAME",
                LocationPlaceholderField::AddressLine1 => "ADDRESS_LINE_1",
                LocationPlaceholderField::AddressLine2 => "ADDRESS_LINE_2",
                LocationPlaceholderField::City => "CITY",
                LocationPlaceholderField::Province => "PROVINCE",
                LocationPlaceholderField::PostalCode => "POSTAL_CODE",
                LocationPlaceholderField::CountryCode => "COUNTRY_CODE",
                LocationPlaceholderField::PhoneNumber => "PHONE_NUMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "ADDRESS_LINE_1" => Some(Self::AddressLine1),
                "ADDRESS_LINE_2" => Some(Self::AddressLine2),
                "CITY" => Some(Self::City),
                "PROVINCE" => Some(Self::Province),
                "POSTAL_CODE" => Some(Self::PostalCode),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MessagePlaceholderFieldEnum {}
/// Nested message and enum types in `MessagePlaceholderFieldEnum`.
pub mod message_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessagePlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        BusinessName = 2,
        CountryCode = 3,
        PhoneNumber = 4,
        MessageExtensionText = 5,
        MessageText = 6,
    }
    impl MessagePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MessagePlaceholderField::Unspecified => "UNSPECIFIED",
                MessagePlaceholderField::Unknown => "UNKNOWN",
                MessagePlaceholderField::BusinessName => "BUSINESS_NAME",
                MessagePlaceholderField::CountryCode => "COUNTRY_CODE",
                MessagePlaceholderField::PhoneNumber => "PHONE_NUMBER",
                MessagePlaceholderField::MessageExtensionText => "MESSAGE_EXTENSION_TEXT",
                MessagePlaceholderField::MessageText => "MESSAGE_TEXT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "COUNTRY_CODE" => Some(Self::CountryCode),
                "PHONE_NUMBER" => Some(Self::PhoneNumber),
                "MESSAGE_EXTENSION_TEXT" => Some(Self::MessageExtensionText),
                "MESSAGE_TEXT" => Some(Self::MessageText),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PricePlaceholderFieldEnum {}
/// Nested message and enum types in `PricePlaceholderFieldEnum`.
pub mod price_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PricePlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Type = 2,
        PriceQualifier = 3,
        TrackingTemplate = 4,
        Language = 5,
        FinalUrlSuffix = 6,
        Item1Header = 100,
        Item1Description = 101,
        Item1Price = 102,
        Item1Unit = 103,
        Item1FinalUrls = 104,
        Item1FinalMobileUrls = 105,
        Item2Header = 200,
        Item2Description = 201,
        Item2Price = 202,
        Item2Unit = 203,
        Item2FinalUrls = 204,
        Item2FinalMobileUrls = 205,
        Item3Header = 300,
        Item3Description = 301,
        Item3Price = 302,
        Item3Unit = 303,
        Item3FinalUrls = 304,
        Item3FinalMobileUrls = 305,
        Item4Header = 400,
        Item4Description = 401,
        Item4Price = 402,
        Item4Unit = 403,
        Item4FinalUrls = 404,
        Item4FinalMobileUrls = 405,
        Item5Header = 500,
        Item5Description = 501,
        Item5Price = 502,
        Item5Unit = 503,
        Item5FinalUrls = 504,
        Item5FinalMobileUrls = 505,
        Item6Header = 600,
        Item6Description = 601,
        Item6Price = 602,
        Item6Unit = 603,
        Item6FinalUrls = 604,
        Item6FinalMobileUrls = 605,
        Item7Header = 700,
        Item7Description = 701,
        Item7Price = 702,
        Item7Unit = 703,
        Item7FinalUrls = 704,
        Item7FinalMobileUrls = 705,
        Item8Header = 800,
        Item8Description = 801,
        Item8Price = 802,
        Item8Unit = 803,
        Item8FinalUrls = 804,
        Item8FinalMobileUrls = 805,
    }
    impl PricePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PricePlaceholderField::Unspecified => "UNSPECIFIED",
                PricePlaceholderField::Unknown => "UNKNOWN",
                PricePlaceholderField::Type => "TYPE",
                PricePlaceholderField::PriceQualifier => "PRICE_QUALIFIER",
                PricePlaceholderField::TrackingTemplate => "TRACKING_TEMPLATE",
                PricePlaceholderField::Language => "LANGUAGE",
                PricePlaceholderField::FinalUrlSuffix => "FINAL_URL_SUFFIX",
                PricePlaceholderField::Item1Header => "ITEM_1_HEADER",
                PricePlaceholderField::Item1Description => "ITEM_1_DESCRIPTION",
                PricePlaceholderField::Item1Price => "ITEM_1_PRICE",
                PricePlaceholderField::Item1Unit => "ITEM_1_UNIT",
                PricePlaceholderField::Item1FinalUrls => "ITEM_1_FINAL_URLS",
                PricePlaceholderField::Item1FinalMobileUrls => "ITEM_1_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item2Header => "ITEM_2_HEADER",
                PricePlaceholderField::Item2Description => "ITEM_2_DESCRIPTION",
                PricePlaceholderField::Item2Price => "ITEM_2_PRICE",
                PricePlaceholderField::Item2Unit => "ITEM_2_UNIT",
                PricePlaceholderField::Item2FinalUrls => "ITEM_2_FINAL_URLS",
                PricePlaceholderField::Item2FinalMobileUrls => "ITEM_2_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item3Header => "ITEM_3_HEADER",
                PricePlaceholderField::Item3Description => "ITEM_3_DESCRIPTION",
                PricePlaceholderField::Item3Price => "ITEM_3_PRICE",
                PricePlaceholderField::Item3Unit => "ITEM_3_UNIT",
                PricePlaceholderField::Item3FinalUrls => "ITEM_3_FINAL_URLS",
                PricePlaceholderField::Item3FinalMobileUrls => "ITEM_3_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item4Header => "ITEM_4_HEADER",
                PricePlaceholderField::Item4Description => "ITEM_4_DESCRIPTION",
                PricePlaceholderField::Item4Price => "ITEM_4_PRICE",
                PricePlaceholderField::Item4Unit => "ITEM_4_UNIT",
                PricePlaceholderField::Item4FinalUrls => "ITEM_4_FINAL_URLS",
                PricePlaceholderField::Item4FinalMobileUrls => "ITEM_4_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item5Header => "ITEM_5_HEADER",
                PricePlaceholderField::Item5Description => "ITEM_5_DESCRIPTION",
                PricePlaceholderField::Item5Price => "ITEM_5_PRICE",
                PricePlaceholderField::Item5Unit => "ITEM_5_UNIT",
                PricePlaceholderField::Item5FinalUrls => "ITEM_5_FINAL_URLS",
                PricePlaceholderField::Item5FinalMobileUrls => "ITEM_5_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item6Header => "ITEM_6_HEADER",
                PricePlaceholderField::Item6Description => "ITEM_6_DESCRIPTION",
                PricePlaceholderField::Item6Price => "ITEM_6_PRICE",
                PricePlaceholderField::Item6Unit => "ITEM_6_UNIT",
                PricePlaceholderField::Item6FinalUrls => "ITEM_6_FINAL_URLS",
                PricePlaceholderField::Item6FinalMobileUrls => "ITEM_6_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item7Header => "ITEM_7_HEADER",
                PricePlaceholderField::Item7Description => "ITEM_7_DESCRIPTION",
                PricePlaceholderField::Item7Price => "ITEM_7_PRICE",
                PricePlaceholderField::Item7Unit => "ITEM_7_UNIT",
                PricePlaceholderField::Item7FinalUrls => "ITEM_7_FINAL_URLS",
                PricePlaceholderField::Item7FinalMobileUrls => "ITEM_7_FINAL_MOBILE_URLS",
                PricePlaceholderField::Item8Header => "ITEM_8_HEADER",
                PricePlaceholderField::Item8Description => "ITEM_8_DESCRIPTION",
                PricePlaceholderField::Item8Price => "ITEM_8_PRICE",
                PricePlaceholderField::Item8Unit => "ITEM_8_UNIT",
                PricePlaceholderField::Item8FinalUrls => "ITEM_8_FINAL_URLS",
                PricePlaceholderField::Item8FinalMobileUrls => "ITEM_8_FINAL_MOBILE_URLS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TYPE" => Some(Self::Type),
                "PRICE_QUALIFIER" => Some(Self::PriceQualifier),
                "TRACKING_TEMPLATE" => Some(Self::TrackingTemplate),
                "LANGUAGE" => Some(Self::Language),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                "ITEM_1_HEADER" => Some(Self::Item1Header),
                "ITEM_1_DESCRIPTION" => Some(Self::Item1Description),
                "ITEM_1_PRICE" => Some(Self::Item1Price),
                "ITEM_1_UNIT" => Some(Self::Item1Unit),
                "ITEM_1_FINAL_URLS" => Some(Self::Item1FinalUrls),
                "ITEM_1_FINAL_MOBILE_URLS" => Some(Self::Item1FinalMobileUrls),
                "ITEM_2_HEADER" => Some(Self::Item2Header),
                "ITEM_2_DESCRIPTION" => Some(Self::Item2Description),
                "ITEM_2_PRICE" => Some(Self::Item2Price),
                "ITEM_2_UNIT" => Some(Self::Item2Unit),
                "ITEM_2_FINAL_URLS" => Some(Self::Item2FinalUrls),
                "ITEM_2_FINAL_MOBILE_URLS" => Some(Self::Item2FinalMobileUrls),
                "ITEM_3_HEADER" => Some(Self::Item3Header),
                "ITEM_3_DESCRIPTION" => Some(Self::Item3Description),
                "ITEM_3_PRICE" => Some(Self::Item3Price),
                "ITEM_3_UNIT" => Some(Self::Item3Unit),
                "ITEM_3_FINAL_URLS" => Some(Self::Item3FinalUrls),
                "ITEM_3_FINAL_MOBILE_URLS" => Some(Self::Item3FinalMobileUrls),
                "ITEM_4_HEADER" => Some(Self::Item4Header),
                "ITEM_4_DESCRIPTION" => Some(Self::Item4Description),
                "ITEM_4_PRICE" => Some(Self::Item4Price),
                "ITEM_4_UNIT" => Some(Self::Item4Unit),
                "ITEM_4_FINAL_URLS" => Some(Self::Item4FinalUrls),
                "ITEM_4_FINAL_MOBILE_URLS" => Some(Self::Item4FinalMobileUrls),
                "ITEM_5_HEADER" => Some(Self::Item5Header),
                "ITEM_5_DESCRIPTION" => Some(Self::Item5Description),
                "ITEM_5_PRICE" => Some(Self::Item5Price),
                "ITEM_5_UNIT" => Some(Self::Item5Unit),
                "ITEM_5_FINAL_URLS" => Some(Self::Item5FinalUrls),
                "ITEM_5_FINAL_MOBILE_URLS" => Some(Self::Item5FinalMobileUrls),
                "ITEM_6_HEADER" => Some(Self::Item6Header),
                "ITEM_6_DESCRIPTION" => Some(Self::Item6Description),
                "ITEM_6_PRICE" => Some(Self::Item6Price),
                "ITEM_6_UNIT" => Some(Self::Item6Unit),
                "ITEM_6_FINAL_URLS" => Some(Self::Item6FinalUrls),
                "ITEM_6_FINAL_MOBILE_URLS" => Some(Self::Item6FinalMobileUrls),
                "ITEM_7_HEADER" => Some(Self::Item7Header),
                "ITEM_7_DESCRIPTION" => Some(Self::Item7Description),
                "ITEM_7_PRICE" => Some(Self::Item7Price),
                "ITEM_7_UNIT" => Some(Self::Item7Unit),
                "ITEM_7_FINAL_URLS" => Some(Self::Item7FinalUrls),
                "ITEM_7_FINAL_MOBILE_URLS" => Some(Self::Item7FinalMobileUrls),
                "ITEM_8_HEADER" => Some(Self::Item8Header),
                "ITEM_8_DESCRIPTION" => Some(Self::Item8Description),
                "ITEM_8_PRICE" => Some(Self::Item8Price),
                "ITEM_8_UNIT" => Some(Self::Item8Unit),
                "ITEM_8_FINAL_URLS" => Some(Self::Item8FinalUrls),
                "ITEM_8_FINAL_MOBILE_URLS" => Some(Self::Item8FinalMobileUrls),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PromotionPlaceholderFieldEnum {}
/// Nested message and enum types in `PromotionPlaceholderFieldEnum`.
pub mod promotion_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PromotionPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        PromotionTarget = 2,
        DiscountModifier = 3,
        PercentOff = 4,
        MoneyAmountOff = 5,
        PromotionCode = 6,
        OrdersOverAmount = 7,
        PromotionStart = 8,
        PromotionEnd = 9,
        Occasion = 10,
        FinalUrls = 11,
        FinalMobileUrls = 12,
        TrackingUrl = 13,
        Language = 14,
        FinalUrlSuffix = 15,
    }
    impl PromotionPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PromotionPlaceholderField::Unspecified => "UNSPECIFIED",
                PromotionPlaceholderField::Unknown => "UNKNOWN",
                PromotionPlaceholderField::PromotionTarget => "PROMOTION_TARGET",
                PromotionPlaceholderField::DiscountModifier => "DISCOUNT_MODIFIER",
                PromotionPlaceholderField::PercentOff => "PERCENT_OFF",
                PromotionPlaceholderField::MoneyAmountOff => "MONEY_AMOUNT_OFF",
                PromotionPlaceholderField::PromotionCode => "PROMOTION_CODE",
                PromotionPlaceholderField::OrdersOverAmount => "ORDERS_OVER_AMOUNT",
                PromotionPlaceholderField::PromotionStart => "PROMOTION_START",
                PromotionPlaceholderField::PromotionEnd => "PROMOTION_END",
                PromotionPlaceholderField::Occasion => "OCCASION",
                PromotionPlaceholderField::FinalUrls => "FINAL_URLS",
                PromotionPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                PromotionPlaceholderField::TrackingUrl => "TRACKING_URL",
                PromotionPlaceholderField::Language => "LANGUAGE",
                PromotionPlaceholderField::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PROMOTION_TARGET" => Some(Self::PromotionTarget),
                "DISCOUNT_MODIFIER" => Some(Self::DiscountModifier),
                "PERCENT_OFF" => Some(Self::PercentOff),
                "MONEY_AMOUNT_OFF" => Some(Self::MoneyAmountOff),
                "PROMOTION_CODE" => Some(Self::PromotionCode),
                "ORDERS_OVER_AMOUNT" => Some(Self::OrdersOverAmount),
                "PROMOTION_START" => Some(Self::PromotionStart),
                "PROMOTION_END" => Some(Self::PromotionEnd),
                "OCCASION" => Some(Self::Occasion),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "LANGUAGE" => Some(Self::Language),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RealEstatePlaceholderFieldEnum {}
/// Nested message and enum types in `RealEstatePlaceholderFieldEnum`.
pub mod real_estate_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RealEstatePlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        ListingId = 2,
        ListingName = 3,
        CityName = 4,
        Description = 5,
        Address = 6,
        Price = 7,
        FormattedPrice = 8,
        ImageUrl = 9,
        PropertyType = 10,
        ListingType = 11,
        ContextualKeywords = 12,
        FinalUrls = 13,
        FinalMobileUrls = 14,
        TrackingUrl = 15,
        AndroidAppLink = 16,
        SimilarListingIds = 17,
        IosAppLink = 18,
        IosAppStoreId = 19,
    }
    impl RealEstatePlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RealEstatePlaceholderField::Unspecified => "UNSPECIFIED",
                RealEstatePlaceholderField::Unknown => "UNKNOWN",
                RealEstatePlaceholderField::ListingId => "LISTING_ID",
                RealEstatePlaceholderField::ListingName => "LISTING_NAME",
                RealEstatePlaceholderField::CityName => "CITY_NAME",
                RealEstatePlaceholderField::Description => "DESCRIPTION",
                RealEstatePlaceholderField::Address => "ADDRESS",
                RealEstatePlaceholderField::Price => "PRICE",
                RealEstatePlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                RealEstatePlaceholderField::ImageUrl => "IMAGE_URL",
                RealEstatePlaceholderField::PropertyType => "PROPERTY_TYPE",
                RealEstatePlaceholderField::ListingType => "LISTING_TYPE",
                RealEstatePlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                RealEstatePlaceholderField::FinalUrls => "FINAL_URLS",
                RealEstatePlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                RealEstatePlaceholderField::TrackingUrl => "TRACKING_URL",
                RealEstatePlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                RealEstatePlaceholderField::SimilarListingIds => "SIMILAR_LISTING_IDS",
                RealEstatePlaceholderField::IosAppLink => "IOS_APP_LINK",
                RealEstatePlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LISTING_ID" => Some(Self::ListingId),
                "LISTING_NAME" => Some(Self::ListingName),
                "CITY_NAME" => Some(Self::CityName),
                "DESCRIPTION" => Some(Self::Description),
                "ADDRESS" => Some(Self::Address),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "PROPERTY_TYPE" => Some(Self::PropertyType),
                "LISTING_TYPE" => Some(Self::ListingType),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_LISTING_IDS" => Some(Self::SimilarListingIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SitelinkPlaceholderFieldEnum {}
/// Nested message and enum types in `SitelinkPlaceholderFieldEnum`.
pub mod sitelink_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SitelinkPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Text = 2,
        Line1 = 3,
        Line2 = 4,
        FinalUrls = 5,
        FinalMobileUrls = 6,
        TrackingUrl = 7,
        FinalUrlSuffix = 8,
    }
    impl SitelinkPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SitelinkPlaceholderField::Unspecified => "UNSPECIFIED",
                SitelinkPlaceholderField::Unknown => "UNKNOWN",
                SitelinkPlaceholderField::Text => "TEXT",
                SitelinkPlaceholderField::Line1 => "LINE_1",
                SitelinkPlaceholderField::Line2 => "LINE_2",
                SitelinkPlaceholderField::FinalUrls => "FINAL_URLS",
                SitelinkPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                SitelinkPlaceholderField::TrackingUrl => "TRACKING_URL",
                SitelinkPlaceholderField::FinalUrlSuffix => "FINAL_URL_SUFFIX",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT" => Some(Self::Text),
                "LINE_1" => Some(Self::Line1),
                "LINE_2" => Some(Self::Line2),
                "FINAL_URLS" => Some(Self::FinalUrls),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "FINAL_URL_SUFFIX" => Some(Self::FinalUrlSuffix),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StructuredSnippetPlaceholderFieldEnum {}
/// Nested message and enum types in `StructuredSnippetPlaceholderFieldEnum`.
pub mod structured_snippet_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum StructuredSnippetPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        Header = 2,
        Snippets = 3,
    }
    impl StructuredSnippetPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                StructuredSnippetPlaceholderField::Unspecified => "UNSPECIFIED",
                StructuredSnippetPlaceholderField::Unknown => "UNKNOWN",
                StructuredSnippetPlaceholderField::Header => "HEADER",
                StructuredSnippetPlaceholderField::Snippets => "SNIPPETS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADER" => Some(Self::Header),
                "SNIPPETS" => Some(Self::Snippets),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TravelPlaceholderFieldEnum {}
/// Nested message and enum types in `TravelPlaceholderFieldEnum`.
pub mod travel_placeholder_field_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TravelPlaceholderField {
        Unspecified = 0,
        Unknown = 1,
        DestinationId = 2,
        OriginId = 3,
        Title = 4,
        DestinationName = 5,
        OriginName = 6,
        Price = 7,
        FormattedPrice = 8,
        SalePrice = 9,
        FormattedSalePrice = 10,
        ImageUrl = 11,
        Category = 12,
        ContextualKeywords = 13,
        DestinationAddress = 14,
        FinalUrl = 15,
        FinalMobileUrls = 16,
        TrackingUrl = 17,
        AndroidAppLink = 18,
        SimilarDestinationIds = 19,
        IosAppLink = 20,
        IosAppStoreId = 21,
    }
    impl TravelPlaceholderField {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TravelPlaceholderField::Unspecified => "UNSPECIFIED",
                TravelPlaceholderField::Unknown => "UNKNOWN",
                TravelPlaceholderField::DestinationId => "DESTINATION_ID",
                TravelPlaceholderField::OriginId => "ORIGIN_ID",
                TravelPlaceholderField::Title => "TITLE",
                TravelPlaceholderField::DestinationName => "DESTINATION_NAME",
                TravelPlaceholderField::OriginName => "ORIGIN_NAME",
                TravelPlaceholderField::Price => "PRICE",
                TravelPlaceholderField::FormattedPrice => "FORMATTED_PRICE",
                TravelPlaceholderField::SalePrice => "SALE_PRICE",
                TravelPlaceholderField::FormattedSalePrice => "FORMATTED_SALE_PRICE",
                TravelPlaceholderField::ImageUrl => "IMAGE_URL",
                TravelPlaceholderField::Category => "CATEGORY",
                TravelPlaceholderField::ContextualKeywords => "CONTEXTUAL_KEYWORDS",
                TravelPlaceholderField::DestinationAddress => "DESTINATION_ADDRESS",
                TravelPlaceholderField::FinalUrl => "FINAL_URL",
                TravelPlaceholderField::FinalMobileUrls => "FINAL_MOBILE_URLS",
                TravelPlaceholderField::TrackingUrl => "TRACKING_URL",
                TravelPlaceholderField::AndroidAppLink => "ANDROID_APP_LINK",
                TravelPlaceholderField::SimilarDestinationIds => {
                    "SIMILAR_DESTINATION_IDS"
                }
                TravelPlaceholderField::IosAppLink => "IOS_APP_LINK",
                TravelPlaceholderField::IosAppStoreId => "IOS_APP_STORE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DESTINATION_ID" => Some(Self::DestinationId),
                "ORIGIN_ID" => Some(Self::OriginId),
                "TITLE" => Some(Self::Title),
                "DESTINATION_NAME" => Some(Self::DestinationName),
                "ORIGIN_NAME" => Some(Self::OriginName),
                "PRICE" => Some(Self::Price),
                "FORMATTED_PRICE" => Some(Self::FormattedPrice),
                "SALE_PRICE" => Some(Self::SalePrice),
                "FORMATTED_SALE_PRICE" => Some(Self::FormattedSalePrice),
                "IMAGE_URL" => Some(Self::ImageUrl),
                "CATEGORY" => Some(Self::Category),
                "CONTEXTUAL_KEYWORDS" => Some(Self::ContextualKeywords),
                "DESTINATION_ADDRESS" => Some(Self::DestinationAddress),
                "FINAL_URL" => Some(Self::FinalUrl),
                "FINAL_MOBILE_URLS" => Some(Self::FinalMobileUrls),
                "TRACKING_URL" => Some(Self::TrackingUrl),
                "ANDROID_APP_LINK" => Some(Self::AndroidAppLink),
                "SIMILAR_DESTINATION_IDS" => Some(Self::SimilarDestinationIds),
                "IOS_APP_LINK" => Some(Self::IosAppLink),
                "IOS_APP_STORE_ID" => Some(Self::IosAppStoreId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MobileDeviceTypeEnum {}
/// Nested message and enum types in `MobileDeviceTypeEnum`.
pub mod mobile_device_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MobileDeviceType {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
        Tablet = 3,
    }
    impl MobileDeviceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MobileDeviceType::Unspecified => "UNSPECIFIED",
                MobileDeviceType::Unknown => "UNKNOWN",
                MobileDeviceType::Mobile => "MOBILE",
                MobileDeviceType::Tablet => "TABLET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "TABLET" => Some(Self::Tablet),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupPrimaryStatusEnum {}
/// Nested message and enum types in `AssetGroupPrimaryStatusEnum`.
pub mod asset_group_primary_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupPrimaryStatus {
        Unspecified = 0,
        Unknown = 1,
        Eligible = 2,
        Paused = 3,
        Removed = 4,
        NotEligible = 5,
        Limited = 6,
        Pending = 7,
    }
    impl AssetGroupPrimaryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupPrimaryStatus::Unspecified => "UNSPECIFIED",
                AssetGroupPrimaryStatus::Unknown => "UNKNOWN",
                AssetGroupPrimaryStatus::Eligible => "ELIGIBLE",
                AssetGroupPrimaryStatus::Paused => "PAUSED",
                AssetGroupPrimaryStatus::Removed => "REMOVED",
                AssetGroupPrimaryStatus::NotEligible => "NOT_ELIGIBLE",
                AssetGroupPrimaryStatus::Limited => "LIMITED",
                AssetGroupPrimaryStatus::Pending => "PENDING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ELIGIBLE" => Some(Self::Eligible),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "LIMITED" => Some(Self::Limited),
                "PENDING" => Some(Self::Pending),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupPrimaryStatusReasonEnum {}
/// Nested message and enum types in `AssetGroupPrimaryStatusReasonEnum`.
pub mod asset_group_primary_status_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupPrimaryStatusReason {
        Unspecified = 0,
        Unknown = 1,
        AssetGroupPaused = 2,
        AssetGroupRemoved = 3,
        CampaignRemoved = 4,
        CampaignPaused = 5,
        CampaignPending = 6,
        CampaignEnded = 7,
        AssetGroupLimited = 8,
        AssetGroupDisapproved = 9,
        AssetGroupUnderReview = 10,
    }
    impl AssetGroupPrimaryStatusReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupPrimaryStatusReason::Unspecified => "UNSPECIFIED",
                AssetGroupPrimaryStatusReason::Unknown => "UNKNOWN",
                AssetGroupPrimaryStatusReason::AssetGroupPaused => "ASSET_GROUP_PAUSED",
                AssetGroupPrimaryStatusReason::AssetGroupRemoved => "ASSET_GROUP_REMOVED",
                AssetGroupPrimaryStatusReason::CampaignRemoved => "CAMPAIGN_REMOVED",
                AssetGroupPrimaryStatusReason::CampaignPaused => "CAMPAIGN_PAUSED",
                AssetGroupPrimaryStatusReason::CampaignPending => "CAMPAIGN_PENDING",
                AssetGroupPrimaryStatusReason::CampaignEnded => "CAMPAIGN_ENDED",
                AssetGroupPrimaryStatusReason::AssetGroupLimited => "ASSET_GROUP_LIMITED",
                AssetGroupPrimaryStatusReason::AssetGroupDisapproved => {
                    "ASSET_GROUP_DISAPPROVED"
                }
                AssetGroupPrimaryStatusReason::AssetGroupUnderReview => {
                    "ASSET_GROUP_UNDER_REVIEW"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ASSET_GROUP_PAUSED" => Some(Self::AssetGroupPaused),
                "ASSET_GROUP_REMOVED" => Some(Self::AssetGroupRemoved),
                "CAMPAIGN_REMOVED" => Some(Self::CampaignRemoved),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "CAMPAIGN_PENDING" => Some(Self::CampaignPending),
                "CAMPAIGN_ENDED" => Some(Self::CampaignEnded),
                "ASSET_GROUP_LIMITED" => Some(Self::AssetGroupLimited),
                "ASSET_GROUP_DISAPPROVED" => Some(Self::AssetGroupDisapproved),
                "ASSET_GROUP_UNDER_REVIEW" => Some(Self::AssetGroupUnderReview),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupStatusEnum {}
/// Nested message and enum types in `AssetGroupStatusEnum`.
pub mod asset_group_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AssetGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupStatus::Unspecified => "UNSPECIFIED",
                AssetGroupStatus::Unknown => "UNKNOWN",
                AssetGroupStatus::Enabled => "ENABLED",
                AssetGroupStatus::Paused => "PAUSED",
                AssetGroupStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributionModelEnum {}
/// Nested message and enum types in `AttributionModelEnum`.
pub mod attribution_model_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttributionModel {
        Unspecified = 0,
        Unknown = 1,
        External = 100,
        GoogleAdsLastClick = 101,
        GoogleSearchAttributionFirstClick = 102,
        GoogleSearchAttributionLinear = 103,
        GoogleSearchAttributionTimeDecay = 104,
        GoogleSearchAttributionPositionBased = 105,
        GoogleSearchAttributionDataDriven = 106,
    }
    impl AttributionModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttributionModel::Unspecified => "UNSPECIFIED",
                AttributionModel::Unknown => "UNKNOWN",
                AttributionModel::External => "EXTERNAL",
                AttributionModel::GoogleAdsLastClick => "GOOGLE_ADS_LAST_CLICK",
                AttributionModel::GoogleSearchAttributionFirstClick => {
                    "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK"
                }
                AttributionModel::GoogleSearchAttributionLinear => {
                    "GOOGLE_SEARCH_ATTRIBUTION_LINEAR"
                }
                AttributionModel::GoogleSearchAttributionTimeDecay => {
                    "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY"
                }
                AttributionModel::GoogleSearchAttributionPositionBased => {
                    "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED"
                }
                AttributionModel::GoogleSearchAttributionDataDriven => {
                    "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTERNAL" => Some(Self::External),
                "GOOGLE_ADS_LAST_CLICK" => Some(Self::GoogleAdsLastClick),
                "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK" => {
                    Some(Self::GoogleSearchAttributionFirstClick)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_LINEAR" => {
                    Some(Self::GoogleSearchAttributionLinear)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY" => {
                    Some(Self::GoogleSearchAttributionTimeDecay)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED" => {
                    Some(Self::GoogleSearchAttributionPositionBased)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN" => {
                    Some(Self::GoogleSearchAttributionDataDriven)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionCountingTypeEnum {}
/// Nested message and enum types in `ConversionActionCountingTypeEnum`.
pub mod conversion_action_counting_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionCountingType {
        Unspecified = 0,
        Unknown = 1,
        OnePerClick = 2,
        ManyPerClick = 3,
    }
    impl ConversionActionCountingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionCountingType::Unspecified => "UNSPECIFIED",
                ConversionActionCountingType::Unknown => "UNKNOWN",
                ConversionActionCountingType::OnePerClick => "ONE_PER_CLICK",
                ConversionActionCountingType::ManyPerClick => "MANY_PER_CLICK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONE_PER_CLICK" => Some(Self::OnePerClick),
                "MANY_PER_CLICK" => Some(Self::ManyPerClick),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionStatusEnum {}
/// Nested message and enum types in `ConversionActionStatusEnum`.
pub mod conversion_action_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Hidden = 4,
    }
    impl ConversionActionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionStatus::Unspecified => "UNSPECIFIED",
                ConversionActionStatus::Unknown => "UNKNOWN",
                ConversionActionStatus::Enabled => "ENABLED",
                ConversionActionStatus::Removed => "REMOVED",
                ConversionActionStatus::Hidden => "HIDDEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "HIDDEN" => Some(Self::Hidden),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionTypeEnum {}
/// Nested message and enum types in `ConversionActionTypeEnum`.
pub mod conversion_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionType {
        Unspecified = 0,
        Unknown = 1,
        AdCall = 2,
        ClickToCall = 3,
        GooglePlayDownload = 4,
        GooglePlayInAppPurchase = 5,
        UploadCalls = 6,
        UploadClicks = 7,
        Webpage = 8,
        WebsiteCall = 9,
        StoreSalesDirectUpload = 10,
        StoreSales = 11,
        FirebaseAndroidFirstOpen = 12,
        FirebaseAndroidInAppPurchase = 13,
        FirebaseAndroidCustom = 14,
        FirebaseIosFirstOpen = 15,
        FirebaseIosInAppPurchase = 16,
        FirebaseIosCustom = 17,
        ThirdPartyAppAnalyticsAndroidFirstOpen = 18,
        ThirdPartyAppAnalyticsAndroidInAppPurchase = 19,
        ThirdPartyAppAnalyticsAndroidCustom = 20,
        ThirdPartyAppAnalyticsIosFirstOpen = 21,
        ThirdPartyAppAnalyticsIosInAppPurchase = 22,
        ThirdPartyAppAnalyticsIosCustom = 23,
        AndroidAppPreRegistration = 24,
        AndroidInstallsAllOtherApps = 25,
        FloodlightAction = 26,
        FloodlightTransaction = 27,
        GoogleHosted = 28,
        LeadFormSubmit = 29,
        Salesforce = 30,
        SearchAds360 = 31,
        SmartCampaignAdClicksToCall = 32,
        SmartCampaignMapClicksToCall = 33,
        SmartCampaignMapDirections = 34,
        SmartCampaignTrackedCalls = 35,
        StoreVisits = 36,
        WebpageCodeless = 37,
        UniversalAnalyticsGoal = 38,
        UniversalAnalyticsTransaction = 39,
        GoogleAnalytics4Custom = 40,
        GoogleAnalytics4Purchase = 41,
    }
    impl ConversionActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionType::Unspecified => "UNSPECIFIED",
                ConversionActionType::Unknown => "UNKNOWN",
                ConversionActionType::AdCall => "AD_CALL",
                ConversionActionType::ClickToCall => "CLICK_TO_CALL",
                ConversionActionType::GooglePlayDownload => "GOOGLE_PLAY_DOWNLOAD",
                ConversionActionType::GooglePlayInAppPurchase => {
                    "GOOGLE_PLAY_IN_APP_PURCHASE"
                }
                ConversionActionType::UploadCalls => "UPLOAD_CALLS",
                ConversionActionType::UploadClicks => "UPLOAD_CLICKS",
                ConversionActionType::Webpage => "WEBPAGE",
                ConversionActionType::WebsiteCall => "WEBSITE_CALL",
                ConversionActionType::StoreSalesDirectUpload => {
                    "STORE_SALES_DIRECT_UPLOAD"
                }
                ConversionActionType::StoreSales => "STORE_SALES",
                ConversionActionType::FirebaseAndroidFirstOpen => {
                    "FIREBASE_ANDROID_FIRST_OPEN"
                }
                ConversionActionType::FirebaseAndroidInAppPurchase => {
                    "FIREBASE_ANDROID_IN_APP_PURCHASE"
                }
                ConversionActionType::FirebaseAndroidCustom => "FIREBASE_ANDROID_CUSTOM",
                ConversionActionType::FirebaseIosFirstOpen => "FIREBASE_IOS_FIRST_OPEN",
                ConversionActionType::FirebaseIosInAppPurchase => {
                    "FIREBASE_IOS_IN_APP_PURCHASE"
                }
                ConversionActionType::FirebaseIosCustom => "FIREBASE_IOS_CUSTOM",
                ConversionActionType::ThirdPartyAppAnalyticsAndroidFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN"
                }
                ConversionActionType::ThirdPartyAppAnalyticsAndroidInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE"
                }
                ConversionActionType::ThirdPartyAppAnalyticsAndroidCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM"
                }
                ConversionActionType::AndroidAppPreRegistration => {
                    "ANDROID_APP_PRE_REGISTRATION"
                }
                ConversionActionType::AndroidInstallsAllOtherApps => {
                    "ANDROID_INSTALLS_ALL_OTHER_APPS"
                }
                ConversionActionType::FloodlightAction => "FLOODLIGHT_ACTION",
                ConversionActionType::FloodlightTransaction => "FLOODLIGHT_TRANSACTION",
                ConversionActionType::GoogleHosted => "GOOGLE_HOSTED",
                ConversionActionType::LeadFormSubmit => "LEAD_FORM_SUBMIT",
                ConversionActionType::Salesforce => "SALESFORCE",
                ConversionActionType::SearchAds360 => "SEARCH_ADS_360",
                ConversionActionType::SmartCampaignAdClicksToCall => {
                    "SMART_CAMPAIGN_AD_CLICKS_TO_CALL"
                }
                ConversionActionType::SmartCampaignMapClicksToCall => {
                    "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL"
                }
                ConversionActionType::SmartCampaignMapDirections => {
                    "SMART_CAMPAIGN_MAP_DIRECTIONS"
                }
                ConversionActionType::SmartCampaignTrackedCalls => {
                    "SMART_CAMPAIGN_TRACKED_CALLS"
                }
                ConversionActionType::StoreVisits => "STORE_VISITS",
                ConversionActionType::WebpageCodeless => "WEBPAGE_CODELESS",
                ConversionActionType::UniversalAnalyticsGoal => {
                    "UNIVERSAL_ANALYTICS_GOAL"
                }
                ConversionActionType::UniversalAnalyticsTransaction => {
                    "UNIVERSAL_ANALYTICS_TRANSACTION"
                }
                ConversionActionType::GoogleAnalytics4Custom => {
                    "GOOGLE_ANALYTICS_4_CUSTOM"
                }
                ConversionActionType::GoogleAnalytics4Purchase => {
                    "GOOGLE_ANALYTICS_4_PURCHASE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_CALL" => Some(Self::AdCall),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "GOOGLE_PLAY_DOWNLOAD" => Some(Self::GooglePlayDownload),
                "GOOGLE_PLAY_IN_APP_PURCHASE" => Some(Self::GooglePlayInAppPurchase),
                "UPLOAD_CALLS" => Some(Self::UploadCalls),
                "UPLOAD_CLICKS" => Some(Self::UploadClicks),
                "WEBPAGE" => Some(Self::Webpage),
                "WEBSITE_CALL" => Some(Self::WebsiteCall),
                "STORE_SALES_DIRECT_UPLOAD" => Some(Self::StoreSalesDirectUpload),
                "STORE_SALES" => Some(Self::StoreSales),
                "FIREBASE_ANDROID_FIRST_OPEN" => Some(Self::FirebaseAndroidFirstOpen),
                "FIREBASE_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::FirebaseAndroidInAppPurchase)
                }
                "FIREBASE_ANDROID_CUSTOM" => Some(Self::FirebaseAndroidCustom),
                "FIREBASE_IOS_FIRST_OPEN" => Some(Self::FirebaseIosFirstOpen),
                "FIREBASE_IOS_IN_APP_PURCHASE" => Some(Self::FirebaseIosInAppPurchase),
                "FIREBASE_IOS_CUSTOM" => Some(Self::FirebaseIosCustom),
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidCustom)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsIosFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsIosInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsIosCustom)
                }
                "ANDROID_APP_PRE_REGISTRATION" => Some(Self::AndroidAppPreRegistration),
                "ANDROID_INSTALLS_ALL_OTHER_APPS" => {
                    Some(Self::AndroidInstallsAllOtherApps)
                }
                "FLOODLIGHT_ACTION" => Some(Self::FloodlightAction),
                "FLOODLIGHT_TRANSACTION" => Some(Self::FloodlightTransaction),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "LEAD_FORM_SUBMIT" => Some(Self::LeadFormSubmit),
                "SALESFORCE" => Some(Self::Salesforce),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "SMART_CAMPAIGN_AD_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignAdClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignMapClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_DIRECTIONS" => Some(Self::SmartCampaignMapDirections),
                "SMART_CAMPAIGN_TRACKED_CALLS" => Some(Self::SmartCampaignTrackedCalls),
                "STORE_VISITS" => Some(Self::StoreVisits),
                "WEBPAGE_CODELESS" => Some(Self::WebpageCodeless),
                "UNIVERSAL_ANALYTICS_GOAL" => Some(Self::UniversalAnalyticsGoal),
                "UNIVERSAL_ANALYTICS_TRANSACTION" => {
                    Some(Self::UniversalAnalyticsTransaction)
                }
                "GOOGLE_ANALYTICS_4_CUSTOM" => Some(Self::GoogleAnalytics4Custom),
                "GOOGLE_ANALYTICS_4_PURCHASE" => Some(Self::GoogleAnalytics4Purchase),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataDrivenModelStatusEnum {}
/// Nested message and enum types in `DataDrivenModelStatusEnum`.
pub mod data_driven_model_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataDrivenModelStatus {
        Unspecified = 0,
        Unknown = 1,
        Available = 2,
        Stale = 3,
        Expired = 4,
        NeverGenerated = 5,
    }
    impl DataDrivenModelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataDrivenModelStatus::Unspecified => "UNSPECIFIED",
                DataDrivenModelStatus::Unknown => "UNKNOWN",
                DataDrivenModelStatus::Available => "AVAILABLE",
                DataDrivenModelStatus::Stale => "STALE",
                DataDrivenModelStatus::Expired => "EXPIRED",
                DataDrivenModelStatus::NeverGenerated => "NEVER_GENERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AVAILABLE" => Some(Self::Available),
                "STALE" => Some(Self::Stale),
                "EXPIRED" => Some(Self::Expired),
                "NEVER_GENERATED" => Some(Self::NeverGenerated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DistanceBucketEnum {}
/// Nested message and enum types in `DistanceBucketEnum`.
pub mod distance_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DistanceBucket {
        Unspecified = 0,
        Unknown = 1,
        Within700m = 2,
        Within1km = 3,
        Within5km = 4,
        Within10km = 5,
        Within15km = 6,
        Within20km = 7,
        Within25km = 8,
        Within30km = 9,
        Within35km = 10,
        Within40km = 11,
        Within45km = 12,
        Within50km = 13,
        Within55km = 14,
        Within60km = 15,
        Within65km = 16,
        Beyond65km = 17,
        Within07miles = 18,
        Within1mile = 19,
        Within5miles = 20,
        Within10miles = 21,
        Within15miles = 22,
        Within20miles = 23,
        Within25miles = 24,
        Within30miles = 25,
        Within35miles = 26,
        Within40miles = 27,
        Beyond40miles = 28,
    }
    impl DistanceBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DistanceBucket::Unspecified => "UNSPECIFIED",
                DistanceBucket::Unknown => "UNKNOWN",
                DistanceBucket::Within700m => "WITHIN_700M",
                DistanceBucket::Within1km => "WITHIN_1KM",
                DistanceBucket::Within5km => "WITHIN_5KM",
                DistanceBucket::Within10km => "WITHIN_10KM",
                DistanceBucket::Within15km => "WITHIN_15KM",
                DistanceBucket::Within20km => "WITHIN_20KM",
                DistanceBucket::Within25km => "WITHIN_25KM",
                DistanceBucket::Within30km => "WITHIN_30KM",
                DistanceBucket::Within35km => "WITHIN_35KM",
                DistanceBucket::Within40km => "WITHIN_40KM",
                DistanceBucket::Within45km => "WITHIN_45KM",
                DistanceBucket::Within50km => "WITHIN_50KM",
                DistanceBucket::Within55km => "WITHIN_55KM",
                DistanceBucket::Within60km => "WITHIN_60KM",
                DistanceBucket::Within65km => "WITHIN_65KM",
                DistanceBucket::Beyond65km => "BEYOND_65KM",
                DistanceBucket::Within07miles => "WITHIN_0_7MILES",
                DistanceBucket::Within1mile => "WITHIN_1MILE",
                DistanceBucket::Within5miles => "WITHIN_5MILES",
                DistanceBucket::Within10miles => "WITHIN_10MILES",
                DistanceBucket::Within15miles => "WITHIN_15MILES",
                DistanceBucket::Within20miles => "WITHIN_20MILES",
                DistanceBucket::Within25miles => "WITHIN_25MILES",
                DistanceBucket::Within30miles => "WITHIN_30MILES",
                DistanceBucket::Within35miles => "WITHIN_35MILES",
                DistanceBucket::Within40miles => "WITHIN_40MILES",
                DistanceBucket::Beyond40miles => "BEYOND_40MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WITHIN_700M" => Some(Self::Within700m),
                "WITHIN_1KM" => Some(Self::Within1km),
                "WITHIN_5KM" => Some(Self::Within5km),
                "WITHIN_10KM" => Some(Self::Within10km),
                "WITHIN_15KM" => Some(Self::Within15km),
                "WITHIN_20KM" => Some(Self::Within20km),
                "WITHIN_25KM" => Some(Self::Within25km),
                "WITHIN_30KM" => Some(Self::Within30km),
                "WITHIN_35KM" => Some(Self::Within35km),
                "WITHIN_40KM" => Some(Self::Within40km),
                "WITHIN_45KM" => Some(Self::Within45km),
                "WITHIN_50KM" => Some(Self::Within50km),
                "WITHIN_55KM" => Some(Self::Within55km),
                "WITHIN_60KM" => Some(Self::Within60km),
                "WITHIN_65KM" => Some(Self::Within65km),
                "BEYOND_65KM" => Some(Self::Beyond65km),
                "WITHIN_0_7MILES" => Some(Self::Within07miles),
                "WITHIN_1MILE" => Some(Self::Within1mile),
                "WITHIN_5MILES" => Some(Self::Within5miles),
                "WITHIN_10MILES" => Some(Self::Within10miles),
                "WITHIN_15MILES" => Some(Self::Within15miles),
                "WITHIN_20MILES" => Some(Self::Within20miles),
                "WITHIN_25MILES" => Some(Self::Within25miles),
                "WITHIN_30MILES" => Some(Self::Within30miles),
                "WITHIN_35MILES" => Some(Self::Within35miles),
                "WITHIN_40MILES" => Some(Self::Within40miles),
                "BEYOND_40MILES" => Some(Self::Beyond40miles),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RecommendationSubscriptionStatusEnum {}
/// Nested message and enum types in `RecommendationSubscriptionStatusEnum`.
pub mod recommendation_subscription_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RecommendationSubscriptionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
    }
    impl RecommendationSubscriptionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RecommendationSubscriptionStatus::Unspecified => "UNSPECIFIED",
                RecommendationSubscriptionStatus::Unknown => "UNKNOWN",
                RecommendationSubscriptionStatus::Enabled => "ENABLED",
                RecommendationSubscriptionStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerAcquisitionOptimizationModeEnum {}
/// Nested message and enum types in `CustomerAcquisitionOptimizationModeEnum`.
pub mod customer_acquisition_optimization_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerAcquisitionOptimizationMode {
        Unspecified = 0,
        Unknown = 1,
        TargetAllEqually = 2,
        BidHigherForNewCustomer = 3,
        TargetNewCustomer = 4,
    }
    impl CustomerAcquisitionOptimizationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerAcquisitionOptimizationMode::Unspecified => "UNSPECIFIED",
                CustomerAcquisitionOptimizationMode::Unknown => "UNKNOWN",
                CustomerAcquisitionOptimizationMode::TargetAllEqually => {
                    "TARGET_ALL_EQUALLY"
                }
                CustomerAcquisitionOptimizationMode::BidHigherForNewCustomer => {
                    "BID_HIGHER_FOR_NEW_CUSTOMER"
                }
                CustomerAcquisitionOptimizationMode::TargetNewCustomer => {
                    "TARGET_NEW_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TARGET_ALL_EQUALLY" => Some(Self::TargetAllEqually),
                "BID_HIGHER_FOR_NEW_CUSTOMER" => Some(Self::BidHigherForNewCustomer),
                "TARGET_NEW_CUSTOMER" => Some(Self::TargetNewCustomer),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanForecastIntervalEnum {}
/// Nested message and enum types in `KeywordPlanForecastIntervalEnum`.
pub mod keyword_plan_forecast_interval_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanForecastInterval {
        Unspecified = 0,
        Unknown = 1,
        NextWeek = 3,
        NextMonth = 4,
        NextQuarter = 5,
    }
    impl KeywordPlanForecastInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanForecastInterval::Unspecified => "UNSPECIFIED",
                KeywordPlanForecastInterval::Unknown => "UNKNOWN",
                KeywordPlanForecastInterval::NextWeek => "NEXT_WEEK",
                KeywordPlanForecastInterval::NextMonth => "NEXT_MONTH",
                KeywordPlanForecastInterval::NextQuarter => "NEXT_QUARTER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEXT_WEEK" => Some(Self::NextWeek),
                "NEXT_MONTH" => Some(Self::NextMonth),
                "NEXT_QUARTER" => Some(Self::NextQuarter),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkSourceTypeEnum {}
/// Nested message and enum types in `SkAdNetworkSourceTypeEnum`.
pub mod sk_ad_network_source_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkSourceType {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        Website = 3,
        MobileApplication = 4,
    }
    impl SkAdNetworkSourceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SkAdNetworkSourceType::Unspecified => "UNSPECIFIED",
                SkAdNetworkSourceType::Unknown => "UNKNOWN",
                SkAdNetworkSourceType::Unavailable => "UNAVAILABLE",
                SkAdNetworkSourceType::Website => "WEBSITE",
                SkAdNetworkSourceType::MobileApplication => "MOBILE_APPLICATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "WEBSITE" => Some(Self::Website),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkUserTypeEnum {}
/// Nested message and enum types in `SkAdNetworkUserTypeEnum`.
pub mod sk_ad_network_user_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkUserType {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        NewInstaller = 3,
        Reinstaller = 4,
    }
    impl SkAdNetworkUserType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SkAdNetworkUserType::Unspecified => "UNSPECIFIED",
                SkAdNetworkUserType::Unknown => "UNKNOWN",
                SkAdNetworkUserType::Unavailable => "UNAVAILABLE",
                SkAdNetworkUserType::NewInstaller => "NEW_INSTALLER",
                SkAdNetworkUserType::Reinstaller => "REINSTALLER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "NEW_INSTALLER" => Some(Self::NewInstaller),
                "REINSTALLER" => Some(Self::Reinstaller),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanCompetitionLevelEnum {}
/// Nested message and enum types in `KeywordPlanCompetitionLevelEnum`.
pub mod keyword_plan_competition_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanCompetitionLevel {
        Unspecified = 0,
        Unknown = 1,
        Low = 2,
        Medium = 3,
        High = 4,
    }
    impl KeywordPlanCompetitionLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanCompetitionLevel::Unspecified => "UNSPECIFIED",
                KeywordPlanCompetitionLevel::Unknown => "UNKNOWN",
                KeywordPlanCompetitionLevel::Low => "LOW",
                KeywordPlanCompetitionLevel::Medium => "MEDIUM",
                KeywordPlanCompetitionLevel::High => "HIGH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOW" => Some(Self::Low),
                "MEDIUM" => Some(Self::Medium),
                "HIGH" => Some(Self::High),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelRateTypeEnum {}
/// Nested message and enum types in `HotelRateTypeEnum`.
pub mod hotel_rate_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelRateType {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        PublicRate = 3,
        QualifiedRate = 4,
        PrivateRate = 5,
    }
    impl HotelRateType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelRateType::Unspecified => "UNSPECIFIED",
                HotelRateType::Unknown => "UNKNOWN",
                HotelRateType::Unavailable => "UNAVAILABLE",
                HotelRateType::PublicRate => "PUBLIC_RATE",
                HotelRateType::QualifiedRate => "QUALIFIED_RATE",
                HotelRateType::PrivateRate => "PRIVATE_RATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "PUBLIC_RATE" => Some(Self::PublicRate),
                "QUALIFIED_RATE" => Some(Self::QualifiedRate),
                "PRIVATE_RATE" => Some(Self::PrivateRate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ClickTypeEnum {}
/// Nested message and enum types in `ClickTypeEnum`.
pub mod click_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClickType {
        Unspecified = 0,
        Unknown = 1,
        AppDeeplink = 2,
        Breadcrumbs = 3,
        BroadbandPlan = 4,
        CallTracking = 5,
        Calls = 6,
        ClickOnEngagementAd = 7,
        GetDirections = 8,
        LocationExpansion = 9,
        LocationFormatCall = 10,
        LocationFormatDirections = 11,
        LocationFormatImage = 12,
        LocationFormatLandingPage = 13,
        LocationFormatMap = 14,
        LocationFormatStoreInfo = 15,
        LocationFormatText = 16,
        MobileCallTracking = 17,
        OfferPrints = 18,
        Other = 19,
        ProductExtensionClicks = 20,
        ProductListingAdClicks = 21,
        Sitelinks = 22,
        StoreLocator = 23,
        UrlClicks = 25,
        VideoAppStoreClicks = 26,
        VideoCallToActionClicks = 27,
        VideoCardActionHeadlineClicks = 28,
        VideoEndCapClicks = 29,
        VideoWebsiteClicks = 30,
        VisualSitelinks = 31,
        WirelessPlan = 32,
        ProductListingAdLocal = 33,
        ProductListingAdMultichannelLocal = 34,
        ProductListingAdMultichannelOnline = 35,
        ProductListingAdsCoupon = 36,
        ProductListingAdTransactable = 37,
        ProductAdAppDeeplink = 38,
        ShowcaseAdCategoryLink = 39,
        ShowcaseAdLocalStorefrontLink = 40,
        ShowcaseAdOnlineProductLink = 42,
        ShowcaseAdLocalProductLink = 43,
        PromotionExtension = 44,
        SwipeableGalleryAdHeadline = 45,
        SwipeableGalleryAdSwipes = 46,
        SwipeableGalleryAdSeeMore = 47,
        SwipeableGalleryAdSitelinkOne = 48,
        SwipeableGalleryAdSitelinkTwo = 49,
        SwipeableGalleryAdSitelinkThree = 50,
        SwipeableGalleryAdSitelinkFour = 51,
        SwipeableGalleryAdSitelinkFive = 52,
        HotelPrice = 53,
        PriceExtension = 54,
        HotelBookOnGoogleRoomSelection = 55,
        ShoppingComparisonListing = 56,
        CrossNetwork = 57,
        AdImage = 58,
    }
    impl ClickType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClickType::Unspecified => "UNSPECIFIED",
                ClickType::Unknown => "UNKNOWN",
                ClickType::AppDeeplink => "APP_DEEPLINK",
                ClickType::Breadcrumbs => "BREADCRUMBS",
                ClickType::BroadbandPlan => "BROADBAND_PLAN",
                ClickType::CallTracking => "CALL_TRACKING",
                ClickType::Calls => "CALLS",
                ClickType::ClickOnEngagementAd => "CLICK_ON_ENGAGEMENT_AD",
                ClickType::GetDirections => "GET_DIRECTIONS",
                ClickType::LocationExpansion => "LOCATION_EXPANSION",
                ClickType::LocationFormatCall => "LOCATION_FORMAT_CALL",
                ClickType::LocationFormatDirections => "LOCATION_FORMAT_DIRECTIONS",
                ClickType::LocationFormatImage => "LOCATION_FORMAT_IMAGE",
                ClickType::LocationFormatLandingPage => "LOCATION_FORMAT_LANDING_PAGE",
                ClickType::LocationFormatMap => "LOCATION_FORMAT_MAP",
                ClickType::LocationFormatStoreInfo => "LOCATION_FORMAT_STORE_INFO",
                ClickType::LocationFormatText => "LOCATION_FORMAT_TEXT",
                ClickType::MobileCallTracking => "MOBILE_CALL_TRACKING",
                ClickType::OfferPrints => "OFFER_PRINTS",
                ClickType::Other => "OTHER",
                ClickType::ProductExtensionClicks => "PRODUCT_EXTENSION_CLICKS",
                ClickType::ProductListingAdClicks => "PRODUCT_LISTING_AD_CLICKS",
                ClickType::Sitelinks => "SITELINKS",
                ClickType::StoreLocator => "STORE_LOCATOR",
                ClickType::UrlClicks => "URL_CLICKS",
                ClickType::VideoAppStoreClicks => "VIDEO_APP_STORE_CLICKS",
                ClickType::VideoCallToActionClicks => "VIDEO_CALL_TO_ACTION_CLICKS",
                ClickType::VideoCardActionHeadlineClicks => {
                    "VIDEO_CARD_ACTION_HEADLINE_CLICKS"
                }
                ClickType::VideoEndCapClicks => "VIDEO_END_CAP_CLICKS",
                ClickType::VideoWebsiteClicks => "VIDEO_WEBSITE_CLICKS",
                ClickType::VisualSitelinks => "VISUAL_SITELINKS",
                ClickType::WirelessPlan => "WIRELESS_PLAN",
                ClickType::ProductListingAdLocal => "PRODUCT_LISTING_AD_LOCAL",
                ClickType::ProductListingAdMultichannelLocal => {
                    "PRODUCT_LISTING_AD_MULTICHANNEL_LOCAL"
                }
                ClickType::ProductListingAdMultichannelOnline => {
                    "PRODUCT_LISTING_AD_MULTICHANNEL_ONLINE"
                }
                ClickType::ProductListingAdsCoupon => "PRODUCT_LISTING_ADS_COUPON",
                ClickType::ProductListingAdTransactable => {
                    "PRODUCT_LISTING_AD_TRANSACTABLE"
                }
                ClickType::ProductAdAppDeeplink => "PRODUCT_AD_APP_DEEPLINK",
                ClickType::ShowcaseAdCategoryLink => "SHOWCASE_AD_CATEGORY_LINK",
                ClickType::ShowcaseAdLocalStorefrontLink => {
                    "SHOWCASE_AD_LOCAL_STOREFRONT_LINK"
                }
                ClickType::ShowcaseAdOnlineProductLink => {
                    "SHOWCASE_AD_ONLINE_PRODUCT_LINK"
                }
                ClickType::ShowcaseAdLocalProductLink => "SHOWCASE_AD_LOCAL_PRODUCT_LINK",
                ClickType::PromotionExtension => "PROMOTION_EXTENSION",
                ClickType::SwipeableGalleryAdHeadline => "SWIPEABLE_GALLERY_AD_HEADLINE",
                ClickType::SwipeableGalleryAdSwipes => "SWIPEABLE_GALLERY_AD_SWIPES",
                ClickType::SwipeableGalleryAdSeeMore => "SWIPEABLE_GALLERY_AD_SEE_MORE",
                ClickType::SwipeableGalleryAdSitelinkOne => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_ONE"
                }
                ClickType::SwipeableGalleryAdSitelinkTwo => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_TWO"
                }
                ClickType::SwipeableGalleryAdSitelinkThree => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_THREE"
                }
                ClickType::SwipeableGalleryAdSitelinkFour => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_FOUR"
                }
                ClickType::SwipeableGalleryAdSitelinkFive => {
                    "SWIPEABLE_GALLERY_AD_SITELINK_FIVE"
                }
                ClickType::HotelPrice => "HOTEL_PRICE",
                ClickType::PriceExtension => "PRICE_EXTENSION",
                ClickType::HotelBookOnGoogleRoomSelection => {
                    "HOTEL_BOOK_ON_GOOGLE_ROOM_SELECTION"
                }
                ClickType::ShoppingComparisonListing => "SHOPPING_COMPARISON_LISTING",
                ClickType::CrossNetwork => "CROSS_NETWORK",
                ClickType::AdImage => "AD_IMAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APP_DEEPLINK" => Some(Self::AppDeeplink),
                "BREADCRUMBS" => Some(Self::Breadcrumbs),
                "BROADBAND_PLAN" => Some(Self::BroadbandPlan),
                "CALL_TRACKING" => Some(Self::CallTracking),
                "CALLS" => Some(Self::Calls),
                "CLICK_ON_ENGAGEMENT_AD" => Some(Self::ClickOnEngagementAd),
                "GET_DIRECTIONS" => Some(Self::GetDirections),
                "LOCATION_EXPANSION" => Some(Self::LocationExpansion),
                "LOCATION_FORMAT_CALL" => Some(Self::LocationFormatCall),
                "LOCATION_FORMAT_DIRECTIONS" => Some(Self::LocationFormatDirections),
                "LOCATION_FORMAT_IMAGE" => Some(Self::LocationFormatImage),
                "LOCATION_FORMAT_LANDING_PAGE" => Some(Self::LocationFormatLandingPage),
                "LOCATION_FORMAT_MAP" => Some(Self::LocationFormatMap),
                "LOCATION_FORMAT_STORE_INFO" => Some(Self::LocationFormatStoreInfo),
                "LOCATION_FORMAT_TEXT" => Some(Self::LocationFormatText),
                "MOBILE_CALL_TRACKING" => Some(Self::MobileCallTracking),
                "OFFER_PRINTS" => Some(Self::OfferPrints),
                "OTHER" => Some(Self::Other),
                "PRODUCT_EXTENSION_CLICKS" => Some(Self::ProductExtensionClicks),
                "PRODUCT_LISTING_AD_CLICKS" => Some(Self::ProductListingAdClicks),
                "SITELINKS" => Some(Self::Sitelinks),
                "STORE_LOCATOR" => Some(Self::StoreLocator),
                "URL_CLICKS" => Some(Self::UrlClicks),
                "VIDEO_APP_STORE_CLICKS" => Some(Self::VideoAppStoreClicks),
                "VIDEO_CALL_TO_ACTION_CLICKS" => Some(Self::VideoCallToActionClicks),
                "VIDEO_CARD_ACTION_HEADLINE_CLICKS" => {
                    Some(Self::VideoCardActionHeadlineClicks)
                }
                "VIDEO_END_CAP_CLICKS" => Some(Self::VideoEndCapClicks),
                "VIDEO_WEBSITE_CLICKS" => Some(Self::VideoWebsiteClicks),
                "VISUAL_SITELINKS" => Some(Self::VisualSitelinks),
                "WIRELESS_PLAN" => Some(Self::WirelessPlan),
                "PRODUCT_LISTING_AD_LOCAL" => Some(Self::ProductListingAdLocal),
                "PRODUCT_LISTING_AD_MULTICHANNEL_LOCAL" => {
                    Some(Self::ProductListingAdMultichannelLocal)
                }
                "PRODUCT_LISTING_AD_MULTICHANNEL_ONLINE" => {
                    Some(Self::ProductListingAdMultichannelOnline)
                }
                "PRODUCT_LISTING_ADS_COUPON" => Some(Self::ProductListingAdsCoupon),
                "PRODUCT_LISTING_AD_TRANSACTABLE" => {
                    Some(Self::ProductListingAdTransactable)
                }
                "PRODUCT_AD_APP_DEEPLINK" => Some(Self::ProductAdAppDeeplink),
                "SHOWCASE_AD_CATEGORY_LINK" => Some(Self::ShowcaseAdCategoryLink),
                "SHOWCASE_AD_LOCAL_STOREFRONT_LINK" => {
                    Some(Self::ShowcaseAdLocalStorefrontLink)
                }
                "SHOWCASE_AD_ONLINE_PRODUCT_LINK" => {
                    Some(Self::ShowcaseAdOnlineProductLink)
                }
                "SHOWCASE_AD_LOCAL_PRODUCT_LINK" => {
                    Some(Self::ShowcaseAdLocalProductLink)
                }
                "PROMOTION_EXTENSION" => Some(Self::PromotionExtension),
                "SWIPEABLE_GALLERY_AD_HEADLINE" => Some(Self::SwipeableGalleryAdHeadline),
                "SWIPEABLE_GALLERY_AD_SWIPES" => Some(Self::SwipeableGalleryAdSwipes),
                "SWIPEABLE_GALLERY_AD_SEE_MORE" => Some(Self::SwipeableGalleryAdSeeMore),
                "SWIPEABLE_GALLERY_AD_SITELINK_ONE" => {
                    Some(Self::SwipeableGalleryAdSitelinkOne)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_TWO" => {
                    Some(Self::SwipeableGalleryAdSitelinkTwo)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_THREE" => {
                    Some(Self::SwipeableGalleryAdSitelinkThree)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_FOUR" => {
                    Some(Self::SwipeableGalleryAdSitelinkFour)
                }
                "SWIPEABLE_GALLERY_AD_SITELINK_FIVE" => {
                    Some(Self::SwipeableGalleryAdSitelinkFive)
                }
                "HOTEL_PRICE" => Some(Self::HotelPrice),
                "PRICE_EXTENSION" => Some(Self::PriceExtension),
                "HOTEL_BOOK_ON_GOOGLE_ROOM_SELECTION" => {
                    Some(Self::HotelBookOnGoogleRoomSelection)
                }
                "SHOPPING_COMPARISON_LISTING" => Some(Self::ShoppingComparisonListing),
                "CROSS_NETWORK" => Some(Self::CrossNetwork),
                "AD_IMAGE" => Some(Self::AdImage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdDestinationTypeEnum {}
/// Nested message and enum types in `AdDestinationTypeEnum`.
pub mod ad_destination_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdDestinationType {
        Unspecified = 0,
        Unknown = 1,
        NotApplicable = 2,
        Website = 3,
        AppDeepLink = 4,
        AppStore = 5,
        PhoneCall = 6,
        MapDirections = 7,
        LocationListing = 8,
        Message = 9,
        LeadForm = 10,
        Youtube = 11,
        UnmodeledForConversions = 12,
    }
    impl AdDestinationType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdDestinationType::Unspecified => "UNSPECIFIED",
                AdDestinationType::Unknown => "UNKNOWN",
                AdDestinationType::NotApplicable => "NOT_APPLICABLE",
                AdDestinationType::Website => "WEBSITE",
                AdDestinationType::AppDeepLink => "APP_DEEP_LINK",
                AdDestinationType::AppStore => "APP_STORE",
                AdDestinationType::PhoneCall => "PHONE_CALL",
                AdDestinationType::MapDirections => "MAP_DIRECTIONS",
                AdDestinationType::LocationListing => "LOCATION_LISTING",
                AdDestinationType::Message => "MESSAGE",
                AdDestinationType::LeadForm => "LEAD_FORM",
                AdDestinationType::Youtube => "YOUTUBE",
                AdDestinationType::UnmodeledForConversions => "UNMODELED_FOR_CONVERSIONS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_APPLICABLE" => Some(Self::NotApplicable),
                "WEBSITE" => Some(Self::Website),
                "APP_DEEP_LINK" => Some(Self::AppDeepLink),
                "APP_STORE" => Some(Self::AppStore),
                "PHONE_CALL" => Some(Self::PhoneCall),
                "MAP_DIRECTIONS" => Some(Self::MapDirections),
                "LOCATION_LISTING" => Some(Self::LocationListing),
                "MESSAGE" => Some(Self::Message),
                "LEAD_FORM" => Some(Self::LeadForm),
                "YOUTUBE" => Some(Self::Youtube),
                "UNMODELED_FOR_CONVERSIONS" => Some(Self::UnmodeledForConversions),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummaryRowSettingEnum {}
/// Nested message and enum types in `SummaryRowSettingEnum`.
pub mod summary_row_setting_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SummaryRowSetting {
        Unspecified = 0,
        Unknown = 1,
        NoSummaryRow = 2,
        SummaryRowWithResults = 3,
        SummaryRowOnly = 4,
    }
    impl SummaryRowSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SummaryRowSetting::Unspecified => "UNSPECIFIED",
                SummaryRowSetting::Unknown => "UNKNOWN",
                SummaryRowSetting::NoSummaryRow => "NO_SUMMARY_ROW",
                SummaryRowSetting::SummaryRowWithResults => "SUMMARY_ROW_WITH_RESULTS",
                SummaryRowSetting::SummaryRowOnly => "SUMMARY_ROW_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_SUMMARY_ROW" => Some(Self::NoSummaryRow),
                "SUMMARY_ROW_WITH_RESULTS" => Some(Self::SummaryRowWithResults),
                "SUMMARY_ROW_ONLY" => Some(Self::SummaryRowOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelPriceBucketEnum {}
/// Nested message and enum types in `HotelPriceBucketEnum`.
pub mod hotel_price_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelPriceBucket {
        Unspecified = 0,
        Unknown = 1,
        LowestUnique = 2,
        LowestTied = 3,
        NotLowest = 4,
        OnlyPartnerShown = 5,
    }
    impl HotelPriceBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelPriceBucket::Unspecified => "UNSPECIFIED",
                HotelPriceBucket::Unknown => "UNKNOWN",
                HotelPriceBucket::LowestUnique => "LOWEST_UNIQUE",
                HotelPriceBucket::LowestTied => "LOWEST_TIED",
                HotelPriceBucket::NotLowest => "NOT_LOWEST",
                HotelPriceBucket::OnlyPartnerShown => "ONLY_PARTNER_SHOWN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LOWEST_UNIQUE" => Some(Self::LowestUnique),
                "LOWEST_TIED" => Some(Self::LowestTied),
                "NOT_LOWEST" => Some(Self::NotLowest),
                "ONLY_PARTNER_SHOWN" => Some(Self::OnlyPartnerShown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResponseContentTypeEnum {}
/// Nested message and enum types in `ResponseContentTypeEnum`.
pub mod response_content_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResponseContentType {
        Unspecified = 0,
        ResourceNameOnly = 1,
        MutableResource = 2,
    }
    impl ResponseContentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResponseContentType::Unspecified => "UNSPECIFIED",
                ResponseContentType::ResourceNameOnly => "RESOURCE_NAME_ONLY",
                ResponseContentType::MutableResource => "MUTABLE_RESOURCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "RESOURCE_NAME_ONLY" => Some(Self::ResourceNameOnly),
                "MUTABLE_RESOURCE" => Some(Self::MutableResource),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanAggregateMetricTypeEnum {}
/// Nested message and enum types in `KeywordPlanAggregateMetricTypeEnum`.
pub mod keyword_plan_aggregate_metric_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanAggregateMetricType {
        Unspecified = 0,
        Unknown = 1,
        Device = 2,
    }
    impl KeywordPlanAggregateMetricType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanAggregateMetricType::Unspecified => "UNSPECIFIED",
                KeywordPlanAggregateMetricType::Unknown => "UNKNOWN",
                KeywordPlanAggregateMetricType::Device => "DEVICE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEVICE" => Some(Self::Device),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchTermMatchTypeEnum {}
/// Nested message and enum types in `SearchTermMatchTypeEnum`.
pub mod search_term_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchTermMatchType {
        Unspecified = 0,
        Unknown = 1,
        Broad = 2,
        Exact = 3,
        Phrase = 4,
        NearExact = 5,
        NearPhrase = 6,
    }
    impl SearchTermMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchTermMatchType::Unspecified => "UNSPECIFIED",
                SearchTermMatchType::Unknown => "UNKNOWN",
                SearchTermMatchType::Broad => "BROAD",
                SearchTermMatchType::Exact => "EXACT",
                SearchTermMatchType::Phrase => "PHRASE",
                SearchTermMatchType::NearExact => "NEAR_EXACT",
                SearchTermMatchType::NearPhrase => "NEAR_PHRASE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BROAD" => Some(Self::Broad),
                "EXACT" => Some(Self::Exact),
                "PHRASE" => Some(Self::Phrase),
                "NEAR_EXACT" => Some(Self::NearExact),
                "NEAR_PHRASE" => Some(Self::NearPhrase),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanAgeRangeEnum {}
/// Nested message and enum types in `ReachPlanAgeRangeEnum`.
pub mod reach_plan_age_range_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanAgeRange {
        Unspecified = 0,
        Unknown = 1,
        AgeRange1824 = 503001,
        AgeRange1834 = 2,
        AgeRange1844 = 3,
        AgeRange1849 = 4,
        AgeRange1854 = 5,
        AgeRange1864 = 6,
        AgeRange1865Up = 7,
        AgeRange2134 = 8,
        AgeRange2534 = 503002,
        AgeRange2544 = 9,
        AgeRange2549 = 10,
        AgeRange2554 = 11,
        AgeRange2564 = 12,
        AgeRange2565Up = 13,
        AgeRange3544 = 503003,
        AgeRange3549 = 14,
        AgeRange3554 = 15,
        AgeRange3564 = 16,
        AgeRange3565Up = 17,
        AgeRange4554 = 503004,
        AgeRange4564 = 18,
        AgeRange4565Up = 19,
        AgeRange5065Up = 20,
        AgeRange5564 = 503005,
        AgeRange5565Up = 21,
        AgeRange65Up = 503006,
    }
    impl ReachPlanAgeRange {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReachPlanAgeRange::Unspecified => "UNSPECIFIED",
                ReachPlanAgeRange::Unknown => "UNKNOWN",
                ReachPlanAgeRange::AgeRange1824 => "AGE_RANGE_18_24",
                ReachPlanAgeRange::AgeRange1834 => "AGE_RANGE_18_34",
                ReachPlanAgeRange::AgeRange1844 => "AGE_RANGE_18_44",
                ReachPlanAgeRange::AgeRange1849 => "AGE_RANGE_18_49",
                ReachPlanAgeRange::AgeRange1854 => "AGE_RANGE_18_54",
                ReachPlanAgeRange::AgeRange1864 => "AGE_RANGE_18_64",
                ReachPlanAgeRange::AgeRange1865Up => "AGE_RANGE_18_65_UP",
                ReachPlanAgeRange::AgeRange2134 => "AGE_RANGE_21_34",
                ReachPlanAgeRange::AgeRange2534 => "AGE_RANGE_25_34",
                ReachPlanAgeRange::AgeRange2544 => "AGE_RANGE_25_44",
                ReachPlanAgeRange::AgeRange2549 => "AGE_RANGE_25_49",
                ReachPlanAgeRange::AgeRange2554 => "AGE_RANGE_25_54",
                ReachPlanAgeRange::AgeRange2564 => "AGE_RANGE_25_64",
                ReachPlanAgeRange::AgeRange2565Up => "AGE_RANGE_25_65_UP",
                ReachPlanAgeRange::AgeRange3544 => "AGE_RANGE_35_44",
                ReachPlanAgeRange::AgeRange3549 => "AGE_RANGE_35_49",
                ReachPlanAgeRange::AgeRange3554 => "AGE_RANGE_35_54",
                ReachPlanAgeRange::AgeRange3564 => "AGE_RANGE_35_64",
                ReachPlanAgeRange::AgeRange3565Up => "AGE_RANGE_35_65_UP",
                ReachPlanAgeRange::AgeRange4554 => "AGE_RANGE_45_54",
                ReachPlanAgeRange::AgeRange4564 => "AGE_RANGE_45_64",
                ReachPlanAgeRange::AgeRange4565Up => "AGE_RANGE_45_65_UP",
                ReachPlanAgeRange::AgeRange5065Up => "AGE_RANGE_50_65_UP",
                ReachPlanAgeRange::AgeRange5564 => "AGE_RANGE_55_64",
                ReachPlanAgeRange::AgeRange5565Up => "AGE_RANGE_55_65_UP",
                ReachPlanAgeRange::AgeRange65Up => "AGE_RANGE_65_UP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AGE_RANGE_18_24" => Some(Self::AgeRange1824),
                "AGE_RANGE_18_34" => Some(Self::AgeRange1834),
                "AGE_RANGE_18_44" => Some(Self::AgeRange1844),
                "AGE_RANGE_18_49" => Some(Self::AgeRange1849),
                "AGE_RANGE_18_54" => Some(Self::AgeRange1854),
                "AGE_RANGE_18_64" => Some(Self::AgeRange1864),
                "AGE_RANGE_18_65_UP" => Some(Self::AgeRange1865Up),
                "AGE_RANGE_21_34" => Some(Self::AgeRange2134),
                "AGE_RANGE_25_34" => Some(Self::AgeRange2534),
                "AGE_RANGE_25_44" => Some(Self::AgeRange2544),
                "AGE_RANGE_25_49" => Some(Self::AgeRange2549),
                "AGE_RANGE_25_54" => Some(Self::AgeRange2554),
                "AGE_RANGE_25_64" => Some(Self::AgeRange2564),
                "AGE_RANGE_25_65_UP" => Some(Self::AgeRange2565Up),
                "AGE_RANGE_35_44" => Some(Self::AgeRange3544),
                "AGE_RANGE_35_49" => Some(Self::AgeRange3549),
                "AGE_RANGE_35_54" => Some(Self::AgeRange3554),
                "AGE_RANGE_35_64" => Some(Self::AgeRange3564),
                "AGE_RANGE_35_65_UP" => Some(Self::AgeRange3565Up),
                "AGE_RANGE_45_54" => Some(Self::AgeRange4554),
                "AGE_RANGE_45_64" => Some(Self::AgeRange4564),
                "AGE_RANGE_45_65_UP" => Some(Self::AgeRange4565Up),
                "AGE_RANGE_50_65_UP" => Some(Self::AgeRange5065Up),
                "AGE_RANGE_55_64" => Some(Self::AgeRange5564),
                "AGE_RANGE_55_65_UP" => Some(Self::AgeRange5565Up),
                "AGE_RANGE_65_UP" => Some(Self::AgeRange65Up),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgramEnum {}
/// Nested message and enum types in `IdentityVerificationProgramEnum`.
pub mod identity_verification_program_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityVerificationProgram {
        Unspecified = 0,
        Unknown = 1,
        AdvertiserIdentityVerification = 2,
    }
    impl IdentityVerificationProgram {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IdentityVerificationProgram::Unspecified => "UNSPECIFIED",
                IdentityVerificationProgram::Unknown => "UNKNOWN",
                IdentityVerificationProgram::AdvertiserIdentityVerification => {
                    "ADVERTISER_IDENTITY_VERIFICATION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADVERTISER_IDENTITY_VERIFICATION" => {
                    Some(Self::AdvertiserIdentityVerification)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchEngineResultsPageTypeEnum {}
/// Nested message and enum types in `SearchEngineResultsPageTypeEnum`.
pub mod search_engine_results_page_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchEngineResultsPageType {
        Unspecified = 0,
        Unknown = 1,
        AdsOnly = 2,
        OrganicOnly = 3,
        AdsAndOrganic = 4,
    }
    impl SearchEngineResultsPageType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchEngineResultsPageType::Unspecified => "UNSPECIFIED",
                SearchEngineResultsPageType::Unknown => "UNKNOWN",
                SearchEngineResultsPageType::AdsOnly => "ADS_ONLY",
                SearchEngineResultsPageType::OrganicOnly => "ORGANIC_ONLY",
                SearchEngineResultsPageType::AdsAndOrganic => "ADS_AND_ORGANIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ADS_ONLY" => Some(Self::AdsOnly),
                "ORGANIC_ONLY" => Some(Self::OrganicOnly),
                "ADS_AND_ORGANIC" => Some(Self::AdsAndOrganic),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkAdEventTypeEnum {}
/// Nested message and enum types in `SkAdNetworkAdEventTypeEnum`.
pub mod sk_ad_network_ad_event_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkAdEventType {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        Interaction = 3,
        View = 4,
    }
    impl SkAdNetworkAdEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SkAdNetworkAdEventType::Unspecified => "UNSPECIFIED",
                SkAdNetworkAdEventType::Unknown => "UNKNOWN",
                SkAdNetworkAdEventType::Unavailable => "UNAVAILABLE",
                SkAdNetworkAdEventType::Interaction => "INTERACTION",
                SkAdNetworkAdEventType::View => "VIEW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "INTERACTION" => Some(Self::Interaction),
                "VIEW" => Some(Self::View),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignNotEligibleReasonEnum {}
/// Nested message and enum types in `SmartCampaignNotEligibleReasonEnum`.
pub mod smart_campaign_not_eligible_reason_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignNotEligibleReason {
        Unspecified = 0,
        Unknown = 1,
        AccountIssue = 2,
        BillingIssue = 3,
        BusinessProfileLocationRemoved = 4,
        AllAdsDisapproved = 5,
    }
    impl SmartCampaignNotEligibleReason {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SmartCampaignNotEligibleReason::Unspecified => "UNSPECIFIED",
                SmartCampaignNotEligibleReason::Unknown => "UNKNOWN",
                SmartCampaignNotEligibleReason::AccountIssue => "ACCOUNT_ISSUE",
                SmartCampaignNotEligibleReason::BillingIssue => "BILLING_ISSUE",
                SmartCampaignNotEligibleReason::BusinessProfileLocationRemoved => {
                    "BUSINESS_PROFILE_LOCATION_REMOVED"
                }
                SmartCampaignNotEligibleReason::AllAdsDisapproved => {
                    "ALL_ADS_DISAPPROVED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACCOUNT_ISSUE" => Some(Self::AccountIssue),
                "BILLING_ISSUE" => Some(Self::BillingIssue),
                "BUSINESS_PROFILE_LOCATION_REMOVED" => {
                    Some(Self::BusinessProfileLocationRemoved)
                }
                "ALL_ADS_DISAPPROVED" => Some(Self::AllAdsDisapproved),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IdentityVerificationProgramStatusEnum {}
/// Nested message and enum types in `IdentityVerificationProgramStatusEnum`.
pub mod identity_verification_program_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdentityVerificationProgramStatus {
        Unspecified = 0,
        Unknown = 1,
        PendingUserAction = 2,
        PendingReview = 3,
        Success = 4,
        Failure = 5,
    }
    impl IdentityVerificationProgramStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                IdentityVerificationProgramStatus::Unspecified => "UNSPECIFIED",
                IdentityVerificationProgramStatus::Unknown => "UNKNOWN",
                IdentityVerificationProgramStatus::PendingUserAction => {
                    "PENDING_USER_ACTION"
                }
                IdentityVerificationProgramStatus::PendingReview => "PENDING_REVIEW",
                IdentityVerificationProgramStatus::Success => "SUCCESS",
                IdentityVerificationProgramStatus::Failure => "FAILURE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING_USER_ACTION" => Some(Self::PendingUserAction),
                "PENDING_REVIEW" => Some(Self::PendingReview),
                "SUCCESS" => Some(Self::Success),
                "FAILURE" => Some(Self::Failure),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionOrAdjustmentLagBucketEnum {}
/// Nested message and enum types in `ConversionOrAdjustmentLagBucketEnum`.
pub mod conversion_or_adjustment_lag_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionOrAdjustmentLagBucket {
        Unspecified = 0,
        Unknown = 1,
        ConversionLessThanOneDay = 2,
        ConversionOneToTwoDays = 3,
        ConversionTwoToThreeDays = 4,
        ConversionThreeToFourDays = 5,
        ConversionFourToFiveDays = 6,
        ConversionFiveToSixDays = 7,
        ConversionSixToSevenDays = 8,
        ConversionSevenToEightDays = 9,
        ConversionEightToNineDays = 10,
        ConversionNineToTenDays = 11,
        ConversionTenToElevenDays = 12,
        ConversionElevenToTwelveDays = 13,
        ConversionTwelveToThirteenDays = 14,
        ConversionThirteenToFourteenDays = 15,
        ConversionFourteenToTwentyOneDays = 16,
        ConversionTwentyOneToThirtyDays = 17,
        ConversionThirtyToFortyFiveDays = 18,
        ConversionFortyFiveToSixtyDays = 19,
        ConversionSixtyToNinetyDays = 20,
        AdjustmentLessThanOneDay = 21,
        AdjustmentOneToTwoDays = 22,
        AdjustmentTwoToThreeDays = 23,
        AdjustmentThreeToFourDays = 24,
        AdjustmentFourToFiveDays = 25,
        AdjustmentFiveToSixDays = 26,
        AdjustmentSixToSevenDays = 27,
        AdjustmentSevenToEightDays = 28,
        AdjustmentEightToNineDays = 29,
        AdjustmentNineToTenDays = 30,
        AdjustmentTenToElevenDays = 31,
        AdjustmentElevenToTwelveDays = 32,
        AdjustmentTwelveToThirteenDays = 33,
        AdjustmentThirteenToFourteenDays = 34,
        AdjustmentFourteenToTwentyOneDays = 35,
        AdjustmentTwentyOneToThirtyDays = 36,
        AdjustmentThirtyToFortyFiveDays = 37,
        AdjustmentFortyFiveToSixtyDays = 38,
        AdjustmentSixtyToNinetyDays = 39,
        AdjustmentNinetyToOneHundredAndFortyFiveDays = 40,
        ConversionUnknown = 41,
        AdjustmentUnknown = 42,
    }
    impl ConversionOrAdjustmentLagBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionOrAdjustmentLagBucket::Unspecified => "UNSPECIFIED",
                ConversionOrAdjustmentLagBucket::Unknown => "UNKNOWN",
                ConversionOrAdjustmentLagBucket::ConversionLessThanOneDay => {
                    "CONVERSION_LESS_THAN_ONE_DAY"
                }
                ConversionOrAdjustmentLagBucket::ConversionOneToTwoDays => {
                    "CONVERSION_ONE_TO_TWO_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionTwoToThreeDays => {
                    "CONVERSION_TWO_TO_THREE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionThreeToFourDays => {
                    "CONVERSION_THREE_TO_FOUR_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionFourToFiveDays => {
                    "CONVERSION_FOUR_TO_FIVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionFiveToSixDays => {
                    "CONVERSION_FIVE_TO_SIX_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionSixToSevenDays => {
                    "CONVERSION_SIX_TO_SEVEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionSevenToEightDays => {
                    "CONVERSION_SEVEN_TO_EIGHT_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionEightToNineDays => {
                    "CONVERSION_EIGHT_TO_NINE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionNineToTenDays => {
                    "CONVERSION_NINE_TO_TEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionTenToElevenDays => {
                    "CONVERSION_TEN_TO_ELEVEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionElevenToTwelveDays => {
                    "CONVERSION_ELEVEN_TO_TWELVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionTwelveToThirteenDays => {
                    "CONVERSION_TWELVE_TO_THIRTEEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionThirteenToFourteenDays => {
                    "CONVERSION_THIRTEEN_TO_FOURTEEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionFourteenToTwentyOneDays => {
                    "CONVERSION_FOURTEEN_TO_TWENTY_ONE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionTwentyOneToThirtyDays => {
                    "CONVERSION_TWENTY_ONE_TO_THIRTY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionThirtyToFortyFiveDays => {
                    "CONVERSION_THIRTY_TO_FORTY_FIVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionFortyFiveToSixtyDays => {
                    "CONVERSION_FORTY_FIVE_TO_SIXTY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionSixtyToNinetyDays => {
                    "CONVERSION_SIXTY_TO_NINETY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentLessThanOneDay => {
                    "ADJUSTMENT_LESS_THAN_ONE_DAY"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentOneToTwoDays => {
                    "ADJUSTMENT_ONE_TO_TWO_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentTwoToThreeDays => {
                    "ADJUSTMENT_TWO_TO_THREE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentThreeToFourDays => {
                    "ADJUSTMENT_THREE_TO_FOUR_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentFourToFiveDays => {
                    "ADJUSTMENT_FOUR_TO_FIVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentFiveToSixDays => {
                    "ADJUSTMENT_FIVE_TO_SIX_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentSixToSevenDays => {
                    "ADJUSTMENT_SIX_TO_SEVEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentSevenToEightDays => {
                    "ADJUSTMENT_SEVEN_TO_EIGHT_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentEightToNineDays => {
                    "ADJUSTMENT_EIGHT_TO_NINE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentNineToTenDays => {
                    "ADJUSTMENT_NINE_TO_TEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentTenToElevenDays => {
                    "ADJUSTMENT_TEN_TO_ELEVEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentElevenToTwelveDays => {
                    "ADJUSTMENT_ELEVEN_TO_TWELVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentTwelveToThirteenDays => {
                    "ADJUSTMENT_TWELVE_TO_THIRTEEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentThirteenToFourteenDays => {
                    "ADJUSTMENT_THIRTEEN_TO_FOURTEEN_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentFourteenToTwentyOneDays => {
                    "ADJUSTMENT_FOURTEEN_TO_TWENTY_ONE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentTwentyOneToThirtyDays => {
                    "ADJUSTMENT_TWENTY_ONE_TO_THIRTY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentThirtyToFortyFiveDays => {
                    "ADJUSTMENT_THIRTY_TO_FORTY_FIVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentFortyFiveToSixtyDays => {
                    "ADJUSTMENT_FORTY_FIVE_TO_SIXTY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentSixtyToNinetyDays => {
                    "ADJUSTMENT_SIXTY_TO_NINETY_DAYS"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentNinetyToOneHundredAndFortyFiveDays => {
                    "ADJUSTMENT_NINETY_TO_ONE_HUNDRED_AND_FORTY_FIVE_DAYS"
                }
                ConversionOrAdjustmentLagBucket::ConversionUnknown => {
                    "CONVERSION_UNKNOWN"
                }
                ConversionOrAdjustmentLagBucket::AdjustmentUnknown => {
                    "ADJUSTMENT_UNKNOWN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CONVERSION_LESS_THAN_ONE_DAY" => Some(Self::ConversionLessThanOneDay),
                "CONVERSION_ONE_TO_TWO_DAYS" => Some(Self::ConversionOneToTwoDays),
                "CONVERSION_TWO_TO_THREE_DAYS" => Some(Self::ConversionTwoToThreeDays),
                "CONVERSION_THREE_TO_FOUR_DAYS" => Some(Self::ConversionThreeToFourDays),
                "CONVERSION_FOUR_TO_FIVE_DAYS" => Some(Self::ConversionFourToFiveDays),
                "CONVERSION_FIVE_TO_SIX_DAYS" => Some(Self::ConversionFiveToSixDays),
                "CONVERSION_SIX_TO_SEVEN_DAYS" => Some(Self::ConversionSixToSevenDays),
                "CONVERSION_SEVEN_TO_EIGHT_DAYS" => {
                    Some(Self::ConversionSevenToEightDays)
                }
                "CONVERSION_EIGHT_TO_NINE_DAYS" => Some(Self::ConversionEightToNineDays),
                "CONVERSION_NINE_TO_TEN_DAYS" => Some(Self::ConversionNineToTenDays),
                "CONVERSION_TEN_TO_ELEVEN_DAYS" => Some(Self::ConversionTenToElevenDays),
                "CONVERSION_ELEVEN_TO_TWELVE_DAYS" => {
                    Some(Self::ConversionElevenToTwelveDays)
                }
                "CONVERSION_TWELVE_TO_THIRTEEN_DAYS" => {
                    Some(Self::ConversionTwelveToThirteenDays)
                }
                "CONVERSION_THIRTEEN_TO_FOURTEEN_DAYS" => {
                    Some(Self::ConversionThirteenToFourteenDays)
                }
                "CONVERSION_FOURTEEN_TO_TWENTY_ONE_DAYS" => {
                    Some(Self::ConversionFourteenToTwentyOneDays)
                }
                "CONVERSION_TWENTY_ONE_TO_THIRTY_DAYS" => {
                    Some(Self::ConversionTwentyOneToThirtyDays)
                }
                "CONVERSION_THIRTY_TO_FORTY_FIVE_DAYS" => {
                    Some(Self::ConversionThirtyToFortyFiveDays)
                }
                "CONVERSION_FORTY_FIVE_TO_SIXTY_DAYS" => {
                    Some(Self::ConversionFortyFiveToSixtyDays)
                }
                "CONVERSION_SIXTY_TO_NINETY_DAYS" => {
                    Some(Self::ConversionSixtyToNinetyDays)
                }
                "ADJUSTMENT_LESS_THAN_ONE_DAY" => Some(Self::AdjustmentLessThanOneDay),
                "ADJUSTMENT_ONE_TO_TWO_DAYS" => Some(Self::AdjustmentOneToTwoDays),
                "ADJUSTMENT_TWO_TO_THREE_DAYS" => Some(Self::AdjustmentTwoToThreeDays),
                "ADJUSTMENT_THREE_TO_FOUR_DAYS" => Some(Self::AdjustmentThreeToFourDays),
                "ADJUSTMENT_FOUR_TO_FIVE_DAYS" => Some(Self::AdjustmentFourToFiveDays),
                "ADJUSTMENT_FIVE_TO_SIX_DAYS" => Some(Self::AdjustmentFiveToSixDays),
                "ADJUSTMENT_SIX_TO_SEVEN_DAYS" => Some(Self::AdjustmentSixToSevenDays),
                "ADJUSTMENT_SEVEN_TO_EIGHT_DAYS" => {
                    Some(Self::AdjustmentSevenToEightDays)
                }
                "ADJUSTMENT_EIGHT_TO_NINE_DAYS" => Some(Self::AdjustmentEightToNineDays),
                "ADJUSTMENT_NINE_TO_TEN_DAYS" => Some(Self::AdjustmentNineToTenDays),
                "ADJUSTMENT_TEN_TO_ELEVEN_DAYS" => Some(Self::AdjustmentTenToElevenDays),
                "ADJUSTMENT_ELEVEN_TO_TWELVE_DAYS" => {
                    Some(Self::AdjustmentElevenToTwelveDays)
                }
                "ADJUSTMENT_TWELVE_TO_THIRTEEN_DAYS" => {
                    Some(Self::AdjustmentTwelveToThirteenDays)
                }
                "ADJUSTMENT_THIRTEEN_TO_FOURTEEN_DAYS" => {
                    Some(Self::AdjustmentThirteenToFourteenDays)
                }
                "ADJUSTMENT_FOURTEEN_TO_TWENTY_ONE_DAYS" => {
                    Some(Self::AdjustmentFourteenToTwentyOneDays)
                }
                "ADJUSTMENT_TWENTY_ONE_TO_THIRTY_DAYS" => {
                    Some(Self::AdjustmentTwentyOneToThirtyDays)
                }
                "ADJUSTMENT_THIRTY_TO_FORTY_FIVE_DAYS" => {
                    Some(Self::AdjustmentThirtyToFortyFiveDays)
                }
                "ADJUSTMENT_FORTY_FIVE_TO_SIXTY_DAYS" => {
                    Some(Self::AdjustmentFortyFiveToSixtyDays)
                }
                "ADJUSTMENT_SIXTY_TO_NINETY_DAYS" => {
                    Some(Self::AdjustmentSixtyToNinetyDays)
                }
                "ADJUSTMENT_NINETY_TO_ONE_HUNDRED_AND_FORTY_FIVE_DAYS" => {
                    Some(Self::AdjustmentNinetyToOneHundredAndFortyFiveDays)
                }
                "CONVERSION_UNKNOWN" => Some(Self::ConversionUnknown),
                "ADJUSTMENT_UNKNOWN" => Some(Self::AdjustmentUnknown),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ResourceLimitTypeEnum {}
/// Nested message and enum types in `ResourceLimitTypeEnum`.
pub mod resource_limit_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ResourceLimitType {
        Unspecified = 0,
        Unknown = 1,
        CampaignsPerCustomer = 2,
        BaseCampaignsPerCustomer = 3,
        ExperimentCampaignsPerCustomer = 105,
        HotelCampaignsPerCustomer = 4,
        SmartShoppingCampaignsPerCustomer = 5,
        AdGroupsPerCampaign = 6,
        AdGroupsPerShoppingCampaign = 8,
        AdGroupsPerHotelCampaign = 9,
        ReportingAdGroupsPerLocalCampaign = 10,
        ReportingAdGroupsPerAppCampaign = 11,
        ManagedAdGroupsPerSmartCampaign = 52,
        AdGroupCriteriaPerCustomer = 12,
        BaseAdGroupCriteriaPerCustomer = 13,
        ExperimentAdGroupCriteriaPerCustomer = 107,
        AdGroupCriteriaPerCampaign = 14,
        CampaignCriteriaPerCustomer = 15,
        BaseCampaignCriteriaPerCustomer = 16,
        ExperimentCampaignCriteriaPerCustomer = 108,
        WebpageCriteriaPerCustomer = 17,
        BaseWebpageCriteriaPerCustomer = 18,
        ExperimentWebpageCriteriaPerCustomer = 19,
        CombinedAudienceCriteriaPerAdGroup = 20,
        CustomerNegativePlacementCriteriaPerCustomer = 21,
        CustomerNegativeYoutubeChannelCriteriaPerCustomer = 22,
        CriteriaPerAdGroup = 23,
        ListingGroupsPerAdGroup = 24,
        ExplicitlySharedBudgetsPerCustomer = 25,
        ImplicitlySharedBudgetsPerCustomer = 26,
        CombinedAudienceCriteriaPerCampaign = 27,
        NegativeKeywordsPerCampaign = 28,
        NegativePlacementsPerCampaign = 29,
        GeoTargetsPerCampaign = 30,
        NegativeIpBlocksPerCampaign = 32,
        ProximitiesPerCampaign = 33,
        ListingScopesPerShoppingCampaign = 34,
        ListingScopesPerNonShoppingCampaign = 35,
        NegativeKeywordsPerSharedSet = 36,
        NegativePlacementsPerSharedSet = 37,
        SharedSetsPerCustomerForTypeDefault = 40,
        SharedSetsPerCustomerForNegativePlacementListLower = 41,
        HotelAdvanceBookingWindowBidModifiersPerAdGroup = 44,
        BiddingStrategiesPerCustomer = 45,
        BasicUserListsPerCustomer = 47,
        LogicalUserListsPerCustomer = 48,
        RuleBasedUserListsPerCustomer = 153,
        BaseAdGroupAdsPerCustomer = 53,
        ExperimentAdGroupAdsPerCustomer = 54,
        AdGroupAdsPerCampaign = 55,
        TextAndOtherAdsPerAdGroup = 56,
        ImageAdsPerAdGroup = 57,
        ShoppingSmartAdsPerAdGroup = 58,
        ResponsiveSearchAdsPerAdGroup = 59,
        AppAdsPerAdGroup = 60,
        AppEngagementAdsPerAdGroup = 61,
        LocalAdsPerAdGroup = 62,
        VideoAdsPerAdGroup = 63,
        LeadFormCampaignAssetsPerCampaign = 143,
        PromotionCustomerAssetsPerCustomer = 79,
        PromotionCampaignAssetsPerCampaign = 80,
        PromotionAdGroupAssetsPerAdGroup = 81,
        CalloutCustomerAssetsPerCustomer = 134,
        CalloutCampaignAssetsPerCampaign = 135,
        CalloutAdGroupAssetsPerAdGroup = 136,
        SitelinkCustomerAssetsPerCustomer = 137,
        SitelinkCampaignAssetsPerCampaign = 138,
        SitelinkAdGroupAssetsPerAdGroup = 139,
        StructuredSnippetCustomerAssetsPerCustomer = 140,
        StructuredSnippetCampaignAssetsPerCampaign = 141,
        StructuredSnippetAdGroupAssetsPerAdGroup = 142,
        MobileAppCustomerAssetsPerCustomer = 144,
        MobileAppCampaignAssetsPerCampaign = 145,
        MobileAppAdGroupAssetsPerAdGroup = 146,
        HotelCalloutCustomerAssetsPerCustomer = 147,
        HotelCalloutCampaignAssetsPerCampaign = 148,
        HotelCalloutAdGroupAssetsPerAdGroup = 149,
        CallCustomerAssetsPerCustomer = 150,
        CallCampaignAssetsPerCampaign = 151,
        CallAdGroupAssetsPerAdGroup = 152,
        PriceCustomerAssetsPerCustomer = 154,
        PriceCampaignAssetsPerCampaign = 155,
        PriceAdGroupAssetsPerAdGroup = 156,
        AdImageCampaignAssetsPerCampaign = 175,
        AdImageAdGroupAssetsPerAdGroup = 176,
        PageFeedAssetSetsPerCustomer = 157,
        DynamicEducationFeedAssetSetsPerCustomer = 158,
        AssetsPerPageFeedAssetSet = 159,
        AssetsPerDynamicEducationFeedAssetSet = 160,
        DynamicRealEstateAssetSetsPerCustomer = 161,
        AssetsPerDynamicRealEstateAssetSet = 162,
        DynamicCustomAssetSetsPerCustomer = 163,
        AssetsPerDynamicCustomAssetSet = 164,
        DynamicHotelsAndRentalsAssetSetsPerCustomer = 165,
        AssetsPerDynamicHotelsAndRentalsAssetSet = 166,
        DynamicLocalAssetSetsPerCustomer = 167,
        AssetsPerDynamicLocalAssetSet = 168,
        DynamicFlightsAssetSetsPerCustomer = 169,
        AssetsPerDynamicFlightsAssetSet = 170,
        DynamicTravelAssetSetsPerCustomer = 171,
        AssetsPerDynamicTravelAssetSet = 172,
        DynamicJobsAssetSetsPerCustomer = 173,
        AssetsPerDynamicJobsAssetSet = 174,
        BusinessNameCampaignAssetsPerCampaign = 179,
        BusinessLogoCampaignAssetsPerCampaign = 180,
        VersionsPerAd = 82,
        UserFeedsPerCustomer = 90,
        SystemFeedsPerCustomer = 91,
        FeedAttributesPerFeed = 92,
        FeedItemsPerCustomer = 94,
        CampaignFeedsPerCustomer = 95,
        BaseCampaignFeedsPerCustomer = 96,
        ExperimentCampaignFeedsPerCustomer = 109,
        AdGroupFeedsPerCustomer = 97,
        BaseAdGroupFeedsPerCustomer = 98,
        ExperimentAdGroupFeedsPerCustomer = 110,
        AdGroupFeedsPerCampaign = 99,
        FeedItemSetsPerCustomer = 100,
        FeedItemsPerFeedItemSet = 101,
        CampaignExperimentsPerCustomer = 112,
        ExperimentArmsPerVideoExperiment = 113,
        OwnedLabelsPerCustomer = 115,
        LabelsPerCampaign = 117,
        LabelsPerAdGroup = 118,
        LabelsPerAdGroupAd = 119,
        LabelsPerAdGroupCriterion = 120,
        TargetCustomersPerLabel = 121,
        KeywordPlansPerUserPerCustomer = 122,
        KeywordPlanAdGroupKeywordsPerKeywordPlan = 123,
        KeywordPlanAdGroupsPerKeywordPlan = 124,
        KeywordPlanNegativeKeywordsPerKeywordPlan = 125,
        KeywordPlanCampaignsPerKeywordPlan = 126,
        ConversionActionsPerCustomer = 128,
        BatchJobOperationsPerJob = 130,
        BatchJobsPerCustomer = 131,
        HotelCheckInDateRangeBidModifiersPerAdGroup = 132,
        SharedSetsPerAccountForAccountLevelNegativeKeywords = 177,
        AccountLevelNegativeKeywordsPerSharedSet = 178,
        EnabledAssetPerHotelPropertyAssetSet = 181,
        EnabledHotelPropertyAssetLinksPerAssetGroup = 182,
        BrandsPerSharedSet = 183,
        EnabledBrandListCriteriaPerCampaign = 184,
        SharedSetsPerAccountForBrand = 185,
        LookalikeUserListsPerCustomer = 186,
    }
    impl ResourceLimitType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ResourceLimitType::Unspecified => "UNSPECIFIED",
                ResourceLimitType::Unknown => "UNKNOWN",
                ResourceLimitType::CampaignsPerCustomer => "CAMPAIGNS_PER_CUSTOMER",
                ResourceLimitType::BaseCampaignsPerCustomer => {
                    "BASE_CAMPAIGNS_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentCampaignsPerCustomer => {
                    "EXPERIMENT_CAMPAIGNS_PER_CUSTOMER"
                }
                ResourceLimitType::HotelCampaignsPerCustomer => {
                    "HOTEL_CAMPAIGNS_PER_CUSTOMER"
                }
                ResourceLimitType::SmartShoppingCampaignsPerCustomer => {
                    "SMART_SHOPPING_CAMPAIGNS_PER_CUSTOMER"
                }
                ResourceLimitType::AdGroupsPerCampaign => "AD_GROUPS_PER_CAMPAIGN",
                ResourceLimitType::AdGroupsPerShoppingCampaign => {
                    "AD_GROUPS_PER_SHOPPING_CAMPAIGN"
                }
                ResourceLimitType::AdGroupsPerHotelCampaign => {
                    "AD_GROUPS_PER_HOTEL_CAMPAIGN"
                }
                ResourceLimitType::ReportingAdGroupsPerLocalCampaign => {
                    "REPORTING_AD_GROUPS_PER_LOCAL_CAMPAIGN"
                }
                ResourceLimitType::ReportingAdGroupsPerAppCampaign => {
                    "REPORTING_AD_GROUPS_PER_APP_CAMPAIGN"
                }
                ResourceLimitType::ManagedAdGroupsPerSmartCampaign => {
                    "MANAGED_AD_GROUPS_PER_SMART_CAMPAIGN"
                }
                ResourceLimitType::AdGroupCriteriaPerCustomer => {
                    "AD_GROUP_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::BaseAdGroupCriteriaPerCustomer => {
                    "BASE_AD_GROUP_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentAdGroupCriteriaPerCustomer => {
                    "EXPERIMENT_AD_GROUP_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::AdGroupCriteriaPerCampaign => {
                    "AD_GROUP_CRITERIA_PER_CAMPAIGN"
                }
                ResourceLimitType::CampaignCriteriaPerCustomer => {
                    "CAMPAIGN_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::BaseCampaignCriteriaPerCustomer => {
                    "BASE_CAMPAIGN_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentCampaignCriteriaPerCustomer => {
                    "EXPERIMENT_CAMPAIGN_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::WebpageCriteriaPerCustomer => {
                    "WEBPAGE_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::BaseWebpageCriteriaPerCustomer => {
                    "BASE_WEBPAGE_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentWebpageCriteriaPerCustomer => {
                    "EXPERIMENT_WEBPAGE_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::CombinedAudienceCriteriaPerAdGroup => {
                    "COMBINED_AUDIENCE_CRITERIA_PER_AD_GROUP"
                }
                ResourceLimitType::CustomerNegativePlacementCriteriaPerCustomer => {
                    "CUSTOMER_NEGATIVE_PLACEMENT_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::CustomerNegativeYoutubeChannelCriteriaPerCustomer => {
                    "CUSTOMER_NEGATIVE_YOUTUBE_CHANNEL_CRITERIA_PER_CUSTOMER"
                }
                ResourceLimitType::CriteriaPerAdGroup => "CRITERIA_PER_AD_GROUP",
                ResourceLimitType::ListingGroupsPerAdGroup => {
                    "LISTING_GROUPS_PER_AD_GROUP"
                }
                ResourceLimitType::ExplicitlySharedBudgetsPerCustomer => {
                    "EXPLICITLY_SHARED_BUDGETS_PER_CUSTOMER"
                }
                ResourceLimitType::ImplicitlySharedBudgetsPerCustomer => {
                    "IMPLICITLY_SHARED_BUDGETS_PER_CUSTOMER"
                }
                ResourceLimitType::CombinedAudienceCriteriaPerCampaign => {
                    "COMBINED_AUDIENCE_CRITERIA_PER_CAMPAIGN"
                }
                ResourceLimitType::NegativeKeywordsPerCampaign => {
                    "NEGATIVE_KEYWORDS_PER_CAMPAIGN"
                }
                ResourceLimitType::NegativePlacementsPerCampaign => {
                    "NEGATIVE_PLACEMENTS_PER_CAMPAIGN"
                }
                ResourceLimitType::GeoTargetsPerCampaign => "GEO_TARGETS_PER_CAMPAIGN",
                ResourceLimitType::NegativeIpBlocksPerCampaign => {
                    "NEGATIVE_IP_BLOCKS_PER_CAMPAIGN"
                }
                ResourceLimitType::ProximitiesPerCampaign => "PROXIMITIES_PER_CAMPAIGN",
                ResourceLimitType::ListingScopesPerShoppingCampaign => {
                    "LISTING_SCOPES_PER_SHOPPING_CAMPAIGN"
                }
                ResourceLimitType::ListingScopesPerNonShoppingCampaign => {
                    "LISTING_SCOPES_PER_NON_SHOPPING_CAMPAIGN"
                }
                ResourceLimitType::NegativeKeywordsPerSharedSet => {
                    "NEGATIVE_KEYWORDS_PER_SHARED_SET"
                }
                ResourceLimitType::NegativePlacementsPerSharedSet => {
                    "NEGATIVE_PLACEMENTS_PER_SHARED_SET"
                }
                ResourceLimitType::SharedSetsPerCustomerForTypeDefault => {
                    "SHARED_SETS_PER_CUSTOMER_FOR_TYPE_DEFAULT"
                }
                ResourceLimitType::SharedSetsPerCustomerForNegativePlacementListLower => {
                    "SHARED_SETS_PER_CUSTOMER_FOR_NEGATIVE_PLACEMENT_LIST_LOWER"
                }
                ResourceLimitType::HotelAdvanceBookingWindowBidModifiersPerAdGroup => {
                    "HOTEL_ADVANCE_BOOKING_WINDOW_BID_MODIFIERS_PER_AD_GROUP"
                }
                ResourceLimitType::BiddingStrategiesPerCustomer => {
                    "BIDDING_STRATEGIES_PER_CUSTOMER"
                }
                ResourceLimitType::BasicUserListsPerCustomer => {
                    "BASIC_USER_LISTS_PER_CUSTOMER"
                }
                ResourceLimitType::LogicalUserListsPerCustomer => {
                    "LOGICAL_USER_LISTS_PER_CUSTOMER"
                }
                ResourceLimitType::RuleBasedUserListsPerCustomer => {
                    "RULE_BASED_USER_LISTS_PER_CUSTOMER"
                }
                ResourceLimitType::BaseAdGroupAdsPerCustomer => {
                    "BASE_AD_GROUP_ADS_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentAdGroupAdsPerCustomer => {
                    "EXPERIMENT_AD_GROUP_ADS_PER_CUSTOMER"
                }
                ResourceLimitType::AdGroupAdsPerCampaign => "AD_GROUP_ADS_PER_CAMPAIGN",
                ResourceLimitType::TextAndOtherAdsPerAdGroup => {
                    "TEXT_AND_OTHER_ADS_PER_AD_GROUP"
                }
                ResourceLimitType::ImageAdsPerAdGroup => "IMAGE_ADS_PER_AD_GROUP",
                ResourceLimitType::ShoppingSmartAdsPerAdGroup => {
                    "SHOPPING_SMART_ADS_PER_AD_GROUP"
                }
                ResourceLimitType::ResponsiveSearchAdsPerAdGroup => {
                    "RESPONSIVE_SEARCH_ADS_PER_AD_GROUP"
                }
                ResourceLimitType::AppAdsPerAdGroup => "APP_ADS_PER_AD_GROUP",
                ResourceLimitType::AppEngagementAdsPerAdGroup => {
                    "APP_ENGAGEMENT_ADS_PER_AD_GROUP"
                }
                ResourceLimitType::LocalAdsPerAdGroup => "LOCAL_ADS_PER_AD_GROUP",
                ResourceLimitType::VideoAdsPerAdGroup => "VIDEO_ADS_PER_AD_GROUP",
                ResourceLimitType::LeadFormCampaignAssetsPerCampaign => {
                    "LEAD_FORM_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::PromotionCustomerAssetsPerCustomer => {
                    "PROMOTION_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::PromotionCampaignAssetsPerCampaign => {
                    "PROMOTION_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::PromotionAdGroupAssetsPerAdGroup => {
                    "PROMOTION_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::CalloutCustomerAssetsPerCustomer => {
                    "CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::CalloutCampaignAssetsPerCampaign => {
                    "CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::CalloutAdGroupAssetsPerAdGroup => {
                    "CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::SitelinkCustomerAssetsPerCustomer => {
                    "SITELINK_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::SitelinkCampaignAssetsPerCampaign => {
                    "SITELINK_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::SitelinkAdGroupAssetsPerAdGroup => {
                    "SITELINK_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::StructuredSnippetCustomerAssetsPerCustomer => {
                    "STRUCTURED_SNIPPET_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::StructuredSnippetCampaignAssetsPerCampaign => {
                    "STRUCTURED_SNIPPET_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::StructuredSnippetAdGroupAssetsPerAdGroup => {
                    "STRUCTURED_SNIPPET_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::MobileAppCustomerAssetsPerCustomer => {
                    "MOBILE_APP_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::MobileAppCampaignAssetsPerCampaign => {
                    "MOBILE_APP_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::MobileAppAdGroupAssetsPerAdGroup => {
                    "MOBILE_APP_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::HotelCalloutCustomerAssetsPerCustomer => {
                    "HOTEL_CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::HotelCalloutCampaignAssetsPerCampaign => {
                    "HOTEL_CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::HotelCalloutAdGroupAssetsPerAdGroup => {
                    "HOTEL_CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::CallCustomerAssetsPerCustomer => {
                    "CALL_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::CallCampaignAssetsPerCampaign => {
                    "CALL_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::CallAdGroupAssetsPerAdGroup => {
                    "CALL_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::PriceCustomerAssetsPerCustomer => {
                    "PRICE_CUSTOMER_ASSETS_PER_CUSTOMER"
                }
                ResourceLimitType::PriceCampaignAssetsPerCampaign => {
                    "PRICE_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::PriceAdGroupAssetsPerAdGroup => {
                    "PRICE_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::AdImageCampaignAssetsPerCampaign => {
                    "AD_IMAGE_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::AdImageAdGroupAssetsPerAdGroup => {
                    "AD_IMAGE_AD_GROUP_ASSETS_PER_AD_GROUP"
                }
                ResourceLimitType::PageFeedAssetSetsPerCustomer => {
                    "PAGE_FEED_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::DynamicEducationFeedAssetSetsPerCustomer => {
                    "DYNAMIC_EDUCATION_FEED_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerPageFeedAssetSet => {
                    "ASSETS_PER_PAGE_FEED_ASSET_SET"
                }
                ResourceLimitType::AssetsPerDynamicEducationFeedAssetSet => {
                    "ASSETS_PER_DYNAMIC_EDUCATION_FEED_ASSET_SET"
                }
                ResourceLimitType::DynamicRealEstateAssetSetsPerCustomer => {
                    "DYNAMIC_REAL_ESTATE_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicRealEstateAssetSet => {
                    "ASSETS_PER_DYNAMIC_REAL_ESTATE_ASSET_SET"
                }
                ResourceLimitType::DynamicCustomAssetSetsPerCustomer => {
                    "DYNAMIC_CUSTOM_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicCustomAssetSet => {
                    "ASSETS_PER_DYNAMIC_CUSTOM_ASSET_SET"
                }
                ResourceLimitType::DynamicHotelsAndRentalsAssetSetsPerCustomer => {
                    "DYNAMIC_HOTELS_AND_RENTALS_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicHotelsAndRentalsAssetSet => {
                    "ASSETS_PER_DYNAMIC_HOTELS_AND_RENTALS_ASSET_SET"
                }
                ResourceLimitType::DynamicLocalAssetSetsPerCustomer => {
                    "DYNAMIC_LOCAL_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicLocalAssetSet => {
                    "ASSETS_PER_DYNAMIC_LOCAL_ASSET_SET"
                }
                ResourceLimitType::DynamicFlightsAssetSetsPerCustomer => {
                    "DYNAMIC_FLIGHTS_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicFlightsAssetSet => {
                    "ASSETS_PER_DYNAMIC_FLIGHTS_ASSET_SET"
                }
                ResourceLimitType::DynamicTravelAssetSetsPerCustomer => {
                    "DYNAMIC_TRAVEL_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicTravelAssetSet => {
                    "ASSETS_PER_DYNAMIC_TRAVEL_ASSET_SET"
                }
                ResourceLimitType::DynamicJobsAssetSetsPerCustomer => {
                    "DYNAMIC_JOBS_ASSET_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::AssetsPerDynamicJobsAssetSet => {
                    "ASSETS_PER_DYNAMIC_JOBS_ASSET_SET"
                }
                ResourceLimitType::BusinessNameCampaignAssetsPerCampaign => {
                    "BUSINESS_NAME_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::BusinessLogoCampaignAssetsPerCampaign => {
                    "BUSINESS_LOGO_CAMPAIGN_ASSETS_PER_CAMPAIGN"
                }
                ResourceLimitType::VersionsPerAd => "VERSIONS_PER_AD",
                ResourceLimitType::UserFeedsPerCustomer => "USER_FEEDS_PER_CUSTOMER",
                ResourceLimitType::SystemFeedsPerCustomer => "SYSTEM_FEEDS_PER_CUSTOMER",
                ResourceLimitType::FeedAttributesPerFeed => "FEED_ATTRIBUTES_PER_FEED",
                ResourceLimitType::FeedItemsPerCustomer => "FEED_ITEMS_PER_CUSTOMER",
                ResourceLimitType::CampaignFeedsPerCustomer => {
                    "CAMPAIGN_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::BaseCampaignFeedsPerCustomer => {
                    "BASE_CAMPAIGN_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentCampaignFeedsPerCustomer => {
                    "EXPERIMENT_CAMPAIGN_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::AdGroupFeedsPerCustomer => {
                    "AD_GROUP_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::BaseAdGroupFeedsPerCustomer => {
                    "BASE_AD_GROUP_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentAdGroupFeedsPerCustomer => {
                    "EXPERIMENT_AD_GROUP_FEEDS_PER_CUSTOMER"
                }
                ResourceLimitType::AdGroupFeedsPerCampaign => {
                    "AD_GROUP_FEEDS_PER_CAMPAIGN"
                }
                ResourceLimitType::FeedItemSetsPerCustomer => {
                    "FEED_ITEM_SETS_PER_CUSTOMER"
                }
                ResourceLimitType::FeedItemsPerFeedItemSet => {
                    "FEED_ITEMS_PER_FEED_ITEM_SET"
                }
                ResourceLimitType::CampaignExperimentsPerCustomer => {
                    "CAMPAIGN_EXPERIMENTS_PER_CUSTOMER"
                }
                ResourceLimitType::ExperimentArmsPerVideoExperiment => {
                    "EXPERIMENT_ARMS_PER_VIDEO_EXPERIMENT"
                }
                ResourceLimitType::OwnedLabelsPerCustomer => "OWNED_LABELS_PER_CUSTOMER",
                ResourceLimitType::LabelsPerCampaign => "LABELS_PER_CAMPAIGN",
                ResourceLimitType::LabelsPerAdGroup => "LABELS_PER_AD_GROUP",
                ResourceLimitType::LabelsPerAdGroupAd => "LABELS_PER_AD_GROUP_AD",
                ResourceLimitType::LabelsPerAdGroupCriterion => {
                    "LABELS_PER_AD_GROUP_CRITERION"
                }
                ResourceLimitType::TargetCustomersPerLabel => {
                    "TARGET_CUSTOMERS_PER_LABEL"
                }
                ResourceLimitType::KeywordPlansPerUserPerCustomer => {
                    "KEYWORD_PLANS_PER_USER_PER_CUSTOMER"
                }
                ResourceLimitType::KeywordPlanAdGroupKeywordsPerKeywordPlan => {
                    "KEYWORD_PLAN_AD_GROUP_KEYWORDS_PER_KEYWORD_PLAN"
                }
                ResourceLimitType::KeywordPlanAdGroupsPerKeywordPlan => {
                    "KEYWORD_PLAN_AD_GROUPS_PER_KEYWORD_PLAN"
                }
                ResourceLimitType::KeywordPlanNegativeKeywordsPerKeywordPlan => {
                    "KEYWORD_PLAN_NEGATIVE_KEYWORDS_PER_KEYWORD_PLAN"
                }
                ResourceLimitType::KeywordPlanCampaignsPerKeywordPlan => {
                    "KEYWORD_PLAN_CAMPAIGNS_PER_KEYWORD_PLAN"
                }
                ResourceLimitType::ConversionActionsPerCustomer => {
                    "CONVERSION_ACTIONS_PER_CUSTOMER"
                }
                ResourceLimitType::BatchJobOperationsPerJob => {
                    "BATCH_JOB_OPERATIONS_PER_JOB"
                }
                ResourceLimitType::BatchJobsPerCustomer => "BATCH_JOBS_PER_CUSTOMER",
                ResourceLimitType::HotelCheckInDateRangeBidModifiersPerAdGroup => {
                    "HOTEL_CHECK_IN_DATE_RANGE_BID_MODIFIERS_PER_AD_GROUP"
                }
                ResourceLimitType::SharedSetsPerAccountForAccountLevelNegativeKeywords => {
                    "SHARED_SETS_PER_ACCOUNT_FOR_ACCOUNT_LEVEL_NEGATIVE_KEYWORDS"
                }
                ResourceLimitType::AccountLevelNegativeKeywordsPerSharedSet => {
                    "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS_PER_SHARED_SET"
                }
                ResourceLimitType::EnabledAssetPerHotelPropertyAssetSet => {
                    "ENABLED_ASSET_PER_HOTEL_PROPERTY_ASSET_SET"
                }
                ResourceLimitType::EnabledHotelPropertyAssetLinksPerAssetGroup => {
                    "ENABLED_HOTEL_PROPERTY_ASSET_LINKS_PER_ASSET_GROUP"
                }
                ResourceLimitType::BrandsPerSharedSet => "BRANDS_PER_SHARED_SET",
                ResourceLimitType::EnabledBrandListCriteriaPerCampaign => {
                    "ENABLED_BRAND_LIST_CRITERIA_PER_CAMPAIGN"
                }
                ResourceLimitType::SharedSetsPerAccountForBrand => {
                    "SHARED_SETS_PER_ACCOUNT_FOR_BRAND"
                }
                ResourceLimitType::LookalikeUserListsPerCustomer => {
                    "LOOKALIKE_USER_LISTS_PER_CUSTOMER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CAMPAIGNS_PER_CUSTOMER" => Some(Self::CampaignsPerCustomer),
                "BASE_CAMPAIGNS_PER_CUSTOMER" => Some(Self::BaseCampaignsPerCustomer),
                "EXPERIMENT_CAMPAIGNS_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignsPerCustomer)
                }
                "HOTEL_CAMPAIGNS_PER_CUSTOMER" => Some(Self::HotelCampaignsPerCustomer),
                "SMART_SHOPPING_CAMPAIGNS_PER_CUSTOMER" => {
                    Some(Self::SmartShoppingCampaignsPerCustomer)
                }
                "AD_GROUPS_PER_CAMPAIGN" => Some(Self::AdGroupsPerCampaign),
                "AD_GROUPS_PER_SHOPPING_CAMPAIGN" => {
                    Some(Self::AdGroupsPerShoppingCampaign)
                }
                "AD_GROUPS_PER_HOTEL_CAMPAIGN" => Some(Self::AdGroupsPerHotelCampaign),
                "REPORTING_AD_GROUPS_PER_LOCAL_CAMPAIGN" => {
                    Some(Self::ReportingAdGroupsPerLocalCampaign)
                }
                "REPORTING_AD_GROUPS_PER_APP_CAMPAIGN" => {
                    Some(Self::ReportingAdGroupsPerAppCampaign)
                }
                "MANAGED_AD_GROUPS_PER_SMART_CAMPAIGN" => {
                    Some(Self::ManagedAdGroupsPerSmartCampaign)
                }
                "AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::AdGroupCriteriaPerCustomer)
                }
                "BASE_AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseAdGroupCriteriaPerCustomer)
                }
                "EXPERIMENT_AD_GROUP_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupCriteriaPerCustomer)
                }
                "AD_GROUP_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::AdGroupCriteriaPerCampaign)
                }
                "CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CampaignCriteriaPerCustomer)
                }
                "BASE_CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseCampaignCriteriaPerCustomer)
                }
                "EXPERIMENT_CAMPAIGN_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignCriteriaPerCustomer)
                }
                "WEBPAGE_CRITERIA_PER_CUSTOMER" => Some(Self::WebpageCriteriaPerCustomer),
                "BASE_WEBPAGE_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::BaseWebpageCriteriaPerCustomer)
                }
                "EXPERIMENT_WEBPAGE_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::ExperimentWebpageCriteriaPerCustomer)
                }
                "COMBINED_AUDIENCE_CRITERIA_PER_AD_GROUP" => {
                    Some(Self::CombinedAudienceCriteriaPerAdGroup)
                }
                "CUSTOMER_NEGATIVE_PLACEMENT_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CustomerNegativePlacementCriteriaPerCustomer)
                }
                "CUSTOMER_NEGATIVE_YOUTUBE_CHANNEL_CRITERIA_PER_CUSTOMER" => {
                    Some(Self::CustomerNegativeYoutubeChannelCriteriaPerCustomer)
                }
                "CRITERIA_PER_AD_GROUP" => Some(Self::CriteriaPerAdGroup),
                "LISTING_GROUPS_PER_AD_GROUP" => Some(Self::ListingGroupsPerAdGroup),
                "EXPLICITLY_SHARED_BUDGETS_PER_CUSTOMER" => {
                    Some(Self::ExplicitlySharedBudgetsPerCustomer)
                }
                "IMPLICITLY_SHARED_BUDGETS_PER_CUSTOMER" => {
                    Some(Self::ImplicitlySharedBudgetsPerCustomer)
                }
                "COMBINED_AUDIENCE_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::CombinedAudienceCriteriaPerCampaign)
                }
                "NEGATIVE_KEYWORDS_PER_CAMPAIGN" => {
                    Some(Self::NegativeKeywordsPerCampaign)
                }
                "NEGATIVE_PLACEMENTS_PER_CAMPAIGN" => {
                    Some(Self::NegativePlacementsPerCampaign)
                }
                "GEO_TARGETS_PER_CAMPAIGN" => Some(Self::GeoTargetsPerCampaign),
                "NEGATIVE_IP_BLOCKS_PER_CAMPAIGN" => {
                    Some(Self::NegativeIpBlocksPerCampaign)
                }
                "PROXIMITIES_PER_CAMPAIGN" => Some(Self::ProximitiesPerCampaign),
                "LISTING_SCOPES_PER_SHOPPING_CAMPAIGN" => {
                    Some(Self::ListingScopesPerShoppingCampaign)
                }
                "LISTING_SCOPES_PER_NON_SHOPPING_CAMPAIGN" => {
                    Some(Self::ListingScopesPerNonShoppingCampaign)
                }
                "NEGATIVE_KEYWORDS_PER_SHARED_SET" => {
                    Some(Self::NegativeKeywordsPerSharedSet)
                }
                "NEGATIVE_PLACEMENTS_PER_SHARED_SET" => {
                    Some(Self::NegativePlacementsPerSharedSet)
                }
                "SHARED_SETS_PER_CUSTOMER_FOR_TYPE_DEFAULT" => {
                    Some(Self::SharedSetsPerCustomerForTypeDefault)
                }
                "SHARED_SETS_PER_CUSTOMER_FOR_NEGATIVE_PLACEMENT_LIST_LOWER" => {
                    Some(Self::SharedSetsPerCustomerForNegativePlacementListLower)
                }
                "HOTEL_ADVANCE_BOOKING_WINDOW_BID_MODIFIERS_PER_AD_GROUP" => {
                    Some(Self::HotelAdvanceBookingWindowBidModifiersPerAdGroup)
                }
                "BIDDING_STRATEGIES_PER_CUSTOMER" => {
                    Some(Self::BiddingStrategiesPerCustomer)
                }
                "BASIC_USER_LISTS_PER_CUSTOMER" => Some(Self::BasicUserListsPerCustomer),
                "LOGICAL_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::LogicalUserListsPerCustomer)
                }
                "RULE_BASED_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::RuleBasedUserListsPerCustomer)
                }
                "BASE_AD_GROUP_ADS_PER_CUSTOMER" => Some(Self::BaseAdGroupAdsPerCustomer),
                "EXPERIMENT_AD_GROUP_ADS_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupAdsPerCustomer)
                }
                "AD_GROUP_ADS_PER_CAMPAIGN" => Some(Self::AdGroupAdsPerCampaign),
                "TEXT_AND_OTHER_ADS_PER_AD_GROUP" => {
                    Some(Self::TextAndOtherAdsPerAdGroup)
                }
                "IMAGE_ADS_PER_AD_GROUP" => Some(Self::ImageAdsPerAdGroup),
                "SHOPPING_SMART_ADS_PER_AD_GROUP" => {
                    Some(Self::ShoppingSmartAdsPerAdGroup)
                }
                "RESPONSIVE_SEARCH_ADS_PER_AD_GROUP" => {
                    Some(Self::ResponsiveSearchAdsPerAdGroup)
                }
                "APP_ADS_PER_AD_GROUP" => Some(Self::AppAdsPerAdGroup),
                "APP_ENGAGEMENT_ADS_PER_AD_GROUP" => {
                    Some(Self::AppEngagementAdsPerAdGroup)
                }
                "LOCAL_ADS_PER_AD_GROUP" => Some(Self::LocalAdsPerAdGroup),
                "VIDEO_ADS_PER_AD_GROUP" => Some(Self::VideoAdsPerAdGroup),
                "LEAD_FORM_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::LeadFormCampaignAssetsPerCampaign)
                }
                "PROMOTION_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::PromotionCustomerAssetsPerCustomer)
                }
                "PROMOTION_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::PromotionCampaignAssetsPerCampaign)
                }
                "PROMOTION_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::PromotionAdGroupAssetsPerAdGroup)
                }
                "CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::CalloutCustomerAssetsPerCustomer)
                }
                "CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::CalloutCampaignAssetsPerCampaign)
                }
                "CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::CalloutAdGroupAssetsPerAdGroup)
                }
                "SITELINK_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::SitelinkCustomerAssetsPerCustomer)
                }
                "SITELINK_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::SitelinkCampaignAssetsPerCampaign)
                }
                "SITELINK_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::SitelinkAdGroupAssetsPerAdGroup)
                }
                "STRUCTURED_SNIPPET_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::StructuredSnippetCustomerAssetsPerCustomer)
                }
                "STRUCTURED_SNIPPET_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::StructuredSnippetCampaignAssetsPerCampaign)
                }
                "STRUCTURED_SNIPPET_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::StructuredSnippetAdGroupAssetsPerAdGroup)
                }
                "MOBILE_APP_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::MobileAppCustomerAssetsPerCustomer)
                }
                "MOBILE_APP_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::MobileAppCampaignAssetsPerCampaign)
                }
                "MOBILE_APP_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::MobileAppAdGroupAssetsPerAdGroup)
                }
                "HOTEL_CALLOUT_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::HotelCalloutCustomerAssetsPerCustomer)
                }
                "HOTEL_CALLOUT_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::HotelCalloutCampaignAssetsPerCampaign)
                }
                "HOTEL_CALLOUT_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::HotelCalloutAdGroupAssetsPerAdGroup)
                }
                "CALL_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::CallCustomerAssetsPerCustomer)
                }
                "CALL_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::CallCampaignAssetsPerCampaign)
                }
                "CALL_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::CallAdGroupAssetsPerAdGroup)
                }
                "PRICE_CUSTOMER_ASSETS_PER_CUSTOMER" => {
                    Some(Self::PriceCustomerAssetsPerCustomer)
                }
                "PRICE_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::PriceCampaignAssetsPerCampaign)
                }
                "PRICE_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::PriceAdGroupAssetsPerAdGroup)
                }
                "AD_IMAGE_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::AdImageCampaignAssetsPerCampaign)
                }
                "AD_IMAGE_AD_GROUP_ASSETS_PER_AD_GROUP" => {
                    Some(Self::AdImageAdGroupAssetsPerAdGroup)
                }
                "PAGE_FEED_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::PageFeedAssetSetsPerCustomer)
                }
                "DYNAMIC_EDUCATION_FEED_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicEducationFeedAssetSetsPerCustomer)
                }
                "ASSETS_PER_PAGE_FEED_ASSET_SET" => Some(Self::AssetsPerPageFeedAssetSet),
                "ASSETS_PER_DYNAMIC_EDUCATION_FEED_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicEducationFeedAssetSet)
                }
                "DYNAMIC_REAL_ESTATE_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicRealEstateAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_REAL_ESTATE_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicRealEstateAssetSet)
                }
                "DYNAMIC_CUSTOM_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicCustomAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_CUSTOM_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicCustomAssetSet)
                }
                "DYNAMIC_HOTELS_AND_RENTALS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicHotelsAndRentalsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_HOTELS_AND_RENTALS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicHotelsAndRentalsAssetSet)
                }
                "DYNAMIC_LOCAL_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicLocalAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_LOCAL_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicLocalAssetSet)
                }
                "DYNAMIC_FLIGHTS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicFlightsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_FLIGHTS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicFlightsAssetSet)
                }
                "DYNAMIC_TRAVEL_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicTravelAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_TRAVEL_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicTravelAssetSet)
                }
                "DYNAMIC_JOBS_ASSET_SETS_PER_CUSTOMER" => {
                    Some(Self::DynamicJobsAssetSetsPerCustomer)
                }
                "ASSETS_PER_DYNAMIC_JOBS_ASSET_SET" => {
                    Some(Self::AssetsPerDynamicJobsAssetSet)
                }
                "BUSINESS_NAME_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::BusinessNameCampaignAssetsPerCampaign)
                }
                "BUSINESS_LOGO_CAMPAIGN_ASSETS_PER_CAMPAIGN" => {
                    Some(Self::BusinessLogoCampaignAssetsPerCampaign)
                }
                "VERSIONS_PER_AD" => Some(Self::VersionsPerAd),
                "USER_FEEDS_PER_CUSTOMER" => Some(Self::UserFeedsPerCustomer),
                "SYSTEM_FEEDS_PER_CUSTOMER" => Some(Self::SystemFeedsPerCustomer),
                "FEED_ATTRIBUTES_PER_FEED" => Some(Self::FeedAttributesPerFeed),
                "FEED_ITEMS_PER_CUSTOMER" => Some(Self::FeedItemsPerCustomer),
                "CAMPAIGN_FEEDS_PER_CUSTOMER" => Some(Self::CampaignFeedsPerCustomer),
                "BASE_CAMPAIGN_FEEDS_PER_CUSTOMER" => {
                    Some(Self::BaseCampaignFeedsPerCustomer)
                }
                "EXPERIMENT_CAMPAIGN_FEEDS_PER_CUSTOMER" => {
                    Some(Self::ExperimentCampaignFeedsPerCustomer)
                }
                "AD_GROUP_FEEDS_PER_CUSTOMER" => Some(Self::AdGroupFeedsPerCustomer),
                "BASE_AD_GROUP_FEEDS_PER_CUSTOMER" => {
                    Some(Self::BaseAdGroupFeedsPerCustomer)
                }
                "EXPERIMENT_AD_GROUP_FEEDS_PER_CUSTOMER" => {
                    Some(Self::ExperimentAdGroupFeedsPerCustomer)
                }
                "AD_GROUP_FEEDS_PER_CAMPAIGN" => Some(Self::AdGroupFeedsPerCampaign),
                "FEED_ITEM_SETS_PER_CUSTOMER" => Some(Self::FeedItemSetsPerCustomer),
                "FEED_ITEMS_PER_FEED_ITEM_SET" => Some(Self::FeedItemsPerFeedItemSet),
                "CAMPAIGN_EXPERIMENTS_PER_CUSTOMER" => {
                    Some(Self::CampaignExperimentsPerCustomer)
                }
                "EXPERIMENT_ARMS_PER_VIDEO_EXPERIMENT" => {
                    Some(Self::ExperimentArmsPerVideoExperiment)
                }
                "OWNED_LABELS_PER_CUSTOMER" => Some(Self::OwnedLabelsPerCustomer),
                "LABELS_PER_CAMPAIGN" => Some(Self::LabelsPerCampaign),
                "LABELS_PER_AD_GROUP" => Some(Self::LabelsPerAdGroup),
                "LABELS_PER_AD_GROUP_AD" => Some(Self::LabelsPerAdGroupAd),
                "LABELS_PER_AD_GROUP_CRITERION" => Some(Self::LabelsPerAdGroupCriterion),
                "TARGET_CUSTOMERS_PER_LABEL" => Some(Self::TargetCustomersPerLabel),
                "KEYWORD_PLANS_PER_USER_PER_CUSTOMER" => {
                    Some(Self::KeywordPlansPerUserPerCustomer)
                }
                "KEYWORD_PLAN_AD_GROUP_KEYWORDS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanAdGroupKeywordsPerKeywordPlan)
                }
                "KEYWORD_PLAN_AD_GROUPS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanAdGroupsPerKeywordPlan)
                }
                "KEYWORD_PLAN_NEGATIVE_KEYWORDS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanNegativeKeywordsPerKeywordPlan)
                }
                "KEYWORD_PLAN_CAMPAIGNS_PER_KEYWORD_PLAN" => {
                    Some(Self::KeywordPlanCampaignsPerKeywordPlan)
                }
                "CONVERSION_ACTIONS_PER_CUSTOMER" => {
                    Some(Self::ConversionActionsPerCustomer)
                }
                "BATCH_JOB_OPERATIONS_PER_JOB" => Some(Self::BatchJobOperationsPerJob),
                "BATCH_JOBS_PER_CUSTOMER" => Some(Self::BatchJobsPerCustomer),
                "HOTEL_CHECK_IN_DATE_RANGE_BID_MODIFIERS_PER_AD_GROUP" => {
                    Some(Self::HotelCheckInDateRangeBidModifiersPerAdGroup)
                }
                "SHARED_SETS_PER_ACCOUNT_FOR_ACCOUNT_LEVEL_NEGATIVE_KEYWORDS" => {
                    Some(Self::SharedSetsPerAccountForAccountLevelNegativeKeywords)
                }
                "ACCOUNT_LEVEL_NEGATIVE_KEYWORDS_PER_SHARED_SET" => {
                    Some(Self::AccountLevelNegativeKeywordsPerSharedSet)
                }
                "ENABLED_ASSET_PER_HOTEL_PROPERTY_ASSET_SET" => {
                    Some(Self::EnabledAssetPerHotelPropertyAssetSet)
                }
                "ENABLED_HOTEL_PROPERTY_ASSET_LINKS_PER_ASSET_GROUP" => {
                    Some(Self::EnabledHotelPropertyAssetLinksPerAssetGroup)
                }
                "BRANDS_PER_SHARED_SET" => Some(Self::BrandsPerSharedSet),
                "ENABLED_BRAND_LIST_CRITERIA_PER_CAMPAIGN" => {
                    Some(Self::EnabledBrandListCriteriaPerCampaign)
                }
                "SHARED_SETS_PER_ACCOUNT_FOR_BRAND" => {
                    Some(Self::SharedSetsPerAccountForBrand)
                }
                "LOOKALIKE_USER_LISTS_PER_CUSTOMER" => {
                    Some(Self::LookalikeUserListsPerCustomer)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanConceptGroupTypeEnum {}
/// Nested message and enum types in `KeywordPlanConceptGroupTypeEnum`.
pub mod keyword_plan_concept_group_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanConceptGroupType {
        Unspecified = 0,
        Unknown = 1,
        Brand = 2,
        OtherBrands = 3,
        NonBrand = 4,
    }
    impl KeywordPlanConceptGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanConceptGroupType::Unspecified => "UNSPECIFIED",
                KeywordPlanConceptGroupType::Unknown => "UNKNOWN",
                KeywordPlanConceptGroupType::Brand => "BRAND",
                KeywordPlanConceptGroupType::OtherBrands => "OTHER_BRANDS",
                KeywordPlanConceptGroupType::NonBrand => "NON_BRAND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BRAND" => Some(Self::Brand),
                "OTHER_BRANDS" => Some(Self::OtherBrands),
                "NON_BRAND" => Some(Self::NonBrand),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ExternalConversionSourceEnum {}
/// Nested message and enum types in `ExternalConversionSourceEnum`.
pub mod external_conversion_source_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ExternalConversionSource {
        Unspecified = 0,
        Unknown = 1,
        Webpage = 2,
        Analytics = 3,
        Upload = 4,
        AdCallMetrics = 5,
        WebsiteCallMetrics = 6,
        StoreVisits = 7,
        AndroidInApp = 8,
        IosInApp = 9,
        IosFirstOpen = 10,
        AppUnspecified = 11,
        AndroidFirstOpen = 12,
        UploadCalls = 13,
        Firebase = 14,
        ClickToCall = 15,
        Salesforce = 16,
        StoreSalesCrm = 17,
        StoreSalesPaymentNetwork = 18,
        GooglePlay = 19,
        ThirdPartyAppAnalytics = 20,
        GoogleAttribution = 21,
        StoreSalesDirectUpload = 23,
        StoreSales = 24,
        SearchAds360 = 25,
        GoogleHosted = 27,
        Floodlight = 29,
        AnalyticsSearchAds360 = 31,
        FirebaseSearchAds360 = 33,
        DisplayAndVideo360Floodlight = 34,
    }
    impl ExternalConversionSource {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ExternalConversionSource::Unspecified => "UNSPECIFIED",
                ExternalConversionSource::Unknown => "UNKNOWN",
                ExternalConversionSource::Webpage => "WEBPAGE",
                ExternalConversionSource::Analytics => "ANALYTICS",
                ExternalConversionSource::Upload => "UPLOAD",
                ExternalConversionSource::AdCallMetrics => "AD_CALL_METRICS",
                ExternalConversionSource::WebsiteCallMetrics => "WEBSITE_CALL_METRICS",
                ExternalConversionSource::StoreVisits => "STORE_VISITS",
                ExternalConversionSource::AndroidInApp => "ANDROID_IN_APP",
                ExternalConversionSource::IosInApp => "IOS_IN_APP",
                ExternalConversionSource::IosFirstOpen => "IOS_FIRST_OPEN",
                ExternalConversionSource::AppUnspecified => "APP_UNSPECIFIED",
                ExternalConversionSource::AndroidFirstOpen => "ANDROID_FIRST_OPEN",
                ExternalConversionSource::UploadCalls => "UPLOAD_CALLS",
                ExternalConversionSource::Firebase => "FIREBASE",
                ExternalConversionSource::ClickToCall => "CLICK_TO_CALL",
                ExternalConversionSource::Salesforce => "SALESFORCE",
                ExternalConversionSource::StoreSalesCrm => "STORE_SALES_CRM",
                ExternalConversionSource::StoreSalesPaymentNetwork => {
                    "STORE_SALES_PAYMENT_NETWORK"
                }
                ExternalConversionSource::GooglePlay => "GOOGLE_PLAY",
                ExternalConversionSource::ThirdPartyAppAnalytics => {
                    "THIRD_PARTY_APP_ANALYTICS"
                }
                ExternalConversionSource::GoogleAttribution => "GOOGLE_ATTRIBUTION",
                ExternalConversionSource::StoreSalesDirectUpload => {
                    "STORE_SALES_DIRECT_UPLOAD"
                }
                ExternalConversionSource::StoreSales => "STORE_SALES",
                ExternalConversionSource::SearchAds360 => "SEARCH_ADS_360",
                ExternalConversionSource::GoogleHosted => "GOOGLE_HOSTED",
                ExternalConversionSource::Floodlight => "FLOODLIGHT",
                ExternalConversionSource::AnalyticsSearchAds360 => {
                    "ANALYTICS_SEARCH_ADS_360"
                }
                ExternalConversionSource::FirebaseSearchAds360 => {
                    "FIREBASE_SEARCH_ADS_360"
                }
                ExternalConversionSource::DisplayAndVideo360Floodlight => {
                    "DISPLAY_AND_VIDEO_360_FLOODLIGHT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "WEBPAGE" => Some(Self::Webpage),
                "ANALYTICS" => Some(Self::Analytics),
                "UPLOAD" => Some(Self::Upload),
                "AD_CALL_METRICS" => Some(Self::AdCallMetrics),
                "WEBSITE_CALL_METRICS" => Some(Self::WebsiteCallMetrics),
                "STORE_VISITS" => Some(Self::StoreVisits),
                "ANDROID_IN_APP" => Some(Self::AndroidInApp),
                "IOS_IN_APP" => Some(Self::IosInApp),
                "IOS_FIRST_OPEN" => Some(Self::IosFirstOpen),
                "APP_UNSPECIFIED" => Some(Self::AppUnspecified),
                "ANDROID_FIRST_OPEN" => Some(Self::AndroidFirstOpen),
                "UPLOAD_CALLS" => Some(Self::UploadCalls),
                "FIREBASE" => Some(Self::Firebase),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "SALESFORCE" => Some(Self::Salesforce),
                "STORE_SALES_CRM" => Some(Self::StoreSalesCrm),
                "STORE_SALES_PAYMENT_NETWORK" => Some(Self::StoreSalesPaymentNetwork),
                "GOOGLE_PLAY" => Some(Self::GooglePlay),
                "THIRD_PARTY_APP_ANALYTICS" => Some(Self::ThirdPartyAppAnalytics),
                "GOOGLE_ATTRIBUTION" => Some(Self::GoogleAttribution),
                "STORE_SALES_DIRECT_UPLOAD" => Some(Self::StoreSalesDirectUpload),
                "STORE_SALES" => Some(Self::StoreSales),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "FLOODLIGHT" => Some(Self::Floodlight),
                "ANALYTICS_SEARCH_ADS_360" => Some(Self::AnalyticsSearchAds360),
                "FIREBASE_SEARCH_ADS_360" => Some(Self::FirebaseSearchAds360),
                "DISPLAY_AND_VIDEO_360_FLOODLIGHT" => {
                    Some(Self::DisplayAndVideo360Floodlight)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionLagBucketEnum {}
/// Nested message and enum types in `ConversionLagBucketEnum`.
pub mod conversion_lag_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionLagBucket {
        Unspecified = 0,
        Unknown = 1,
        LessThanOneDay = 2,
        OneToTwoDays = 3,
        TwoToThreeDays = 4,
        ThreeToFourDays = 5,
        FourToFiveDays = 6,
        FiveToSixDays = 7,
        SixToSevenDays = 8,
        SevenToEightDays = 9,
        EightToNineDays = 10,
        NineToTenDays = 11,
        TenToElevenDays = 12,
        ElevenToTwelveDays = 13,
        TwelveToThirteenDays = 14,
        ThirteenToFourteenDays = 15,
        FourteenToTwentyOneDays = 16,
        TwentyOneToThirtyDays = 17,
        ThirtyToFortyFiveDays = 18,
        FortyFiveToSixtyDays = 19,
        SixtyToNinetyDays = 20,
    }
    impl ConversionLagBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionLagBucket::Unspecified => "UNSPECIFIED",
                ConversionLagBucket::Unknown => "UNKNOWN",
                ConversionLagBucket::LessThanOneDay => "LESS_THAN_ONE_DAY",
                ConversionLagBucket::OneToTwoDays => "ONE_TO_TWO_DAYS",
                ConversionLagBucket::TwoToThreeDays => "TWO_TO_THREE_DAYS",
                ConversionLagBucket::ThreeToFourDays => "THREE_TO_FOUR_DAYS",
                ConversionLagBucket::FourToFiveDays => "FOUR_TO_FIVE_DAYS",
                ConversionLagBucket::FiveToSixDays => "FIVE_TO_SIX_DAYS",
                ConversionLagBucket::SixToSevenDays => "SIX_TO_SEVEN_DAYS",
                ConversionLagBucket::SevenToEightDays => "SEVEN_TO_EIGHT_DAYS",
                ConversionLagBucket::EightToNineDays => "EIGHT_TO_NINE_DAYS",
                ConversionLagBucket::NineToTenDays => "NINE_TO_TEN_DAYS",
                ConversionLagBucket::TenToElevenDays => "TEN_TO_ELEVEN_DAYS",
                ConversionLagBucket::ElevenToTwelveDays => "ELEVEN_TO_TWELVE_DAYS",
                ConversionLagBucket::TwelveToThirteenDays => "TWELVE_TO_THIRTEEN_DAYS",
                ConversionLagBucket::ThirteenToFourteenDays => {
                    "THIRTEEN_TO_FOURTEEN_DAYS"
                }
                ConversionLagBucket::FourteenToTwentyOneDays => {
                    "FOURTEEN_TO_TWENTY_ONE_DAYS"
                }
                ConversionLagBucket::TwentyOneToThirtyDays => "TWENTY_ONE_TO_THIRTY_DAYS",
                ConversionLagBucket::ThirtyToFortyFiveDays => "THIRTY_TO_FORTY_FIVE_DAYS",
                ConversionLagBucket::FortyFiveToSixtyDays => "FORTY_FIVE_TO_SIXTY_DAYS",
                ConversionLagBucket::SixtyToNinetyDays => "SIXTY_TO_NINETY_DAYS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LESS_THAN_ONE_DAY" => Some(Self::LessThanOneDay),
                "ONE_TO_TWO_DAYS" => Some(Self::OneToTwoDays),
                "TWO_TO_THREE_DAYS" => Some(Self::TwoToThreeDays),
                "THREE_TO_FOUR_DAYS" => Some(Self::ThreeToFourDays),
                "FOUR_TO_FIVE_DAYS" => Some(Self::FourToFiveDays),
                "FIVE_TO_SIX_DAYS" => Some(Self::FiveToSixDays),
                "SIX_TO_SEVEN_DAYS" => Some(Self::SixToSevenDays),
                "SEVEN_TO_EIGHT_DAYS" => Some(Self::SevenToEightDays),
                "EIGHT_TO_NINE_DAYS" => Some(Self::EightToNineDays),
                "NINE_TO_TEN_DAYS" => Some(Self::NineToTenDays),
                "TEN_TO_ELEVEN_DAYS" => Some(Self::TenToElevenDays),
                "ELEVEN_TO_TWELVE_DAYS" => Some(Self::ElevenToTwelveDays),
                "TWELVE_TO_THIRTEEN_DAYS" => Some(Self::TwelveToThirteenDays),
                "THIRTEEN_TO_FOURTEEN_DAYS" => Some(Self::ThirteenToFourteenDays),
                "FOURTEEN_TO_TWENTY_ONE_DAYS" => Some(Self::FourteenToTwentyOneDays),
                "TWENTY_ONE_TO_THIRTY_DAYS" => Some(Self::TwentyOneToThirtyDays),
                "THIRTY_TO_FORTY_FIVE_DAYS" => Some(Self::ThirtyToFortyFiveDays),
                "FORTY_FIVE_TO_SIXTY_DAYS" => Some(Self::FortyFiveToSixtyDays),
                "SIXTY_TO_NINETY_DAYS" => Some(Self::SixtyToNinetyDays),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAttributionEventTypeEnum {}
/// Nested message and enum types in `ConversionAttributionEventTypeEnum`.
pub mod conversion_attribution_event_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAttributionEventType {
        Unspecified = 0,
        Unknown = 1,
        Impression = 2,
        Interaction = 3,
    }
    impl ConversionAttributionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionAttributionEventType::Unspecified => "UNSPECIFIED",
                ConversionAttributionEventType::Unknown => "UNKNOWN",
                ConversionAttributionEventType::Impression => "IMPRESSION",
                ConversionAttributionEventType::Interaction => "INTERACTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMPRESSION" => Some(Self::Impression),
                "INTERACTION" => Some(Self::Interaction),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionValueRulePrimaryDimensionEnum {}
/// Nested message and enum types in `ConversionValueRulePrimaryDimensionEnum`.
pub mod conversion_value_rule_primary_dimension_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionValueRulePrimaryDimension {
        Unspecified = 0,
        Unknown = 1,
        NoRuleApplied = 2,
        Original = 3,
        NewVsReturningUser = 4,
        GeoLocation = 5,
        Device = 6,
        Audience = 7,
        Multiple = 8,
    }
    impl ConversionValueRulePrimaryDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionValueRulePrimaryDimension::Unspecified => "UNSPECIFIED",
                ConversionValueRulePrimaryDimension::Unknown => "UNKNOWN",
                ConversionValueRulePrimaryDimension::NoRuleApplied => "NO_RULE_APPLIED",
                ConversionValueRulePrimaryDimension::Original => "ORIGINAL",
                ConversionValueRulePrimaryDimension::NewVsReturningUser => {
                    "NEW_VS_RETURNING_USER"
                }
                ConversionValueRulePrimaryDimension::GeoLocation => "GEO_LOCATION",
                ConversionValueRulePrimaryDimension::Device => "DEVICE",
                ConversionValueRulePrimaryDimension::Audience => "AUDIENCE",
                ConversionValueRulePrimaryDimension::Multiple => "MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_RULE_APPLIED" => Some(Self::NoRuleApplied),
                "ORIGINAL" => Some(Self::Original),
                "NEW_VS_RETURNING_USER" => Some(Self::NewVsReturningUser),
                "GEO_LOCATION" => Some(Self::GeoLocation),
                "DEVICE" => Some(Self::Device),
                "AUDIENCE" => Some(Self::Audience),
                "MULTIPLE" => Some(Self::Multiple),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionEventTypeEnum {}
/// Nested message and enum types in `InteractionEventTypeEnum`.
pub mod interaction_event_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionEventType {
        Unspecified = 0,
        Unknown = 1,
        Click = 2,
        Engagement = 3,
        VideoView = 4,
        None = 5,
    }
    impl InteractionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InteractionEventType::Unspecified => "UNSPECIFIED",
                InteractionEventType::Unknown => "UNKNOWN",
                InteractionEventType::Click => "CLICK",
                InteractionEventType::Engagement => "ENGAGEMENT",
                InteractionEventType::VideoView => "VIDEO_VIEW",
                InteractionEventType::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICK" => Some(Self::Click),
                "ENGAGEMENT" => Some(Self::Engagement),
                "VIDEO_VIEW" => Some(Self::VideoView),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SlotEnum {}
/// Nested message and enum types in `SlotEnum`.
pub mod slot_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Slot {
        Unspecified = 0,
        Unknown = 1,
        SearchSide = 2,
        SearchTop = 3,
        SearchOther = 4,
        Content = 5,
        SearchPartnerTop = 6,
        SearchPartnerOther = 7,
        Mixed = 8,
    }
    impl Slot {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Slot::Unspecified => "UNSPECIFIED",
                Slot::Unknown => "UNKNOWN",
                Slot::SearchSide => "SEARCH_SIDE",
                Slot::SearchTop => "SEARCH_TOP",
                Slot::SearchOther => "SEARCH_OTHER",
                Slot::Content => "CONTENT",
                Slot::SearchPartnerTop => "SEARCH_PARTNER_TOP",
                Slot::SearchPartnerOther => "SEARCH_PARTNER_OTHER",
                Slot::Mixed => "MIXED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_SIDE" => Some(Self::SearchSide),
                "SEARCH_TOP" => Some(Self::SearchTop),
                "SEARCH_OTHER" => Some(Self::SearchOther),
                "CONTENT" => Some(Self::Content),
                "SEARCH_PARTNER_TOP" => Some(Self::SearchPartnerTop),
                "SEARCH_PARTNER_OTHER" => Some(Self::SearchPartnerOther),
                "MIXED" => Some(Self::Mixed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordPlanKeywordAnnotationEnum {}
/// Nested message and enum types in `KeywordPlanKeywordAnnotationEnum`.
pub mod keyword_plan_keyword_annotation_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordPlanKeywordAnnotation {
        Unspecified = 0,
        Unknown = 1,
        KeywordConcept = 2,
    }
    impl KeywordPlanKeywordAnnotation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordPlanKeywordAnnotation::Unspecified => "UNSPECIFIED",
                KeywordPlanKeywordAnnotation::Unknown => "UNKNOWN",
                KeywordPlanKeywordAnnotation::KeywordConcept => "KEYWORD_CONCEPT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD_CONCEPT" => Some(Self::KeywordConcept),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanSurfaceEnum {}
/// Nested message and enum types in `ReachPlanSurfaceEnum`.
pub mod reach_plan_surface_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanSurface {
        Unspecified = 0,
        Unknown = 1,
        InFeed = 2,
        InStreamBumper = 3,
        InStreamNonSkippable = 4,
        InStreamSkippable = 5,
        Shorts = 6,
    }
    impl ReachPlanSurface {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReachPlanSurface::Unspecified => "UNSPECIFIED",
                ReachPlanSurface::Unknown => "UNKNOWN",
                ReachPlanSurface::InFeed => "IN_FEED",
                ReachPlanSurface::InStreamBumper => "IN_STREAM_BUMPER",
                ReachPlanSurface::InStreamNonSkippable => "IN_STREAM_NON_SKIPPABLE",
                ReachPlanSurface::InStreamSkippable => "IN_STREAM_SKIPPABLE",
                ReachPlanSurface::Shorts => "SHORTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IN_FEED" => Some(Self::InFeed),
                "IN_STREAM_BUMPER" => Some(Self::InStreamBumper),
                "IN_STREAM_NON_SKIPPABLE" => Some(Self::InStreamNonSkippable),
                "IN_STREAM_SKIPPABLE" => Some(Self::InStreamSkippable),
                "SHORTS" => Some(Self::Shorts),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionAdjustmentTypeEnum {}
/// Nested message and enum types in `ConversionAdjustmentTypeEnum`.
pub mod conversion_adjustment_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionAdjustmentType {
        Unspecified = 0,
        Unknown = 1,
        Retraction = 2,
        Restatement = 3,
        Enhancement = 4,
    }
    impl ConversionAdjustmentType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionAdjustmentType::Unspecified => "UNSPECIFIED",
                ConversionAdjustmentType::Unknown => "UNKNOWN",
                ConversionAdjustmentType::Retraction => "RETRACTION",
                ConversionAdjustmentType::Restatement => "RESTATEMENT",
                ConversionAdjustmentType::Enhancement => "ENHANCEMENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RETRACTION" => Some(Self::Retraction),
                "RESTATEMENT" => Some(Self::Restatement),
                "ENHANCEMENT" => Some(Self::Enhancement),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ReachPlanNetworkEnum {}
/// Nested message and enum types in `ReachPlanNetworkEnum`.
pub mod reach_plan_network_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ReachPlanNetwork {
        Unspecified = 0,
        Unknown = 1,
        Youtube = 2,
        GoogleVideoPartners = 3,
        YoutubeAndGoogleVideoPartners = 4,
    }
    impl ReachPlanNetwork {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ReachPlanNetwork::Unspecified => "UNSPECIFIED",
                ReachPlanNetwork::Unknown => "UNKNOWN",
                ReachPlanNetwork::Youtube => "YOUTUBE",
                ReachPlanNetwork::GoogleVideoPartners => "GOOGLE_VIDEO_PARTNERS",
                ReachPlanNetwork::YoutubeAndGoogleVideoPartners => {
                    "YOUTUBE_AND_GOOGLE_VIDEO_PARTNERS"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YOUTUBE" => Some(Self::Youtube),
                "GOOGLE_VIDEO_PARTNERS" => Some(Self::GoogleVideoPartners),
                "YOUTUBE_AND_GOOGLE_VIDEO_PARTNERS" => {
                    Some(Self::YoutubeAndGoogleVideoPartners)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HotelAssetSuggestionStatusEnum {}
/// Nested message and enum types in `HotelAssetSuggestionStatusEnum`.
pub mod hotel_asset_suggestion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HotelAssetSuggestionStatus {
        Unspecified = 0,
        Unknown = 1,
        Success = 2,
        HotelNotFound = 3,
        InvalidPlaceId = 4,
    }
    impl HotelAssetSuggestionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HotelAssetSuggestionStatus::Unspecified => "UNSPECIFIED",
                HotelAssetSuggestionStatus::Unknown => "UNKNOWN",
                HotelAssetSuggestionStatus::Success => "SUCCESS",
                HotelAssetSuggestionStatus::HotelNotFound => "HOTEL_NOT_FOUND",
                HotelAssetSuggestionStatus::InvalidPlaceId => "INVALID_PLACE_ID",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUCCESS" => Some(Self::Success),
                "HOTEL_NOT_FOUND" => Some(Self::HotelNotFound),
                "INVALID_PLACE_ID" => Some(Self::InvalidPlaceId),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdNetworkTypeEnum {}
/// Nested message and enum types in `AdNetworkTypeEnum`.
pub mod ad_network_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdNetworkType {
        Unspecified = 0,
        Unknown = 1,
        Search = 2,
        SearchPartners = 3,
        Content = 4,
        Mixed = 7,
        Youtube = 8,
        GoogleTv = 9,
    }
    impl AdNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdNetworkType::Unspecified => "UNSPECIFIED",
                AdNetworkType::Unknown => "UNKNOWN",
                AdNetworkType::Search => "SEARCH",
                AdNetworkType::SearchPartners => "SEARCH_PARTNERS",
                AdNetworkType::Content => "CONTENT",
                AdNetworkType::Mixed => "MIXED",
                AdNetworkType::Youtube => "YOUTUBE",
                AdNetworkType::GoogleTv => "GOOGLE_TV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "SEARCH_PARTNERS" => Some(Self::SearchPartners),
                "CONTENT" => Some(Self::Content),
                "MIXED" => Some(Self::Mixed),
                "YOUTUBE" => Some(Self::Youtube),
                "GOOGLE_TV" => Some(Self::GoogleTv),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionEnvironmentEnum {}
/// Nested message and enum types in `ConversionEnvironmentEnum`.
pub mod conversion_environment_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionEnvironment {
        Unspecified = 0,
        Unknown = 1,
        App = 2,
        Web = 3,
    }
    impl ConversionEnvironment {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionEnvironment::Unspecified => "UNSPECIFIED",
                ConversionEnvironment::Unknown => "UNKNOWN",
                ConversionEnvironment::App => "APP",
                ConversionEnvironment::Web => "WEB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APP" => Some(Self::App),
                "WEB" => Some(Self::Web),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AudienceInsightsDimensionEnum {}
/// Nested message and enum types in `AudienceInsightsDimensionEnum`.
pub mod audience_insights_dimension_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AudienceInsightsDimension {
        Unspecified = 0,
        Unknown = 1,
        Category = 2,
        KnowledgeGraph = 3,
        GeoTargetCountry = 4,
        SubCountryLocation = 5,
        YoutubeChannel = 6,
        YoutubeDynamicLineup = 7,
        AffinityUserInterest = 8,
        InMarketUserInterest = 9,
        ParentalStatus = 10,
        IncomeRange = 11,
        AgeRange = 12,
        Gender = 13,
    }
    impl AudienceInsightsDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AudienceInsightsDimension::Unspecified => "UNSPECIFIED",
                AudienceInsightsDimension::Unknown => "UNKNOWN",
                AudienceInsightsDimension::Category => "CATEGORY",
                AudienceInsightsDimension::KnowledgeGraph => "KNOWLEDGE_GRAPH",
                AudienceInsightsDimension::GeoTargetCountry => "GEO_TARGET_COUNTRY",
                AudienceInsightsDimension::SubCountryLocation => "SUB_COUNTRY_LOCATION",
                AudienceInsightsDimension::YoutubeChannel => "YOUTUBE_CHANNEL",
                AudienceInsightsDimension::YoutubeDynamicLineup => {
                    "YOUTUBE_DYNAMIC_LINEUP"
                }
                AudienceInsightsDimension::AffinityUserInterest => {
                    "AFFINITY_USER_INTEREST"
                }
                AudienceInsightsDimension::InMarketUserInterest => {
                    "IN_MARKET_USER_INTEREST"
                }
                AudienceInsightsDimension::ParentalStatus => "PARENTAL_STATUS",
                AudienceInsightsDimension::IncomeRange => "INCOME_RANGE",
                AudienceInsightsDimension::AgeRange => "AGE_RANGE",
                AudienceInsightsDimension::Gender => "GENDER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CATEGORY" => Some(Self::Category),
                "KNOWLEDGE_GRAPH" => Some(Self::KnowledgeGraph),
                "GEO_TARGET_COUNTRY" => Some(Self::GeoTargetCountry),
                "SUB_COUNTRY_LOCATION" => Some(Self::SubCountryLocation),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "YOUTUBE_DYNAMIC_LINEUP" => Some(Self::YoutubeDynamicLineup),
                "AFFINITY_USER_INTEREST" => Some(Self::AffinityUserInterest),
                "IN_MARKET_USER_INTEREST" => Some(Self::InMarketUserInterest),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                "AGE_RANGE" => Some(Self::AgeRange),
                "GENDER" => Some(Self::Gender),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmartCampaignStatusEnum {}
/// Nested message and enum types in `SmartCampaignStatusEnum`.
pub mod smart_campaign_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SmartCampaignStatus {
        Unspecified = 0,
        Unknown = 1,
        Paused = 2,
        NotEligible = 3,
        Pending = 4,
        Eligible = 5,
        Removed = 6,
        Ended = 7,
    }
    impl SmartCampaignStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SmartCampaignStatus::Unspecified => "UNSPECIFIED",
                SmartCampaignStatus::Unknown => "UNKNOWN",
                SmartCampaignStatus::Paused => "PAUSED",
                SmartCampaignStatus::NotEligible => "NOT_ELIGIBLE",
                SmartCampaignStatus::Pending => "PENDING",
                SmartCampaignStatus::Eligible => "ELIGIBLE",
                SmartCampaignStatus::Removed => "REMOVED",
                SmartCampaignStatus::Ended => "ENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PAUSED" => Some(Self::Paused),
                "NOT_ELIGIBLE" => Some(Self::NotEligible),
                "PENDING" => Some(Self::Pending),
                "ELIGIBLE" => Some(Self::Eligible),
                "REMOVED" => Some(Self::Removed),
                "ENDED" => Some(Self::Ended),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SkAdNetworkAttributionCreditEnum {}
/// Nested message and enum types in `SkAdNetworkAttributionCreditEnum`.
pub mod sk_ad_network_attribution_credit_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SkAdNetworkAttributionCredit {
        Unspecified = 0,
        Unknown = 1,
        Unavailable = 2,
        Won = 3,
        Contributed = 4,
    }
    impl SkAdNetworkAttributionCredit {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SkAdNetworkAttributionCredit::Unspecified => "UNSPECIFIED",
                SkAdNetworkAttributionCredit::Unknown => "UNKNOWN",
                SkAdNetworkAttributionCredit::Unavailable => "UNAVAILABLE",
                SkAdNetworkAttributionCredit::Won => "WON",
                SkAdNetworkAttributionCredit::Contributed => "CONTRIBUTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "WON" => Some(Self::Won),
                "CONTRIBUTED" => Some(Self::Contributed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConvertingUserPriorEngagementTypeAndLtvBucketEnum {}
/// Nested message and enum types in `ConvertingUserPriorEngagementTypeAndLtvBucketEnum`.
pub mod converting_user_prior_engagement_type_and_ltv_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConvertingUserPriorEngagementTypeAndLtvBucket {
        Unspecified = 0,
        Unknown = 1,
        New = 2,
        Returning = 3,
        NewAndHighLtv = 4,
    }
    impl ConvertingUserPriorEngagementTypeAndLtvBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConvertingUserPriorEngagementTypeAndLtvBucket::Unspecified => {
                    "UNSPECIFIED"
                }
                ConvertingUserPriorEngagementTypeAndLtvBucket::Unknown => "UNKNOWN",
                ConvertingUserPriorEngagementTypeAndLtvBucket::New => "NEW",
                ConvertingUserPriorEngagementTypeAndLtvBucket::Returning => "RETURNING",
                ConvertingUserPriorEngagementTypeAndLtvBucket::NewAndHighLtv => {
                    "NEW_AND_HIGH_LTV"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "RETURNING" => Some(Self::Returning),
                "NEW_AND_HIGH_LTV" => Some(Self::NewAndHighLtv),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetCampaignAssociationStatusEnum {}
/// Nested message and enum types in `BudgetCampaignAssociationStatusEnum`.
pub mod budget_campaign_association_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetCampaignAssociationStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl BudgetCampaignAssociationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetCampaignAssociationStatus::Unspecified => "UNSPECIFIED",
                BudgetCampaignAssociationStatus::Unknown => "UNKNOWN",
                BudgetCampaignAssociationStatus::Enabled => "ENABLED",
                BudgetCampaignAssociationStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdFormatTypeEnum {}
/// Nested message and enum types in `AdFormatTypeEnum`.
pub mod ad_format_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdFormatType {
        Unspecified = 0,
        Unknown = 1,
        Other = 2,
        Unsegmented = 3,
        InstreamSkippable = 4,
        InstreamNonSkippable = 5,
        Infeed = 6,
        Bumper = 7,
        Outstream = 8,
        Masthead = 9,
        Audio = 10,
        Shorts = 11,
    }
    impl AdFormatType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdFormatType::Unspecified => "UNSPECIFIED",
                AdFormatType::Unknown => "UNKNOWN",
                AdFormatType::Other => "OTHER",
                AdFormatType::Unsegmented => "UNSEGMENTED",
                AdFormatType::InstreamSkippable => "INSTREAM_SKIPPABLE",
                AdFormatType::InstreamNonSkippable => "INSTREAM_NON_SKIPPABLE",
                AdFormatType::Infeed => "INFEED",
                AdFormatType::Bumper => "BUMPER",
                AdFormatType::Outstream => "OUTSTREAM",
                AdFormatType::Masthead => "MASTHEAD",
                AdFormatType::Audio => "AUDIO",
                AdFormatType::Shorts => "SHORTS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OTHER" => Some(Self::Other),
                "UNSEGMENTED" => Some(Self::Unsegmented),
                "INSTREAM_SKIPPABLE" => Some(Self::InstreamSkippable),
                "INSTREAM_NON_SKIPPABLE" => Some(Self::InstreamNonSkippable),
                "INFEED" => Some(Self::Infeed),
                "BUMPER" => Some(Self::Bumper),
                "OUTSTREAM" => Some(Self::Outstream),
                "MASTHEAD" => Some(Self::Masthead),
                "AUDIO" => Some(Self::Audio),
                "SHORTS" => Some(Self::Shorts),
                _ => None,
            }
        }
    }
}
