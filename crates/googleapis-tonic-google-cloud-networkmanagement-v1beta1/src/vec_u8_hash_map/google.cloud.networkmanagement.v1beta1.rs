// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(message, optional, tag = "1")]
    pub endpoint_info: ::core::option::Option<EndpointInfo>,
    #[prost(message, repeated, tag = "2")]
    pub steps: ::prost::alloc::vec::Vec<Step>,
    #[prost(int32, tag = "4")]
    pub forward_trace_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Step {
    #[prost(string, tag = "1")]
    pub description: ::prost::alloc::string::String,
    #[prost(enumeration = "step::State", tag = "2")]
    pub state: i32,
    #[prost(bool, tag = "3")]
    pub causes_drop: bool,
    #[prost(string, tag = "4")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(
        oneof = "step::StepInfo",
        tags = "5, 6, 7, 8, 24, 9, 10, 11, 21, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 25, 26, 27, 28"
    )]
    pub step_info: ::core::option::Option<step::StepInfo>,
}
/// Nested message and enum types in `Step`.
pub mod step {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        StartFromInstance = 1,
        StartFromInternet = 2,
        StartFromGoogleService = 27,
        StartFromPrivateNetwork = 3,
        StartFromGkeMaster = 21,
        StartFromCloudSqlInstance = 22,
        StartFromCloudFunction = 23,
        StartFromAppEngineVersion = 25,
        StartFromCloudRunRevision = 26,
        StartFromStorageBucket = 29,
        StartFromPscPublishedService = 30,
        ApplyIngressFirewallRule = 4,
        ApplyEgressFirewallRule = 5,
        ApplyRoute = 6,
        ApplyForwardingRule = 7,
        AnalyzeLoadBalancerBackend = 28,
        SpoofingApproved = 8,
        ArriveAtInstance = 9,
        ArriveAtInternalLoadBalancer = 10,
        ArriveAtExternalLoadBalancer = 11,
        ArriveAtVpnGateway = 12,
        ArriveAtVpnTunnel = 13,
        ArriveAtVpcConnector = 24,
        Nat = 14,
        ProxyConnection = 15,
        Deliver = 16,
        Drop = 17,
        Forward = 18,
        Abort = 19,
        ViewerPermissionMissing = 20,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::StartFromInstance => "START_FROM_INSTANCE",
                State::StartFromInternet => "START_FROM_INTERNET",
                State::StartFromGoogleService => "START_FROM_GOOGLE_SERVICE",
                State::StartFromPrivateNetwork => "START_FROM_PRIVATE_NETWORK",
                State::StartFromGkeMaster => "START_FROM_GKE_MASTER",
                State::StartFromCloudSqlInstance => "START_FROM_CLOUD_SQL_INSTANCE",
                State::StartFromCloudFunction => "START_FROM_CLOUD_FUNCTION",
                State::StartFromAppEngineVersion => "START_FROM_APP_ENGINE_VERSION",
                State::StartFromCloudRunRevision => "START_FROM_CLOUD_RUN_REVISION",
                State::StartFromStorageBucket => "START_FROM_STORAGE_BUCKET",
                State::StartFromPscPublishedService => "START_FROM_PSC_PUBLISHED_SERVICE",
                State::ApplyIngressFirewallRule => "APPLY_INGRESS_FIREWALL_RULE",
                State::ApplyEgressFirewallRule => "APPLY_EGRESS_FIREWALL_RULE",
                State::ApplyRoute => "APPLY_ROUTE",
                State::ApplyForwardingRule => "APPLY_FORWARDING_RULE",
                State::AnalyzeLoadBalancerBackend => "ANALYZE_LOAD_BALANCER_BACKEND",
                State::SpoofingApproved => "SPOOFING_APPROVED",
                State::ArriveAtInstance => "ARRIVE_AT_INSTANCE",
                State::ArriveAtInternalLoadBalancer => "ARRIVE_AT_INTERNAL_LOAD_BALANCER",
                State::ArriveAtExternalLoadBalancer => "ARRIVE_AT_EXTERNAL_LOAD_BALANCER",
                State::ArriveAtVpnGateway => "ARRIVE_AT_VPN_GATEWAY",
                State::ArriveAtVpnTunnel => "ARRIVE_AT_VPN_TUNNEL",
                State::ArriveAtVpcConnector => "ARRIVE_AT_VPC_CONNECTOR",
                State::Nat => "NAT",
                State::ProxyConnection => "PROXY_CONNECTION",
                State::Deliver => "DELIVER",
                State::Drop => "DROP",
                State::Forward => "FORWARD",
                State::Abort => "ABORT",
                State::ViewerPermissionMissing => "VIEWER_PERMISSION_MISSING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "START_FROM_INSTANCE" => Some(Self::StartFromInstance),
                "START_FROM_INTERNET" => Some(Self::StartFromInternet),
                "START_FROM_GOOGLE_SERVICE" => Some(Self::StartFromGoogleService),
                "START_FROM_PRIVATE_NETWORK" => Some(Self::StartFromPrivateNetwork),
                "START_FROM_GKE_MASTER" => Some(Self::StartFromGkeMaster),
                "START_FROM_CLOUD_SQL_INSTANCE" => Some(Self::StartFromCloudSqlInstance),
                "START_FROM_CLOUD_FUNCTION" => Some(Self::StartFromCloudFunction),
                "START_FROM_APP_ENGINE_VERSION" => Some(Self::StartFromAppEngineVersion),
                "START_FROM_CLOUD_RUN_REVISION" => Some(Self::StartFromCloudRunRevision),
                "START_FROM_STORAGE_BUCKET" => Some(Self::StartFromStorageBucket),
                "START_FROM_PSC_PUBLISHED_SERVICE" => {
                    Some(Self::StartFromPscPublishedService)
                }
                "APPLY_INGRESS_FIREWALL_RULE" => Some(Self::ApplyIngressFirewallRule),
                "APPLY_EGRESS_FIREWALL_RULE" => Some(Self::ApplyEgressFirewallRule),
                "APPLY_ROUTE" => Some(Self::ApplyRoute),
                "APPLY_FORWARDING_RULE" => Some(Self::ApplyForwardingRule),
                "ANALYZE_LOAD_BALANCER_BACKEND" => Some(Self::AnalyzeLoadBalancerBackend),
                "SPOOFING_APPROVED" => Some(Self::SpoofingApproved),
                "ARRIVE_AT_INSTANCE" => Some(Self::ArriveAtInstance),
                "ARRIVE_AT_INTERNAL_LOAD_BALANCER" => {
                    Some(Self::ArriveAtInternalLoadBalancer)
                }
                "ARRIVE_AT_EXTERNAL_LOAD_BALANCER" => {
                    Some(Self::ArriveAtExternalLoadBalancer)
                }
                "ARRIVE_AT_VPN_GATEWAY" => Some(Self::ArriveAtVpnGateway),
                "ARRIVE_AT_VPN_TUNNEL" => Some(Self::ArriveAtVpnTunnel),
                "ARRIVE_AT_VPC_CONNECTOR" => Some(Self::ArriveAtVpcConnector),
                "NAT" => Some(Self::Nat),
                "PROXY_CONNECTION" => Some(Self::ProxyConnection),
                "DELIVER" => Some(Self::Deliver),
                "DROP" => Some(Self::Drop),
                "FORWARD" => Some(Self::Forward),
                "ABORT" => Some(Self::Abort),
                "VIEWER_PERMISSION_MISSING" => Some(Self::ViewerPermissionMissing),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum StepInfo {
        #[prost(message, tag = "5")]
        Instance(super::InstanceInfo),
        #[prost(message, tag = "6")]
        Firewall(super::FirewallInfo),
        #[prost(message, tag = "7")]
        Route(super::RouteInfo),
        #[prost(message, tag = "8")]
        Endpoint(super::EndpointInfo),
        #[prost(message, tag = "24")]
        GoogleService(super::GoogleServiceInfo),
        #[prost(message, tag = "9")]
        ForwardingRule(super::ForwardingRuleInfo),
        #[prost(message, tag = "10")]
        VpnGateway(super::VpnGatewayInfo),
        #[prost(message, tag = "11")]
        VpnTunnel(super::VpnTunnelInfo),
        #[prost(message, tag = "21")]
        VpcConnector(super::VpcConnectorInfo),
        #[prost(message, tag = "12")]
        Deliver(super::DeliverInfo),
        #[prost(message, tag = "13")]
        Forward(super::ForwardInfo),
        #[prost(message, tag = "14")]
        Abort(super::AbortInfo),
        #[prost(message, tag = "15")]
        Drop(super::DropInfo),
        #[prost(message, tag = "16")]
        LoadBalancer(super::LoadBalancerInfo),
        #[prost(message, tag = "17")]
        Network(super::NetworkInfo),
        #[prost(message, tag = "18")]
        GkeMaster(super::GkeMasterInfo),
        #[prost(message, tag = "19")]
        CloudSqlInstance(super::CloudSqlInstanceInfo),
        #[prost(message, tag = "20")]
        CloudFunction(super::CloudFunctionInfo),
        #[prost(message, tag = "22")]
        AppEngineVersion(super::AppEngineVersionInfo),
        #[prost(message, tag = "23")]
        CloudRunRevision(super::CloudRunRevisionInfo),
        #[prost(message, tag = "25")]
        Nat(super::NatInfo),
        #[prost(message, tag = "26")]
        ProxyConnection(super::ProxyConnectionInfo),
        #[prost(message, tag = "27")]
        LoadBalancerBackendInfo(super::LoadBalancerBackendInfo),
        #[prost(message, tag = "28")]
        StorageBucket(super::StorageBucketInfo),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstanceInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub interface: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub external_ip: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub network_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[deprecated]
    #[prost(string, tag = "8")]
    pub service_account: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub matched_ip_range: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FirewallInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub direction: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub action: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub priority: i32,
    #[prost(string, tag = "6")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub target_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub target_service_accounts: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, tag = "9")]
    pub policy: ::prost::alloc::string::String,
    #[prost(enumeration = "firewall_info::FirewallRuleType", tag = "10")]
    pub firewall_rule_type: i32,
}
/// Nested message and enum types in `FirewallInfo`.
pub mod firewall_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FirewallRuleType {
        Unspecified = 0,
        HierarchicalFirewallPolicyRule = 1,
        VpcFirewallRule = 2,
        ImpliedVpcFirewallRule = 3,
        ServerlessVpcAccessManagedFirewallRule = 4,
        NetworkFirewallPolicyRule = 5,
        NetworkRegionalFirewallPolicyRule = 6,
        UnsupportedFirewallPolicyRule = 100,
        TrackingState = 101,
    }
    impl FirewallRuleType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FirewallRuleType::Unspecified => "FIREWALL_RULE_TYPE_UNSPECIFIED",
                FirewallRuleType::HierarchicalFirewallPolicyRule => {
                    "HIERARCHICAL_FIREWALL_POLICY_RULE"
                }
                FirewallRuleType::VpcFirewallRule => "VPC_FIREWALL_RULE",
                FirewallRuleType::ImpliedVpcFirewallRule => "IMPLIED_VPC_FIREWALL_RULE",
                FirewallRuleType::ServerlessVpcAccessManagedFirewallRule => {
                    "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE"
                }
                FirewallRuleType::NetworkFirewallPolicyRule => {
                    "NETWORK_FIREWALL_POLICY_RULE"
                }
                FirewallRuleType::NetworkRegionalFirewallPolicyRule => {
                    "NETWORK_REGIONAL_FIREWALL_POLICY_RULE"
                }
                FirewallRuleType::UnsupportedFirewallPolicyRule => {
                    "UNSUPPORTED_FIREWALL_POLICY_RULE"
                }
                FirewallRuleType::TrackingState => "TRACKING_STATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIREWALL_RULE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "HIERARCHICAL_FIREWALL_POLICY_RULE" => {
                    Some(Self::HierarchicalFirewallPolicyRule)
                }
                "VPC_FIREWALL_RULE" => Some(Self::VpcFirewallRule),
                "IMPLIED_VPC_FIREWALL_RULE" => Some(Self::ImpliedVpcFirewallRule),
                "SERVERLESS_VPC_ACCESS_MANAGED_FIREWALL_RULE" => {
                    Some(Self::ServerlessVpcAccessManagedFirewallRule)
                }
                "NETWORK_FIREWALL_POLICY_RULE" => Some(Self::NetworkFirewallPolicyRule),
                "NETWORK_REGIONAL_FIREWALL_POLICY_RULE" => {
                    Some(Self::NetworkRegionalFirewallPolicyRule)
                }
                "UNSUPPORTED_FIREWALL_POLICY_RULE" => {
                    Some(Self::UnsupportedFirewallPolicyRule)
                }
                "TRACKING_STATE" => Some(Self::TrackingState),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RouteInfo {
    #[prost(enumeration = "route_info::RouteType", tag = "8")]
    pub route_type: i32,
    #[prost(enumeration = "route_info::NextHopType", tag = "9")]
    pub next_hop_type: i32,
    #[prost(enumeration = "route_info::RouteScope", tag = "14")]
    pub route_scope: i32,
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub dest_ip_range: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub next_hop: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub priority: i32,
    #[prost(string, repeated, tag = "7")]
    pub instance_tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "10")]
    pub src_ip_range: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "11")]
    pub dest_port_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "12")]
    pub src_port_ranges: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "13")]
    pub protocols: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "15")]
    pub ncc_hub_uri: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "16")]
    pub ncc_spoke_uri: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `RouteInfo`.
pub mod route_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RouteType {
        Unspecified = 0,
        Subnet = 1,
        Static = 2,
        Dynamic = 3,
        PeeringSubnet = 4,
        PeeringStatic = 5,
        PeeringDynamic = 6,
        PolicyBased = 7,
    }
    impl RouteType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RouteType::Unspecified => "ROUTE_TYPE_UNSPECIFIED",
                RouteType::Subnet => "SUBNET",
                RouteType::Static => "STATIC",
                RouteType::Dynamic => "DYNAMIC",
                RouteType::PeeringSubnet => "PEERING_SUBNET",
                RouteType::PeeringStatic => "PEERING_STATIC",
                RouteType::PeeringDynamic => "PEERING_DYNAMIC",
                RouteType::PolicyBased => "POLICY_BASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROUTE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "SUBNET" => Some(Self::Subnet),
                "STATIC" => Some(Self::Static),
                "DYNAMIC" => Some(Self::Dynamic),
                "PEERING_SUBNET" => Some(Self::PeeringSubnet),
                "PEERING_STATIC" => Some(Self::PeeringStatic),
                "PEERING_DYNAMIC" => Some(Self::PeeringDynamic),
                "POLICY_BASED" => Some(Self::PolicyBased),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NextHopType {
        Unspecified = 0,
        NextHopIp = 1,
        NextHopInstance = 2,
        NextHopNetwork = 3,
        NextHopPeering = 4,
        NextHopInterconnect = 5,
        NextHopVpnTunnel = 6,
        NextHopVpnGateway = 7,
        NextHopInternetGateway = 8,
        NextHopBlackhole = 9,
        NextHopIlb = 10,
        NextHopRouterAppliance = 11,
        NextHopNccHub = 12,
    }
    impl NextHopType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NextHopType::Unspecified => "NEXT_HOP_TYPE_UNSPECIFIED",
                NextHopType::NextHopIp => "NEXT_HOP_IP",
                NextHopType::NextHopInstance => "NEXT_HOP_INSTANCE",
                NextHopType::NextHopNetwork => "NEXT_HOP_NETWORK",
                NextHopType::NextHopPeering => "NEXT_HOP_PEERING",
                NextHopType::NextHopInterconnect => "NEXT_HOP_INTERCONNECT",
                NextHopType::NextHopVpnTunnel => "NEXT_HOP_VPN_TUNNEL",
                NextHopType::NextHopVpnGateway => "NEXT_HOP_VPN_GATEWAY",
                NextHopType::NextHopInternetGateway => "NEXT_HOP_INTERNET_GATEWAY",
                NextHopType::NextHopBlackhole => "NEXT_HOP_BLACKHOLE",
                NextHopType::NextHopIlb => "NEXT_HOP_ILB",
                NextHopType::NextHopRouterAppliance => "NEXT_HOP_ROUTER_APPLIANCE",
                NextHopType::NextHopNccHub => "NEXT_HOP_NCC_HUB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NEXT_HOP_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NEXT_HOP_IP" => Some(Self::NextHopIp),
                "NEXT_HOP_INSTANCE" => Some(Self::NextHopInstance),
                "NEXT_HOP_NETWORK" => Some(Self::NextHopNetwork),
                "NEXT_HOP_PEERING" => Some(Self::NextHopPeering),
                "NEXT_HOP_INTERCONNECT" => Some(Self::NextHopInterconnect),
                "NEXT_HOP_VPN_TUNNEL" => Some(Self::NextHopVpnTunnel),
                "NEXT_HOP_VPN_GATEWAY" => Some(Self::NextHopVpnGateway),
                "NEXT_HOP_INTERNET_GATEWAY" => Some(Self::NextHopInternetGateway),
                "NEXT_HOP_BLACKHOLE" => Some(Self::NextHopBlackhole),
                "NEXT_HOP_ILB" => Some(Self::NextHopIlb),
                "NEXT_HOP_ROUTER_APPLIANCE" => Some(Self::NextHopRouterAppliance),
                "NEXT_HOP_NCC_HUB" => Some(Self::NextHopNccHub),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RouteScope {
        Unspecified = 0,
        Network = 1,
        NccHub = 2,
    }
    impl RouteScope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RouteScope::Unspecified => "ROUTE_SCOPE_UNSPECIFIED",
                RouteScope::Network => "NETWORK",
                RouteScope::NccHub => "NCC_HUB",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROUTE_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
                "NETWORK" => Some(Self::Network),
                "NCC_HUB" => Some(Self::NccHub),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GoogleServiceInfo {
    #[prost(string, tag = "1")]
    pub source_ip: ::prost::alloc::string::String,
    #[prost(enumeration = "google_service_info::GoogleServiceType", tag = "2")]
    pub google_service_type: i32,
}
/// Nested message and enum types in `GoogleServiceInfo`.
pub mod google_service_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GoogleServiceType {
        Unspecified = 0,
        Iap = 1,
        GfeProxyOrHealthCheckProber = 2,
        CloudDns = 3,
        GoogleApi = 4,
        GoogleApiPsc = 5,
        GoogleApiVpcSc = 6,
    }
    impl GoogleServiceType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GoogleServiceType::Unspecified => "GOOGLE_SERVICE_TYPE_UNSPECIFIED",
                GoogleServiceType::Iap => "IAP",
                GoogleServiceType::GfeProxyOrHealthCheckProber => {
                    "GFE_PROXY_OR_HEALTH_CHECK_PROBER"
                }
                GoogleServiceType::CloudDns => "CLOUD_DNS",
                GoogleServiceType::GoogleApi => "GOOGLE_API",
                GoogleServiceType::GoogleApiPsc => "GOOGLE_API_PSC",
                GoogleServiceType::GoogleApiVpcSc => "GOOGLE_API_VPC_SC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "GOOGLE_SERVICE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "IAP" => Some(Self::Iap),
                "GFE_PROXY_OR_HEALTH_CHECK_PROBER" => {
                    Some(Self::GfeProxyOrHealthCheckProber)
                }
                "CLOUD_DNS" => Some(Self::CloudDns),
                "GOOGLE_API" => Some(Self::GoogleApi),
                "GOOGLE_API_PSC" => Some(Self::GoogleApiPsc),
                "GOOGLE_API_VPC_SC" => Some(Self::GoogleApiVpcSc),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardingRuleInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub matched_protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub matched_port_range: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub vip: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub network_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerInfo {
    #[prost(enumeration = "load_balancer_info::LoadBalancerType", tag = "1")]
    pub load_balancer_type: i32,
    #[deprecated]
    #[prost(string, tag = "2")]
    pub health_check_uri: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub backends: ::prost::alloc::vec::Vec<LoadBalancerBackend>,
    #[prost(enumeration = "load_balancer_info::BackendType", tag = "4")]
    pub backend_type: i32,
    #[prost(string, tag = "5")]
    pub backend_uri: ::prost::alloc::string::String,
}
/// Nested message and enum types in `LoadBalancerInfo`.
pub mod load_balancer_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LoadBalancerType {
        Unspecified = 0,
        InternalTcpUdp = 1,
        NetworkTcpUdp = 2,
        HttpProxy = 3,
        TcpProxy = 4,
        SslProxy = 5,
    }
    impl LoadBalancerType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LoadBalancerType::Unspecified => "LOAD_BALANCER_TYPE_UNSPECIFIED",
                LoadBalancerType::InternalTcpUdp => "INTERNAL_TCP_UDP",
                LoadBalancerType::NetworkTcpUdp => "NETWORK_TCP_UDP",
                LoadBalancerType::HttpProxy => "HTTP_PROXY",
                LoadBalancerType::TcpProxy => "TCP_PROXY",
                LoadBalancerType::SslProxy => "SSL_PROXY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LOAD_BALANCER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INTERNAL_TCP_UDP" => Some(Self::InternalTcpUdp),
                "NETWORK_TCP_UDP" => Some(Self::NetworkTcpUdp),
                "HTTP_PROXY" => Some(Self::HttpProxy),
                "TCP_PROXY" => Some(Self::TcpProxy),
                "SSL_PROXY" => Some(Self::SslProxy),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BackendType {
        Unspecified = 0,
        BackendService = 1,
        TargetPool = 2,
        TargetInstance = 3,
    }
    impl BackendType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BackendType::Unspecified => "BACKEND_TYPE_UNSPECIFIED",
                BackendType::BackendService => "BACKEND_SERVICE",
                BackendType::TargetPool => "TARGET_POOL",
                BackendType::TargetInstance => "TARGET_INSTANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BACKEND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BACKEND_SERVICE" => Some(Self::BackendService),
                "TARGET_POOL" => Some(Self::TargetPool),
                "TARGET_INSTANCE" => Some(Self::TargetInstance),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerBackend {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(enumeration = "load_balancer_backend::HealthCheckFirewallState", tag = "3")]
    pub health_check_firewall_state: i32,
    #[prost(string, repeated, tag = "4")]
    pub health_check_allowing_firewall_rules: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    #[prost(string, repeated, tag = "5")]
    pub health_check_blocking_firewall_rules: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `LoadBalancerBackend`.
pub mod load_balancer_backend {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthCheckFirewallState {
        Unspecified = 0,
        Configured = 1,
        Misconfigured = 2,
    }
    impl HealthCheckFirewallState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthCheckFirewallState::Unspecified => {
                    "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED"
                }
                HealthCheckFirewallState::Configured => "CONFIGURED",
                HealthCheckFirewallState::Misconfigured => "MISCONFIGURED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HEALTH_CHECK_FIREWALL_STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "CONFIGURED" => Some(Self::Configured),
                "MISCONFIGURED" => Some(Self::Misconfigured),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnGatewayInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub vpn_tunnel_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpnTunnelInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_gateway: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub remote_gateway: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub remote_gateway_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub source_gateway_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub region: ::prost::alloc::string::String,
    #[prost(enumeration = "vpn_tunnel_info::RoutingType", tag = "9")]
    pub routing_type: i32,
}
/// Nested message and enum types in `VpnTunnelInfo`.
pub mod vpn_tunnel_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RoutingType {
        Unspecified = 0,
        RouteBased = 1,
        PolicyBased = 2,
        Dynamic = 3,
    }
    impl RoutingType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                RoutingType::Unspecified => "ROUTING_TYPE_UNSPECIFIED",
                RoutingType::RouteBased => "ROUTE_BASED",
                RoutingType::PolicyBased => "POLICY_BASED",
                RoutingType::Dynamic => "DYNAMIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ROUTING_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "ROUTE_BASED" => Some(Self::RouteBased),
                "POLICY_BASED" => Some(Self::PolicyBased),
                "DYNAMIC" => Some(Self::Dynamic),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EndpointInfo {
    #[prost(string, tag = "1")]
    pub source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub source_port: i32,
    #[prost(int32, tag = "5")]
    pub destination_port: i32,
    #[prost(string, tag = "6")]
    pub source_network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub destination_network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub source_agent_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeliverInfo {
    #[prost(enumeration = "deliver_info::Target", tag = "1")]
    pub target: i32,
    #[prost(string, tag = "2")]
    pub resource_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip_address: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DeliverInfo`.
pub mod deliver_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Target {
        Unspecified = 0,
        Instance = 1,
        Internet = 2,
        GoogleApi = 3,
        GkeMaster = 4,
        CloudSqlInstance = 5,
        PscPublishedService = 6,
        PscGoogleApi = 7,
        PscVpcSc = 8,
        ServerlessNeg = 9,
        StorageBucket = 10,
        PrivateNetwork = 11,
        CloudFunction = 12,
        AppEngineVersion = 13,
        CloudRunRevision = 14,
    }
    impl Target {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Target::Unspecified => "TARGET_UNSPECIFIED",
                Target::Instance => "INSTANCE",
                Target::Internet => "INTERNET",
                Target::GoogleApi => "GOOGLE_API",
                Target::GkeMaster => "GKE_MASTER",
                Target::CloudSqlInstance => "CLOUD_SQL_INSTANCE",
                Target::PscPublishedService => "PSC_PUBLISHED_SERVICE",
                Target::PscGoogleApi => "PSC_GOOGLE_API",
                Target::PscVpcSc => "PSC_VPC_SC",
                Target::ServerlessNeg => "SERVERLESS_NEG",
                Target::StorageBucket => "STORAGE_BUCKET",
                Target::PrivateNetwork => "PRIVATE_NETWORK",
                Target::CloudFunction => "CLOUD_FUNCTION",
                Target::AppEngineVersion => "APP_ENGINE_VERSION",
                Target::CloudRunRevision => "CLOUD_RUN_REVISION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTANCE" => Some(Self::Instance),
                "INTERNET" => Some(Self::Internet),
                "GOOGLE_API" => Some(Self::GoogleApi),
                "GKE_MASTER" => Some(Self::GkeMaster),
                "CLOUD_SQL_INSTANCE" => Some(Self::CloudSqlInstance),
                "PSC_PUBLISHED_SERVICE" => Some(Self::PscPublishedService),
                "PSC_GOOGLE_API" => Some(Self::PscGoogleApi),
                "PSC_VPC_SC" => Some(Self::PscVpcSc),
                "SERVERLESS_NEG" => Some(Self::ServerlessNeg),
                "STORAGE_BUCKET" => Some(Self::StorageBucket),
                "PRIVATE_NETWORK" => Some(Self::PrivateNetwork),
                "CLOUD_FUNCTION" => Some(Self::CloudFunction),
                "APP_ENGINE_VERSION" => Some(Self::AppEngineVersion),
                "CLOUD_RUN_REVISION" => Some(Self::CloudRunRevision),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ForwardInfo {
    #[prost(enumeration = "forward_info::Target", tag = "1")]
    pub target: i32,
    #[prost(string, tag = "2")]
    pub resource_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub ip_address: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ForwardInfo`.
pub mod forward_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Target {
        Unspecified = 0,
        PeeringVpc = 1,
        VpnGateway = 2,
        Interconnect = 3,
        GkeMaster = 4,
        ImportedCustomRouteNextHop = 5,
        CloudSqlInstance = 6,
        AnotherProject = 7,
        NccHub = 8,
        RouterAppliance = 9,
    }
    impl Target {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Target::Unspecified => "TARGET_UNSPECIFIED",
                Target::PeeringVpc => "PEERING_VPC",
                Target::VpnGateway => "VPN_GATEWAY",
                Target::Interconnect => "INTERCONNECT",
                Target::GkeMaster => "GKE_MASTER",
                Target::ImportedCustomRouteNextHop => "IMPORTED_CUSTOM_ROUTE_NEXT_HOP",
                Target::CloudSqlInstance => "CLOUD_SQL_INSTANCE",
                Target::AnotherProject => "ANOTHER_PROJECT",
                Target::NccHub => "NCC_HUB",
                Target::RouterAppliance => "ROUTER_APPLIANCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_UNSPECIFIED" => Some(Self::Unspecified),
                "PEERING_VPC" => Some(Self::PeeringVpc),
                "VPN_GATEWAY" => Some(Self::VpnGateway),
                "INTERCONNECT" => Some(Self::Interconnect),
                "GKE_MASTER" => Some(Self::GkeMaster),
                "IMPORTED_CUSTOM_ROUTE_NEXT_HOP" => {
                    Some(Self::ImportedCustomRouteNextHop)
                }
                "CLOUD_SQL_INSTANCE" => Some(Self::CloudSqlInstance),
                "ANOTHER_PROJECT" => Some(Self::AnotherProject),
                "NCC_HUB" => Some(Self::NccHub),
                "ROUTER_APPLIANCE" => Some(Self::RouterAppliance),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AbortInfo {
    #[prost(enumeration = "abort_info::Cause", tag = "1")]
    pub cause: i32,
    #[prost(string, tag = "2")]
    pub resource_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub projects_missing_permission: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `AbortInfo`.
pub mod abort_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cause {
        Unspecified = 0,
        UnknownNetwork = 1,
        UnknownProject = 3,
        NoExternalIp = 7,
        UnintendedDestination = 8,
        SourceEndpointNotFound = 11,
        MismatchedSourceNetwork = 12,
        DestinationEndpointNotFound = 13,
        MismatchedDestinationNetwork = 14,
        UnknownIp = 2,
        SourceIpAddressNotInSourceNetwork = 23,
        PermissionDenied = 4,
        PermissionDeniedNoCloudNatConfigs = 28,
        PermissionDeniedNoNegEndpointConfigs = 29,
        NoSourceLocation = 5,
        InvalidArgument = 6,
        TraceTooLong = 9,
        InternalError = 10,
        Unsupported = 15,
        MismatchedIpVersion = 16,
        GkeKonnectivityProxyUnsupported = 17,
        ResourceConfigNotFound = 18,
        VmInstanceConfigNotFound = 24,
        NetworkConfigNotFound = 25,
        FirewallConfigNotFound = 26,
        RouteConfigNotFound = 27,
        GoogleManagedServiceAmbiguousPscEndpoint = 19,
        SourcePscCloudSqlUnsupported = 20,
        SourceForwardingRuleUnsupported = 21,
        NonRoutableIpAddress = 22,
        UnknownIssueInGoogleManagedProject = 30,
        UnsupportedGoogleManagedProjectConfig = 31,
    }
    impl Cause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Cause::Unspecified => "CAUSE_UNSPECIFIED",
                Cause::UnknownNetwork => "UNKNOWN_NETWORK",
                Cause::UnknownProject => "UNKNOWN_PROJECT",
                Cause::NoExternalIp => "NO_EXTERNAL_IP",
                Cause::UnintendedDestination => "UNINTENDED_DESTINATION",
                Cause::SourceEndpointNotFound => "SOURCE_ENDPOINT_NOT_FOUND",
                Cause::MismatchedSourceNetwork => "MISMATCHED_SOURCE_NETWORK",
                Cause::DestinationEndpointNotFound => "DESTINATION_ENDPOINT_NOT_FOUND",
                Cause::MismatchedDestinationNetwork => "MISMATCHED_DESTINATION_NETWORK",
                Cause::UnknownIp => "UNKNOWN_IP",
                Cause::SourceIpAddressNotInSourceNetwork => {
                    "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK"
                }
                Cause::PermissionDenied => "PERMISSION_DENIED",
                Cause::PermissionDeniedNoCloudNatConfigs => {
                    "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS"
                }
                Cause::PermissionDeniedNoNegEndpointConfigs => {
                    "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS"
                }
                Cause::NoSourceLocation => "NO_SOURCE_LOCATION",
                Cause::InvalidArgument => "INVALID_ARGUMENT",
                Cause::TraceTooLong => "TRACE_TOO_LONG",
                Cause::InternalError => "INTERNAL_ERROR",
                Cause::Unsupported => "UNSUPPORTED",
                Cause::MismatchedIpVersion => "MISMATCHED_IP_VERSION",
                Cause::GkeKonnectivityProxyUnsupported => {
                    "GKE_KONNECTIVITY_PROXY_UNSUPPORTED"
                }
                Cause::ResourceConfigNotFound => "RESOURCE_CONFIG_NOT_FOUND",
                Cause::VmInstanceConfigNotFound => "VM_INSTANCE_CONFIG_NOT_FOUND",
                Cause::NetworkConfigNotFound => "NETWORK_CONFIG_NOT_FOUND",
                Cause::FirewallConfigNotFound => "FIREWALL_CONFIG_NOT_FOUND",
                Cause::RouteConfigNotFound => "ROUTE_CONFIG_NOT_FOUND",
                Cause::GoogleManagedServiceAmbiguousPscEndpoint => {
                    "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT"
                }
                Cause::SourcePscCloudSqlUnsupported => "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED",
                Cause::SourceForwardingRuleUnsupported => {
                    "SOURCE_FORWARDING_RULE_UNSUPPORTED"
                }
                Cause::NonRoutableIpAddress => "NON_ROUTABLE_IP_ADDRESS",
                Cause::UnknownIssueInGoogleManagedProject => {
                    "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT"
                }
                Cause::UnsupportedGoogleManagedProjectConfig => {
                    "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN_NETWORK" => Some(Self::UnknownNetwork),
                "UNKNOWN_PROJECT" => Some(Self::UnknownProject),
                "NO_EXTERNAL_IP" => Some(Self::NoExternalIp),
                "UNINTENDED_DESTINATION" => Some(Self::UnintendedDestination),
                "SOURCE_ENDPOINT_NOT_FOUND" => Some(Self::SourceEndpointNotFound),
                "MISMATCHED_SOURCE_NETWORK" => Some(Self::MismatchedSourceNetwork),
                "DESTINATION_ENDPOINT_NOT_FOUND" => {
                    Some(Self::DestinationEndpointNotFound)
                }
                "MISMATCHED_DESTINATION_NETWORK" => {
                    Some(Self::MismatchedDestinationNetwork)
                }
                "UNKNOWN_IP" => Some(Self::UnknownIp),
                "SOURCE_IP_ADDRESS_NOT_IN_SOURCE_NETWORK" => {
                    Some(Self::SourceIpAddressNotInSourceNetwork)
                }
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "PERMISSION_DENIED_NO_CLOUD_NAT_CONFIGS" => {
                    Some(Self::PermissionDeniedNoCloudNatConfigs)
                }
                "PERMISSION_DENIED_NO_NEG_ENDPOINT_CONFIGS" => {
                    Some(Self::PermissionDeniedNoNegEndpointConfigs)
                }
                "NO_SOURCE_LOCATION" => Some(Self::NoSourceLocation),
                "INVALID_ARGUMENT" => Some(Self::InvalidArgument),
                "TRACE_TOO_LONG" => Some(Self::TraceTooLong),
                "INTERNAL_ERROR" => Some(Self::InternalError),
                "UNSUPPORTED" => Some(Self::Unsupported),
                "MISMATCHED_IP_VERSION" => Some(Self::MismatchedIpVersion),
                "GKE_KONNECTIVITY_PROXY_UNSUPPORTED" => {
                    Some(Self::GkeKonnectivityProxyUnsupported)
                }
                "RESOURCE_CONFIG_NOT_FOUND" => Some(Self::ResourceConfigNotFound),
                "VM_INSTANCE_CONFIG_NOT_FOUND" => Some(Self::VmInstanceConfigNotFound),
                "NETWORK_CONFIG_NOT_FOUND" => Some(Self::NetworkConfigNotFound),
                "FIREWALL_CONFIG_NOT_FOUND" => Some(Self::FirewallConfigNotFound),
                "ROUTE_CONFIG_NOT_FOUND" => Some(Self::RouteConfigNotFound),
                "GOOGLE_MANAGED_SERVICE_AMBIGUOUS_PSC_ENDPOINT" => {
                    Some(Self::GoogleManagedServiceAmbiguousPscEndpoint)
                }
                "SOURCE_PSC_CLOUD_SQL_UNSUPPORTED" => {
                    Some(Self::SourcePscCloudSqlUnsupported)
                }
                "SOURCE_FORWARDING_RULE_UNSUPPORTED" => {
                    Some(Self::SourceForwardingRuleUnsupported)
                }
                "NON_ROUTABLE_IP_ADDRESS" => Some(Self::NonRoutableIpAddress),
                "UNKNOWN_ISSUE_IN_GOOGLE_MANAGED_PROJECT" => {
                    Some(Self::UnknownIssueInGoogleManagedProject)
                }
                "UNSUPPORTED_GOOGLE_MANAGED_PROJECT_CONFIG" => {
                    Some(Self::UnsupportedGoogleManagedProjectConfig)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DropInfo {
    #[prost(enumeration = "drop_info::Cause", tag = "1")]
    pub cause: i32,
    #[prost(string, tag = "2")]
    pub resource_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub destination_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub region: ::prost::alloc::string::String,
}
/// Nested message and enum types in `DropInfo`.
pub mod drop_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cause {
        Unspecified = 0,
        UnknownExternalAddress = 1,
        ForeignIpDisallowed = 2,
        FirewallRule = 3,
        NoRoute = 4,
        RouteBlackhole = 5,
        RouteWrongNetwork = 6,
        RouteNextHopIpAddressNotResolved = 42,
        RouteNextHopResourceNotFound = 43,
        RouteNextHopInstanceWrongNetwork = 49,
        RouteNextHopInstanceNonPrimaryIp = 50,
        RouteNextHopForwardingRuleIpMismatch = 51,
        RouteNextHopVpnTunnelNotEstablished = 52,
        RouteNextHopForwardingRuleTypeInvalid = 53,
        NoRouteFromInternetToPrivateIpv6Address = 44,
        VpnTunnelLocalSelectorMismatch = 45,
        VpnTunnelRemoteSelectorMismatch = 46,
        PrivateTrafficToInternet = 7,
        PrivateGoogleAccessDisallowed = 8,
        PrivateGoogleAccessViaVpnTunnelUnsupported = 47,
        NoExternalAddress = 9,
        UnknownInternalAddress = 10,
        ForwardingRuleMismatch = 11,
        ForwardingRuleNoInstances = 12,
        FirewallBlockingLoadBalancerBackendHealthCheck = 13,
        InstanceNotRunning = 14,
        GkeClusterNotRunning = 27,
        CloudSqlInstanceNotRunning = 28,
        TrafficTypeBlocked = 15,
        GkeMasterUnauthorizedAccess = 16,
        CloudSqlInstanceUnauthorizedAccess = 17,
        DroppedInsideGkeService = 18,
        DroppedInsideCloudSqlService = 19,
        GoogleManagedServiceNoPeering = 20,
        GoogleManagedServiceNoPscEndpoint = 38,
        GkePscEndpointMissing = 36,
        CloudSqlInstanceNoIpAddress = 21,
        GkeControlPlaneRegionMismatch = 30,
        PublicGkeControlPlaneToPrivateDestination = 31,
        GkeControlPlaneNoRoute = 32,
        CloudSqlInstanceNotConfiguredForExternalTraffic = 33,
        PublicCloudSqlInstanceToPrivateDestination = 34,
        CloudSqlInstanceNoRoute = 35,
        CloudFunctionNotActive = 22,
        VpcConnectorNotSet = 23,
        VpcConnectorNotRunning = 24,
        ForwardingRuleRegionMismatch = 25,
        PscConnectionNotAccepted = 26,
        PscEndpointAccessedFromPeeredNetwork = 41,
        PscNegProducerEndpointNoGlobalAccess = 48,
        PscNegProducerForwardingRuleMultiplePorts = 54,
        CloudSqlPscNegUnsupported = 58,
        NoNatSubnetsForPscServiceAttachment = 57,
        HybridNegNonDynamicRouteMatched = 55,
        HybridNegNonLocalDynamicRouteMatched = 56,
        CloudRunRevisionNotReady = 29,
        DroppedInsidePscServiceProducer = 37,
        LoadBalancerHasNoProxySubnet = 39,
        CloudNatNoAddresses = 40,
        RoutingLoop = 59,
    }
    impl Cause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Cause::Unspecified => "CAUSE_UNSPECIFIED",
                Cause::UnknownExternalAddress => "UNKNOWN_EXTERNAL_ADDRESS",
                Cause::ForeignIpDisallowed => "FOREIGN_IP_DISALLOWED",
                Cause::FirewallRule => "FIREWALL_RULE",
                Cause::NoRoute => "NO_ROUTE",
                Cause::RouteBlackhole => "ROUTE_BLACKHOLE",
                Cause::RouteWrongNetwork => "ROUTE_WRONG_NETWORK",
                Cause::RouteNextHopIpAddressNotResolved => {
                    "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED"
                }
                Cause::RouteNextHopResourceNotFound => {
                    "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND"
                }
                Cause::RouteNextHopInstanceWrongNetwork => {
                    "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK"
                }
                Cause::RouteNextHopInstanceNonPrimaryIp => {
                    "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP"
                }
                Cause::RouteNextHopForwardingRuleIpMismatch => {
                    "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH"
                }
                Cause::RouteNextHopVpnTunnelNotEstablished => {
                    "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED"
                }
                Cause::RouteNextHopForwardingRuleTypeInvalid => {
                    "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID"
                }
                Cause::NoRouteFromInternetToPrivateIpv6Address => {
                    "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS"
                }
                Cause::VpnTunnelLocalSelectorMismatch => {
                    "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH"
                }
                Cause::VpnTunnelRemoteSelectorMismatch => {
                    "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH"
                }
                Cause::PrivateTrafficToInternet => "PRIVATE_TRAFFIC_TO_INTERNET",
                Cause::PrivateGoogleAccessDisallowed => {
                    "PRIVATE_GOOGLE_ACCESS_DISALLOWED"
                }
                Cause::PrivateGoogleAccessViaVpnTunnelUnsupported => {
                    "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED"
                }
                Cause::NoExternalAddress => "NO_EXTERNAL_ADDRESS",
                Cause::UnknownInternalAddress => "UNKNOWN_INTERNAL_ADDRESS",
                Cause::ForwardingRuleMismatch => "FORWARDING_RULE_MISMATCH",
                Cause::ForwardingRuleNoInstances => "FORWARDING_RULE_NO_INSTANCES",
                Cause::FirewallBlockingLoadBalancerBackendHealthCheck => {
                    "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK"
                }
                Cause::InstanceNotRunning => "INSTANCE_NOT_RUNNING",
                Cause::GkeClusterNotRunning => "GKE_CLUSTER_NOT_RUNNING",
                Cause::CloudSqlInstanceNotRunning => "CLOUD_SQL_INSTANCE_NOT_RUNNING",
                Cause::TrafficTypeBlocked => "TRAFFIC_TYPE_BLOCKED",
                Cause::GkeMasterUnauthorizedAccess => "GKE_MASTER_UNAUTHORIZED_ACCESS",
                Cause::CloudSqlInstanceUnauthorizedAccess => {
                    "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS"
                }
                Cause::DroppedInsideGkeService => "DROPPED_INSIDE_GKE_SERVICE",
                Cause::DroppedInsideCloudSqlService => "DROPPED_INSIDE_CLOUD_SQL_SERVICE",
                Cause::GoogleManagedServiceNoPeering => {
                    "GOOGLE_MANAGED_SERVICE_NO_PEERING"
                }
                Cause::GoogleManagedServiceNoPscEndpoint => {
                    "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT"
                }
                Cause::GkePscEndpointMissing => "GKE_PSC_ENDPOINT_MISSING",
                Cause::CloudSqlInstanceNoIpAddress => "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS",
                Cause::GkeControlPlaneRegionMismatch => {
                    "GKE_CONTROL_PLANE_REGION_MISMATCH"
                }
                Cause::PublicGkeControlPlaneToPrivateDestination => {
                    "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION"
                }
                Cause::GkeControlPlaneNoRoute => "GKE_CONTROL_PLANE_NO_ROUTE",
                Cause::CloudSqlInstanceNotConfiguredForExternalTraffic => {
                    "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC"
                }
                Cause::PublicCloudSqlInstanceToPrivateDestination => {
                    "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION"
                }
                Cause::CloudSqlInstanceNoRoute => "CLOUD_SQL_INSTANCE_NO_ROUTE",
                Cause::CloudFunctionNotActive => "CLOUD_FUNCTION_NOT_ACTIVE",
                Cause::VpcConnectorNotSet => "VPC_CONNECTOR_NOT_SET",
                Cause::VpcConnectorNotRunning => "VPC_CONNECTOR_NOT_RUNNING",
                Cause::ForwardingRuleRegionMismatch => "FORWARDING_RULE_REGION_MISMATCH",
                Cause::PscConnectionNotAccepted => "PSC_CONNECTION_NOT_ACCEPTED",
                Cause::PscEndpointAccessedFromPeeredNetwork => {
                    "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK"
                }
                Cause::PscNegProducerEndpointNoGlobalAccess => {
                    "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS"
                }
                Cause::PscNegProducerForwardingRuleMultiplePorts => {
                    "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS"
                }
                Cause::CloudSqlPscNegUnsupported => "CLOUD_SQL_PSC_NEG_UNSUPPORTED",
                Cause::NoNatSubnetsForPscServiceAttachment => {
                    "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT"
                }
                Cause::HybridNegNonDynamicRouteMatched => {
                    "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED"
                }
                Cause::HybridNegNonLocalDynamicRouteMatched => {
                    "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED"
                }
                Cause::CloudRunRevisionNotReady => "CLOUD_RUN_REVISION_NOT_READY",
                Cause::DroppedInsidePscServiceProducer => {
                    "DROPPED_INSIDE_PSC_SERVICE_PRODUCER"
                }
                Cause::LoadBalancerHasNoProxySubnet => {
                    "LOAD_BALANCER_HAS_NO_PROXY_SUBNET"
                }
                Cause::CloudNatNoAddresses => "CLOUD_NAT_NO_ADDRESSES",
                Cause::RoutingLoop => "ROUTING_LOOP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN_EXTERNAL_ADDRESS" => Some(Self::UnknownExternalAddress),
                "FOREIGN_IP_DISALLOWED" => Some(Self::ForeignIpDisallowed),
                "FIREWALL_RULE" => Some(Self::FirewallRule),
                "NO_ROUTE" => Some(Self::NoRoute),
                "ROUTE_BLACKHOLE" => Some(Self::RouteBlackhole),
                "ROUTE_WRONG_NETWORK" => Some(Self::RouteWrongNetwork),
                "ROUTE_NEXT_HOP_IP_ADDRESS_NOT_RESOLVED" => {
                    Some(Self::RouteNextHopIpAddressNotResolved)
                }
                "ROUTE_NEXT_HOP_RESOURCE_NOT_FOUND" => {
                    Some(Self::RouteNextHopResourceNotFound)
                }
                "ROUTE_NEXT_HOP_INSTANCE_WRONG_NETWORK" => {
                    Some(Self::RouteNextHopInstanceWrongNetwork)
                }
                "ROUTE_NEXT_HOP_INSTANCE_NON_PRIMARY_IP" => {
                    Some(Self::RouteNextHopInstanceNonPrimaryIp)
                }
                "ROUTE_NEXT_HOP_FORWARDING_RULE_IP_MISMATCH" => {
                    Some(Self::RouteNextHopForwardingRuleIpMismatch)
                }
                "ROUTE_NEXT_HOP_VPN_TUNNEL_NOT_ESTABLISHED" => {
                    Some(Self::RouteNextHopVpnTunnelNotEstablished)
                }
                "ROUTE_NEXT_HOP_FORWARDING_RULE_TYPE_INVALID" => {
                    Some(Self::RouteNextHopForwardingRuleTypeInvalid)
                }
                "NO_ROUTE_FROM_INTERNET_TO_PRIVATE_IPV6_ADDRESS" => {
                    Some(Self::NoRouteFromInternetToPrivateIpv6Address)
                }
                "VPN_TUNNEL_LOCAL_SELECTOR_MISMATCH" => {
                    Some(Self::VpnTunnelLocalSelectorMismatch)
                }
                "VPN_TUNNEL_REMOTE_SELECTOR_MISMATCH" => {
                    Some(Self::VpnTunnelRemoteSelectorMismatch)
                }
                "PRIVATE_TRAFFIC_TO_INTERNET" => Some(Self::PrivateTrafficToInternet),
                "PRIVATE_GOOGLE_ACCESS_DISALLOWED" => {
                    Some(Self::PrivateGoogleAccessDisallowed)
                }
                "PRIVATE_GOOGLE_ACCESS_VIA_VPN_TUNNEL_UNSUPPORTED" => {
                    Some(Self::PrivateGoogleAccessViaVpnTunnelUnsupported)
                }
                "NO_EXTERNAL_ADDRESS" => Some(Self::NoExternalAddress),
                "UNKNOWN_INTERNAL_ADDRESS" => Some(Self::UnknownInternalAddress),
                "FORWARDING_RULE_MISMATCH" => Some(Self::ForwardingRuleMismatch),
                "FORWARDING_RULE_NO_INSTANCES" => Some(Self::ForwardingRuleNoInstances),
                "FIREWALL_BLOCKING_LOAD_BALANCER_BACKEND_HEALTH_CHECK" => {
                    Some(Self::FirewallBlockingLoadBalancerBackendHealthCheck)
                }
                "INSTANCE_NOT_RUNNING" => Some(Self::InstanceNotRunning),
                "GKE_CLUSTER_NOT_RUNNING" => Some(Self::GkeClusterNotRunning),
                "CLOUD_SQL_INSTANCE_NOT_RUNNING" => {
                    Some(Self::CloudSqlInstanceNotRunning)
                }
                "TRAFFIC_TYPE_BLOCKED" => Some(Self::TrafficTypeBlocked),
                "GKE_MASTER_UNAUTHORIZED_ACCESS" => {
                    Some(Self::GkeMasterUnauthorizedAccess)
                }
                "CLOUD_SQL_INSTANCE_UNAUTHORIZED_ACCESS" => {
                    Some(Self::CloudSqlInstanceUnauthorizedAccess)
                }
                "DROPPED_INSIDE_GKE_SERVICE" => Some(Self::DroppedInsideGkeService),
                "DROPPED_INSIDE_CLOUD_SQL_SERVICE" => {
                    Some(Self::DroppedInsideCloudSqlService)
                }
                "GOOGLE_MANAGED_SERVICE_NO_PEERING" => {
                    Some(Self::GoogleManagedServiceNoPeering)
                }
                "GOOGLE_MANAGED_SERVICE_NO_PSC_ENDPOINT" => {
                    Some(Self::GoogleManagedServiceNoPscEndpoint)
                }
                "GKE_PSC_ENDPOINT_MISSING" => Some(Self::GkePscEndpointMissing),
                "CLOUD_SQL_INSTANCE_NO_IP_ADDRESS" => {
                    Some(Self::CloudSqlInstanceNoIpAddress)
                }
                "GKE_CONTROL_PLANE_REGION_MISMATCH" => {
                    Some(Self::GkeControlPlaneRegionMismatch)
                }
                "PUBLIC_GKE_CONTROL_PLANE_TO_PRIVATE_DESTINATION" => {
                    Some(Self::PublicGkeControlPlaneToPrivateDestination)
                }
                "GKE_CONTROL_PLANE_NO_ROUTE" => Some(Self::GkeControlPlaneNoRoute),
                "CLOUD_SQL_INSTANCE_NOT_CONFIGURED_FOR_EXTERNAL_TRAFFIC" => {
                    Some(Self::CloudSqlInstanceNotConfiguredForExternalTraffic)
                }
                "PUBLIC_CLOUD_SQL_INSTANCE_TO_PRIVATE_DESTINATION" => {
                    Some(Self::PublicCloudSqlInstanceToPrivateDestination)
                }
                "CLOUD_SQL_INSTANCE_NO_ROUTE" => Some(Self::CloudSqlInstanceNoRoute),
                "CLOUD_FUNCTION_NOT_ACTIVE" => Some(Self::CloudFunctionNotActive),
                "VPC_CONNECTOR_NOT_SET" => Some(Self::VpcConnectorNotSet),
                "VPC_CONNECTOR_NOT_RUNNING" => Some(Self::VpcConnectorNotRunning),
                "FORWARDING_RULE_REGION_MISMATCH" => {
                    Some(Self::ForwardingRuleRegionMismatch)
                }
                "PSC_CONNECTION_NOT_ACCEPTED" => Some(Self::PscConnectionNotAccepted),
                "PSC_ENDPOINT_ACCESSED_FROM_PEERED_NETWORK" => {
                    Some(Self::PscEndpointAccessedFromPeeredNetwork)
                }
                "PSC_NEG_PRODUCER_ENDPOINT_NO_GLOBAL_ACCESS" => {
                    Some(Self::PscNegProducerEndpointNoGlobalAccess)
                }
                "PSC_NEG_PRODUCER_FORWARDING_RULE_MULTIPLE_PORTS" => {
                    Some(Self::PscNegProducerForwardingRuleMultiplePorts)
                }
                "CLOUD_SQL_PSC_NEG_UNSUPPORTED" => Some(Self::CloudSqlPscNegUnsupported),
                "NO_NAT_SUBNETS_FOR_PSC_SERVICE_ATTACHMENT" => {
                    Some(Self::NoNatSubnetsForPscServiceAttachment)
                }
                "HYBRID_NEG_NON_DYNAMIC_ROUTE_MATCHED" => {
                    Some(Self::HybridNegNonDynamicRouteMatched)
                }
                "HYBRID_NEG_NON_LOCAL_DYNAMIC_ROUTE_MATCHED" => {
                    Some(Self::HybridNegNonLocalDynamicRouteMatched)
                }
                "CLOUD_RUN_REVISION_NOT_READY" => Some(Self::CloudRunRevisionNotReady),
                "DROPPED_INSIDE_PSC_SERVICE_PRODUCER" => {
                    Some(Self::DroppedInsidePscServiceProducer)
                }
                "LOAD_BALANCER_HAS_NO_PROXY_SUBNET" => {
                    Some(Self::LoadBalancerHasNoProxySubnet)
                }
                "CLOUD_NAT_NO_ADDRESSES" => Some(Self::CloudNatNoAddresses),
                "ROUTING_LOOP" => Some(Self::RoutingLoop),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GkeMasterInfo {
    #[prost(string, tag = "2")]
    pub cluster_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub cluster_network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub external_ip: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudSqlInstanceInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub internal_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub external_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub region: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudFunctionInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub location: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub version_id: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloudRunRevisionInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub location: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub service_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppEngineVersionInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub runtime: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub environment: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcConnectorInfo {
    #[prost(string, tag = "1")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub location: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NatInfo {
    #[prost(enumeration = "nat_info::Type", tag = "1")]
    pub r#type: i32,
    #[prost(string, tag = "2")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub network_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub old_source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub new_source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub old_destination_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub new_destination_ip: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub old_source_port: i32,
    #[prost(int32, tag = "9")]
    pub new_source_port: i32,
    #[prost(int32, tag = "10")]
    pub old_destination_port: i32,
    #[prost(int32, tag = "11")]
    pub new_destination_port: i32,
    #[prost(string, tag = "12")]
    pub router_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub nat_gateway_name: ::prost::alloc::string::String,
}
/// Nested message and enum types in `NatInfo`.
pub mod nat_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        InternalToExternal = 1,
        ExternalToInternal = 2,
        CloudNat = 3,
        PrivateServiceConnect = 4,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::InternalToExternal => "INTERNAL_TO_EXTERNAL",
                Type::ExternalToInternal => "EXTERNAL_TO_INTERNAL",
                Type::CloudNat => "CLOUD_NAT",
                Type::PrivateServiceConnect => "PRIVATE_SERVICE_CONNECT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INTERNAL_TO_EXTERNAL" => Some(Self::InternalToExternal),
                "EXTERNAL_TO_INTERNAL" => Some(Self::ExternalToInternal),
                "CLOUD_NAT" => Some(Self::CloudNat),
                "PRIVATE_SERVICE_CONNECT" => Some(Self::PrivateServiceConnect),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProxyConnectionInfo {
    #[prost(string, tag = "1")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub old_source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_source_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub old_destination_ip: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub new_destination_ip: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub old_source_port: i32,
    #[prost(int32, tag = "7")]
    pub new_source_port: i32,
    #[prost(int32, tag = "8")]
    pub old_destination_port: i32,
    #[prost(int32, tag = "9")]
    pub new_destination_port: i32,
    #[prost(string, tag = "10")]
    pub subnet_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub network_uri: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LoadBalancerBackendInfo {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub instance_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub backend_service_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub instance_group_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub network_endpoint_group_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub backend_bucket_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub psc_service_attachment_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub psc_google_api_target: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub health_check_uri: ::prost::alloc::string::String,
    #[prost(
        enumeration = "load_balancer_backend_info::HealthCheckFirewallsConfigState",
        tag = "7"
    )]
    pub health_check_firewalls_config_state: i32,
}
/// Nested message and enum types in `LoadBalancerBackendInfo`.
pub mod load_balancer_backend_info {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum HealthCheckFirewallsConfigState {
        Unspecified = 0,
        FirewallsConfigured = 1,
        FirewallsPartiallyConfigured = 2,
        FirewallsNotConfigured = 3,
        FirewallsUnsupported = 4,
    }
    impl HealthCheckFirewallsConfigState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                HealthCheckFirewallsConfigState::Unspecified => {
                    "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED"
                }
                HealthCheckFirewallsConfigState::FirewallsConfigured => {
                    "FIREWALLS_CONFIGURED"
                }
                HealthCheckFirewallsConfigState::FirewallsPartiallyConfigured => {
                    "FIREWALLS_PARTIALLY_CONFIGURED"
                }
                HealthCheckFirewallsConfigState::FirewallsNotConfigured => {
                    "FIREWALLS_NOT_CONFIGURED"
                }
                HealthCheckFirewallsConfigState::FirewallsUnsupported => {
                    "FIREWALLS_UNSUPPORTED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "HEALTH_CHECK_FIREWALLS_CONFIG_STATE_UNSPECIFIED" => {
                    Some(Self::Unspecified)
                }
                "FIREWALLS_CONFIGURED" => Some(Self::FirewallsConfigured),
                "FIREWALLS_PARTIALLY_CONFIGURED" => {
                    Some(Self::FirewallsPartiallyConfigured)
                }
                "FIREWALLS_NOT_CONFIGURED" => Some(Self::FirewallsNotConfigured),
                "FIREWALLS_UNSUPPORTED" => Some(Self::FirewallsUnsupported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageBucketInfo {
    #[prost(string, tag = "1")]
    pub bucket: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum LoadBalancerType {
    Unspecified = 0,
    HttpsAdvancedLoadBalancer = 1,
    HttpsLoadBalancer = 2,
    RegionalHttpsLoadBalancer = 3,
    InternalHttpsLoadBalancer = 4,
    SslProxyLoadBalancer = 5,
    TcpProxyLoadBalancer = 6,
    InternalTcpProxyLoadBalancer = 7,
    NetworkLoadBalancer = 8,
    LegacyNetworkLoadBalancer = 9,
    TcpUdpInternalLoadBalancer = 10,
}
impl LoadBalancerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            LoadBalancerType::Unspecified => "LOAD_BALANCER_TYPE_UNSPECIFIED",
            LoadBalancerType::HttpsAdvancedLoadBalancer => "HTTPS_ADVANCED_LOAD_BALANCER",
            LoadBalancerType::HttpsLoadBalancer => "HTTPS_LOAD_BALANCER",
            LoadBalancerType::RegionalHttpsLoadBalancer => "REGIONAL_HTTPS_LOAD_BALANCER",
            LoadBalancerType::InternalHttpsLoadBalancer => "INTERNAL_HTTPS_LOAD_BALANCER",
            LoadBalancerType::SslProxyLoadBalancer => "SSL_PROXY_LOAD_BALANCER",
            LoadBalancerType::TcpProxyLoadBalancer => "TCP_PROXY_LOAD_BALANCER",
            LoadBalancerType::InternalTcpProxyLoadBalancer => {
                "INTERNAL_TCP_PROXY_LOAD_BALANCER"
            }
            LoadBalancerType::NetworkLoadBalancer => "NETWORK_LOAD_BALANCER",
            LoadBalancerType::LegacyNetworkLoadBalancer => "LEGACY_NETWORK_LOAD_BALANCER",
            LoadBalancerType::TcpUdpInternalLoadBalancer => {
                "TCP_UDP_INTERNAL_LOAD_BALANCER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LOAD_BALANCER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "HTTPS_ADVANCED_LOAD_BALANCER" => Some(Self::HttpsAdvancedLoadBalancer),
            "HTTPS_LOAD_BALANCER" => Some(Self::HttpsLoadBalancer),
            "REGIONAL_HTTPS_LOAD_BALANCER" => Some(Self::RegionalHttpsLoadBalancer),
            "INTERNAL_HTTPS_LOAD_BALANCER" => Some(Self::InternalHttpsLoadBalancer),
            "SSL_PROXY_LOAD_BALANCER" => Some(Self::SslProxyLoadBalancer),
            "TCP_PROXY_LOAD_BALANCER" => Some(Self::TcpProxyLoadBalancer),
            "INTERNAL_TCP_PROXY_LOAD_BALANCER" => {
                Some(Self::InternalTcpProxyLoadBalancer)
            }
            "NETWORK_LOAD_BALANCER" => Some(Self::NetworkLoadBalancer),
            "LEGACY_NETWORK_LOAD_BALANCER" => Some(Self::LegacyNetworkLoadBalancer),
            "TCP_UDP_INTERNAL_LOAD_BALANCER" => Some(Self::TcpUdpInternalLoadBalancer),
            _ => None,
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConnectivityTest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub description: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<Endpoint>,
    #[prost(message, optional, tag = "4")]
    pub destination: ::core::option::Option<Endpoint>,
    #[prost(string, tag = "5")]
    pub protocol: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub related_projects: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub display_name: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "8")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "10")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "12")]
    pub reachability_details: ::core::option::Option<ReachabilityDetails>,
    #[prost(message, optional, tag = "14")]
    pub probing_details: ::core::option::Option<ProbingDetails>,
    #[prost(bool, tag = "17")]
    pub bypass_firewall_checks: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Endpoint {
    #[prost(string, tag = "1")]
    pub ip_address: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub port: i32,
    #[prost(string, tag = "3")]
    pub instance: ::prost::alloc::string::String,
    #[prost(string, tag = "13")]
    pub forwarding_rule: ::prost::alloc::string::String,
    #[prost(enumeration = "endpoint::ForwardingRuleTarget", optional, tag = "14")]
    pub forwarding_rule_target: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "15")]
    pub load_balancer_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "LoadBalancerType", optional, tag = "16")]
    pub load_balancer_type: ::core::option::Option<i32>,
    #[prost(string, tag = "7")]
    pub gke_master_cluster: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub cloud_sql_instance: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub cloud_function: ::core::option::Option<endpoint::CloudFunctionEndpoint>,
    #[prost(message, optional, tag = "11")]
    pub app_engine_version: ::core::option::Option<endpoint::AppEngineVersionEndpoint>,
    #[prost(message, optional, tag = "12")]
    pub cloud_run_revision: ::core::option::Option<endpoint::CloudRunRevisionEndpoint>,
    #[prost(string, tag = "4")]
    pub network: ::prost::alloc::string::String,
    #[prost(enumeration = "endpoint::NetworkType", tag = "5")]
    pub network_type: i32,
    #[prost(string, tag = "6")]
    pub project_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Endpoint`.
pub mod endpoint {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudFunctionEndpoint {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AppEngineVersionEndpoint {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CloudRunRevisionEndpoint {
        #[prost(string, tag = "1")]
        pub uri: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NetworkType {
        Unspecified = 0,
        GcpNetwork = 1,
        NonGcpNetwork = 2,
    }
    impl NetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NetworkType::Unspecified => "NETWORK_TYPE_UNSPECIFIED",
                NetworkType::GcpNetwork => "GCP_NETWORK",
                NetworkType::NonGcpNetwork => "NON_GCP_NETWORK",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "NETWORK_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "GCP_NETWORK" => Some(Self::GcpNetwork),
                "NON_GCP_NETWORK" => Some(Self::NonGcpNetwork),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ForwardingRuleTarget {
        Unspecified = 0,
        Instance = 1,
        LoadBalancer = 2,
        VpnGateway = 3,
        Psc = 4,
    }
    impl ForwardingRuleTarget {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ForwardingRuleTarget::Unspecified => "FORWARDING_RULE_TARGET_UNSPECIFIED",
                ForwardingRuleTarget::Instance => "INSTANCE",
                ForwardingRuleTarget::LoadBalancer => "LOAD_BALANCER",
                ForwardingRuleTarget::VpnGateway => "VPN_GATEWAY",
                ForwardingRuleTarget::Psc => "PSC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORWARDING_RULE_TARGET_UNSPECIFIED" => Some(Self::Unspecified),
                "INSTANCE" => Some(Self::Instance),
                "LOAD_BALANCER" => Some(Self::LoadBalancer),
                "VPN_GATEWAY" => Some(Self::VpnGateway),
                "PSC" => Some(Self::Psc),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReachabilityDetails {
    #[prost(enumeration = "reachability_details::Result", tag = "1")]
    pub result: i32,
    #[prost(message, optional, tag = "2")]
    pub verify_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(message, repeated, tag = "5")]
    pub traces: ::prost::alloc::vec::Vec<Trace>,
}
/// Nested message and enum types in `ReachabilityDetails`.
pub mod reachability_details {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Result {
        Unspecified = 0,
        Reachable = 1,
        Unreachable = 2,
        Ambiguous = 4,
        Undetermined = 5,
    }
    impl Result {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Result::Unspecified => "RESULT_UNSPECIFIED",
                Result::Reachable => "REACHABLE",
                Result::Unreachable => "UNREACHABLE",
                Result::Ambiguous => "AMBIGUOUS",
                Result::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "REACHABLE" => Some(Self::Reachable),
                "UNREACHABLE" => Some(Self::Unreachable),
                "AMBIGUOUS" => Some(Self::Ambiguous),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LatencyPercentile {
    #[prost(int32, tag = "1")]
    pub percent: i32,
    #[prost(int64, tag = "2")]
    pub latency_micros: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LatencyDistribution {
    #[prost(message, repeated, tag = "1")]
    pub latency_percentiles: ::prost::alloc::vec::Vec<LatencyPercentile>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProbingDetails {
    #[prost(enumeration = "probing_details::ProbingResult", tag = "1")]
    pub result: i32,
    #[prost(message, optional, tag = "2")]
    pub verify_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub error: ::core::option::Option<super::super::super::rpc::Status>,
    #[prost(enumeration = "probing_details::ProbingAbortCause", tag = "4")]
    pub abort_cause: i32,
    #[prost(int32, tag = "5")]
    pub sent_probe_count: i32,
    #[prost(int32, tag = "6")]
    pub successful_probe_count: i32,
    #[prost(message, optional, tag = "7")]
    pub endpoint_info: ::core::option::Option<EndpointInfo>,
    #[prost(message, optional, tag = "8")]
    pub probing_latency: ::core::option::Option<LatencyDistribution>,
    #[prost(message, optional, tag = "9")]
    pub destination_egress_location: ::core::option::Option<
        probing_details::EdgeLocation,
    >,
}
/// Nested message and enum types in `ProbingDetails`.
pub mod probing_details {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct EdgeLocation {
        #[prost(string, tag = "1")]
        pub metropolitan_area: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProbingResult {
        Unspecified = 0,
        Reachable = 1,
        Unreachable = 2,
        ReachabilityInconsistent = 3,
        Undetermined = 4,
    }
    impl ProbingResult {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProbingResult::Unspecified => "PROBING_RESULT_UNSPECIFIED",
                ProbingResult::Reachable => "REACHABLE",
                ProbingResult::Unreachable => "UNREACHABLE",
                ProbingResult::ReachabilityInconsistent => "REACHABILITY_INCONSISTENT",
                ProbingResult::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROBING_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
                "REACHABLE" => Some(Self::Reachable),
                "UNREACHABLE" => Some(Self::Unreachable),
                "REACHABILITY_INCONSISTENT" => Some(Self::ReachabilityInconsistent),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProbingAbortCause {
        Unspecified = 0,
        PermissionDenied = 1,
        NoSourceLocation = 2,
    }
    impl ProbingAbortCause {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProbingAbortCause::Unspecified => "PROBING_ABORT_CAUSE_UNSPECIFIED",
                ProbingAbortCause::PermissionDenied => "PERMISSION_DENIED",
                ProbingAbortCause::NoSourceLocation => "NO_SOURCE_LOCATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PROBING_ABORT_CAUSE_UNSPECIFIED" => Some(Self::Unspecified),
                "PERMISSION_DENIED" => Some(Self::PermissionDenied),
                "NO_SOURCE_LOCATION" => Some(Self::NoSourceLocation),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectivityTestsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListConnectivityTestsResponse {
    #[prost(message, repeated, tag = "1")]
    pub resources: ::prost::alloc::vec::Vec<ConnectivityTest>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectivityTestRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateConnectivityTestRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub test_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub resource: ::core::option::Option<ConnectivityTest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateConnectivityTestRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub resource: ::core::option::Option<ConnectivityTest>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteConnectivityTestRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RerunConnectivityTestRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(message, optional, tag = "1")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub target: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub verb: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub status_detail: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub cancel_requested: bool,
    #[prost(string, tag = "7")]
    pub api_version: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod reachability_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Reachability service in the Google Cloud Network Management API provides
    /// services that analyze the reachability within a single Google Virtual Private
    /// Cloud (VPC) network, between peered VPC networks, between VPC and on-premises
    /// networks, or between VPC networks and internet hosts. A reachability analysis
    /// is based on Google Cloud network configurations.
    ///
    /// You can use the analysis results to verify these configurations and
    /// to troubleshoot connectivity issues.
    #[derive(Debug, Clone)]
    pub struct ReachabilityServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReachabilityServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReachabilityServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ReachabilityServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all Connectivity Tests owned by a project.
        pub async fn list_connectivity_tests(
            &mut self,
            request: impl tonic::IntoRequest<super::ListConnectivityTestsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListConnectivityTestsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/ListConnectivityTests",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "ListConnectivityTests",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a specific Connectivity Test.
        pub async fn get_connectivity_test(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectivityTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ConnectivityTest>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/GetConnectivityTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "GetConnectivityTest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new Connectivity Test.
        /// After you create a test, the reachability analysis is performed as part
        /// of the long running operation, which completes when the analysis completes.
        ///
        /// If the endpoint specifications in `ConnectivityTest` are invalid
        /// (for example, containing non-existent resources in the network, or you
        /// don't have read permissions to the network configurations of listed
        /// projects), then the reachability result returns a value of `UNKNOWN`.
        ///
        /// If the endpoint specifications in `ConnectivityTest` are
        /// incomplete, the reachability result returns a value of
        /// <code>AMBIGUOUS</code>. For more information,
        /// see the Connectivity Test documentation.
        pub async fn create_connectivity_test(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateConnectivityTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/CreateConnectivityTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "CreateConnectivityTest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates the configuration of an existing `ConnectivityTest`.
        /// After you update a test, the reachability analysis is performed as part
        /// of the long running operation, which completes when the analysis completes.
        /// The Reachability state in the test resource is updated with the new result.
        ///
        /// If the endpoint specifications in `ConnectivityTest` are invalid
        /// (for example, they contain non-existent resources in the network, or the
        /// user does not have read permissions to the network configurations of
        /// listed projects), then the reachability result returns a value of
        /// <code>UNKNOWN</code>.
        ///
        /// If the endpoint specifications in `ConnectivityTest` are incomplete, the
        /// reachability result returns a value of `AMBIGUOUS`. See the documentation
        /// in `ConnectivityTest` for for more details.
        pub async fn update_connectivity_test(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateConnectivityTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/UpdateConnectivityTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "UpdateConnectivityTest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Rerun an existing `ConnectivityTest`.
        /// After the user triggers the rerun, the reachability analysis is performed
        /// as part of the long running operation, which completes when the analysis
        /// completes.
        ///
        /// Even though the test configuration remains the same, the reachability
        /// result may change due to underlying network configuration changes.
        ///
        /// If the endpoint specifications in `ConnectivityTest` become invalid (for
        /// example, specified resources are deleted in the network, or you lost
        /// read permissions to the network configurations of listed projects), then
        /// the reachability result returns a value of `UNKNOWN`.
        pub async fn rerun_connectivity_test(
            &mut self,
            request: impl tonic::IntoRequest<super::RerunConnectivityTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/RerunConnectivityTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "RerunConnectivityTest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a specific `ConnectivityTest`.
        pub async fn delete_connectivity_test(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteConnectivityTestRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.ReachabilityService/DeleteConnectivityTest",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.ReachabilityService",
                        "DeleteConnectivityTest",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VpcFlowLogsConfig {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "vpc_flow_logs_config::State", optional, tag = "3")]
    pub state: ::core::option::Option<i32>,
    #[prost(
        enumeration = "vpc_flow_logs_config::AggregationInterval",
        optional,
        tag = "4"
    )]
    pub aggregation_interval: ::core::option::Option<i32>,
    #[prost(float, optional, tag = "5")]
    pub flow_sampling: ::core::option::Option<f32>,
    #[prost(enumeration = "vpc_flow_logs_config::Metadata", optional, tag = "6")]
    pub metadata: ::core::option::Option<i32>,
    #[prost(string, repeated, tag = "7")]
    pub metadata_fields: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub filter_expr: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "11")]
    pub labels: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(message, optional, tag = "9")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "10")]
    pub update_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(oneof = "vpc_flow_logs_config::TargetResource", tags = "102, 103")]
    pub target_resource: ::core::option::Option<vpc_flow_logs_config::TargetResource>,
}
/// Nested message and enum types in `VpcFlowLogsConfig`.
pub mod vpc_flow_logs_config {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum State {
        Unspecified = 0,
        Enabled = 1,
        Disabled = 2,
    }
    impl State {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                State::Unspecified => "STATE_UNSPECIFIED",
                State::Enabled => "ENABLED",
                State::Disabled => "DISABLED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATE_UNSPECIFIED" => Some(Self::Unspecified),
                "ENABLED" => Some(Self::Enabled),
                "DISABLED" => Some(Self::Disabled),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AggregationInterval {
        Unspecified = 0,
        Interval5Sec = 1,
        Interval30Sec = 2,
        Interval1Min = 3,
        Interval5Min = 4,
        Interval10Min = 5,
        Interval15Min = 6,
    }
    impl AggregationInterval {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AggregationInterval::Unspecified => "AGGREGATION_INTERVAL_UNSPECIFIED",
                AggregationInterval::Interval5Sec => "INTERVAL_5_SEC",
                AggregationInterval::Interval30Sec => "INTERVAL_30_SEC",
                AggregationInterval::Interval1Min => "INTERVAL_1_MIN",
                AggregationInterval::Interval5Min => "INTERVAL_5_MIN",
                AggregationInterval::Interval10Min => "INTERVAL_10_MIN",
                AggregationInterval::Interval15Min => "INTERVAL_15_MIN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "AGGREGATION_INTERVAL_UNSPECIFIED" => Some(Self::Unspecified),
                "INTERVAL_5_SEC" => Some(Self::Interval5Sec),
                "INTERVAL_30_SEC" => Some(Self::Interval30Sec),
                "INTERVAL_1_MIN" => Some(Self::Interval1Min),
                "INTERVAL_5_MIN" => Some(Self::Interval5Min),
                "INTERVAL_10_MIN" => Some(Self::Interval10Min),
                "INTERVAL_15_MIN" => Some(Self::Interval15Min),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Metadata {
        Unspecified = 0,
        IncludeAllMetadata = 1,
        ExcludeAllMetadata = 2,
        CustomMetadata = 3,
    }
    impl Metadata {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Metadata::Unspecified => "METADATA_UNSPECIFIED",
                Metadata::IncludeAllMetadata => "INCLUDE_ALL_METADATA",
                Metadata::ExcludeAllMetadata => "EXCLUDE_ALL_METADATA",
                Metadata::CustomMetadata => "CUSTOM_METADATA",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "METADATA_UNSPECIFIED" => Some(Self::Unspecified),
                "INCLUDE_ALL_METADATA" => Some(Self::IncludeAllMetadata),
                "EXCLUDE_ALL_METADATA" => Some(Self::ExcludeAllMetadata),
                "CUSTOM_METADATA" => Some(Self::CustomMetadata),
                _ => None,
            }
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TargetResource {
        #[prost(string, tag = "102")]
        InterconnectAttachment(::prost::alloc::string::String),
        #[prost(string, tag = "103")]
        VpnTunnel(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpcFlowLogsConfigsRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub filter: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub order_by: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVpcFlowLogsConfigsResponse {
    #[prost(message, repeated, tag = "1")]
    pub vpc_flow_logs_configs: ::prost::alloc::vec::Vec<VpcFlowLogsConfig>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub unreachable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVpcFlowLogsConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVpcFlowLogsConfigRequest {
    #[prost(string, tag = "1")]
    pub parent: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub vpc_flow_logs_config_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub vpc_flow_logs_config: ::core::option::Option<VpcFlowLogsConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVpcFlowLogsConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
    #[prost(message, optional, tag = "2")]
    pub vpc_flow_logs_config: ::core::option::Option<VpcFlowLogsConfig>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVpcFlowLogsConfigRequest {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod vpc_flow_logs_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The VPC Flow Logs service in the Google Cloud Network Management API provides
    /// configurations that generate Flow Logs. The service and the configuration
    /// resources created using this service are global.
    #[derive(Debug, Clone)]
    pub struct VpcFlowLogsServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VpcFlowLogsServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VpcFlowLogsServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VpcFlowLogsServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists all `VpcFlowLogsConfigs` in a given project.
        pub async fn list_vpc_flow_logs_configs(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVpcFlowLogsConfigsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListVpcFlowLogsConfigsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.VpcFlowLogsService/ListVpcFlowLogsConfigs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.VpcFlowLogsService",
                        "ListVpcFlowLogsConfigs",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the details of a specific `VpcFlowLogsConfig`.
        pub async fn get_vpc_flow_logs_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVpcFlowLogsConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::VpcFlowLogsConfig>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.VpcFlowLogsService/GetVpcFlowLogsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.VpcFlowLogsService",
                        "GetVpcFlowLogsConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new `VpcFlowLogsConfig`.
        /// If a configuration with the exact same settings already exists (even if the
        /// ID is different), the creation fails.
        /// Notes:
        ///
        /// 1. Creating a configuration with state=DISABLED will fail.
        /// 1. The following fields are not considrered as `settings` for the purpose
        ///   of the check mentioned above, therefore - creating another configuration
        ///   with the same fields but different values for the following fields will
        ///   fail as well:
        ///
        /// * name
        /// * create_time
        /// * update_time
        /// * labels
        /// * description
        pub async fn create_vpc_flow_logs_config(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVpcFlowLogsConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.VpcFlowLogsService/CreateVpcFlowLogsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.VpcFlowLogsService",
                        "CreateVpcFlowLogsConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an existing `VpcFlowLogsConfig`.
        /// If a configuration with the exact same settings already exists (even if the
        /// ID is different), the creation fails.
        /// Notes:
        ///
        /// 1. The following fields are not considrered as `settings` for the purpose
        ///   of the check mentioned above, therefore - updating another configuration
        ///   with the same fields but different values for the following fields will
        ///   fail as well:
        ///
        /// * name
        /// * create_time
        /// * update_time
        /// * labels
        /// * description
        pub async fn update_vpc_flow_logs_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVpcFlowLogsConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.VpcFlowLogsService/UpdateVpcFlowLogsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.VpcFlowLogsService",
                        "UpdateVpcFlowLogsConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a specific `VpcFlowLogsConfig`.
        pub async fn delete_vpc_flow_logs_config(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVpcFlowLogsConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.cloud.networkmanagement.v1beta1.VpcFlowLogsService/DeleteVpcFlowLogsConfig",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.cloud.networkmanagement.v1beta1.VpcFlowLogsService",
                        "DeleteVpcFlowLogsConfig",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
