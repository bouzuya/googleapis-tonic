// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationMetadata {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "4")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "5")]
    pub request: ::core::option::Option<::prost_types::Any>,
    #[prost(message, repeated, tag = "6")]
    pub events: ::prost::alloc::vec::Vec<OperationEvent>,
    #[prost(string, tag = "7")]
    pub client_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub runtime_metadata: ::core::option::Option<::prost_types::Any>,
    #[prost(btree_map = "string, string", tag = "9")]
    pub labels: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OperationEvent {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantSetMetadata {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub id: ::prost::alloc::string::String,
    #[prost(enumeration = "variant_set_metadata::Type", tag = "5")]
    pub r#type: i32,
    #[prost(string, tag = "8")]
    pub number: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub description: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "3")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
/// Nested message and enum types in `VariantSetMetadata`.
pub mod variant_set_metadata {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Integer = 1,
        Float = 2,
        Flag = 3,
        Character = 4,
        String = 5,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Integer => "INTEGER",
                Type::Float => "FLOAT",
                Type::Flag => "FLAG",
                Type::Character => "CHARACTER",
                Type::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "INTEGER" => Some(Self::Integer),
                "FLOAT" => Some(Self::Float),
                "FLAG" => Some(Self::Flag),
                "CHARACTER" => Some(Self::Character),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantSet {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "5")]
    pub reference_bounds: ::prost::alloc::vec::Vec<ReferenceBound>,
    #[prost(message, repeated, tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<VariantSetMetadata>,
    #[prost(string, tag = "7")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub description: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Variant {
    #[prost(string, tag = "15")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "12")]
    pub created: i64,
    #[prost(string, tag = "14")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "16")]
    pub start: i64,
    #[prost(int64, tag = "13")]
    pub end: i64,
    #[prost(string, tag = "6")]
    pub reference_bases: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub alternate_bases: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(double, tag = "8")]
    pub quality: f64,
    #[prost(string, repeated, tag = "9")]
    pub filter: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(btree_map = "string, message", tag = "10")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
    #[prost(message, repeated, tag = "11")]
    pub calls: ::prost::alloc::vec::Vec<VariantCall>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantCall {
    #[prost(string, tag = "8")]
    pub call_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub call_set_name: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "7")]
    pub genotype: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "5")]
    pub phaseset: ::prost::alloc::string::String,
    #[prost(double, repeated, tag = "6")]
    pub genotype_likelihood: ::prost::alloc::vec::Vec<f64>,
    #[prost(btree_map = "string, message", tag = "2")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CallSet {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub sample_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub variant_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "5")]
    pub created: i64,
    #[prost(btree_map = "string, message", tag = "4")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceBound {
    #[prost(string, tag = "1")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub upper_bound: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportVariantsRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub source_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(enumeration = "import_variants_request::Format", tag = "3")]
    pub format: i32,
    #[prost(bool, tag = "5")]
    pub normalize_reference_names: bool,
    #[prost(btree_map = "string, enumeration(InfoMergeOperation)", tag = "6")]
    pub info_merge_config: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        i32,
    >,
}
/// Nested message and enum types in `ImportVariantsRequest`.
pub mod import_variants_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        Unspecified = 0,
        Vcf = 1,
        CompleteGenomics = 2,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::Unspecified => "FORMAT_UNSPECIFIED",
                Format::Vcf => "FORMAT_VCF",
                Format::CompleteGenomics => "FORMAT_COMPLETE_GENOMICS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "FORMAT_VCF" => Some(Self::Vcf),
                "FORMAT_COMPLETE_GENOMICS" => Some(Self::CompleteGenomics),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportVariantsResponse {
    #[prost(string, repeated, tag = "1")]
    pub call_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVariantSetRequest {
    #[prost(message, optional, tag = "1")]
    pub variant_set: ::core::option::Option<VariantSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportVariantSetRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub call_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(enumeration = "export_variant_set_request::Format", tag = "4")]
    pub format: i32,
    #[prost(string, tag = "5")]
    pub bigquery_dataset: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub bigquery_table: ::prost::alloc::string::String,
}
/// Nested message and enum types in `ExportVariantSetRequest`.
pub mod export_variant_set_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Format {
        Unspecified = 0,
        Bigquery = 1,
    }
    impl Format {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Format::Unspecified => "FORMAT_UNSPECIFIED",
                Format::Bigquery => "FORMAT_BIGQUERY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
                "FORMAT_BIGQUERY" => Some(Self::Bigquery),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVariantSetRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVariantSetsRequest {
    #[prost(string, repeated, tag = "1")]
    pub dataset_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVariantSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub variant_sets: ::prost::alloc::vec::Vec<VariantSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVariantSetRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVariantSetRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub variant_set: ::core::option::Option<VariantSet>,
    #[prost(message, optional, tag = "5")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVariantsRequest {
    #[prost(string, repeated, tag = "1")]
    pub variant_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub variant_name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub call_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub start: i64,
    #[prost(int64, tag = "6")]
    pub end: i64,
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub page_size: i32,
    #[prost(int32, tag = "9")]
    pub max_calls: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchVariantsResponse {
    #[prost(message, repeated, tag = "1")]
    pub variants: ::prost::alloc::vec::Vec<Variant>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateVariantRequest {
    #[prost(message, optional, tag = "1")]
    pub variant: ::core::option::Option<Variant>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateVariantRequest {
    #[prost(string, tag = "1")]
    pub variant_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub variant: ::core::option::Option<Variant>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteVariantRequest {
    #[prost(string, tag = "1")]
    pub variant_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVariantRequest {
    #[prost(string, tag = "1")]
    pub variant_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeVariantsRequest {
    #[prost(string, tag = "1")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub variants: ::prost::alloc::vec::Vec<Variant>,
    #[prost(btree_map = "string, enumeration(InfoMergeOperation)", tag = "3")]
    pub info_merge_config: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        i32,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCallSetsRequest {
    #[prost(string, repeated, tag = "1")]
    pub variant_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchCallSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub call_sets: ::prost::alloc::vec::Vec<CallSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateCallSetRequest {
    #[prost(message, optional, tag = "1")]
    pub call_set: ::core::option::Option<CallSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateCallSetRequest {
    #[prost(string, tag = "1")]
    pub call_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub call_set: ::core::option::Option<CallSet>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteCallSetRequest {
    #[prost(string, tag = "1")]
    pub call_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCallSetRequest {
    #[prost(string, tag = "1")]
    pub call_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamVariantsRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub variant_set_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub call_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub start: i64,
    #[prost(int64, tag = "6")]
    pub end: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamVariantsResponse {
    #[prost(message, repeated, tag = "1")]
    pub variants: ::prost::alloc::vec::Vec<Variant>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InfoMergeOperation {
    Unspecified = 0,
    IgnoreNew = 1,
    MoveToCalls = 2,
}
impl InfoMergeOperation {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            InfoMergeOperation::Unspecified => "INFO_MERGE_OPERATION_UNSPECIFIED",
            InfoMergeOperation::IgnoreNew => "IGNORE_NEW",
            InfoMergeOperation::MoveToCalls => "MOVE_TO_CALLS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INFO_MERGE_OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
            "IGNORE_NEW" => Some(Self::IgnoreNew),
            "MOVE_TO_CALLS" => Some(Self::MoveToCalls),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod streaming_variant_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct StreamingVariantServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StreamingVariantServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamingVariantServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StreamingVariantServiceClient::new(
                InterceptedService::new(inner, interceptor),
            )
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns a stream of all the variants matching the search request, ordered
        /// by reference name, position, and ID.
        pub async fn stream_variants(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamVariantsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamVariantsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.StreamingVariantService/StreamVariants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.StreamingVariantService",
                        "StreamVariants",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod variant_service_v1_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct VariantServiceV1Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> VariantServiceV1Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> VariantServiceV1Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            VariantServiceV1Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates variant data by asynchronously importing the provided information.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// The variants for import will be merged with any existing variant that
        /// matches its reference sequence, start, end, reference bases, and
        /// alternative bases. If no such variant exists, a new one will be created.
        ///
        /// When variants are merged, the call information from the new variant
        /// is added to the existing variant, and Variant info fields are merged
        /// as specified in
        /// \[infoMergeConfig\]\[google.genomics.v1.ImportVariantsRequest.info_merge_config\].
        /// As a special case, for single-sample VCF files, QUAL and FILTER fields will
        /// be moved to the call level; these are sometimes interpreted in a
        /// call-specific context.
        /// Imported VCF headers are appended to the metadata already in a variant set.
        pub async fn import_variants(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportVariantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/ImportVariants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "ImportVariants",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new variant set.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// The provided variant set must have a valid `datasetId` set - all other
        /// fields are optional. Note that the `id` field will be ignored, as this is
        /// assigned by the server.
        pub async fn create_variant_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVariantSetRequest>,
        ) -> std::result::Result<tonic::Response<super::VariantSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/CreateVariantSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "CreateVariantSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports variant set data to an external destination.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn export_variant_set(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportVariantSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/ExportVariantSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "ExportVariantSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a variant set by ID.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_variant_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVariantSetRequest>,
        ) -> std::result::Result<tonic::Response<super::VariantSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/GetVariantSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "GetVariantSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns a list of all variant sets matching search criteria.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchVariantSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L49).
        pub async fn search_variant_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchVariantSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchVariantSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/SearchVariantSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "SearchVariantSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a variant set including all variants, call sets, and calls within.
        /// This is not reversible.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn delete_variant_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVariantSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/DeleteVariantSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "DeleteVariantSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a variant set using patch semantics.
        ///
        /// For the definitions of variant sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn update_variant_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVariantSetRequest>,
        ) -> std::result::Result<tonic::Response<super::VariantSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/UpdateVariantSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "UpdateVariantSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of variants matching the criteria.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchVariants](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L126).
        pub async fn search_variants(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchVariantsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchVariantsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/SearchVariants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "SearchVariants",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new variant.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn create_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::Variant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/CreateVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "CreateVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a variant.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// This method supports patch semantics. Returns the modified variant without
        /// its calls.
        pub async fn update_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::Variant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/UpdateVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "UpdateVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a variant.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn delete_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteVariantRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/DeleteVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "DeleteVariant",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a variant by ID.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_variant(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVariantRequest>,
        ) -> std::result::Result<tonic::Response<super::Variant>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/GetVariant",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.genomics.v1.VariantServiceV1", "GetVariant"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Merges the given variants with existing variants.
        ///
        /// For the definitions of variants and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Each variant will be
        /// merged with an existing variant that matches its reference sequence,
        /// start, end, reference bases, and alternative bases. If no such variant
        /// exists, a new one will be created.
        ///
        /// When variants are merged, the call information from the new variant
        /// is added to the existing variant. Variant info fields are merged as
        /// specified in the
        /// \[infoMergeConfig\]\[google.genomics.v1.MergeVariantsRequest.info_merge_config\]
        /// field of the MergeVariantsRequest.
        ///
        /// Please exercise caution when using this method!  It is easy to introduce
        /// mistakes in existing variants and difficult to back out of them.  For
        /// example,
        /// suppose you were trying to merge a new variant with an existing one and
        /// both
        /// variants contain calls that belong to callsets with the same callset ID.
        ///
        /// ```text
        /// // Existing variant - irrelevant fields trimmed for clarity
        /// {
        ///     "variantSetId": "10473108253681171589",
        ///     "referenceName": "1",
        ///     "start": "10582",
        ///     "referenceBases": "G",
        ///     "alternateBases": [
        ///         "A"
        ///     ],
        ///     "calls": [
        ///         {
        ///             "callSetId": "10473108253681171589-0",
        ///             "callSetName": "CALLSET0",
        ///             "genotype": [
        ///                 0,
        ///                 1
        ///             ],
        ///         }
        ///     ]
        /// }
        ///
        /// // New variant with conflicting call information
        /// {
        ///     "variantSetId": "10473108253681171589",
        ///     "referenceName": "1",
        ///     "start": "10582",
        ///     "referenceBases": "G",
        ///     "alternateBases": [
        ///         "A"
        ///     ],
        ///     "calls": [
        ///         {
        ///             "callSetId": "10473108253681171589-0",
        ///             "callSetName": "CALLSET0",
        ///             "genotype": [
        ///                 1,
        ///                 1
        ///             ],
        ///         }
        ///     ]
        /// }
        /// ```
        ///
        /// The resulting merged variant would overwrite the existing calls with those
        /// from the new variant:
        ///
        /// ```text
        /// {
        ///     "variantSetId": "10473108253681171589",
        ///     "referenceName": "1",
        ///     "start": "10582",
        ///     "referenceBases": "G",
        ///     "alternateBases": [
        ///         "A"
        ///     ],
        ///     "calls": [
        ///         {
        ///             "callSetId": "10473108253681171589-0",
        ///             "callSetName": "CALLSET0",
        ///             "genotype": [
        ///                 1,
        ///                 1
        ///             ],
        ///         }
        ///     ]
        /// }
        /// ```
        ///
        /// This may be the desired outcome, but it is up to the user to determine if
        /// if that is indeed the case.
        pub async fn merge_variants(
            &mut self,
            request: impl tonic::IntoRequest<super::MergeVariantsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/MergeVariants",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "MergeVariants",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of call sets matching the criteria.
        ///
        /// For the definitions of call sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchCallSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/variantmethods.avdl#L178).
        pub async fn search_call_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchCallSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchCallSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/SearchCallSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "SearchCallSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new call set.
        ///
        /// For the definitions of call sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn create_call_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateCallSetRequest>,
        ) -> std::result::Result<tonic::Response<super::CallSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/CreateCallSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "CreateCallSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a call set.
        ///
        /// For the definitions of call sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// This method supports patch semantics.
        pub async fn update_call_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateCallSetRequest>,
        ) -> std::result::Result<tonic::Response<super::CallSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/UpdateCallSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "UpdateCallSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a call set.
        ///
        /// For the definitions of call sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn delete_call_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteCallSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/DeleteCallSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.VariantServiceV1",
                        "DeleteCallSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a call set by ID.
        ///
        /// For the definitions of call sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_call_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCallSetRequest>,
        ) -> std::result::Result<tonic::Response<super::CallSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.VariantServiceV1/GetCallSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.genomics.v1.VariantServiceV1", "GetCallSet"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Position {
    #[prost(string, tag = "1")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub position: i64,
    #[prost(bool, tag = "3")]
    pub reverse_strand: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Reference {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub length: i64,
    #[prost(string, tag = "3")]
    pub md5checksum: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "6")]
    pub source_accessions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "7")]
    pub ncbi_taxon_id: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReferenceSet {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub reference_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub md5checksum: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub ncbi_taxon_id: i32,
    #[prost(string, tag = "5")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub assembly_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "8")]
    pub source_accessions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReferenceSetsRequest {
    #[prost(string, repeated, tag = "1")]
    pub md5checksums: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub accessions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub assembly_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReferenceSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub reference_sets: ::prost::alloc::vec::Vec<ReferenceSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReferenceSetRequest {
    #[prost(string, tag = "1")]
    pub reference_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReferencesRequest {
    #[prost(string, repeated, tag = "1")]
    pub md5checksums: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "2")]
    pub accessions: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReferencesResponse {
    #[prost(message, repeated, tag = "1")]
    pub references: ::prost::alloc::vec::Vec<Reference>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReferenceRequest {
    #[prost(string, tag = "1")]
    pub reference_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBasesRequest {
    #[prost(string, tag = "1")]
    pub reference_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start: i64,
    #[prost(int64, tag = "3")]
    pub end: i64,
    #[prost(string, tag = "4")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBasesResponse {
    #[prost(int64, tag = "1")]
    pub offset: i64,
    #[prost(string, tag = "2")]
    pub sequence: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod reference_service_v1_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct ReferenceServiceV1Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReferenceServiceV1Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReferenceServiceV1Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ReferenceServiceV1Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Searches for reference sets which match the given criteria.
        ///
        /// For the definitions of references and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchReferenceSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L71)
        pub async fn search_reference_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchReferenceSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchReferenceSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReferenceServiceV1/SearchReferenceSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReferenceServiceV1",
                        "SearchReferenceSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a reference set.
        ///
        /// For the definitions of references and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.getReferenceSet](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L83).
        pub async fn get_reference_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReferenceSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ReferenceSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReferenceServiceV1/GetReferenceSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReferenceServiceV1",
                        "GetReferenceSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for references which match the given criteria.
        ///
        /// For the definitions of references and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchReferences](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L146).
        pub async fn search_references(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchReferencesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchReferencesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReferenceServiceV1/SearchReferences",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReferenceServiceV1",
                        "SearchReferences",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a reference.
        ///
        /// For the definitions of references and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.getReference](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L158).
        pub async fn get_reference(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReferenceRequest>,
        ) -> std::result::Result<tonic::Response<super::Reference>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReferenceServiceV1/GetReference",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReferenceServiceV1",
                        "GetReference",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists the bases in a reference, optionally restricted to a range.
        ///
        /// For the definitions of references and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.getReferenceBases](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/referencemethods.avdl#L221).
        pub async fn list_bases(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBasesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBasesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReferenceServiceV1/ListBases",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.genomics.v1.ReferenceServiceV1", "ListBases"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CigarUnit {
    #[prost(enumeration = "cigar_unit::Operation", tag = "1")]
    pub operation: i32,
    #[prost(int64, tag = "2")]
    pub operation_length: i64,
    #[prost(string, tag = "3")]
    pub reference_sequence: ::prost::alloc::string::String,
}
/// Nested message and enum types in `CigarUnit`.
pub mod cigar_unit {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Operation {
        Unspecified = 0,
        AlignmentMatch = 1,
        Insert = 2,
        Delete = 3,
        Skip = 4,
        ClipSoft = 5,
        ClipHard = 6,
        Pad = 7,
        SequenceMatch = 8,
        SequenceMismatch = 9,
    }
    impl Operation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Operation::Unspecified => "OPERATION_UNSPECIFIED",
                Operation::AlignmentMatch => "ALIGNMENT_MATCH",
                Operation::Insert => "INSERT",
                Operation::Delete => "DELETE",
                Operation::Skip => "SKIP",
                Operation::ClipSoft => "CLIP_SOFT",
                Operation::ClipHard => "CLIP_HARD",
                Operation::Pad => "PAD",
                Operation::SequenceMatch => "SEQUENCE_MATCH",
                Operation::SequenceMismatch => "SEQUENCE_MISMATCH",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "OPERATION_UNSPECIFIED" => Some(Self::Unspecified),
                "ALIGNMENT_MATCH" => Some(Self::AlignmentMatch),
                "INSERT" => Some(Self::Insert),
                "DELETE" => Some(Self::Delete),
                "SKIP" => Some(Self::Skip),
                "CLIP_SOFT" => Some(Self::ClipSoft),
                "CLIP_HARD" => Some(Self::ClipHard),
                "PAD" => Some(Self::Pad),
                "SEQUENCE_MATCH" => Some(Self::SequenceMatch),
                "SEQUENCE_MISMATCH" => Some(Self::SequenceMismatch),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dataset {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub create_time: ::core::option::Option<::prost_types::Timestamp>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub page_size: i32,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListDatasetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub datasets: ::prost::alloc::vec::Vec<Dataset>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateDatasetRequest {
    #[prost(message, optional, tag = "1")]
    pub dataset: ::core::option::Option<Dataset>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateDatasetRequest {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub dataset: ::core::option::Option<Dataset>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteDatasetRequest {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndeleteDatasetRequest {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetDatasetRequest {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod dataset_service_v1_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service manages datasets, which are collections of genomic data.
    #[derive(Debug, Clone)]
    pub struct DatasetServiceV1Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> DatasetServiceV1Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> DatasetServiceV1Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            DatasetServiceV1Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Lists datasets within a project.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn list_datasets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListDatasetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListDatasetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/ListDatasets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "ListDatasets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new dataset.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn create_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/CreateDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "CreateDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a dataset by ID.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::GetDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/GetDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.genomics.v1.DatasetServiceV1", "GetDataset"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a dataset.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// This method supports patch semantics.
        pub async fn update_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/UpdateDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "UpdateDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a dataset and all of its contents (all read group sets,
        /// reference sets, variant sets, call sets, annotation sets, etc.)
        /// This is reversible (up to one week after the deletion) via
        /// the
        /// \[datasets.undelete\]\[google.genomics.v1.DatasetServiceV1.UndeleteDataset\]
        /// operation.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn delete_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteDatasetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/DeleteDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "DeleteDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Undeletes a dataset by restoring a dataset which was deleted via this API.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// This operation is only possible for a week after the deletion occurred.
        pub async fn undelete_dataset(
            &mut self,
            request: impl tonic::IntoRequest<super::UndeleteDatasetRequest>,
        ) -> std::result::Result<tonic::Response<super::Dataset>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/UndeleteDataset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "UndeleteDataset",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Sets the access control policy on the specified dataset. Replaces any
        /// existing policy.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// See <a href="/iam/docs/managing-policies#setting_a_policy">Setting a
        /// Policy</a> for more information.
        pub async fn set_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::iam::v1::SetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/SetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "SetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets the access control policy for the dataset. This is empty if the
        /// policy or resource does not exist.
        ///
        /// See <a href="/iam/docs/managing-policies#getting_a_policy">Getting a
        /// Policy</a> for more information.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_iam_policy(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::iam::v1::GetIamPolicyRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::iam::v1::Policy>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/GetIamPolicy",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "GetIamPolicy",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Returns permissions that a caller has on the specified resource.
        /// See <a href="/iam/docs/managing-policies#testing_permissions">Testing
        /// Permissions</a> for more information.
        ///
        /// For the definitions of datasets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn test_iam_permissions(
            &mut self,
            request: impl tonic::IntoRequest<
                super::super::super::iam::v1::TestIamPermissionsRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<super::super::super::iam::v1::TestIamPermissionsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.DatasetServiceV1/TestIamPermissions",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.DatasetServiceV1",
                        "TestIamPermissions",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinearAlignment {
    #[prost(message, optional, tag = "1")]
    pub position: ::core::option::Option<Position>,
    #[prost(int32, tag = "2")]
    pub mapping_quality: i32,
    #[prost(message, repeated, tag = "3")]
    pub cigar: ::prost::alloc::vec::Vec<CigarUnit>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Read {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub read_group_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub read_group_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub fragment_name: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub proper_placement: bool,
    #[prost(bool, tag = "6")]
    pub duplicate_fragment: bool,
    #[prost(int32, tag = "7")]
    pub fragment_length: i32,
    #[prost(int32, tag = "8")]
    pub read_number: i32,
    #[prost(int32, tag = "9")]
    pub number_reads: i32,
    #[prost(bool, tag = "10")]
    pub failed_vendor_quality_checks: bool,
    #[prost(message, optional, tag = "11")]
    pub alignment: ::core::option::Option<LinearAlignment>,
    #[prost(bool, tag = "12")]
    pub secondary_alignment: bool,
    #[prost(bool, tag = "13")]
    pub supplementary_alignment: bool,
    #[prost(string, tag = "14")]
    pub aligned_sequence: ::prost::alloc::string::String,
    #[prost(int32, repeated, tag = "15")]
    pub aligned_quality: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, optional, tag = "16")]
    pub next_mate_position: ::core::option::Option<Position>,
    #[prost(btree_map = "string, message", tag = "17")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnnotationSet {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub source_uri: ::prost::alloc::string::String,
    #[prost(enumeration = "AnnotationType", tag = "6")]
    pub r#type: i32,
    #[prost(btree_map = "string, message", tag = "17")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Annotation {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub annotation_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub reference_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub start: i64,
    #[prost(int64, tag = "7")]
    pub end: i64,
    #[prost(bool, tag = "8")]
    pub reverse_strand: bool,
    #[prost(enumeration = "AnnotationType", tag = "9")]
    pub r#type: i32,
    #[prost(btree_map = "string, message", tag = "12")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
    #[prost(oneof = "annotation::Value", tags = "10, 11")]
    pub value: ::core::option::Option<annotation::Value>,
}
/// Nested message and enum types in `Annotation`.
pub mod annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Value {
        #[prost(message, tag = "10")]
        Variant(super::VariantAnnotation),
        #[prost(message, tag = "11")]
        Transcript(super::Transcript),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VariantAnnotation {
    #[prost(enumeration = "variant_annotation::Type", tag = "1")]
    pub r#type: i32,
    #[prost(enumeration = "variant_annotation::Effect", tag = "2")]
    pub effect: i32,
    #[prost(string, tag = "3")]
    pub alternate_bases: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub gene_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub transcript_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "6")]
    pub conditions: ::prost::alloc::vec::Vec<variant_annotation::ClinicalCondition>,
    #[prost(enumeration = "variant_annotation::ClinicalSignificance", tag = "7")]
    pub clinical_significance: i32,
}
/// Nested message and enum types in `VariantAnnotation`.
pub mod variant_annotation {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ClinicalCondition {
        #[prost(string, repeated, tag = "1")]
        pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
        #[prost(message, repeated, tag = "2")]
        pub external_ids: ::prost::alloc::vec::Vec<super::ExternalId>,
        #[prost(string, tag = "3")]
        pub concept_id: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub omim_id: ::prost::alloc::string::String,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        Other = 1,
        Insertion = 2,
        Deletion = 3,
        Substitution = 4,
        Snp = 5,
        Structural = 6,
        Cnv = 7,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Unspecified => "TYPE_UNSPECIFIED",
                Type::Other => "TYPE_OTHER",
                Type::Insertion => "INSERTION",
                Type::Deletion => "DELETION",
                Type::Substitution => "SUBSTITUTION",
                Type::Snp => "SNP",
                Type::Structural => "STRUCTURAL",
                Type::Cnv => "CNV",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_OTHER" => Some(Self::Other),
                "INSERTION" => Some(Self::Insertion),
                "DELETION" => Some(Self::Deletion),
                "SUBSTITUTION" => Some(Self::Substitution),
                "SNP" => Some(Self::Snp),
                "STRUCTURAL" => Some(Self::Structural),
                "CNV" => Some(Self::Cnv),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Effect {
        Unspecified = 0,
        Other = 1,
        Frameshift = 2,
        FramePreservingIndel = 3,
        SynonymousSnp = 4,
        NonsynonymousSnp = 5,
        StopGain = 6,
        StopLoss = 7,
        SpliceSiteDisruption = 8,
    }
    impl Effect {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Effect::Unspecified => "EFFECT_UNSPECIFIED",
                Effect::Other => "EFFECT_OTHER",
                Effect::Frameshift => "FRAMESHIFT",
                Effect::FramePreservingIndel => "FRAME_PRESERVING_INDEL",
                Effect::SynonymousSnp => "SYNONYMOUS_SNP",
                Effect::NonsynonymousSnp => "NONSYNONYMOUS_SNP",
                Effect::StopGain => "STOP_GAIN",
                Effect::StopLoss => "STOP_LOSS",
                Effect::SpliceSiteDisruption => "SPLICE_SITE_DISRUPTION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EFFECT_UNSPECIFIED" => Some(Self::Unspecified),
                "EFFECT_OTHER" => Some(Self::Other),
                "FRAMESHIFT" => Some(Self::Frameshift),
                "FRAME_PRESERVING_INDEL" => Some(Self::FramePreservingIndel),
                "SYNONYMOUS_SNP" => Some(Self::SynonymousSnp),
                "NONSYNONYMOUS_SNP" => Some(Self::NonsynonymousSnp),
                "STOP_GAIN" => Some(Self::StopGain),
                "STOP_LOSS" => Some(Self::StopLoss),
                "SPLICE_SITE_DISRUPTION" => Some(Self::SpliceSiteDisruption),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ClinicalSignificance {
        Unspecified = 0,
        Other = 1,
        Uncertain = 2,
        Benign = 3,
        LikelyBenign = 4,
        LikelyPathogenic = 5,
        Pathogenic = 6,
        DrugResponse = 7,
        Histocompatibility = 8,
        ConfersSensitivity = 9,
        RiskFactor = 10,
        Association = 11,
        Protective = 12,
        MultipleReported = 13,
    }
    impl ClinicalSignificance {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ClinicalSignificance::Unspecified => "CLINICAL_SIGNIFICANCE_UNSPECIFIED",
                ClinicalSignificance::Other => "CLINICAL_SIGNIFICANCE_OTHER",
                ClinicalSignificance::Uncertain => "UNCERTAIN",
                ClinicalSignificance::Benign => "BENIGN",
                ClinicalSignificance::LikelyBenign => "LIKELY_BENIGN",
                ClinicalSignificance::LikelyPathogenic => "LIKELY_PATHOGENIC",
                ClinicalSignificance::Pathogenic => "PATHOGENIC",
                ClinicalSignificance::DrugResponse => "DRUG_RESPONSE",
                ClinicalSignificance::Histocompatibility => "HISTOCOMPATIBILITY",
                ClinicalSignificance::ConfersSensitivity => "CONFERS_SENSITIVITY",
                ClinicalSignificance::RiskFactor => "RISK_FACTOR",
                ClinicalSignificance::Association => "ASSOCIATION",
                ClinicalSignificance::Protective => "PROTECTIVE",
                ClinicalSignificance::MultipleReported => "MULTIPLE_REPORTED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CLINICAL_SIGNIFICANCE_UNSPECIFIED" => Some(Self::Unspecified),
                "CLINICAL_SIGNIFICANCE_OTHER" => Some(Self::Other),
                "UNCERTAIN" => Some(Self::Uncertain),
                "BENIGN" => Some(Self::Benign),
                "LIKELY_BENIGN" => Some(Self::LikelyBenign),
                "LIKELY_PATHOGENIC" => Some(Self::LikelyPathogenic),
                "PATHOGENIC" => Some(Self::Pathogenic),
                "DRUG_RESPONSE" => Some(Self::DrugResponse),
                "HISTOCOMPATIBILITY" => Some(Self::Histocompatibility),
                "CONFERS_SENSITIVITY" => Some(Self::ConfersSensitivity),
                "RISK_FACTOR" => Some(Self::RiskFactor),
                "ASSOCIATION" => Some(Self::Association),
                "PROTECTIVE" => Some(Self::Protective),
                "MULTIPLE_REPORTED" => Some(Self::MultipleReported),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transcript {
    #[prost(string, tag = "1")]
    pub gene_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub exons: ::prost::alloc::vec::Vec<transcript::Exon>,
    #[prost(message, optional, tag = "3")]
    pub coding_sequence: ::core::option::Option<transcript::CodingSequence>,
}
/// Nested message and enum types in `Transcript`.
pub mod transcript {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Exon {
        #[prost(int64, tag = "1")]
        pub start: i64,
        #[prost(int64, tag = "2")]
        pub end: i64,
        #[prost(message, optional, tag = "3")]
        pub frame: ::core::option::Option<i32>,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct CodingSequence {
        #[prost(int64, tag = "1")]
        pub start: i64,
        #[prost(int64, tag = "2")]
        pub end: i64,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalId {
    #[prost(string, tag = "1")]
    pub source_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationSetRequest {
    #[prost(message, optional, tag = "1")]
    pub annotation_set: ::core::option::Option<AnnotationSet>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationSetRequest {
    #[prost(string, tag = "1")]
    pub annotation_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnnotationSetRequest {
    #[prost(string, tag = "1")]
    pub annotation_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub annotation_set: ::core::option::Option<AnnotationSet>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationSetRequest {
    #[prost(string, tag = "1")]
    pub annotation_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAnnotationSetsRequest {
    #[prost(string, repeated, tag = "1")]
    pub dataset_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "AnnotationType", repeated, tag = "4")]
    pub types: ::prost::alloc::vec::Vec<i32>,
    #[prost(string, tag = "5")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAnnotationSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotation_sets: ::prost::alloc::vec::Vec<AnnotationSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateAnnotationRequest {
    #[prost(message, optional, tag = "1")]
    pub annotation: ::core::option::Option<Annotation>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAnnotationsRequest {
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(string, tag = "2")]
    pub request_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchCreateAnnotationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<batch_create_annotations_response::Entry>,
}
/// Nested message and enum types in `BatchCreateAnnotationsResponse`.
pub mod batch_create_annotations_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Entry {
        #[prost(message, optional, tag = "1")]
        pub status: ::core::option::Option<super::super::super::rpc::Status>,
        #[prost(message, optional, tag = "2")]
        pub annotation: ::core::option::Option<super::Annotation>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAnnotationRequest {
    #[prost(string, tag = "1")]
    pub annotation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateAnnotationRequest {
    #[prost(string, tag = "1")]
    pub annotation_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub annotation: ::core::option::Option<Annotation>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteAnnotationRequest {
    #[prost(string, tag = "1")]
    pub annotation_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAnnotationsRequest {
    #[prost(string, repeated, tag = "1")]
    pub annotation_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub start: i64,
    #[prost(int64, tag = "5")]
    pub end: i64,
    #[prost(string, tag = "6")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub page_size: i32,
    #[prost(oneof = "search_annotations_request::Reference", tags = "2, 3")]
    pub reference: ::core::option::Option<search_annotations_request::Reference>,
}
/// Nested message and enum types in `SearchAnnotationsRequest`.
pub mod search_annotations_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Reference {
        #[prost(string, tag = "2")]
        ReferenceId(::prost::alloc::string::String),
        #[prost(string, tag = "3")]
        ReferenceName(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchAnnotationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub annotations: ::prost::alloc::vec::Vec<Annotation>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AnnotationType {
    Unspecified = 0,
    Generic = 1,
    Variant = 2,
    Gene = 3,
    Transcript = 4,
}
impl AnnotationType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AnnotationType::Unspecified => "ANNOTATION_TYPE_UNSPECIFIED",
            AnnotationType::Generic => "GENERIC",
            AnnotationType::Variant => "VARIANT",
            AnnotationType::Gene => "GENE",
            AnnotationType::Transcript => "TRANSCRIPT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ANNOTATION_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "GENERIC" => Some(Self::Generic),
            "VARIANT" => Some(Self::Variant),
            "GENE" => Some(Self::Gene),
            "TRANSCRIPT" => Some(Self::Transcript),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod annotation_service_v1_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// This service provides storage and positional retrieval of genomic
    /// reference annotations, including variant annotations.
    #[derive(Debug, Clone)]
    pub struct AnnotationServiceV1Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> AnnotationServiceV1Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AnnotationServiceV1Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            AnnotationServiceV1Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates a new annotation set. Caller must have WRITE permission for the
        /// associated dataset.
        ///
        /// The following fields are required:
        ///
        /// * \[datasetId\]\[google.genomics.v1.AnnotationSet.dataset_id\]
        /// * \[referenceSetId\]\[google.genomics.v1.AnnotationSet.reference_set_id\]
        ///
        /// All other fields may be optionally specified, unless documented as being
        /// server-generated (for example, the `id` field).
        pub async fn create_annotation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationSetRequest>,
        ) -> std::result::Result<tonic::Response<super::AnnotationSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/CreateAnnotationSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "CreateAnnotationSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an annotation set. Caller must have READ permission for
        /// the associated dataset.
        pub async fn get_annotation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnnotationSetRequest>,
        ) -> std::result::Result<tonic::Response<super::AnnotationSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/GetAnnotationSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "GetAnnotationSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an annotation set. The update must respect all mutability
        /// restrictions and other invariants described on the annotation set resource.
        /// Caller must have WRITE permission for the associated dataset.
        pub async fn update_annotation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnnotationSetRequest>,
        ) -> std::result::Result<tonic::Response<super::AnnotationSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotationSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "UpdateAnnotationSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an annotation set. Caller must have WRITE permission
        /// for the associated annotation set.
        pub async fn delete_annotation_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnnotationSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotationSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "DeleteAnnotationSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for annotation sets that match the given criteria. Annotation sets
        /// are returned in an unspecified order. This order is consistent, such that
        /// two queries for the same content (regardless of page size) yield annotation
        /// sets in the same order across their respective streams of paginated
        /// responses. Caller must have READ permission for the queried datasets.
        pub async fn search_annotation_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAnnotationSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAnnotationSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/SearchAnnotationSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "SearchAnnotationSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates a new annotation. Caller must have WRITE permission
        /// for the associated annotation set.
        ///
        /// The following fields are required:
        ///
        /// * \[annotationSetId\]\[google.genomics.v1.Annotation.annotation_set_id\]
        /// * \[referenceName\]\[google.genomics.v1.Annotation.reference_name\] or
        ///  \[referenceId\]\[google.genomics.v1.Annotation.reference_id\]
        ///
        /// ### Transcripts
        ///
        /// For annotations of type TRANSCRIPT, the following fields of
        /// \[transcript\]\[google.genomics.v1.Annotation.transcript\] must be provided:
        ///
        /// * \[exons.start\]\[google.genomics.v1.Transcript.Exon.start\]
        /// * \[exons.end\]\[google.genomics.v1.Transcript.Exon.end\]
        ///
        /// All other fields may be optionally specified, unless documented as being
        /// server-generated (for example, the `id` field). The annotated
        /// range must be no longer than 100Mbp (mega base pairs). See the
        /// \[Annotation resource\]\[google.genomics.v1.Annotation\]
        /// for additional restrictions on each field.
        pub async fn create_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/CreateAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "CreateAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Creates one or more new annotations atomically. All annotations must
        /// belong to the same annotation set. Caller must have WRITE
        /// permission for this annotation set. For optimal performance, batch
        /// positionally adjacent annotations together.
        ///
        /// If the request has a systemic issue, such as an attempt to write to
        /// an inaccessible annotation set, the entire RPC will fail accordingly. For
        /// lesser data issues, when possible an error will be isolated to the
        /// corresponding batch entry in the response; the remaining well formed
        /// annotations will be created normally.
        ///
        /// For details on the requirements for each individual annotation resource,
        /// see
        /// \[CreateAnnotation\]\[google.genomics.v1.AnnotationServiceV1.CreateAnnotation\].
        pub async fn batch_create_annotations(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchCreateAnnotationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchCreateAnnotationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/BatchCreateAnnotations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "BatchCreateAnnotations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets an annotation. Caller must have READ permission
        /// for the associated annotation set.
        pub async fn get_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/GetAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "GetAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates an annotation. Caller must have
        /// WRITE permission for the associated dataset.
        pub async fn update_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<super::Annotation>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/UpdateAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "UpdateAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes an annotation. Caller must have WRITE permission for
        /// the associated annotation set.
        pub async fn delete_annotation(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteAnnotationRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/DeleteAnnotation",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "DeleteAnnotation",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for annotations that match the given criteria. Results are
        /// ordered by genomic coordinate (by reference sequence, then position).
        /// Annotations with equivalent genomic coordinates are returned in an
        /// unspecified order. This order is consistent, such that two queries for the
        /// same content (regardless of page size) yield annotations in the same order
        /// across their respective streams of paginated responses. Caller must have
        /// READ permission for the queried annotation sets.
        pub async fn search_annotations(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchAnnotationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchAnnotationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.AnnotationServiceV1/SearchAnnotations",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.AnnotationServiceV1",
                        "SearchAnnotations",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Range {
    #[prost(string, tag = "1")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start: i64,
    #[prost(int64, tag = "3")]
    pub end: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadGroup {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub sample_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "6")]
    pub experiment: ::core::option::Option<read_group::Experiment>,
    #[prost(int32, tag = "7")]
    pub predicted_insert_size: i32,
    #[prost(message, repeated, tag = "10")]
    pub programs: ::prost::alloc::vec::Vec<read_group::Program>,
    #[prost(string, tag = "11")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(btree_map = "string, message", tag = "12")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
/// Nested message and enum types in `ReadGroup`.
pub mod read_group {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Experiment {
        #[prost(string, tag = "1")]
        pub library_id: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub platform_unit: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub sequencing_center: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub instrument_model: ::prost::alloc::string::String,
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Program {
        #[prost(string, tag = "1")]
        pub command_line: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub id: ::prost::alloc::string::String,
        #[prost(string, tag = "3")]
        pub name: ::prost::alloc::string::String,
        #[prost(string, tag = "4")]
        pub prev_program_id: ::prost::alloc::string::String,
        #[prost(string, tag = "5")]
        pub version: ::prost::alloc::string::String,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadGroupSet {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub filename: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "6")]
    pub read_groups: ::prost::alloc::vec::Vec<ReadGroup>,
    #[prost(btree_map = "string, message", tag = "7")]
    pub info: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost_types::ListValue,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReadGroupSetsRequest {
    #[prost(string, repeated, tag = "1")]
    pub dataset_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReadGroupSetsResponse {
    #[prost(message, repeated, tag = "1")]
    pub read_group_sets: ::prost::alloc::vec::Vec<ReadGroupSet>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportReadGroupSetsRequest {
    #[prost(string, tag = "1")]
    pub dataset_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub reference_set_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub source_uris: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(
        enumeration = "import_read_group_sets_request::PartitionStrategy",
        tag = "5"
    )]
    pub partition_strategy: i32,
}
/// Nested message and enum types in `ImportReadGroupSetsRequest`.
pub mod import_read_group_sets_request {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PartitionStrategy {
        Unspecified = 0,
        PerFilePerSample = 1,
        MergeAll = 2,
    }
    impl PartitionStrategy {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PartitionStrategy::Unspecified => "PARTITION_STRATEGY_UNSPECIFIED",
                PartitionStrategy::PerFilePerSample => "PER_FILE_PER_SAMPLE",
                PartitionStrategy::MergeAll => "MERGE_ALL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARTITION_STRATEGY_UNSPECIFIED" => Some(Self::Unspecified),
                "PER_FILE_PER_SAMPLE" => Some(Self::PerFilePerSample),
                "MERGE_ALL" => Some(Self::MergeAll),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ImportReadGroupSetsResponse {
    #[prost(string, repeated, tag = "1")]
    pub read_group_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportReadGroupSetRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub export_uri: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub read_group_set_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub reference_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateReadGroupSetRequest {
    #[prost(string, tag = "1")]
    pub read_group_set_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub read_group_set: ::core::option::Option<ReadGroupSet>,
    #[prost(message, optional, tag = "3")]
    pub update_mask: ::core::option::Option<::prost_types::FieldMask>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteReadGroupSetRequest {
    #[prost(string, tag = "1")]
    pub read_group_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetReadGroupSetRequest {
    #[prost(string, tag = "1")]
    pub read_group_set_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCoverageBucketsRequest {
    #[prost(string, tag = "1")]
    pub read_group_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub start: i64,
    #[prost(int64, tag = "5")]
    pub end: i64,
    #[prost(int64, tag = "6")]
    pub target_bucket_width: i64,
    #[prost(string, tag = "7")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "8")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CoverageBucket {
    #[prost(message, optional, tag = "1")]
    pub range: ::core::option::Option<Range>,
    #[prost(float, tag = "2")]
    pub mean_coverage: f32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListCoverageBucketsResponse {
    #[prost(int64, tag = "1")]
    pub bucket_width: i64,
    #[prost(message, repeated, tag = "2")]
    pub coverage_buckets: ::prost::alloc::vec::Vec<CoverageBucket>,
    #[prost(string, tag = "3")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReadsRequest {
    #[prost(string, repeated, tag = "1")]
    pub read_group_set_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub read_group_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "8")]
    pub start: i64,
    #[prost(int64, tag = "9")]
    pub end: i64,
    #[prost(string, tag = "3")]
    pub page_token: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub page_size: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchReadsResponse {
    #[prost(message, repeated, tag = "1")]
    pub alignments: ::prost::alloc::vec::Vec<Read>,
    #[prost(string, tag = "2")]
    pub next_page_token: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamReadsRequest {
    #[prost(string, tag = "1")]
    pub project_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub read_group_set_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reference_name: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub start: i64,
    #[prost(int64, tag = "5")]
    pub end: i64,
    #[prost(int32, tag = "6")]
    pub shard: i32,
    #[prost(int32, tag = "7")]
    pub total_shards: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamReadsResponse {
    #[prost(message, repeated, tag = "1")]
    pub alignments: ::prost::alloc::vec::Vec<Read>,
}
/// Generated client implementations.
pub mod streaming_read_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct StreamingReadServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> StreamingReadServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> StreamingReadServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            StreamingReadServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Returns a stream of all the reads matching the search request, ordered
        /// by reference name, position, and ID.
        pub async fn stream_reads(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamReadsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::StreamReadsResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.StreamingReadService/StreamReads",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.StreamingReadService",
                        "StreamReads",
                    ),
                );
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod read_service_v1_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// The Readstore. A data store for DNA sequencing Reads.
    #[derive(Debug, Clone)]
    pub struct ReadServiceV1Client<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl<T> ReadServiceV1Client<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ReadServiceV1Client<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            ReadServiceV1Client::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Creates read group sets by asynchronously importing the provided
        /// information.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// The caller must have WRITE permissions to the dataset.
        ///
        /// ## Notes on [BAM](https://samtools.github.io/hts-specs/SAMv1.pdf) import
        ///
        /// * Tags will be converted to strings - tag types are not preserved
        /// * Comments (`@CO`) in the input file header will not be preserved
        /// * Original header order of references (`@SQ`) will not be preserved
        /// * Any reverse stranded unmapped reads will be reverse complemented, and
        ///  their qualities (also the "BQ" and "OQ" tags, if any) will be reversed
        /// * Unmapped reads will be stripped of positional information (reference name
        ///  and position)
        pub async fn import_read_group_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::ImportReadGroupSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/ImportReadGroupSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "ImportReadGroupSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Exports a read group set to a BAM file in Google Cloud Storage.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Note that currently there may be some differences between exported BAM
        /// files and the original BAM file at the time of import. See
        /// \[ImportReadGroupSets\]\[google.genomics.v1.ReadServiceV1.ImportReadGroupSets\]
        /// for caveats.
        pub async fn export_read_group_set(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportReadGroupSetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::super::super::longrunning::Operation>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/ExportReadGroupSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "ExportReadGroupSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Searches for read group sets matching the criteria.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Implements
        /// [GlobalAllianceApi.searchReadGroupSets](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L135).
        pub async fn search_read_group_sets(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchReadGroupSetsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchReadGroupSetsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/SearchReadGroupSets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "SearchReadGroupSets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Updates a read group set.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// This method supports patch semantics.
        pub async fn update_read_group_set(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateReadGroupSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadGroupSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/UpdateReadGroupSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "UpdateReadGroupSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Deletes a read group set.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn delete_read_group_set(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteReadGroupSetRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/DeleteReadGroupSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "DeleteReadGroupSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a read group set by ID.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        pub async fn get_read_group_set(
            &mut self,
            request: impl tonic::IntoRequest<super::GetReadGroupSetRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadGroupSet>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/GetReadGroupSet",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "GetReadGroupSet",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Lists fixed width coverage buckets for a read group set, each of which
        /// correspond to a range of a reference sequence. Each bucket summarizes
        /// coverage information across its corresponding genomic range.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Coverage is defined as the number of reads which are aligned to a given
        /// base in the reference sequence. Coverage buckets are available at several
        /// precomputed bucket widths, enabling retrieval of various coverage 'zoom
        /// levels'. The caller must have READ permissions for the target read group
        /// set.
        pub async fn list_coverage_buckets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListCoverageBucketsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListCoverageBucketsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/ListCoverageBuckets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "google.genomics.v1.ReadServiceV1",
                        "ListCoverageBuckets",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Gets a list of reads for one or more read group sets.
        ///
        /// For the definitions of read group sets and other genomics resources, see
        /// [Fundamentals of Google
        /// Genomics](https://cloud.google.com/genomics/fundamentals-of-google-genomics)
        ///
        /// Reads search operates over a genomic coordinate space of reference sequence
        /// & position defined over the reference sequences to which the requested
        /// read group sets are aligned.
        ///
        /// If a target positional range is specified, search returns all reads whose
        /// alignment to the reference genome overlap the range. A query which
        /// specifies only read group set IDs yields all reads in those read group
        /// sets, including unmapped reads.
        ///
        /// All reads returned (including reads on subsequent pages) are ordered by
        /// genomic coordinate (by reference sequence, then position). Reads with
        /// equivalent genomic coordinates are returned in an unspecified order. This
        /// order is consistent, such that two queries for the same content (regardless
        /// of page size) yield reads in the same order across their respective streams
        /// of paginated responses.
        ///
        /// Implements
        /// [GlobalAllianceApi.searchReads](https://github.com/ga4gh/schemas/blob/v0.5.1/src/main/resources/avro/readmethods.avdl#L85).
        pub async fn search_reads(
            &mut self,
            request: impl tonic::IntoRequest<super::SearchReadsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SearchReadsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/google.genomics.v1.ReadServiceV1/SearchReads",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("google.genomics.v1.ReadServiceV1", "SearchReads"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
