// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetLinkStatusEnum {}
/// Nested message and enum types in `AssetLinkStatusEnum`.
pub mod asset_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Paused = 4,
    }
    impl AssetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetLinkStatus::Unspecified => "UNSPECIFIED",
                AssetLinkStatus::Unknown => "UNKNOWN",
                AssetLinkStatus::Enabled => "ENABLED",
                AssetLinkStatus::Removed => "REMOVED",
                AssetLinkStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServedAssetFieldTypeEnum {}
/// Nested message and enum types in `ServedAssetFieldTypeEnum`.
pub mod served_asset_field_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ServedAssetFieldType {
        Unspecified = 0,
        Unknown = 1,
        Headline1 = 2,
        Headline2 = 3,
        Headline3 = 4,
        Description1 = 5,
        Description2 = 6,
        Headline = 7,
        HeadlineInPortrait = 8,
        LongHeadline = 9,
        Description = 10,
        DescriptionInPortrait = 11,
        BusinessNameInPortrait = 12,
        BusinessName = 13,
        MarketingImage = 14,
        MarketingImageInPortrait = 15,
        SquareMarketingImage = 16,
        PortraitMarketingImage = 17,
        Logo = 18,
        LandscapeLogo = 19,
        CallToAction = 20,
        YouTubeVideo = 21,
        Sitelink = 22,
        Call = 23,
        MobileApp = 24,
        Callout = 25,
        StructuredSnippet = 26,
        Price = 27,
        Promotion = 28,
        AdImage = 29,
        LeadForm = 30,
        BusinessLogo = 31,
    }
    impl ServedAssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ServedAssetFieldType::Unspecified => "UNSPECIFIED",
                ServedAssetFieldType::Unknown => "UNKNOWN",
                ServedAssetFieldType::Headline1 => "HEADLINE_1",
                ServedAssetFieldType::Headline2 => "HEADLINE_2",
                ServedAssetFieldType::Headline3 => "HEADLINE_3",
                ServedAssetFieldType::Description1 => "DESCRIPTION_1",
                ServedAssetFieldType::Description2 => "DESCRIPTION_2",
                ServedAssetFieldType::Headline => "HEADLINE",
                ServedAssetFieldType::HeadlineInPortrait => "HEADLINE_IN_PORTRAIT",
                ServedAssetFieldType::LongHeadline => "LONG_HEADLINE",
                ServedAssetFieldType::Description => "DESCRIPTION",
                ServedAssetFieldType::DescriptionInPortrait => "DESCRIPTION_IN_PORTRAIT",
                ServedAssetFieldType::BusinessNameInPortrait => {
                    "BUSINESS_NAME_IN_PORTRAIT"
                }
                ServedAssetFieldType::BusinessName => "BUSINESS_NAME",
                ServedAssetFieldType::MarketingImage => "MARKETING_IMAGE",
                ServedAssetFieldType::MarketingImageInPortrait => {
                    "MARKETING_IMAGE_IN_PORTRAIT"
                }
                ServedAssetFieldType::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                ServedAssetFieldType::PortraitMarketingImage => {
                    "PORTRAIT_MARKETING_IMAGE"
                }
                ServedAssetFieldType::Logo => "LOGO",
                ServedAssetFieldType::LandscapeLogo => "LANDSCAPE_LOGO",
                ServedAssetFieldType::CallToAction => "CALL_TO_ACTION",
                ServedAssetFieldType::YouTubeVideo => "YOU_TUBE_VIDEO",
                ServedAssetFieldType::Sitelink => "SITELINK",
                ServedAssetFieldType::Call => "CALL",
                ServedAssetFieldType::MobileApp => "MOBILE_APP",
                ServedAssetFieldType::Callout => "CALLOUT",
                ServedAssetFieldType::StructuredSnippet => "STRUCTURED_SNIPPET",
                ServedAssetFieldType::Price => "PRICE",
                ServedAssetFieldType::Promotion => "PROMOTION",
                ServedAssetFieldType::AdImage => "AD_IMAGE",
                ServedAssetFieldType::LeadForm => "LEAD_FORM",
                ServedAssetFieldType::BusinessLogo => "BUSINESS_LOGO",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE_1" => Some(Self::Headline1),
                "HEADLINE_2" => Some(Self::Headline2),
                "HEADLINE_3" => Some(Self::Headline3),
                "DESCRIPTION_1" => Some(Self::Description1),
                "DESCRIPTION_2" => Some(Self::Description2),
                "HEADLINE" => Some(Self::Headline),
                "HEADLINE_IN_PORTRAIT" => Some(Self::HeadlineInPortrait),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "DESCRIPTION" => Some(Self::Description),
                "DESCRIPTION_IN_PORTRAIT" => Some(Self::DescriptionInPortrait),
                "BUSINESS_NAME_IN_PORTRAIT" => Some(Self::BusinessNameInPortrait),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MARKETING_IMAGE_IN_PORTRAIT" => Some(Self::MarketingImageInPortrait),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "YOU_TUBE_VIDEO" => Some(Self::YouTubeVideo),
                "SITELINK" => Some(Self::Sitelink),
                "CALL" => Some(Self::Call),
                "MOBILE_APP" => Some(Self::MobileApp),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "PRICE" => Some(Self::Price),
                "PROMOTION" => Some(Self::Promotion),
                "AD_IMAGE" => Some(Self::AdImage),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetLinkStatusEnum {}
/// Nested message and enum types in `AssetSetLinkStatusEnum`.
pub mod asset_set_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AssetSetLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetLinkStatus::Unspecified => "UNSPECIFIED",
                AssetSetLinkStatus::Unknown => "UNKNOWN",
                AssetSetLinkStatus::Enabled => "ENABLED",
                AssetSetLinkStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GeoTargetConstantStatusEnum {}
/// Nested message and enum types in `GeoTargetConstantStatusEnum`.
pub mod geo_target_constant_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeoTargetConstantStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        RemovalPlanned = 3,
    }
    impl GeoTargetConstantStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GeoTargetConstantStatus::Unspecified => "UNSPECIFIED",
                GeoTargetConstantStatus::Unknown => "UNKNOWN",
                GeoTargetConstantStatus::Enabled => "ENABLED",
                GeoTargetConstantStatus::RemovalPlanned => "REMOVAL_PLANNED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVAL_PLANNED" => Some(Self::RemovalPlanned),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyTypeEnum {}
/// Nested message and enum types in `BiddingStrategyTypeEnum`.
pub mod bidding_strategy_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyType {
        Unspecified = 0,
        Unknown = 1,
        Commission = 16,
        EnhancedCpc = 2,
        Invalid = 17,
        ManualCpa = 18,
        ManualCpc = 3,
        ManualCpm = 4,
        ManualCpv = 13,
        MaximizeConversions = 10,
        MaximizeConversionValue = 11,
        PageOnePromoted = 5,
        PercentCpc = 12,
        TargetCpa = 6,
        TargetCpm = 14,
        TargetImpressionShare = 15,
        TargetOutrankShare = 7,
        TargetRoas = 8,
        TargetSpend = 9,
    }
    impl BiddingStrategyType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategyType::Unspecified => "UNSPECIFIED",
                BiddingStrategyType::Unknown => "UNKNOWN",
                BiddingStrategyType::Commission => "COMMISSION",
                BiddingStrategyType::EnhancedCpc => "ENHANCED_CPC",
                BiddingStrategyType::Invalid => "INVALID",
                BiddingStrategyType::ManualCpa => "MANUAL_CPA",
                BiddingStrategyType::ManualCpc => "MANUAL_CPC",
                BiddingStrategyType::ManualCpm => "MANUAL_CPM",
                BiddingStrategyType::ManualCpv => "MANUAL_CPV",
                BiddingStrategyType::MaximizeConversions => "MAXIMIZE_CONVERSIONS",
                BiddingStrategyType::MaximizeConversionValue => {
                    "MAXIMIZE_CONVERSION_VALUE"
                }
                BiddingStrategyType::PageOnePromoted => "PAGE_ONE_PROMOTED",
                BiddingStrategyType::PercentCpc => "PERCENT_CPC",
                BiddingStrategyType::TargetCpa => "TARGET_CPA",
                BiddingStrategyType::TargetCpm => "TARGET_CPM",
                BiddingStrategyType::TargetImpressionShare => "TARGET_IMPRESSION_SHARE",
                BiddingStrategyType::TargetOutrankShare => "TARGET_OUTRANK_SHARE",
                BiddingStrategyType::TargetRoas => "TARGET_ROAS",
                BiddingStrategyType::TargetSpend => "TARGET_SPEND",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "COMMISSION" => Some(Self::Commission),
                "ENHANCED_CPC" => Some(Self::EnhancedCpc),
                "INVALID" => Some(Self::Invalid),
                "MANUAL_CPA" => Some(Self::ManualCpa),
                "MANUAL_CPC" => Some(Self::ManualCpc),
                "MANUAL_CPM" => Some(Self::ManualCpm),
                "MANUAL_CPV" => Some(Self::ManualCpv),
                "MAXIMIZE_CONVERSIONS" => Some(Self::MaximizeConversions),
                "MAXIMIZE_CONVERSION_VALUE" => Some(Self::MaximizeConversionValue),
                "PAGE_ONE_PROMOTED" => Some(Self::PageOnePromoted),
                "PERCENT_CPC" => Some(Self::PercentCpc),
                "TARGET_CPA" => Some(Self::TargetCpa),
                "TARGET_CPM" => Some(Self::TargetCpm),
                "TARGET_IMPRESSION_SHARE" => Some(Self::TargetImpressionShare),
                "TARGET_OUTRANK_SHARE" => Some(Self::TargetOutrankShare),
                "TARGET_ROAS" => Some(Self::TargetRoas),
                "TARGET_SPEND" => Some(Self::TargetSpend),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetImpressionShareLocationEnum {}
/// Nested message and enum types in `TargetImpressionShareLocationEnum`.
pub mod target_impression_share_location_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetImpressionShareLocation {
        Unspecified = 0,
        Unknown = 1,
        AnywhereOnPage = 2,
        TopOfPage = 3,
        AbsoluteTopOfPage = 4,
    }
    impl TargetImpressionShareLocation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetImpressionShareLocation::Unspecified => "UNSPECIFIED",
                TargetImpressionShareLocation::Unknown => "UNKNOWN",
                TargetImpressionShareLocation::AnywhereOnPage => "ANYWHERE_ON_PAGE",
                TargetImpressionShareLocation::TopOfPage => "TOP_OF_PAGE",
                TargetImpressionShareLocation::AbsoluteTopOfPage => {
                    "ABSOLUTE_TOP_OF_PAGE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ANYWHERE_ON_PAGE" => Some(Self::AnywhereOnPage),
                "TOP_OF_PAGE" => Some(Self::TopOfPage),
                "ABSOLUTE_TOP_OF_PAGE" => Some(Self::AbsoluteTopOfPage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetFieldTypeEnum {}
/// Nested message and enum types in `AssetFieldTypeEnum`.
pub mod asset_field_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetFieldType {
        Unspecified = 0,
        Unknown = 1,
        Headline = 2,
        Description = 3,
        MandatoryAdText = 4,
        MarketingImage = 5,
        MediaBundle = 6,
        YoutubeVideo = 7,
        BookOnGoogle = 8,
        LeadForm = 9,
        Promotion = 10,
        Callout = 11,
        StructuredSnippet = 12,
        Sitelink = 13,
        MobileApp = 14,
        HotelCallout = 15,
        Call = 16,
        Price = 24,
        LongHeadline = 17,
        BusinessName = 18,
        SquareMarketingImage = 19,
        PortraitMarketingImage = 20,
        Logo = 21,
        LandscapeLogo = 22,
        Video = 23,
        CallToActionSelection = 25,
        AdImage = 26,
        BusinessLogo = 27,
        HotelProperty = 28,
        DiscoveryCarouselCard = 29,
    }
    impl AssetFieldType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetFieldType::Unspecified => "UNSPECIFIED",
                AssetFieldType::Unknown => "UNKNOWN",
                AssetFieldType::Headline => "HEADLINE",
                AssetFieldType::Description => "DESCRIPTION",
                AssetFieldType::MandatoryAdText => "MANDATORY_AD_TEXT",
                AssetFieldType::MarketingImage => "MARKETING_IMAGE",
                AssetFieldType::MediaBundle => "MEDIA_BUNDLE",
                AssetFieldType::YoutubeVideo => "YOUTUBE_VIDEO",
                AssetFieldType::BookOnGoogle => "BOOK_ON_GOOGLE",
                AssetFieldType::LeadForm => "LEAD_FORM",
                AssetFieldType::Promotion => "PROMOTION",
                AssetFieldType::Callout => "CALLOUT",
                AssetFieldType::StructuredSnippet => "STRUCTURED_SNIPPET",
                AssetFieldType::Sitelink => "SITELINK",
                AssetFieldType::MobileApp => "MOBILE_APP",
                AssetFieldType::HotelCallout => "HOTEL_CALLOUT",
                AssetFieldType::Call => "CALL",
                AssetFieldType::Price => "PRICE",
                AssetFieldType::LongHeadline => "LONG_HEADLINE",
                AssetFieldType::BusinessName => "BUSINESS_NAME",
                AssetFieldType::SquareMarketingImage => "SQUARE_MARKETING_IMAGE",
                AssetFieldType::PortraitMarketingImage => "PORTRAIT_MARKETING_IMAGE",
                AssetFieldType::Logo => "LOGO",
                AssetFieldType::LandscapeLogo => "LANDSCAPE_LOGO",
                AssetFieldType::Video => "VIDEO",
                AssetFieldType::CallToActionSelection => "CALL_TO_ACTION_SELECTION",
                AssetFieldType::AdImage => "AD_IMAGE",
                AssetFieldType::BusinessLogo => "BUSINESS_LOGO",
                AssetFieldType::HotelProperty => "HOTEL_PROPERTY",
                AssetFieldType::DiscoveryCarouselCard => "DISCOVERY_CAROUSEL_CARD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "HEADLINE" => Some(Self::Headline),
                "DESCRIPTION" => Some(Self::Description),
                "MANDATORY_AD_TEXT" => Some(Self::MandatoryAdText),
                "MARKETING_IMAGE" => Some(Self::MarketingImage),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "LEAD_FORM" => Some(Self::LeadForm),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "LONG_HEADLINE" => Some(Self::LongHeadline),
                "BUSINESS_NAME" => Some(Self::BusinessName),
                "SQUARE_MARKETING_IMAGE" => Some(Self::SquareMarketingImage),
                "PORTRAIT_MARKETING_IMAGE" => Some(Self::PortraitMarketingImage),
                "LOGO" => Some(Self::Logo),
                "LANDSCAPE_LOGO" => Some(Self::LandscapeLogo),
                "VIDEO" => Some(Self::Video),
                "CALL_TO_ACTION_SELECTION" => Some(Self::CallToActionSelection),
                "AD_IMAGE" => Some(Self::AdImage),
                "BUSINESS_LOGO" => Some(Self::BusinessLogo),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                "DISCOVERY_CAROUSEL_CARD" => Some(Self::DiscoveryCarouselCard),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelEnum {}
/// Nested message and enum types in `ProductChannelEnum`.
pub mod product_channel_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannel {
        Unspecified = 0,
        Unknown = 1,
        Online = 2,
        Local = 3,
    }
    impl ProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductChannel::Unspecified => "UNSPECIFIED",
                ProductChannel::Unknown => "UNKNOWN",
                ProductChannel::Online => "ONLINE",
                ProductChannel::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AgeRangeTypeEnum {}
/// Nested message and enum types in `AgeRangeTypeEnum`.
pub mod age_range_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AgeRangeType {
        Unspecified = 0,
        Unknown = 1,
        AgeRange1824 = 503001,
        AgeRange2534 = 503002,
        AgeRange3544 = 503003,
        AgeRange4554 = 503004,
        AgeRange5564 = 503005,
        AgeRange65Up = 503006,
        AgeRangeUndetermined = 503999,
    }
    impl AgeRangeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AgeRangeType::Unspecified => "UNSPECIFIED",
                AgeRangeType::Unknown => "UNKNOWN",
                AgeRangeType::AgeRange1824 => "AGE_RANGE_18_24",
                AgeRangeType::AgeRange2534 => "AGE_RANGE_25_34",
                AgeRangeType::AgeRange3544 => "AGE_RANGE_35_44",
                AgeRangeType::AgeRange4554 => "AGE_RANGE_45_54",
                AgeRangeType::AgeRange5564 => "AGE_RANGE_55_64",
                AgeRangeType::AgeRange65Up => "AGE_RANGE_65_UP",
                AgeRangeType::AgeRangeUndetermined => "AGE_RANGE_UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AGE_RANGE_18_24" => Some(Self::AgeRange1824),
                "AGE_RANGE_25_34" => Some(Self::AgeRange2534),
                "AGE_RANGE_35_44" => Some(Self::AgeRange3544),
                "AGE_RANGE_45_54" => Some(Self::AgeRange4554),
                "AGE_RANGE_55_64" => Some(Self::AgeRange5564),
                "AGE_RANGE_65_UP" => Some(Self::AgeRange65Up),
                "AGE_RANGE_UNDETERMINED" => Some(Self::AgeRangeUndetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DayOfWeekEnum {}
/// Nested message and enum types in `DayOfWeekEnum`.
pub mod day_of_week_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DayOfWeek {
        Unspecified = 0,
        Unknown = 1,
        Monday = 2,
        Tuesday = 3,
        Wednesday = 4,
        Thursday = 5,
        Friday = 6,
        Saturday = 7,
        Sunday = 8,
    }
    impl DayOfWeek {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DayOfWeek::Unspecified => "UNSPECIFIED",
                DayOfWeek::Unknown => "UNKNOWN",
                DayOfWeek::Monday => "MONDAY",
                DayOfWeek::Tuesday => "TUESDAY",
                DayOfWeek::Wednesday => "WEDNESDAY",
                DayOfWeek::Thursday => "THURSDAY",
                DayOfWeek::Friday => "FRIDAY",
                DayOfWeek::Saturday => "SATURDAY",
                DayOfWeek::Sunday => "SUNDAY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MONDAY" => Some(Self::Monday),
                "TUESDAY" => Some(Self::Tuesday),
                "WEDNESDAY" => Some(Self::Wednesday),
                "THURSDAY" => Some(Self::Thursday),
                "FRIDAY" => Some(Self::Friday),
                "SATURDAY" => Some(Self::Saturday),
                "SUNDAY" => Some(Self::Sunday),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeviceEnum {}
/// Nested message and enum types in `DeviceEnum`.
pub mod device_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Device {
        Unspecified = 0,
        Unknown = 1,
        Mobile = 2,
        Tablet = 3,
        Desktop = 4,
        ConnectedTv = 6,
        Other = 5,
    }
    impl Device {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Device::Unspecified => "UNSPECIFIED",
                Device::Unknown => "UNKNOWN",
                Device::Mobile => "MOBILE",
                Device::Tablet => "TABLET",
                Device::Desktop => "DESKTOP",
                Device::ConnectedTv => "CONNECTED_TV",
                Device::Other => "OTHER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MOBILE" => Some(Self::Mobile),
                "TABLET" => Some(Self::Tablet),
                "DESKTOP" => Some(Self::Desktop),
                "CONNECTED_TV" => Some(Self::ConnectedTv),
                "OTHER" => Some(Self::Other),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenderTypeEnum {}
/// Nested message and enum types in `GenderTypeEnum`.
pub mod gender_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GenderType {
        Unspecified = 0,
        Unknown = 1,
        Male = 10,
        Female = 11,
        Undetermined = 20,
    }
    impl GenderType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                GenderType::Unspecified => "UNSPECIFIED",
                GenderType::Unknown => "UNKNOWN",
                GenderType::Male => "MALE",
                GenderType::Female => "FEMALE",
                GenderType::Undetermined => "UNDETERMINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "MALE" => Some(Self::Male),
                "FEMALE" => Some(Self::Female),
                "UNDETERMINED" => Some(Self::Undetermined),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeywordMatchTypeEnum {}
/// Nested message and enum types in `KeywordMatchTypeEnum`.
pub mod keyword_match_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum KeywordMatchType {
        Unspecified = 0,
        Unknown = 1,
        Exact = 2,
        Phrase = 3,
        Broad = 4,
    }
    impl KeywordMatchType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                KeywordMatchType::Unspecified => "UNSPECIFIED",
                KeywordMatchType::Unknown => "UNKNOWN",
                KeywordMatchType::Exact => "EXACT",
                KeywordMatchType::Phrase => "PHRASE",
                KeywordMatchType::Broad => "BROAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXACT" => Some(Self::Exact),
                "PHRASE" => Some(Self::Phrase),
                "BROAD" => Some(Self::Broad),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupTypeEnum {}
/// Nested message and enum types in `ListingGroupTypeEnum`.
pub mod listing_group_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupType {
        Unspecified = 0,
        Unknown = 1,
        Subdivision = 2,
        Unit = 3,
    }
    impl ListingGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupType::Unspecified => "UNSPECIFIED",
                ListingGroupType::Unknown => "UNKNOWN",
                ListingGroupType::Subdivision => "SUBDIVISION",
                ListingGroupType::Unit => "UNIT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT" => Some(Self::Unit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationGroupRadiusUnitsEnum {}
/// Nested message and enum types in `LocationGroupRadiusUnitsEnum`.
pub mod location_group_radius_units_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationGroupRadiusUnits {
        Unspecified = 0,
        Unknown = 1,
        Meters = 2,
        Miles = 3,
        MilliMiles = 4,
    }
    impl LocationGroupRadiusUnits {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationGroupRadiusUnits::Unspecified => "UNSPECIFIED",
                LocationGroupRadiusUnits::Unknown => "UNKNOWN",
                LocationGroupRadiusUnits::Meters => "METERS",
                LocationGroupRadiusUnits::Miles => "MILES",
                LocationGroupRadiusUnits::MilliMiles => "MILLI_MILES",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "METERS" => Some(Self::Meters),
                "MILES" => Some(Self::Miles),
                "MILLI_MILES" => Some(Self::MilliMiles),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MinuteOfHourEnum {}
/// Nested message and enum types in `MinuteOfHourEnum`.
pub mod minute_of_hour_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MinuteOfHour {
        Unspecified = 0,
        Unknown = 1,
        Zero = 2,
        Fifteen = 3,
        Thirty = 4,
        FortyFive = 5,
    }
    impl MinuteOfHour {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MinuteOfHour::Unspecified => "UNSPECIFIED",
                MinuteOfHour::Unknown => "UNKNOWN",
                MinuteOfHour::Zero => "ZERO",
                MinuteOfHour::Fifteen => "FIFTEEN",
                MinuteOfHour::Thirty => "THIRTY",
                MinuteOfHour::FortyFive => "FORTY_FIVE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ZERO" => Some(Self::Zero),
                "FIFTEEN" => Some(Self::Fifteen),
                "THIRTY" => Some(Self::Thirty),
                "FORTY_FIVE" => Some(Self::FortyFive),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperandEnum {}
/// Nested message and enum types in `WebpageConditionOperandEnum`.
pub mod webpage_condition_operand_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperand {
        Unspecified = 0,
        Unknown = 1,
        Url = 2,
        Category = 3,
        PageTitle = 4,
        PageContent = 5,
        CustomLabel = 6,
    }
    impl WebpageConditionOperand {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WebpageConditionOperand::Unspecified => "UNSPECIFIED",
                WebpageConditionOperand::Unknown => "UNKNOWN",
                WebpageConditionOperand::Url => "URL",
                WebpageConditionOperand::Category => "CATEGORY",
                WebpageConditionOperand::PageTitle => "PAGE_TITLE",
                WebpageConditionOperand::PageContent => "PAGE_CONTENT",
                WebpageConditionOperand::CustomLabel => "CUSTOM_LABEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "URL" => Some(Self::Url),
                "CATEGORY" => Some(Self::Category),
                "PAGE_TITLE" => Some(Self::PageTitle),
                "PAGE_CONTENT" => Some(Self::PageContent),
                "CUSTOM_LABEL" => Some(Self::CustomLabel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct WebpageConditionOperatorEnum {}
/// Nested message and enum types in `WebpageConditionOperatorEnum`.
pub mod webpage_condition_operator_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum WebpageConditionOperator {
        Unspecified = 0,
        Unknown = 1,
        Equals = 2,
        Contains = 3,
    }
    impl WebpageConditionOperator {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                WebpageConditionOperator::Unspecified => "UNSPECIFIED",
                WebpageConditionOperator::Unknown => "UNKNOWN",
                WebpageConditionOperator::Equals => "EQUALS",
                WebpageConditionOperator::Contains => "CONTAINS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EQUALS" => Some(Self::Equals),
                "CONTAINS" => Some(Self::Contains),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallConversionReportingStateEnum {}
/// Nested message and enum types in `CallConversionReportingStateEnum`.
pub mod call_conversion_reporting_state_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallConversionReportingState {
        Unspecified = 0,
        Unknown = 1,
        Disabled = 2,
        UseAccountLevelCallConversionAction = 3,
        UseResourceLevelCallConversionAction = 4,
    }
    impl CallConversionReportingState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallConversionReportingState::Unspecified => "UNSPECIFIED",
                CallConversionReportingState::Unknown => "UNKNOWN",
                CallConversionReportingState::Disabled => "DISABLED",
                CallConversionReportingState::UseAccountLevelCallConversionAction => {
                    "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION"
                }
                CallConversionReportingState::UseResourceLevelCallConversionAction => {
                    "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DISABLED" => Some(Self::Disabled),
                "USE_ACCOUNT_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseAccountLevelCallConversionAction)
                }
                "USE_RESOURCE_LEVEL_CALL_CONVERSION_ACTION" => {
                    Some(Self::UseResourceLevelCallConversionAction)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CallToActionTypeEnum {}
/// Nested message and enum types in `CallToActionTypeEnum`.
pub mod call_to_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CallToActionType {
        Unspecified = 0,
        Unknown = 1,
        LearnMore = 2,
        GetQuote = 3,
        ApplyNow = 4,
        SignUp = 5,
        ContactUs = 6,
        Subscribe = 7,
        Download = 8,
        BookNow = 9,
        ShopNow = 10,
        BuyNow = 11,
        DonateNow = 12,
        OrderNow = 13,
        PlayNow = 14,
        SeeMore = 15,
        StartNow = 16,
        VisitSite = 17,
        WatchNow = 18,
    }
    impl CallToActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CallToActionType::Unspecified => "UNSPECIFIED",
                CallToActionType::Unknown => "UNKNOWN",
                CallToActionType::LearnMore => "LEARN_MORE",
                CallToActionType::GetQuote => "GET_QUOTE",
                CallToActionType::ApplyNow => "APPLY_NOW",
                CallToActionType::SignUp => "SIGN_UP",
                CallToActionType::ContactUs => "CONTACT_US",
                CallToActionType::Subscribe => "SUBSCRIBE",
                CallToActionType::Download => "DOWNLOAD",
                CallToActionType::BookNow => "BOOK_NOW",
                CallToActionType::ShopNow => "SHOP_NOW",
                CallToActionType::BuyNow => "BUY_NOW",
                CallToActionType::DonateNow => "DONATE_NOW",
                CallToActionType::OrderNow => "ORDER_NOW",
                CallToActionType::PlayNow => "PLAY_NOW",
                CallToActionType::SeeMore => "SEE_MORE",
                CallToActionType::StartNow => "START_NOW",
                CallToActionType::VisitSite => "VISIT_SITE",
                CallToActionType::WatchNow => "WATCH_NOW",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEARN_MORE" => Some(Self::LearnMore),
                "GET_QUOTE" => Some(Self::GetQuote),
                "APPLY_NOW" => Some(Self::ApplyNow),
                "SIGN_UP" => Some(Self::SignUp),
                "CONTACT_US" => Some(Self::ContactUs),
                "SUBSCRIBE" => Some(Self::Subscribe),
                "DOWNLOAD" => Some(Self::Download),
                "BOOK_NOW" => Some(Self::BookNow),
                "SHOP_NOW" => Some(Self::ShopNow),
                "BUY_NOW" => Some(Self::BuyNow),
                "DONATE_NOW" => Some(Self::DonateNow),
                "ORDER_NOW" => Some(Self::OrderNow),
                "PLAY_NOW" => Some(Self::PlayNow),
                "SEE_MORE" => Some(Self::SeeMore),
                "START_NOW" => Some(Self::StartNow),
                "VISIT_SITE" => Some(Self::VisitSite),
                "WATCH_NOW" => Some(Self::WatchNow),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LocationOwnershipTypeEnum {}
/// Nested message and enum types in `LocationOwnershipTypeEnum`.
pub mod location_ownership_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LocationOwnershipType {
        Unspecified = 0,
        Unknown = 1,
        BusinessOwner = 2,
        Affiliate = 3,
    }
    impl LocationOwnershipType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LocationOwnershipType::Unspecified => "UNSPECIFIED",
                LocationOwnershipType::Unknown => "UNKNOWN",
                LocationOwnershipType::BusinessOwner => "BUSINESS_OWNER",
                LocationOwnershipType::Affiliate => "AFFILIATE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BUSINESS_OWNER" => Some(Self::BusinessOwner),
                "AFFILIATE" => Some(Self::Affiliate),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MimeTypeEnum {}
/// Nested message and enum types in `MimeTypeEnum`.
pub mod mime_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MimeType {
        Unspecified = 0,
        Unknown = 1,
        ImageJpeg = 2,
        ImageGif = 3,
        ImagePng = 4,
        Flash = 5,
        TextHtml = 6,
        Pdf = 7,
        Msword = 8,
        Msexcel = 9,
        Rtf = 10,
        AudioWav = 11,
        AudioMp3 = 12,
        Html5AdZip = 13,
    }
    impl MimeType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MimeType::Unspecified => "UNSPECIFIED",
                MimeType::Unknown => "UNKNOWN",
                MimeType::ImageJpeg => "IMAGE_JPEG",
                MimeType::ImageGif => "IMAGE_GIF",
                MimeType::ImagePng => "IMAGE_PNG",
                MimeType::Flash => "FLASH",
                MimeType::TextHtml => "TEXT_HTML",
                MimeType::Pdf => "PDF",
                MimeType::Msword => "MSWORD",
                MimeType::Msexcel => "MSEXCEL",
                MimeType::Rtf => "RTF",
                MimeType::AudioWav => "AUDIO_WAV",
                MimeType::AudioMp3 => "AUDIO_MP3",
                MimeType::Html5AdZip => "HTML5_AD_ZIP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "IMAGE_JPEG" => Some(Self::ImageJpeg),
                "IMAGE_GIF" => Some(Self::ImageGif),
                "IMAGE_PNG" => Some(Self::ImagePng),
                "FLASH" => Some(Self::Flash),
                "TEXT_HTML" => Some(Self::TextHtml),
                "PDF" => Some(Self::Pdf),
                "MSWORD" => Some(Self::Msword),
                "MSEXCEL" => Some(Self::Msexcel),
                "RTF" => Some(Self::Rtf),
                "AUDIO_WAV" => Some(Self::AudioWav),
                "AUDIO_MP3" => Some(Self::AudioMp3),
                "HTML5_AD_ZIP" => Some(Self::Html5AdZip),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MobileAppVendorEnum {}
/// Nested message and enum types in `MobileAppVendorEnum`.
pub mod mobile_app_vendor_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MobileAppVendor {
        Unspecified = 0,
        Unknown = 1,
        AppleAppStore = 2,
        GoogleAppStore = 3,
    }
    impl MobileAppVendor {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                MobileAppVendor::Unspecified => "UNSPECIFIED",
                MobileAppVendor::Unknown => "UNKNOWN",
                MobileAppVendor::AppleAppStore => "APPLE_APP_STORE",
                MobileAppVendor::GoogleAppStore => "GOOGLE_APP_STORE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "APPLE_APP_STORE" => Some(Self::AppleAppStore),
                "GOOGLE_APP_STORE" => Some(Self::GoogleAppStore),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetEngineStatusEnum {}
/// Nested message and enum types in `AssetEngineStatusEnum`.
pub mod asset_engine_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetEngineStatus {
        Unspecified = 0,
        Unknown = 1,
        Serving = 2,
        ServingLimited = 3,
        Disapproved = 4,
        Disabled = 5,
        Removed = 6,
    }
    impl AssetEngineStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetEngineStatus::Unspecified => "UNSPECIFIED",
                AssetEngineStatus::Unknown => "UNKNOWN",
                AssetEngineStatus::Serving => "SERVING",
                AssetEngineStatus::ServingLimited => "SERVING_LIMITED",
                AssetEngineStatus::Disapproved => "DISAPPROVED",
                AssetEngineStatus::Disabled => "DISABLED",
                AssetEngineStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SERVING" => Some(Self::Serving),
                "SERVING_LIMITED" => Some(Self::ServingLimited),
                "DISAPPROVED" => Some(Self::Disapproved),
                "DISABLED" => Some(Self::Disabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetStatusEnum {}
/// Nested message and enum types in `AssetStatusEnum`.
pub mod asset_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Archived = 4,
        PendingSystemGenerated = 5,
    }
    impl AssetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetStatus::Unspecified => "UNSPECIFIED",
                AssetStatus::Unknown => "UNKNOWN",
                AssetStatus::Enabled => "ENABLED",
                AssetStatus::Removed => "REMOVED",
                AssetStatus::Archived => "ARCHIVED",
                AssetStatus::PendingSystemGenerated => "PENDING_SYSTEM_GENERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "ARCHIVED" => Some(Self::Archived),
                "PENDING_SYSTEM_GENERATED" => Some(Self::PendingSystemGenerated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetTypeEnum {}
/// Nested message and enum types in `AssetTypeEnum`.
pub mod asset_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetType {
        Unspecified = 0,
        Unknown = 1,
        YoutubeVideo = 2,
        MediaBundle = 3,
        Image = 4,
        Text = 5,
        LeadForm = 6,
        BookOnGoogle = 7,
        Promotion = 8,
        Callout = 9,
        StructuredSnippet = 10,
        Sitelink = 11,
        PageFeed = 12,
        DynamicEducation = 13,
        MobileApp = 14,
        HotelCallout = 15,
        Call = 16,
        Price = 17,
        CallToAction = 18,
        DynamicRealEstate = 19,
        DynamicCustom = 20,
        DynamicHotelsAndRentals = 21,
        DynamicFlights = 22,
        DiscoveryCarouselCard = 23,
        DynamicTravel = 24,
        DynamicLocal = 25,
        DynamicJobs = 26,
        Location = 27,
        HotelProperty = 28,
    }
    impl AssetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetType::Unspecified => "UNSPECIFIED",
                AssetType::Unknown => "UNKNOWN",
                AssetType::YoutubeVideo => "YOUTUBE_VIDEO",
                AssetType::MediaBundle => "MEDIA_BUNDLE",
                AssetType::Image => "IMAGE",
                AssetType::Text => "TEXT",
                AssetType::LeadForm => "LEAD_FORM",
                AssetType::BookOnGoogle => "BOOK_ON_GOOGLE",
                AssetType::Promotion => "PROMOTION",
                AssetType::Callout => "CALLOUT",
                AssetType::StructuredSnippet => "STRUCTURED_SNIPPET",
                AssetType::Sitelink => "SITELINK",
                AssetType::PageFeed => "PAGE_FEED",
                AssetType::DynamicEducation => "DYNAMIC_EDUCATION",
                AssetType::MobileApp => "MOBILE_APP",
                AssetType::HotelCallout => "HOTEL_CALLOUT",
                AssetType::Call => "CALL",
                AssetType::Price => "PRICE",
                AssetType::CallToAction => "CALL_TO_ACTION",
                AssetType::DynamicRealEstate => "DYNAMIC_REAL_ESTATE",
                AssetType::DynamicCustom => "DYNAMIC_CUSTOM",
                AssetType::DynamicHotelsAndRentals => "DYNAMIC_HOTELS_AND_RENTALS",
                AssetType::DynamicFlights => "DYNAMIC_FLIGHTS",
                AssetType::DiscoveryCarouselCard => "DISCOVERY_CAROUSEL_CARD",
                AssetType::DynamicTravel => "DYNAMIC_TRAVEL",
                AssetType::DynamicLocal => "DYNAMIC_LOCAL",
                AssetType::DynamicJobs => "DYNAMIC_JOBS",
                AssetType::Location => "LOCATION",
                AssetType::HotelProperty => "HOTEL_PROPERTY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "MEDIA_BUNDLE" => Some(Self::MediaBundle),
                "IMAGE" => Some(Self::Image),
                "TEXT" => Some(Self::Text),
                "LEAD_FORM" => Some(Self::LeadForm),
                "BOOK_ON_GOOGLE" => Some(Self::BookOnGoogle),
                "PROMOTION" => Some(Self::Promotion),
                "CALLOUT" => Some(Self::Callout),
                "STRUCTURED_SNIPPET" => Some(Self::StructuredSnippet),
                "SITELINK" => Some(Self::Sitelink),
                "PAGE_FEED" => Some(Self::PageFeed),
                "DYNAMIC_EDUCATION" => Some(Self::DynamicEducation),
                "MOBILE_APP" => Some(Self::MobileApp),
                "HOTEL_CALLOUT" => Some(Self::HotelCallout),
                "CALL" => Some(Self::Call),
                "PRICE" => Some(Self::Price),
                "CALL_TO_ACTION" => Some(Self::CallToAction),
                "DYNAMIC_REAL_ESTATE" => Some(Self::DynamicRealEstate),
                "DYNAMIC_CUSTOM" => Some(Self::DynamicCustom),
                "DYNAMIC_HOTELS_AND_RENTALS" => Some(Self::DynamicHotelsAndRentals),
                "DYNAMIC_FLIGHTS" => Some(Self::DynamicFlights),
                "DISCOVERY_CAROUSEL_CARD" => Some(Self::DiscoveryCarouselCard),
                "DYNAMIC_TRAVEL" => Some(Self::DynamicTravel),
                "DYNAMIC_LOCAL" => Some(Self::DynamicLocal),
                "DYNAMIC_JOBS" => Some(Self::DynamicJobs),
                "LOCATION" => Some(Self::Location),
                "HOTEL_PROPERTY" => Some(Self::HotelProperty),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomColumnValueTypeEnum {}
/// Nested message and enum types in `CustomColumnValueTypeEnum`.
pub mod custom_column_value_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomColumnValueType {
        Unspecified = 0,
        Unknown = 1,
        String = 2,
        Int64 = 3,
        Double = 4,
        Boolean = 5,
    }
    impl CustomColumnValueType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomColumnValueType::Unspecified => "UNSPECIFIED",
                CustomColumnValueType::Unknown => "UNKNOWN",
                CustomColumnValueType::String => "STRING",
                CustomColumnValueType::Int64 => "INT64",
                CustomColumnValueType::Double => "DOUBLE",
                CustomColumnValueType::Boolean => "BOOLEAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STRING" => Some(Self::String),
                "INT64" => Some(Self::Int64),
                "DOUBLE" => Some(Self::Double),
                "BOOLEAN" => Some(Self::Boolean),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdEngineStatusEnum {}
/// Nested message and enum types in `AdGroupAdEngineStatusEnum`.
pub mod ad_group_ad_engine_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdEngineStatus {
        Unspecified = 0,
        Unknown = 1,
        AdGroupAdEligible = 2,
        AdGroupAdInappropriateForCampaign = 3,
        AdGroupAdMobileUrlUnderReview = 4,
        AdGroupAdPartiallyInvalid = 5,
        AdGroupAdToBeActivated = 6,
        AdGroupAdNotReviewed = 7,
        AdGroupAdOnHold = 8,
        AdGroupAdPaused = 9,
        AdGroupAdRemoved = 10,
        AdGroupAdPendingReview = 11,
        AdGroupAdUnderReview = 12,
        AdGroupAdApproved = 13,
        AdGroupAdDisapproved = 14,
        AdGroupAdServing = 15,
        AdGroupAdAccountPaused = 16,
        AdGroupAdCampaignPaused = 17,
        AdGroupAdAdGroupPaused = 18,
    }
    impl AdGroupAdEngineStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdEngineStatus::Unspecified => "UNSPECIFIED",
                AdGroupAdEngineStatus::Unknown => "UNKNOWN",
                AdGroupAdEngineStatus::AdGroupAdEligible => "AD_GROUP_AD_ELIGIBLE",
                AdGroupAdEngineStatus::AdGroupAdInappropriateForCampaign => {
                    "AD_GROUP_AD_INAPPROPRIATE_FOR_CAMPAIGN"
                }
                AdGroupAdEngineStatus::AdGroupAdMobileUrlUnderReview => {
                    "AD_GROUP_AD_MOBILE_URL_UNDER_REVIEW"
                }
                AdGroupAdEngineStatus::AdGroupAdPartiallyInvalid => {
                    "AD_GROUP_AD_PARTIALLY_INVALID"
                }
                AdGroupAdEngineStatus::AdGroupAdToBeActivated => {
                    "AD_GROUP_AD_TO_BE_ACTIVATED"
                }
                AdGroupAdEngineStatus::AdGroupAdNotReviewed => "AD_GROUP_AD_NOT_REVIEWED",
                AdGroupAdEngineStatus::AdGroupAdOnHold => "AD_GROUP_AD_ON_HOLD",
                AdGroupAdEngineStatus::AdGroupAdPaused => "AD_GROUP_AD_PAUSED",
                AdGroupAdEngineStatus::AdGroupAdRemoved => "AD_GROUP_AD_REMOVED",
                AdGroupAdEngineStatus::AdGroupAdPendingReview => {
                    "AD_GROUP_AD_PENDING_REVIEW"
                }
                AdGroupAdEngineStatus::AdGroupAdUnderReview => "AD_GROUP_AD_UNDER_REVIEW",
                AdGroupAdEngineStatus::AdGroupAdApproved => "AD_GROUP_AD_APPROVED",
                AdGroupAdEngineStatus::AdGroupAdDisapproved => "AD_GROUP_AD_DISAPPROVED",
                AdGroupAdEngineStatus::AdGroupAdServing => "AD_GROUP_AD_SERVING",
                AdGroupAdEngineStatus::AdGroupAdAccountPaused => {
                    "AD_GROUP_AD_ACCOUNT_PAUSED"
                }
                AdGroupAdEngineStatus::AdGroupAdCampaignPaused => {
                    "AD_GROUP_AD_CAMPAIGN_PAUSED"
                }
                AdGroupAdEngineStatus::AdGroupAdAdGroupPaused => {
                    "AD_GROUP_AD_AD_GROUP_PAUSED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_AD_ELIGIBLE" => Some(Self::AdGroupAdEligible),
                "AD_GROUP_AD_INAPPROPRIATE_FOR_CAMPAIGN" => {
                    Some(Self::AdGroupAdInappropriateForCampaign)
                }
                "AD_GROUP_AD_MOBILE_URL_UNDER_REVIEW" => {
                    Some(Self::AdGroupAdMobileUrlUnderReview)
                }
                "AD_GROUP_AD_PARTIALLY_INVALID" => Some(Self::AdGroupAdPartiallyInvalid),
                "AD_GROUP_AD_TO_BE_ACTIVATED" => Some(Self::AdGroupAdToBeActivated),
                "AD_GROUP_AD_NOT_REVIEWED" => Some(Self::AdGroupAdNotReviewed),
                "AD_GROUP_AD_ON_HOLD" => Some(Self::AdGroupAdOnHold),
                "AD_GROUP_AD_PAUSED" => Some(Self::AdGroupAdPaused),
                "AD_GROUP_AD_REMOVED" => Some(Self::AdGroupAdRemoved),
                "AD_GROUP_AD_PENDING_REVIEW" => Some(Self::AdGroupAdPendingReview),
                "AD_GROUP_AD_UNDER_REVIEW" => Some(Self::AdGroupAdUnderReview),
                "AD_GROUP_AD_APPROVED" => Some(Self::AdGroupAdApproved),
                "AD_GROUP_AD_DISAPPROVED" => Some(Self::AdGroupAdDisapproved),
                "AD_GROUP_AD_SERVING" => Some(Self::AdGroupAdServing),
                "AD_GROUP_AD_ACCOUNT_PAUSED" => Some(Self::AdGroupAdAccountPaused),
                "AD_GROUP_AD_CAMPAIGN_PAUSED" => Some(Self::AdGroupAdCampaignPaused),
                "AD_GROUP_AD_AD_GROUP_PAUSED" => Some(Self::AdGroupAdAdGroupPaused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdStatusEnum {}
/// Nested message and enum types in `AdGroupAdStatusEnum`.
pub mod ad_group_ad_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupAdStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdStatus::Unspecified => "UNSPECIFIED",
                AdGroupAdStatus::Unknown => "UNKNOWN",
                AdGroupAdStatus::Enabled => "ENABLED",
                AdGroupAdStatus::Paused => "PAUSED",
                AdGroupAdStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdTypeEnum {}
/// Nested message and enum types in `AdTypeEnum`.
pub mod ad_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdType {
        Unspecified = 0,
        Unknown = 1,
        TextAd = 2,
        ExpandedTextAd = 3,
        CallOnlyAd = 6,
        ExpandedDynamicSearchAd = 7,
        HotelAd = 8,
        ShoppingSmartAd = 9,
        ShoppingProductAd = 10,
        VideoAd = 12,
        GmailAd = 13,
        ImageAd = 14,
        ResponsiveSearchAd = 15,
        LegacyResponsiveDisplayAd = 16,
        AppAd = 17,
        LegacyAppInstallAd = 18,
        ResponsiveDisplayAd = 19,
        LocalAd = 20,
        Html5UploadAd = 21,
        DynamicHtml5Ad = 22,
        AppEngagementAd = 23,
        ShoppingComparisonListingAd = 24,
        VideoBumperAd = 25,
        VideoNonSkippableInStreamAd = 26,
        VideoOutstreamAd = 27,
        VideoTrueviewDiscoveryAd = 28,
        VideoTrueviewInStreamAd = 29,
        VideoResponsiveAd = 30,
        SmartCampaignAd = 31,
        AppPreRegistrationAd = 33,
        DiscoveryMultiAssetAd = 35,
        DiscoveryCarouselAd = 36,
        TravelAd = 37,
        DiscoveryVideoResponsiveAd = 38,
        MultimediaAd = 43,
    }
    impl AdType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdType::Unspecified => "UNSPECIFIED",
                AdType::Unknown => "UNKNOWN",
                AdType::TextAd => "TEXT_AD",
                AdType::ExpandedTextAd => "EXPANDED_TEXT_AD",
                AdType::CallOnlyAd => "CALL_ONLY_AD",
                AdType::ExpandedDynamicSearchAd => "EXPANDED_DYNAMIC_SEARCH_AD",
                AdType::HotelAd => "HOTEL_AD",
                AdType::ShoppingSmartAd => "SHOPPING_SMART_AD",
                AdType::ShoppingProductAd => "SHOPPING_PRODUCT_AD",
                AdType::VideoAd => "VIDEO_AD",
                AdType::GmailAd => "GMAIL_AD",
                AdType::ImageAd => "IMAGE_AD",
                AdType::ResponsiveSearchAd => "RESPONSIVE_SEARCH_AD",
                AdType::LegacyResponsiveDisplayAd => "LEGACY_RESPONSIVE_DISPLAY_AD",
                AdType::AppAd => "APP_AD",
                AdType::LegacyAppInstallAd => "LEGACY_APP_INSTALL_AD",
                AdType::ResponsiveDisplayAd => "RESPONSIVE_DISPLAY_AD",
                AdType::LocalAd => "LOCAL_AD",
                AdType::Html5UploadAd => "HTML5_UPLOAD_AD",
                AdType::DynamicHtml5Ad => "DYNAMIC_HTML5_AD",
                AdType::AppEngagementAd => "APP_ENGAGEMENT_AD",
                AdType::ShoppingComparisonListingAd => "SHOPPING_COMPARISON_LISTING_AD",
                AdType::VideoBumperAd => "VIDEO_BUMPER_AD",
                AdType::VideoNonSkippableInStreamAd => "VIDEO_NON_SKIPPABLE_IN_STREAM_AD",
                AdType::VideoOutstreamAd => "VIDEO_OUTSTREAM_AD",
                AdType::VideoTrueviewDiscoveryAd => "VIDEO_TRUEVIEW_DISCOVERY_AD",
                AdType::VideoTrueviewInStreamAd => "VIDEO_TRUEVIEW_IN_STREAM_AD",
                AdType::VideoResponsiveAd => "VIDEO_RESPONSIVE_AD",
                AdType::SmartCampaignAd => "SMART_CAMPAIGN_AD",
                AdType::AppPreRegistrationAd => "APP_PRE_REGISTRATION_AD",
                AdType::DiscoveryMultiAssetAd => "DISCOVERY_MULTI_ASSET_AD",
                AdType::DiscoveryCarouselAd => "DISCOVERY_CAROUSEL_AD",
                AdType::TravelAd => "TRAVEL_AD",
                AdType::DiscoveryVideoResponsiveAd => "DISCOVERY_VIDEO_RESPONSIVE_AD",
                AdType::MultimediaAd => "MULTIMEDIA_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "TEXT_AD" => Some(Self::TextAd),
                "EXPANDED_TEXT_AD" => Some(Self::ExpandedTextAd),
                "CALL_ONLY_AD" => Some(Self::CallOnlyAd),
                "EXPANDED_DYNAMIC_SEARCH_AD" => Some(Self::ExpandedDynamicSearchAd),
                "HOTEL_AD" => Some(Self::HotelAd),
                "SHOPPING_SMART_AD" => Some(Self::ShoppingSmartAd),
                "SHOPPING_PRODUCT_AD" => Some(Self::ShoppingProductAd),
                "VIDEO_AD" => Some(Self::VideoAd),
                "GMAIL_AD" => Some(Self::GmailAd),
                "IMAGE_AD" => Some(Self::ImageAd),
                "RESPONSIVE_SEARCH_AD" => Some(Self::ResponsiveSearchAd),
                "LEGACY_RESPONSIVE_DISPLAY_AD" => Some(Self::LegacyResponsiveDisplayAd),
                "APP_AD" => Some(Self::AppAd),
                "LEGACY_APP_INSTALL_AD" => Some(Self::LegacyAppInstallAd),
                "RESPONSIVE_DISPLAY_AD" => Some(Self::ResponsiveDisplayAd),
                "LOCAL_AD" => Some(Self::LocalAd),
                "HTML5_UPLOAD_AD" => Some(Self::Html5UploadAd),
                "DYNAMIC_HTML5_AD" => Some(Self::DynamicHtml5Ad),
                "APP_ENGAGEMENT_AD" => Some(Self::AppEngagementAd),
                "SHOPPING_COMPARISON_LISTING_AD" => {
                    Some(Self::ShoppingComparisonListingAd)
                }
                "VIDEO_BUMPER_AD" => Some(Self::VideoBumperAd),
                "VIDEO_NON_SKIPPABLE_IN_STREAM_AD" => {
                    Some(Self::VideoNonSkippableInStreamAd)
                }
                "VIDEO_OUTSTREAM_AD" => Some(Self::VideoOutstreamAd),
                "VIDEO_TRUEVIEW_DISCOVERY_AD" => Some(Self::VideoTrueviewDiscoveryAd),
                "VIDEO_TRUEVIEW_IN_STREAM_AD" => Some(Self::VideoTrueviewInStreamAd),
                "VIDEO_RESPONSIVE_AD" => Some(Self::VideoResponsiveAd),
                "SMART_CAMPAIGN_AD" => Some(Self::SmartCampaignAd),
                "APP_PRE_REGISTRATION_AD" => Some(Self::AppPreRegistrationAd),
                "DISCOVERY_MULTI_ASSET_AD" => Some(Self::DiscoveryMultiAssetAd),
                "DISCOVERY_CAROUSEL_AD" => Some(Self::DiscoveryCarouselAd),
                "TRAVEL_AD" => Some(Self::TravelAd),
                "DISCOVERY_VIDEO_RESPONSIVE_AD" => Some(Self::DiscoveryVideoResponsiveAd),
                "MULTIMEDIA_AD" => Some(Self::MultimediaAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchAds360FieldCategoryEnum {}
/// Nested message and enum types in `SearchAds360FieldCategoryEnum`.
pub mod search_ads360_field_category_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchAds360FieldCategory {
        Unspecified = 0,
        Unknown = 1,
        Resource = 2,
        Attribute = 3,
        Segment = 5,
        Metric = 6,
    }
    impl SearchAds360FieldCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchAds360FieldCategory::Unspecified => "UNSPECIFIED",
                SearchAds360FieldCategory::Unknown => "UNKNOWN",
                SearchAds360FieldCategory::Resource => "RESOURCE",
                SearchAds360FieldCategory::Attribute => "ATTRIBUTE",
                SearchAds360FieldCategory::Segment => "SEGMENT",
                SearchAds360FieldCategory::Metric => "METRIC",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "RESOURCE" => Some(Self::Resource),
                "ATTRIBUTE" => Some(Self::Attribute),
                "SEGMENT" => Some(Self::Segment),
                "METRIC" => Some(Self::Metric),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchAds360FieldDataTypeEnum {}
/// Nested message and enum types in `SearchAds360FieldDataTypeEnum`.
pub mod search_ads360_field_data_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SearchAds360FieldDataType {
        Unspecified = 0,
        Unknown = 1,
        Boolean = 2,
        Date = 3,
        Double = 4,
        Enum = 5,
        Float = 6,
        Int32 = 7,
        Int64 = 8,
        Message = 9,
        ResourceName = 10,
        String = 11,
        Uint64 = 12,
    }
    impl SearchAds360FieldDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SearchAds360FieldDataType::Unspecified => "UNSPECIFIED",
                SearchAds360FieldDataType::Unknown => "UNKNOWN",
                SearchAds360FieldDataType::Boolean => "BOOLEAN",
                SearchAds360FieldDataType::Date => "DATE",
                SearchAds360FieldDataType::Double => "DOUBLE",
                SearchAds360FieldDataType::Enum => "ENUM",
                SearchAds360FieldDataType::Float => "FLOAT",
                SearchAds360FieldDataType::Int32 => "INT32",
                SearchAds360FieldDataType::Int64 => "INT64",
                SearchAds360FieldDataType::Message => "MESSAGE",
                SearchAds360FieldDataType::ResourceName => "RESOURCE_NAME",
                SearchAds360FieldDataType::String => "STRING",
                SearchAds360FieldDataType::Uint64 => "UINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BOOLEAN" => Some(Self::Boolean),
                "DATE" => Some(Self::Date),
                "DOUBLE" => Some(Self::Double),
                "ENUM" => Some(Self::Enum),
                "FLOAT" => Some(Self::Float),
                "INT32" => Some(Self::Int32),
                "INT64" => Some(Self::Int64),
                "MESSAGE" => Some(Self::Message),
                "RESOURCE_NAME" => Some(Self::ResourceName),
                "STRING" => Some(Self::String),
                "UINT64" => Some(Self::Uint64),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ManagerLinkStatusEnum {}
/// Nested message and enum types in `ManagerLinkStatusEnum`.
pub mod manager_link_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ManagerLinkStatus {
        Unspecified = 0,
        Unknown = 1,
        Active = 2,
        Inactive = 3,
        Pending = 4,
        Refused = 5,
        Canceled = 6,
    }
    impl ManagerLinkStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ManagerLinkStatus::Unspecified => "UNSPECIFIED",
                ManagerLinkStatus::Unknown => "UNKNOWN",
                ManagerLinkStatus::Active => "ACTIVE",
                ManagerLinkStatus::Inactive => "INACTIVE",
                ManagerLinkStatus::Pending => "PENDING",
                ManagerLinkStatus::Refused => "REFUSED",
                ManagerLinkStatus::Canceled => "CANCELED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVE" => Some(Self::Active),
                "INACTIVE" => Some(Self::Inactive),
                "PENDING" => Some(Self::Pending),
                "REFUSED" => Some(Self::Refused),
                "CANCELED" => Some(Self::Canceled),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TargetingDimensionEnum {}
/// Nested message and enum types in `TargetingDimensionEnum`.
pub mod targeting_dimension_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum TargetingDimension {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Audience = 3,
        Topic = 4,
        Gender = 5,
        AgeRange = 6,
        Placement = 7,
        ParentalStatus = 8,
        IncomeRange = 9,
    }
    impl TargetingDimension {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                TargetingDimension::Unspecified => "UNSPECIFIED",
                TargetingDimension::Unknown => "UNKNOWN",
                TargetingDimension::Keyword => "KEYWORD",
                TargetingDimension::Audience => "AUDIENCE",
                TargetingDimension::Topic => "TOPIC",
                TargetingDimension::Gender => "GENDER",
                TargetingDimension::AgeRange => "AGE_RANGE",
                TargetingDimension::Placement => "PLACEMENT",
                TargetingDimension::ParentalStatus => "PARENTAL_STATUS",
                TargetingDimension::IncomeRange => "INCOME_RANGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "AUDIENCE" => Some(Self::Audience),
                "TOPIC" => Some(Self::Topic),
                "GENDER" => Some(Self::Gender),
                "AGE_RANGE" => Some(Self::AgeRange),
                "PLACEMENT" => Some(Self::Placement),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupAdRotationModeEnum {}
/// Nested message and enum types in `AdGroupAdRotationModeEnum`.
pub mod ad_group_ad_rotation_mode_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupAdRotationMode {
        Unspecified = 0,
        Unknown = 1,
        Optimize = 2,
        RotateForever = 3,
    }
    impl AdGroupAdRotationMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupAdRotationMode::Unspecified => "UNSPECIFIED",
                AdGroupAdRotationMode::Unknown => "UNKNOWN",
                AdGroupAdRotationMode::Optimize => "OPTIMIZE",
                AdGroupAdRotationMode::RotateForever => "ROTATE_FOREVER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "ROTATE_FOREVER" => Some(Self::RotateForever),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupEngineStatusEnum {}
/// Nested message and enum types in `AdGroupEngineStatusEnum`.
pub mod ad_group_engine_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupEngineStatus {
        Unspecified = 0,
        Unknown = 1,
        AdGroupEligible = 2,
        AdGroupExpired = 3,
        AdGroupRemoved = 4,
        AdGroupDraft = 5,
        AdGroupPaused = 6,
        AdGroupServing = 7,
        AdGroupSubmitted = 8,
        CampaignPaused = 9,
        AccountPaused = 10,
    }
    impl AdGroupEngineStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupEngineStatus::Unspecified => "UNSPECIFIED",
                AdGroupEngineStatus::Unknown => "UNKNOWN",
                AdGroupEngineStatus::AdGroupEligible => "AD_GROUP_ELIGIBLE",
                AdGroupEngineStatus::AdGroupExpired => "AD_GROUP_EXPIRED",
                AdGroupEngineStatus::AdGroupRemoved => "AD_GROUP_REMOVED",
                AdGroupEngineStatus::AdGroupDraft => "AD_GROUP_DRAFT",
                AdGroupEngineStatus::AdGroupPaused => "AD_GROUP_PAUSED",
                AdGroupEngineStatus::AdGroupServing => "AD_GROUP_SERVING",
                AdGroupEngineStatus::AdGroupSubmitted => "AD_GROUP_SUBMITTED",
                AdGroupEngineStatus::CampaignPaused => "CAMPAIGN_PAUSED",
                AdGroupEngineStatus::AccountPaused => "ACCOUNT_PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_ELIGIBLE" => Some(Self::AdGroupEligible),
                "AD_GROUP_EXPIRED" => Some(Self::AdGroupExpired),
                "AD_GROUP_REMOVED" => Some(Self::AdGroupRemoved),
                "AD_GROUP_DRAFT" => Some(Self::AdGroupDraft),
                "AD_GROUP_PAUSED" => Some(Self::AdGroupPaused),
                "AD_GROUP_SERVING" => Some(Self::AdGroupServing),
                "AD_GROUP_SUBMITTED" => Some(Self::AdGroupSubmitted),
                "CAMPAIGN_PAUSED" => Some(Self::CampaignPaused),
                "ACCOUNT_PAUSED" => Some(Self::AccountPaused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupStatusEnum {}
/// Nested message and enum types in `AdGroupStatusEnum`.
pub mod ad_group_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupStatus::Unspecified => "UNSPECIFIED",
                AdGroupStatus::Unknown => "UNKNOWN",
                AdGroupStatus::Enabled => "ENABLED",
                AdGroupStatus::Paused => "PAUSED",
                AdGroupStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupTypeEnum {}
/// Nested message and enum types in `AdGroupTypeEnum`.
pub mod ad_group_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupType {
        Unspecified = 0,
        Unknown = 1,
        SearchStandard = 2,
        DisplayStandard = 3,
        ShoppingProductAds = 4,
        ShoppingShowcaseAds = 5,
        HotelAds = 6,
        ShoppingSmartAds = 7,
        VideoBumper = 8,
        VideoTrueViewInStream = 9,
        VideoTrueViewInDisplay = 10,
        VideoNonSkippableInStream = 11,
        VideoOutstream = 12,
        SearchDynamicAds = 13,
        ShoppingComparisonListingAds = 14,
        PromotedHotelAds = 15,
        VideoResponsive = 16,
        VideoEfficientReach = 17,
        SmartCampaignAds = 18,
        TravelAds = 19,
    }
    impl AdGroupType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupType::Unspecified => "UNSPECIFIED",
                AdGroupType::Unknown => "UNKNOWN",
                AdGroupType::SearchStandard => "SEARCH_STANDARD",
                AdGroupType::DisplayStandard => "DISPLAY_STANDARD",
                AdGroupType::ShoppingProductAds => "SHOPPING_PRODUCT_ADS",
                AdGroupType::ShoppingShowcaseAds => "SHOPPING_SHOWCASE_ADS",
                AdGroupType::HotelAds => "HOTEL_ADS",
                AdGroupType::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                AdGroupType::VideoBumper => "VIDEO_BUMPER",
                AdGroupType::VideoTrueViewInStream => "VIDEO_TRUE_VIEW_IN_STREAM",
                AdGroupType::VideoTrueViewInDisplay => "VIDEO_TRUE_VIEW_IN_DISPLAY",
                AdGroupType::VideoNonSkippableInStream => "VIDEO_NON_SKIPPABLE_IN_STREAM",
                AdGroupType::VideoOutstream => "VIDEO_OUTSTREAM",
                AdGroupType::SearchDynamicAds => "SEARCH_DYNAMIC_ADS",
                AdGroupType::ShoppingComparisonListingAds => {
                    "SHOPPING_COMPARISON_LISTING_ADS"
                }
                AdGroupType::PromotedHotelAds => "PROMOTED_HOTEL_ADS",
                AdGroupType::VideoResponsive => "VIDEO_RESPONSIVE",
                AdGroupType::VideoEfficientReach => "VIDEO_EFFICIENT_REACH",
                AdGroupType::SmartCampaignAds => "SMART_CAMPAIGN_ADS",
                AdGroupType::TravelAds => "TRAVEL_ADS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_STANDARD" => Some(Self::SearchStandard),
                "DISPLAY_STANDARD" => Some(Self::DisplayStandard),
                "SHOPPING_PRODUCT_ADS" => Some(Self::ShoppingProductAds),
                "SHOPPING_SHOWCASE_ADS" => Some(Self::ShoppingShowcaseAds),
                "HOTEL_ADS" => Some(Self::HotelAds),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "VIDEO_BUMPER" => Some(Self::VideoBumper),
                "VIDEO_TRUE_VIEW_IN_STREAM" => Some(Self::VideoTrueViewInStream),
                "VIDEO_TRUE_VIEW_IN_DISPLAY" => Some(Self::VideoTrueViewInDisplay),
                "VIDEO_NON_SKIPPABLE_IN_STREAM" => Some(Self::VideoNonSkippableInStream),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "SEARCH_DYNAMIC_ADS" => Some(Self::SearchDynamicAds),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "PROMOTED_HOTEL_ADS" => Some(Self::PromotedHotelAds),
                "VIDEO_RESPONSIVE" => Some(Self::VideoResponsive),
                "VIDEO_EFFICIENT_REACH" => Some(Self::VideoEfficientReach),
                "SMART_CAMPAIGN_ADS" => Some(Self::SmartCampaignAds),
                "TRAVEL_ADS" => Some(Self::TravelAds),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetDeliveryMethodEnum {}
/// Nested message and enum types in `BudgetDeliveryMethodEnum`.
pub mod budget_delivery_method_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetDeliveryMethod {
        Unspecified = 0,
        Unknown = 1,
        Standard = 2,
        Accelerated = 3,
    }
    impl BudgetDeliveryMethod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetDeliveryMethod::Unspecified => "UNSPECIFIED",
                BudgetDeliveryMethod::Unknown => "UNKNOWN",
                BudgetDeliveryMethod::Standard => "STANDARD",
                BudgetDeliveryMethod::Accelerated => "ACCELERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "ACCELERATED" => Some(Self::Accelerated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BudgetPeriodEnum {}
/// Nested message and enum types in `BudgetPeriodEnum`.
pub mod budget_period_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BudgetPeriod {
        Unspecified = 0,
        Unknown = 1,
        Daily = 2,
        FixedDaily = 4,
        CustomPeriod = 5,
    }
    impl BudgetPeriod {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BudgetPeriod::Unspecified => "UNSPECIFIED",
                BudgetPeriod::Unknown => "UNKNOWN",
                BudgetPeriod::Daily => "DAILY",
                BudgetPeriod::FixedDaily => "FIXED_DAILY",
                BudgetPeriod::CustomPeriod => "CUSTOM_PERIOD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DAILY" => Some(Self::Daily),
                "FIXED_DAILY" => Some(Self::FixedDaily),
                "CUSTOM_PERIOD" => Some(Self::CustomPeriod),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LabelStatusEnum {}
/// Nested message and enum types in `LabelStatusEnum`.
pub mod label_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum LabelStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl LabelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                LabelStatus::Unspecified => "UNSPECIFIED",
                LabelStatus::Unknown => "UNKNOWN",
                LabelStatus::Enabled => "ENABLED",
                LabelStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CustomerStatusEnum {}
/// Nested message and enum types in `CustomerStatusEnum`.
pub mod customer_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CustomerStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Canceled = 3,
        Suspended = 4,
        Closed = 5,
    }
    impl CustomerStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CustomerStatus::Unspecified => "UNSPECIFIED",
                CustomerStatus::Unknown => "UNKNOWN",
                CustomerStatus::Enabled => "ENABLED",
                CustomerStatus::Canceled => "CANCELED",
                CustomerStatus::Suspended => "SUSPENDED",
                CustomerStatus::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "CANCELED" => Some(Self::Canceled),
                "SUSPENDED" => Some(Self::Suspended),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignCriterionStatusEnum {}
/// Nested message and enum types in `CampaignCriterionStatusEnum`.
pub mod campaign_criterion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignCriterionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl CampaignCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignCriterionStatus::Unspecified => "UNSPECIFIED",
                CampaignCriterionStatus::Unknown => "UNKNOWN",
                CampaignCriterionStatus::Enabled => "ENABLED",
                CampaignCriterionStatus::Paused => "PAUSED",
                CampaignCriterionStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CriterionTypeEnum {}
/// Nested message and enum types in `CriterionTypeEnum`.
pub mod criterion_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CriterionType {
        Unspecified = 0,
        Unknown = 1,
        Keyword = 2,
        Placement = 3,
        MobileAppCategory = 4,
        MobileApplication = 5,
        Device = 6,
        Location = 7,
        ListingGroup = 8,
        AdSchedule = 9,
        AgeRange = 10,
        Gender = 11,
        IncomeRange = 12,
        ParentalStatus = 13,
        YoutubeVideo = 14,
        YoutubeChannel = 15,
        UserList = 16,
        Proximity = 17,
        Topic = 18,
        ListingScope = 19,
        Language = 20,
        IpBlock = 21,
        ContentLabel = 22,
        Carrier = 23,
        UserInterest = 24,
        Webpage = 25,
        OperatingSystemVersion = 26,
        AppPaymentModel = 27,
        MobileDevice = 28,
        CustomAffinity = 29,
        CustomIntent = 30,
        LocationGroup = 31,
        CustomAudience = 32,
        CombinedAudience = 33,
        KeywordTheme = 34,
        Audience = 35,
        LocalServiceId = 37,
        Brand = 39,
        BrandList = 40,
        LifeEvent = 41,
    }
    impl CriterionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CriterionType::Unspecified => "UNSPECIFIED",
                CriterionType::Unknown => "UNKNOWN",
                CriterionType::Keyword => "KEYWORD",
                CriterionType::Placement => "PLACEMENT",
                CriterionType::MobileAppCategory => "MOBILE_APP_CATEGORY",
                CriterionType::MobileApplication => "MOBILE_APPLICATION",
                CriterionType::Device => "DEVICE",
                CriterionType::Location => "LOCATION",
                CriterionType::ListingGroup => "LISTING_GROUP",
                CriterionType::AdSchedule => "AD_SCHEDULE",
                CriterionType::AgeRange => "AGE_RANGE",
                CriterionType::Gender => "GENDER",
                CriterionType::IncomeRange => "INCOME_RANGE",
                CriterionType::ParentalStatus => "PARENTAL_STATUS",
                CriterionType::YoutubeVideo => "YOUTUBE_VIDEO",
                CriterionType::YoutubeChannel => "YOUTUBE_CHANNEL",
                CriterionType::UserList => "USER_LIST",
                CriterionType::Proximity => "PROXIMITY",
                CriterionType::Topic => "TOPIC",
                CriterionType::ListingScope => "LISTING_SCOPE",
                CriterionType::Language => "LANGUAGE",
                CriterionType::IpBlock => "IP_BLOCK",
                CriterionType::ContentLabel => "CONTENT_LABEL",
                CriterionType::Carrier => "CARRIER",
                CriterionType::UserInterest => "USER_INTEREST",
                CriterionType::Webpage => "WEBPAGE",
                CriterionType::OperatingSystemVersion => "OPERATING_SYSTEM_VERSION",
                CriterionType::AppPaymentModel => "APP_PAYMENT_MODEL",
                CriterionType::MobileDevice => "MOBILE_DEVICE",
                CriterionType::CustomAffinity => "CUSTOM_AFFINITY",
                CriterionType::CustomIntent => "CUSTOM_INTENT",
                CriterionType::LocationGroup => "LOCATION_GROUP",
                CriterionType::CustomAudience => "CUSTOM_AUDIENCE",
                CriterionType::CombinedAudience => "COMBINED_AUDIENCE",
                CriterionType::KeywordTheme => "KEYWORD_THEME",
                CriterionType::Audience => "AUDIENCE",
                CriterionType::LocalServiceId => "LOCAL_SERVICE_ID",
                CriterionType::Brand => "BRAND",
                CriterionType::BrandList => "BRAND_LIST",
                CriterionType::LifeEvent => "LIFE_EVENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "KEYWORD" => Some(Self::Keyword),
                "PLACEMENT" => Some(Self::Placement),
                "MOBILE_APP_CATEGORY" => Some(Self::MobileAppCategory),
                "MOBILE_APPLICATION" => Some(Self::MobileApplication),
                "DEVICE" => Some(Self::Device),
                "LOCATION" => Some(Self::Location),
                "LISTING_GROUP" => Some(Self::ListingGroup),
                "AD_SCHEDULE" => Some(Self::AdSchedule),
                "AGE_RANGE" => Some(Self::AgeRange),
                "GENDER" => Some(Self::Gender),
                "INCOME_RANGE" => Some(Self::IncomeRange),
                "PARENTAL_STATUS" => Some(Self::ParentalStatus),
                "YOUTUBE_VIDEO" => Some(Self::YoutubeVideo),
                "YOUTUBE_CHANNEL" => Some(Self::YoutubeChannel),
                "USER_LIST" => Some(Self::UserList),
                "PROXIMITY" => Some(Self::Proximity),
                "TOPIC" => Some(Self::Topic),
                "LISTING_SCOPE" => Some(Self::ListingScope),
                "LANGUAGE" => Some(Self::Language),
                "IP_BLOCK" => Some(Self::IpBlock),
                "CONTENT_LABEL" => Some(Self::ContentLabel),
                "CARRIER" => Some(Self::Carrier),
                "USER_INTEREST" => Some(Self::UserInterest),
                "WEBPAGE" => Some(Self::Webpage),
                "OPERATING_SYSTEM_VERSION" => Some(Self::OperatingSystemVersion),
                "APP_PAYMENT_MODEL" => Some(Self::AppPaymentModel),
                "MOBILE_DEVICE" => Some(Self::MobileDevice),
                "CUSTOM_AFFINITY" => Some(Self::CustomAffinity),
                "CUSTOM_INTENT" => Some(Self::CustomIntent),
                "LOCATION_GROUP" => Some(Self::LocationGroup),
                "CUSTOM_AUDIENCE" => Some(Self::CustomAudience),
                "COMBINED_AUDIENCE" => Some(Self::CombinedAudience),
                "KEYWORD_THEME" => Some(Self::KeywordTheme),
                "AUDIENCE" => Some(Self::Audience),
                "LOCAL_SERVICE_ID" => Some(Self::LocalServiceId),
                "BRAND" => Some(Self::Brand),
                "BRAND_LIST" => Some(Self::BrandList),
                "LIFE_EVENT" => Some(Self::LifeEvent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UserListTypeEnum {}
/// Nested message and enum types in `UserListTypeEnum`.
pub mod user_list_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum UserListType {
        Unspecified = 0,
        Unknown = 1,
        Remarketing = 2,
        Logical = 3,
        ExternalRemarketing = 4,
        RuleBased = 5,
        Similar = 6,
        CrmBased = 7,
    }
    impl UserListType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                UserListType::Unspecified => "UNSPECIFIED",
                UserListType::Unknown => "UNKNOWN",
                UserListType::Remarketing => "REMARKETING",
                UserListType::Logical => "LOGICAL",
                UserListType::ExternalRemarketing => "EXTERNAL_REMARKETING",
                UserListType::RuleBased => "RULE_BASED",
                UserListType::Similar => "SIMILAR",
                UserListType::CrmBased => "CRM_BASED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "REMARKETING" => Some(Self::Remarketing),
                "LOGICAL" => Some(Self::Logical),
                "EXTERNAL_REMARKETING" => Some(Self::ExternalRemarketing),
                "RULE_BASED" => Some(Self::RuleBased),
                "SIMILAR" => Some(Self::Similar),
                "CRM_BASED" => Some(Self::CrmBased),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributionTypeEnum {}
/// Nested message and enum types in `AttributionTypeEnum`.
pub mod attribution_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttributionType {
        Unspecified = 0,
        Unknown = 1,
        Visit = 2,
        CriterionAd = 3,
    }
    impl AttributionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttributionType::Unspecified => "UNSPECIFIED",
                AttributionType::Unknown => "UNKNOWN",
                AttributionType::Visit => "VISIT",
                AttributionType::CriterionAd => "CRITERION_AD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "VISIT" => Some(Self::Visit),
                "CRITERION_AD" => Some(Self::CriterionAd),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionStatusEnum {}
/// Nested message and enum types in `ConversionStatusEnum`.
pub mod conversion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl ConversionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionStatus::Unspecified => "UNSPECIFIED",
                ConversionStatus::Unknown => "UNKNOWN",
                ConversionStatus::Enabled => "ENABLED",
                ConversionStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategyStatusEnum {}
/// Nested message and enum types in `BiddingStrategyStatusEnum`.
pub mod bidding_strategy_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategyStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 4,
    }
    impl BiddingStrategyStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategyStatus::Unspecified => "UNSPECIFIED",
                BiddingStrategyStatus::Unknown => "UNKNOWN",
                BiddingStrategyStatus::Enabled => "ENABLED",
                BiddingStrategyStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountStatusEnum {}
/// Nested message and enum types in `AccountStatusEnum`.
pub mod account_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Suspended = 4,
        Removed = 5,
        Draft = 6,
    }
    impl AccountStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountStatus::Unspecified => "UNSPECIFIED",
                AccountStatus::Unknown => "UNKNOWN",
                AccountStatus::Enabled => "ENABLED",
                AccountStatus::Paused => "PAUSED",
                AccountStatus::Suspended => "SUSPENDED",
                AccountStatus::Removed => "REMOVED",
                AccountStatus::Draft => "DRAFT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "SUSPENDED" => Some(Self::Suspended),
                "REMOVED" => Some(Self::Removed),
                "DRAFT" => Some(Self::Draft),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AccountTypeEnum {}
/// Nested message and enum types in `AccountTypeEnum`.
pub mod account_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AccountType {
        Unspecified = 0,
        Unknown = 1,
        Baidu = 2,
        EngineTrack = 3,
        Facebook = 4,
        FacebookGateway = 5,
        GoogleAds = 6,
        Microsoft = 7,
        SearchAds360 = 8,
        YahooJapan = 9,
    }
    impl AccountType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AccountType::Unspecified => "UNSPECIFIED",
                AccountType::Unknown => "UNKNOWN",
                AccountType::Baidu => "BAIDU",
                AccountType::EngineTrack => "ENGINE_TRACK",
                AccountType::Facebook => "FACEBOOK",
                AccountType::FacebookGateway => "FACEBOOK_GATEWAY",
                AccountType::GoogleAds => "GOOGLE_ADS",
                AccountType::Microsoft => "MICROSOFT",
                AccountType::SearchAds360 => "SEARCH_ADS_360",
                AccountType::YahooJapan => "YAHOO_JAPAN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BAIDU" => Some(Self::Baidu),
                "ENGINE_TRACK" => Some(Self::EngineTrack),
                "FACEBOOK" => Some(Self::Facebook),
                "FACEBOOK_GATEWAY" => Some(Self::FacebookGateway),
                "GOOGLE_ADS" => Some(Self::GoogleAds),
                "MICROSOFT" => Some(Self::Microsoft),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "YAHOO_JAPAN" => Some(Self::YahooJapan),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionTrackingStatusEnum {}
/// Nested message and enum types in `ConversionTrackingStatusEnum`.
pub mod conversion_tracking_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionTrackingStatus {
        Unspecified = 0,
        Unknown = 1,
        NotConversionTracked = 2,
        ConversionTrackingManagedBySelf = 3,
        ConversionTrackingManagedByThisManager = 4,
        ConversionTrackingManagedByAnotherManager = 5,
    }
    impl ConversionTrackingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionTrackingStatus::Unspecified => "UNSPECIFIED",
                ConversionTrackingStatus::Unknown => "UNKNOWN",
                ConversionTrackingStatus::NotConversionTracked => {
                    "NOT_CONVERSION_TRACKED"
                }
                ConversionTrackingStatus::ConversionTrackingManagedBySelf => {
                    "CONVERSION_TRACKING_MANAGED_BY_SELF"
                }
                ConversionTrackingStatus::ConversionTrackingManagedByThisManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER"
                }
                ConversionTrackingStatus::ConversionTrackingManagedByAnotherManager => {
                    "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NOT_CONVERSION_TRACKED" => Some(Self::NotConversionTracked),
                "CONVERSION_TRACKING_MANAGED_BY_SELF" => {
                    Some(Self::ConversionTrackingManagedBySelf)
                }
                "CONVERSION_TRACKING_MANAGED_BY_THIS_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByThisManager)
                }
                "CONVERSION_TRACKING_MANAGED_BY_ANOTHER_MANAGER" => {
                    Some(Self::ConversionTrackingManagedByAnotherManager)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterBiddingCategoryLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterBiddingCategoryLevelEnum`.
pub mod listing_group_filter_bidding_category_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterBiddingCategoryLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ListingGroupFilterBiddingCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterBiddingCategoryLevel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterBiddingCategoryLevel::Unknown => "UNKNOWN",
                ListingGroupFilterBiddingCategoryLevel::Level1 => "LEVEL1",
                ListingGroupFilterBiddingCategoryLevel::Level2 => "LEVEL2",
                ListingGroupFilterBiddingCategoryLevel::Level3 => "LEVEL3",
                ListingGroupFilterBiddingCategoryLevel::Level4 => "LEVEL4",
                ListingGroupFilterBiddingCategoryLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterCustomAttributeIndexEnum {}
/// Nested message and enum types in `ListingGroupFilterCustomAttributeIndexEnum`.
pub mod listing_group_filter_custom_attribute_index_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterCustomAttributeIndex {
        Unspecified = 0,
        Unknown = 1,
        Index0 = 2,
        Index1 = 3,
        Index2 = 4,
        Index3 = 5,
        Index4 = 6,
    }
    impl ListingGroupFilterCustomAttributeIndex {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterCustomAttributeIndex::Unspecified => "UNSPECIFIED",
                ListingGroupFilterCustomAttributeIndex::Unknown => "UNKNOWN",
                ListingGroupFilterCustomAttributeIndex::Index0 => "INDEX0",
                ListingGroupFilterCustomAttributeIndex::Index1 => "INDEX1",
                ListingGroupFilterCustomAttributeIndex::Index2 => "INDEX2",
                ListingGroupFilterCustomAttributeIndex::Index3 => "INDEX3",
                ListingGroupFilterCustomAttributeIndex::Index4 => "INDEX4",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "INDEX0" => Some(Self::Index0),
                "INDEX1" => Some(Self::Index1),
                "INDEX2" => Some(Self::Index2),
                "INDEX3" => Some(Self::Index3),
                "INDEX4" => Some(Self::Index4),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductChannelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductChannelEnum`.
pub mod listing_group_filter_product_channel_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductChannel {
        Unspecified = 0,
        Unknown = 1,
        Online = 2,
        Local = 3,
    }
    impl ListingGroupFilterProductChannel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductChannel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductChannel::Unknown => "UNKNOWN",
                ListingGroupFilterProductChannel::Online => "ONLINE",
                ListingGroupFilterProductChannel::Local => "LOCAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ONLINE" => Some(Self::Online),
                "LOCAL" => Some(Self::Local),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductConditionEnum {}
/// Nested message and enum types in `ListingGroupFilterProductConditionEnum`.
pub mod listing_group_filter_product_condition_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductCondition {
        Unspecified = 0,
        Unknown = 1,
        New = 2,
        Refurbished = 3,
        Used = 4,
    }
    impl ListingGroupFilterProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductCondition::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductCondition::Unknown => "UNKNOWN",
                ListingGroupFilterProductCondition::New => "NEW",
                ListingGroupFilterProductCondition::Refurbished => "REFURBISHED",
                ListingGroupFilterProductCondition::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterProductTypeLevelEnum {}
/// Nested message and enum types in `ListingGroupFilterProductTypeLevelEnum`.
pub mod listing_group_filter_product_type_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterProductTypeLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ListingGroupFilterProductTypeLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterProductTypeLevel::Unspecified => "UNSPECIFIED",
                ListingGroupFilterProductTypeLevel::Unknown => "UNKNOWN",
                ListingGroupFilterProductTypeLevel::Level1 => "LEVEL1",
                ListingGroupFilterProductTypeLevel::Level2 => "LEVEL2",
                ListingGroupFilterProductTypeLevel::Level3 => "LEVEL3",
                ListingGroupFilterProductTypeLevel::Level4 => "LEVEL4",
                ListingGroupFilterProductTypeLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterTypeEnum {}
/// Nested message and enum types in `ListingGroupFilterTypeEnum`.
pub mod listing_group_filter_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterType {
        Unspecified = 0,
        Unknown = 1,
        Subdivision = 2,
        UnitIncluded = 3,
        UnitExcluded = 4,
    }
    impl ListingGroupFilterType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterType::Unspecified => "UNSPECIFIED",
                ListingGroupFilterType::Unknown => "UNKNOWN",
                ListingGroupFilterType::Subdivision => "SUBDIVISION",
                ListingGroupFilterType::UnitIncluded => "UNIT_INCLUDED",
                ListingGroupFilterType::UnitExcluded => "UNIT_EXCLUDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SUBDIVISION" => Some(Self::Subdivision),
                "UNIT_INCLUDED" => Some(Self::UnitIncluded),
                "UNIT_EXCLUDED" => Some(Self::UnitExcluded),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListingGroupFilterVerticalEnum {}
/// Nested message and enum types in `ListingGroupFilterVerticalEnum`.
pub mod listing_group_filter_vertical_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ListingGroupFilterVertical {
        Unspecified = 0,
        Unknown = 1,
        Shopping = 2,
    }
    impl ListingGroupFilterVertical {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ListingGroupFilterVertical::Unspecified => "UNSPECIFIED",
                ListingGroupFilterVertical::Unknown => "UNKNOWN",
                ListingGroupFilterVertical::Shopping => "SHOPPING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SHOPPING" => Some(Self::Shopping),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionEngineStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionEngineStatusEnum`.
pub mod ad_group_criterion_engine_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionEngineStatus {
        Unspecified = 0,
        Unknown = 1,
        AdGroupCriterionEligible = 2,
        AdGroupCriterionInappropriateForCampaign = 3,
        AdGroupCriterionInvalidMobileSearch = 4,
        AdGroupCriterionInvalidPcSearch = 5,
        AdGroupCriterionInvalidSearch = 6,
        AdGroupCriterionLowSearchVolume = 7,
        AdGroupCriterionMobileUrlUnderReview = 8,
        AdGroupCriterionPartiallyInvalid = 9,
        AdGroupCriterionToBeActivated = 10,
        AdGroupCriterionUnderReview = 11,
        AdGroupCriterionNotReviewed = 12,
        AdGroupCriterionOnHold = 13,
        AdGroupCriterionPendingReview = 14,
        AdGroupCriterionPaused = 15,
        AdGroupCriterionRemoved = 16,
        AdGroupCriterionApproved = 17,
        AdGroupCriterionDisapproved = 18,
        AdGroupCriterionServing = 19,
        AdGroupCriterionAccountPaused = 20,
    }
    impl AdGroupCriterionEngineStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionEngineStatus::Unspecified => "UNSPECIFIED",
                AdGroupCriterionEngineStatus::Unknown => "UNKNOWN",
                AdGroupCriterionEngineStatus::AdGroupCriterionEligible => {
                    "AD_GROUP_CRITERION_ELIGIBLE"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionInappropriateForCampaign => {
                    "AD_GROUP_CRITERION_INAPPROPRIATE_FOR_CAMPAIGN"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionInvalidMobileSearch => {
                    "AD_GROUP_CRITERION_INVALID_MOBILE_SEARCH"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionInvalidPcSearch => {
                    "AD_GROUP_CRITERION_INVALID_PC_SEARCH"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionInvalidSearch => {
                    "AD_GROUP_CRITERION_INVALID_SEARCH"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionLowSearchVolume => {
                    "AD_GROUP_CRITERION_LOW_SEARCH_VOLUME"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionMobileUrlUnderReview => {
                    "AD_GROUP_CRITERION_MOBILE_URL_UNDER_REVIEW"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionPartiallyInvalid => {
                    "AD_GROUP_CRITERION_PARTIALLY_INVALID"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionToBeActivated => {
                    "AD_GROUP_CRITERION_TO_BE_ACTIVATED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionUnderReview => {
                    "AD_GROUP_CRITERION_UNDER_REVIEW"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionNotReviewed => {
                    "AD_GROUP_CRITERION_NOT_REVIEWED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionOnHold => {
                    "AD_GROUP_CRITERION_ON_HOLD"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionPendingReview => {
                    "AD_GROUP_CRITERION_PENDING_REVIEW"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionPaused => {
                    "AD_GROUP_CRITERION_PAUSED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionRemoved => {
                    "AD_GROUP_CRITERION_REMOVED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionApproved => {
                    "AD_GROUP_CRITERION_APPROVED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionDisapproved => {
                    "AD_GROUP_CRITERION_DISAPPROVED"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionServing => {
                    "AD_GROUP_CRITERION_SERVING"
                }
                AdGroupCriterionEngineStatus::AdGroupCriterionAccountPaused => {
                    "AD_GROUP_CRITERION_ACCOUNT_PAUSED"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_GROUP_CRITERION_ELIGIBLE" => Some(Self::AdGroupCriterionEligible),
                "AD_GROUP_CRITERION_INAPPROPRIATE_FOR_CAMPAIGN" => {
                    Some(Self::AdGroupCriterionInappropriateForCampaign)
                }
                "AD_GROUP_CRITERION_INVALID_MOBILE_SEARCH" => {
                    Some(Self::AdGroupCriterionInvalidMobileSearch)
                }
                "AD_GROUP_CRITERION_INVALID_PC_SEARCH" => {
                    Some(Self::AdGroupCriterionInvalidPcSearch)
                }
                "AD_GROUP_CRITERION_INVALID_SEARCH" => {
                    Some(Self::AdGroupCriterionInvalidSearch)
                }
                "AD_GROUP_CRITERION_LOW_SEARCH_VOLUME" => {
                    Some(Self::AdGroupCriterionLowSearchVolume)
                }
                "AD_GROUP_CRITERION_MOBILE_URL_UNDER_REVIEW" => {
                    Some(Self::AdGroupCriterionMobileUrlUnderReview)
                }
                "AD_GROUP_CRITERION_PARTIALLY_INVALID" => {
                    Some(Self::AdGroupCriterionPartiallyInvalid)
                }
                "AD_GROUP_CRITERION_TO_BE_ACTIVATED" => {
                    Some(Self::AdGroupCriterionToBeActivated)
                }
                "AD_GROUP_CRITERION_UNDER_REVIEW" => {
                    Some(Self::AdGroupCriterionUnderReview)
                }
                "AD_GROUP_CRITERION_NOT_REVIEWED" => {
                    Some(Self::AdGroupCriterionNotReviewed)
                }
                "AD_GROUP_CRITERION_ON_HOLD" => Some(Self::AdGroupCriterionOnHold),
                "AD_GROUP_CRITERION_PENDING_REVIEW" => {
                    Some(Self::AdGroupCriterionPendingReview)
                }
                "AD_GROUP_CRITERION_PAUSED" => Some(Self::AdGroupCriterionPaused),
                "AD_GROUP_CRITERION_REMOVED" => Some(Self::AdGroupCriterionRemoved),
                "AD_GROUP_CRITERION_APPROVED" => Some(Self::AdGroupCriterionApproved),
                "AD_GROUP_CRITERION_DISAPPROVED" => {
                    Some(Self::AdGroupCriterionDisapproved)
                }
                "AD_GROUP_CRITERION_SERVING" => Some(Self::AdGroupCriterionServing),
                "AD_GROUP_CRITERION_ACCOUNT_PAUSED" => {
                    Some(Self::AdGroupCriterionAccountPaused)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdGroupCriterionStatusEnum {}
/// Nested message and enum types in `AdGroupCriterionStatusEnum`.
pub mod ad_group_criterion_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdGroupCriterionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AdGroupCriterionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdGroupCriterionStatus::Unspecified => "UNSPECIFIED",
                AdGroupCriterionStatus::Unknown => "UNKNOWN",
                AdGroupCriterionStatus::Enabled => "ENABLED",
                AdGroupCriterionStatus::Paused => "PAUSED",
                AdGroupCriterionStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetSetAssetStatusEnum {}
/// Nested message and enum types in `AssetSetAssetStatusEnum`.
pub mod asset_set_asset_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetSetAssetStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
    }
    impl AssetSetAssetStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetSetAssetStatus::Unspecified => "UNSPECIFIED",
                AssetSetAssetStatus::Unknown => "UNKNOWN",
                AssetSetAssetStatus::Enabled => "ENABLED",
                AssetSetAssetStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableCardinalityEnum {}
/// Nested message and enum types in `ConversionCustomVariableCardinalityEnum`.
pub mod conversion_custom_variable_cardinality_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableCardinality {
        Unspecified = 0,
        Unknown = 1,
        BelowAllLimits = 2,
        ExceedsSegmentationLimitButNotStatsLimit = 3,
        ApproachesStatsLimit = 4,
        ExceedsStatsLimit = 5,
    }
    impl ConversionCustomVariableCardinality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCustomVariableCardinality::Unspecified => "UNSPECIFIED",
                ConversionCustomVariableCardinality::Unknown => "UNKNOWN",
                ConversionCustomVariableCardinality::BelowAllLimits => "BELOW_ALL_LIMITS",
                ConversionCustomVariableCardinality::ExceedsSegmentationLimitButNotStatsLimit => {
                    "EXCEEDS_SEGMENTATION_LIMIT_BUT_NOT_STATS_LIMIT"
                }
                ConversionCustomVariableCardinality::ApproachesStatsLimit => {
                    "APPROACHES_STATS_LIMIT"
                }
                ConversionCustomVariableCardinality::ExceedsStatsLimit => {
                    "EXCEEDS_STATS_LIMIT"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BELOW_ALL_LIMITS" => Some(Self::BelowAllLimits),
                "EXCEEDS_SEGMENTATION_LIMIT_BUT_NOT_STATS_LIMIT" => {
                    Some(Self::ExceedsSegmentationLimitButNotStatsLimit)
                }
                "APPROACHES_STATS_LIMIT" => Some(Self::ApproachesStatsLimit),
                "EXCEEDS_STATS_LIMIT" => Some(Self::ExceedsStatsLimit),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableFamilyEnum {}
/// Nested message and enum types in `ConversionCustomVariableFamilyEnum`.
pub mod conversion_custom_variable_family_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableFamily {
        Unspecified = 0,
        Unknown = 1,
        Standard = 2,
        Floodlight = 3,
    }
    impl ConversionCustomVariableFamily {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCustomVariableFamily::Unspecified => "UNSPECIFIED",
                ConversionCustomVariableFamily::Unknown => "UNKNOWN",
                ConversionCustomVariableFamily::Standard => "STANDARD",
                ConversionCustomVariableFamily::Floodlight => "FLOODLIGHT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "STANDARD" => Some(Self::Standard),
                "FLOODLIGHT" => Some(Self::Floodlight),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionCustomVariableStatusEnum {}
/// Nested message and enum types in `ConversionCustomVariableStatusEnum`.
pub mod conversion_custom_variable_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionCustomVariableStatus {
        Unspecified = 0,
        Unknown = 1,
        ActivationNeeded = 2,
        Enabled = 3,
        Paused = 4,
    }
    impl ConversionCustomVariableStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionCustomVariableStatus::Unspecified => "UNSPECIFIED",
                ConversionCustomVariableStatus::Unknown => "UNKNOWN",
                ConversionCustomVariableStatus::ActivationNeeded => "ACTIVATION_NEEDED",
                ConversionCustomVariableStatus::Enabled => "ENABLED",
                ConversionCustomVariableStatus::Paused => "PAUSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVATION_NEEDED" => Some(Self::ActivationNeeded),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloodlightVariableDataTypeEnum {}
/// Nested message and enum types in `FloodlightVariableDataTypeEnum`.
pub mod floodlight_variable_data_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FloodlightVariableDataType {
        Unspecified = 0,
        Unknown = 1,
        Number = 2,
        String = 3,
    }
    impl FloodlightVariableDataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FloodlightVariableDataType::Unspecified => "UNSPECIFIED",
                FloodlightVariableDataType::Unknown => "UNKNOWN",
                FloodlightVariableDataType::Number => "NUMBER",
                FloodlightVariableDataType::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NUMBER" => Some(Self::Number),
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloodlightVariableTypeEnum {}
/// Nested message and enum types in `FloodlightVariableTypeEnum`.
pub mod floodlight_variable_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FloodlightVariableType {
        Unspecified = 0,
        Unknown = 1,
        Dimension = 2,
        Metric = 3,
        Unset = 4,
    }
    impl FloodlightVariableType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                FloodlightVariableType::Unspecified => "UNSPECIFIED",
                FloodlightVariableType::Unknown => "UNKNOWN",
                FloodlightVariableType::Dimension => "DIMENSION",
                FloodlightVariableType::Metric => "METRIC",
                FloodlightVariableType::Unset => "UNSET",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DIMENSION" => Some(Self::Dimension),
                "METRIC" => Some(Self::Metric),
                "UNSET" => Some(Self::Unset),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductBiddingCategoryLevelEnum {}
/// Nested message and enum types in `ProductBiddingCategoryLevelEnum`.
pub mod product_bidding_category_level_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductBiddingCategoryLevel {
        Unspecified = 0,
        Unknown = 1,
        Level1 = 2,
        Level2 = 3,
        Level3 = 4,
        Level4 = 5,
        Level5 = 6,
    }
    impl ProductBiddingCategoryLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductBiddingCategoryLevel::Unspecified => "UNSPECIFIED",
                ProductBiddingCategoryLevel::Unknown => "UNKNOWN",
                ProductBiddingCategoryLevel::Level1 => "LEVEL1",
                ProductBiddingCategoryLevel::Level2 => "LEVEL2",
                ProductBiddingCategoryLevel::Level3 => "LEVEL3",
                ProductBiddingCategoryLevel::Level4 => "LEVEL4",
                ProductBiddingCategoryLevel::Level5 => "LEVEL5",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "LEVEL1" => Some(Self::Level1),
                "LEVEL2" => Some(Self::Level2),
                "LEVEL3" => Some(Self::Level3),
                "LEVEL4" => Some(Self::Level4),
                "LEVEL5" => Some(Self::Level5),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductBiddingCategoryStatusEnum {}
/// Nested message and enum types in `ProductBiddingCategoryStatusEnum`.
pub mod product_bidding_category_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductBiddingCategoryStatus {
        Unspecified = 0,
        Unknown = 1,
        Active = 2,
        Obsolete = 3,
    }
    impl ProductBiddingCategoryStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductBiddingCategoryStatus::Unspecified => "UNSPECIFIED",
                ProductBiddingCategoryStatus::Unknown => "UNKNOWN",
                ProductBiddingCategoryStatus::Active => "ACTIVE",
                ProductBiddingCategoryStatus::Obsolete => "OBSOLETE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ACTIVE" => Some(Self::Active),
                "OBSOLETE" => Some(Self::Obsolete),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdStrengthEnum {}
/// Nested message and enum types in `AdStrengthEnum`.
pub mod ad_strength_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdStrength {
        Unspecified = 0,
        Unknown = 1,
        Pending = 2,
        NoAds = 3,
        Poor = 4,
        Average = 5,
        Good = 6,
        Excellent = 7,
    }
    impl AdStrength {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdStrength::Unspecified => "UNSPECIFIED",
                AdStrength::Unknown => "UNKNOWN",
                AdStrength::Pending => "PENDING",
                AdStrength::NoAds => "NO_ADS",
                AdStrength::Poor => "POOR",
                AdStrength::Average => "AVERAGE",
                AdStrength::Good => "GOOD",
                AdStrength::Excellent => "EXCELLENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PENDING" => Some(Self::Pending),
                "NO_ADS" => Some(Self::NoAds),
                "POOR" => Some(Self::Poor),
                "AVERAGE" => Some(Self::Average),
                "GOOD" => Some(Self::Good),
                "EXCELLENT" => Some(Self::Excellent),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AssetGroupStatusEnum {}
/// Nested message and enum types in `AssetGroupStatusEnum`.
pub mod asset_group_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AssetGroupStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl AssetGroupStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AssetGroupStatus::Unspecified => "UNSPECIFIED",
                AssetGroupStatus::Unknown => "UNKNOWN",
                AssetGroupStatus::Enabled => "ENABLED",
                AssetGroupStatus::Paused => "PAUSED",
                AssetGroupStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AttributionModelEnum {}
/// Nested message and enum types in `AttributionModelEnum`.
pub mod attribution_model_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AttributionModel {
        Unspecified = 0,
        Unknown = 1,
        External = 100,
        GoogleAdsLastClick = 101,
        GoogleSearchAttributionFirstClick = 102,
        GoogleSearchAttributionLinear = 103,
        GoogleSearchAttributionTimeDecay = 104,
        GoogleSearchAttributionPositionBased = 105,
        GoogleSearchAttributionDataDriven = 106,
    }
    impl AttributionModel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AttributionModel::Unspecified => "UNSPECIFIED",
                AttributionModel::Unknown => "UNKNOWN",
                AttributionModel::External => "EXTERNAL",
                AttributionModel::GoogleAdsLastClick => "GOOGLE_ADS_LAST_CLICK",
                AttributionModel::GoogleSearchAttributionFirstClick => {
                    "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK"
                }
                AttributionModel::GoogleSearchAttributionLinear => {
                    "GOOGLE_SEARCH_ATTRIBUTION_LINEAR"
                }
                AttributionModel::GoogleSearchAttributionTimeDecay => {
                    "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY"
                }
                AttributionModel::GoogleSearchAttributionPositionBased => {
                    "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED"
                }
                AttributionModel::GoogleSearchAttributionDataDriven => {
                    "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "EXTERNAL" => Some(Self::External),
                "GOOGLE_ADS_LAST_CLICK" => Some(Self::GoogleAdsLastClick),
                "GOOGLE_SEARCH_ATTRIBUTION_FIRST_CLICK" => {
                    Some(Self::GoogleSearchAttributionFirstClick)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_LINEAR" => {
                    Some(Self::GoogleSearchAttributionLinear)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_TIME_DECAY" => {
                    Some(Self::GoogleSearchAttributionTimeDecay)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_POSITION_BASED" => {
                    Some(Self::GoogleSearchAttributionPositionBased)
                }
                "GOOGLE_SEARCH_ATTRIBUTION_DATA_DRIVEN" => {
                    Some(Self::GoogleSearchAttributionDataDriven)
                }
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionCategoryEnum {}
/// Nested message and enum types in `ConversionActionCategoryEnum`.
pub mod conversion_action_category_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionCategory {
        Unspecified = 0,
        Unknown = 1,
        Default = 2,
        PageView = 3,
        Purchase = 4,
        Signup = 5,
        Lead = 6,
        Download = 7,
        AddToCart = 8,
        BeginCheckout = 9,
        SubscribePaid = 10,
        PhoneCallLead = 11,
        ImportedLead = 12,
        SubmitLeadForm = 13,
        BookAppointment = 14,
        RequestQuote = 15,
        GetDirections = 16,
        OutboundClick = 17,
        Contact = 18,
        Engagement = 19,
        StoreVisit = 20,
        StoreSale = 21,
        QualifiedLead = 22,
        ConvertedLead = 23,
    }
    impl ConversionActionCategory {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionCategory::Unspecified => "UNSPECIFIED",
                ConversionActionCategory::Unknown => "UNKNOWN",
                ConversionActionCategory::Default => "DEFAULT",
                ConversionActionCategory::PageView => "PAGE_VIEW",
                ConversionActionCategory::Purchase => "PURCHASE",
                ConversionActionCategory::Signup => "SIGNUP",
                ConversionActionCategory::Lead => "LEAD",
                ConversionActionCategory::Download => "DOWNLOAD",
                ConversionActionCategory::AddToCart => "ADD_TO_CART",
                ConversionActionCategory::BeginCheckout => "BEGIN_CHECKOUT",
                ConversionActionCategory::SubscribePaid => "SUBSCRIBE_PAID",
                ConversionActionCategory::PhoneCallLead => "PHONE_CALL_LEAD",
                ConversionActionCategory::ImportedLead => "IMPORTED_LEAD",
                ConversionActionCategory::SubmitLeadForm => "SUBMIT_LEAD_FORM",
                ConversionActionCategory::BookAppointment => "BOOK_APPOINTMENT",
                ConversionActionCategory::RequestQuote => "REQUEST_QUOTE",
                ConversionActionCategory::GetDirections => "GET_DIRECTIONS",
                ConversionActionCategory::OutboundClick => "OUTBOUND_CLICK",
                ConversionActionCategory::Contact => "CONTACT",
                ConversionActionCategory::Engagement => "ENGAGEMENT",
                ConversionActionCategory::StoreVisit => "STORE_VISIT",
                ConversionActionCategory::StoreSale => "STORE_SALE",
                ConversionActionCategory::QualifiedLead => "QUALIFIED_LEAD",
                ConversionActionCategory::ConvertedLead => "CONVERTED_LEAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "DEFAULT" => Some(Self::Default),
                "PAGE_VIEW" => Some(Self::PageView),
                "PURCHASE" => Some(Self::Purchase),
                "SIGNUP" => Some(Self::Signup),
                "LEAD" => Some(Self::Lead),
                "DOWNLOAD" => Some(Self::Download),
                "ADD_TO_CART" => Some(Self::AddToCart),
                "BEGIN_CHECKOUT" => Some(Self::BeginCheckout),
                "SUBSCRIBE_PAID" => Some(Self::SubscribePaid),
                "PHONE_CALL_LEAD" => Some(Self::PhoneCallLead),
                "IMPORTED_LEAD" => Some(Self::ImportedLead),
                "SUBMIT_LEAD_FORM" => Some(Self::SubmitLeadForm),
                "BOOK_APPOINTMENT" => Some(Self::BookAppointment),
                "REQUEST_QUOTE" => Some(Self::RequestQuote),
                "GET_DIRECTIONS" => Some(Self::GetDirections),
                "OUTBOUND_CLICK" => Some(Self::OutboundClick),
                "CONTACT" => Some(Self::Contact),
                "ENGAGEMENT" => Some(Self::Engagement),
                "STORE_VISIT" => Some(Self::StoreVisit),
                "STORE_SALE" => Some(Self::StoreSale),
                "QUALIFIED_LEAD" => Some(Self::QualifiedLead),
                "CONVERTED_LEAD" => Some(Self::ConvertedLead),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionStatusEnum {}
/// Nested message and enum types in `ConversionActionStatusEnum`.
pub mod conversion_action_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Removed = 3,
        Hidden = 4,
    }
    impl ConversionActionStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionStatus::Unspecified => "UNSPECIFIED",
                ConversionActionStatus::Unknown => "UNKNOWN",
                ConversionActionStatus::Enabled => "ENABLED",
                ConversionActionStatus::Removed => "REMOVED",
                ConversionActionStatus::Hidden => "HIDDEN",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "REMOVED" => Some(Self::Removed),
                "HIDDEN" => Some(Self::Hidden),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ConversionActionTypeEnum {}
/// Nested message and enum types in `ConversionActionTypeEnum`.
pub mod conversion_action_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ConversionActionType {
        Unspecified = 0,
        Unknown = 1,
        AdCall = 2,
        ClickToCall = 3,
        GooglePlayDownload = 4,
        GooglePlayInAppPurchase = 5,
        UploadCalls = 6,
        UploadClicks = 7,
        Webpage = 8,
        WebsiteCall = 9,
        StoreSalesDirectUpload = 10,
        StoreSales = 11,
        FirebaseAndroidFirstOpen = 12,
        FirebaseAndroidInAppPurchase = 13,
        FirebaseAndroidCustom = 14,
        FirebaseIosFirstOpen = 15,
        FirebaseIosInAppPurchase = 16,
        FirebaseIosCustom = 17,
        ThirdPartyAppAnalyticsAndroidFirstOpen = 18,
        ThirdPartyAppAnalyticsAndroidInAppPurchase = 19,
        ThirdPartyAppAnalyticsAndroidCustom = 20,
        ThirdPartyAppAnalyticsIosFirstOpen = 21,
        ThirdPartyAppAnalyticsIosInAppPurchase = 22,
        ThirdPartyAppAnalyticsIosCustom = 23,
        AndroidAppPreRegistration = 24,
        AndroidInstallsAllOtherApps = 25,
        FloodlightAction = 26,
        FloodlightTransaction = 27,
        GoogleHosted = 28,
        LeadFormSubmit = 29,
        Salesforce = 30,
        SearchAds360 = 31,
        SmartCampaignAdClicksToCall = 32,
        SmartCampaignMapClicksToCall = 33,
        SmartCampaignMapDirections = 34,
        SmartCampaignTrackedCalls = 35,
        StoreVisits = 36,
        WebpageCodeless = 37,
        UniversalAnalyticsGoal = 38,
        UniversalAnalyticsTransaction = 39,
        GoogleAnalytics4Custom = 40,
        GoogleAnalytics4Purchase = 41,
    }
    impl ConversionActionType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ConversionActionType::Unspecified => "UNSPECIFIED",
                ConversionActionType::Unknown => "UNKNOWN",
                ConversionActionType::AdCall => "AD_CALL",
                ConversionActionType::ClickToCall => "CLICK_TO_CALL",
                ConversionActionType::GooglePlayDownload => "GOOGLE_PLAY_DOWNLOAD",
                ConversionActionType::GooglePlayInAppPurchase => {
                    "GOOGLE_PLAY_IN_APP_PURCHASE"
                }
                ConversionActionType::UploadCalls => "UPLOAD_CALLS",
                ConversionActionType::UploadClicks => "UPLOAD_CLICKS",
                ConversionActionType::Webpage => "WEBPAGE",
                ConversionActionType::WebsiteCall => "WEBSITE_CALL",
                ConversionActionType::StoreSalesDirectUpload => {
                    "STORE_SALES_DIRECT_UPLOAD"
                }
                ConversionActionType::StoreSales => "STORE_SALES",
                ConversionActionType::FirebaseAndroidFirstOpen => {
                    "FIREBASE_ANDROID_FIRST_OPEN"
                }
                ConversionActionType::FirebaseAndroidInAppPurchase => {
                    "FIREBASE_ANDROID_IN_APP_PURCHASE"
                }
                ConversionActionType::FirebaseAndroidCustom => "FIREBASE_ANDROID_CUSTOM",
                ConversionActionType::FirebaseIosFirstOpen => "FIREBASE_IOS_FIRST_OPEN",
                ConversionActionType::FirebaseIosInAppPurchase => {
                    "FIREBASE_IOS_IN_APP_PURCHASE"
                }
                ConversionActionType::FirebaseIosCustom => "FIREBASE_IOS_CUSTOM",
                ConversionActionType::ThirdPartyAppAnalyticsAndroidFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN"
                }
                ConversionActionType::ThirdPartyAppAnalyticsAndroidInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE"
                }
                ConversionActionType::ThirdPartyAppAnalyticsAndroidCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosFirstOpen => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosInAppPurchase => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE"
                }
                ConversionActionType::ThirdPartyAppAnalyticsIosCustom => {
                    "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM"
                }
                ConversionActionType::AndroidAppPreRegistration => {
                    "ANDROID_APP_PRE_REGISTRATION"
                }
                ConversionActionType::AndroidInstallsAllOtherApps => {
                    "ANDROID_INSTALLS_ALL_OTHER_APPS"
                }
                ConversionActionType::FloodlightAction => "FLOODLIGHT_ACTION",
                ConversionActionType::FloodlightTransaction => "FLOODLIGHT_TRANSACTION",
                ConversionActionType::GoogleHosted => "GOOGLE_HOSTED",
                ConversionActionType::LeadFormSubmit => "LEAD_FORM_SUBMIT",
                ConversionActionType::Salesforce => "SALESFORCE",
                ConversionActionType::SearchAds360 => "SEARCH_ADS_360",
                ConversionActionType::SmartCampaignAdClicksToCall => {
                    "SMART_CAMPAIGN_AD_CLICKS_TO_CALL"
                }
                ConversionActionType::SmartCampaignMapClicksToCall => {
                    "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL"
                }
                ConversionActionType::SmartCampaignMapDirections => {
                    "SMART_CAMPAIGN_MAP_DIRECTIONS"
                }
                ConversionActionType::SmartCampaignTrackedCalls => {
                    "SMART_CAMPAIGN_TRACKED_CALLS"
                }
                ConversionActionType::StoreVisits => "STORE_VISITS",
                ConversionActionType::WebpageCodeless => "WEBPAGE_CODELESS",
                ConversionActionType::UniversalAnalyticsGoal => {
                    "UNIVERSAL_ANALYTICS_GOAL"
                }
                ConversionActionType::UniversalAnalyticsTransaction => {
                    "UNIVERSAL_ANALYTICS_TRANSACTION"
                }
                ConversionActionType::GoogleAnalytics4Custom => {
                    "GOOGLE_ANALYTICS_4_CUSTOM"
                }
                ConversionActionType::GoogleAnalytics4Purchase => {
                    "GOOGLE_ANALYTICS_4_PURCHASE"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AD_CALL" => Some(Self::AdCall),
                "CLICK_TO_CALL" => Some(Self::ClickToCall),
                "GOOGLE_PLAY_DOWNLOAD" => Some(Self::GooglePlayDownload),
                "GOOGLE_PLAY_IN_APP_PURCHASE" => Some(Self::GooglePlayInAppPurchase),
                "UPLOAD_CALLS" => Some(Self::UploadCalls),
                "UPLOAD_CLICKS" => Some(Self::UploadClicks),
                "WEBPAGE" => Some(Self::Webpage),
                "WEBSITE_CALL" => Some(Self::WebsiteCall),
                "STORE_SALES_DIRECT_UPLOAD" => Some(Self::StoreSalesDirectUpload),
                "STORE_SALES" => Some(Self::StoreSales),
                "FIREBASE_ANDROID_FIRST_OPEN" => Some(Self::FirebaseAndroidFirstOpen),
                "FIREBASE_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::FirebaseAndroidInAppPurchase)
                }
                "FIREBASE_ANDROID_CUSTOM" => Some(Self::FirebaseAndroidCustom),
                "FIREBASE_IOS_FIRST_OPEN" => Some(Self::FirebaseIosFirstOpen),
                "FIREBASE_IOS_IN_APP_PURCHASE" => Some(Self::FirebaseIosInAppPurchase),
                "FIREBASE_IOS_CUSTOM" => Some(Self::FirebaseIosCustom),
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_ANDROID_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsAndroidCustom)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_FIRST_OPEN" => {
                    Some(Self::ThirdPartyAppAnalyticsIosFirstOpen)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_IN_APP_PURCHASE" => {
                    Some(Self::ThirdPartyAppAnalyticsIosInAppPurchase)
                }
                "THIRD_PARTY_APP_ANALYTICS_IOS_CUSTOM" => {
                    Some(Self::ThirdPartyAppAnalyticsIosCustom)
                }
                "ANDROID_APP_PRE_REGISTRATION" => Some(Self::AndroidAppPreRegistration),
                "ANDROID_INSTALLS_ALL_OTHER_APPS" => {
                    Some(Self::AndroidInstallsAllOtherApps)
                }
                "FLOODLIGHT_ACTION" => Some(Self::FloodlightAction),
                "FLOODLIGHT_TRANSACTION" => Some(Self::FloodlightTransaction),
                "GOOGLE_HOSTED" => Some(Self::GoogleHosted),
                "LEAD_FORM_SUBMIT" => Some(Self::LeadFormSubmit),
                "SALESFORCE" => Some(Self::Salesforce),
                "SEARCH_ADS_360" => Some(Self::SearchAds360),
                "SMART_CAMPAIGN_AD_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignAdClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_CLICKS_TO_CALL" => {
                    Some(Self::SmartCampaignMapClicksToCall)
                }
                "SMART_CAMPAIGN_MAP_DIRECTIONS" => Some(Self::SmartCampaignMapDirections),
                "SMART_CAMPAIGN_TRACKED_CALLS" => Some(Self::SmartCampaignTrackedCalls),
                "STORE_VISITS" => Some(Self::StoreVisits),
                "WEBPAGE_CODELESS" => Some(Self::WebpageCodeless),
                "UNIVERSAL_ANALYTICS_GOAL" => Some(Self::UniversalAnalyticsGoal),
                "UNIVERSAL_ANALYTICS_TRANSACTION" => {
                    Some(Self::UniversalAnalyticsTransaction)
                }
                "GOOGLE_ANALYTICS_4_CUSTOM" => Some(Self::GoogleAnalytics4Custom),
                "GOOGLE_ANALYTICS_4_PURCHASE" => Some(Self::GoogleAnalytics4Purchase),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DataDrivenModelStatusEnum {}
/// Nested message and enum types in `DataDrivenModelStatusEnum`.
pub mod data_driven_model_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataDrivenModelStatus {
        Unspecified = 0,
        Unknown = 1,
        Available = 2,
        Stale = 3,
        Expired = 4,
        NeverGenerated = 5,
    }
    impl DataDrivenModelStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataDrivenModelStatus::Unspecified => "UNSPECIFIED",
                DataDrivenModelStatus::Unknown => "UNKNOWN",
                DataDrivenModelStatus::Available => "AVAILABLE",
                DataDrivenModelStatus::Stale => "STALE",
                DataDrivenModelStatus::Expired => "EXPIRED",
                DataDrivenModelStatus::NeverGenerated => "NEVER_GENERATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "AVAILABLE" => Some(Self::Available),
                "STALE" => Some(Self::Stale),
                "EXPIRED" => Some(Self::Expired),
                "NEVER_GENERATED" => Some(Self::NeverGenerated),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdServingOptimizationStatusEnum {}
/// Nested message and enum types in `AdServingOptimizationStatusEnum`.
pub mod ad_serving_optimization_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdServingOptimizationStatus {
        Unspecified = 0,
        Unknown = 1,
        Optimize = 2,
        ConversionOptimize = 3,
        Rotate = 4,
        RotateIndefinitely = 5,
        Unavailable = 6,
    }
    impl AdServingOptimizationStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdServingOptimizationStatus::Unspecified => "UNSPECIFIED",
                AdServingOptimizationStatus::Unknown => "UNKNOWN",
                AdServingOptimizationStatus::Optimize => "OPTIMIZE",
                AdServingOptimizationStatus::ConversionOptimize => "CONVERSION_OPTIMIZE",
                AdServingOptimizationStatus::Rotate => "ROTATE",
                AdServingOptimizationStatus::RotateIndefinitely => "ROTATE_INDEFINITELY",
                AdServingOptimizationStatus::Unavailable => "UNAVAILABLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OPTIMIZE" => Some(Self::Optimize),
                "CONVERSION_OPTIMIZE" => Some(Self::ConversionOptimize),
                "ROTATE" => Some(Self::Rotate),
                "ROTATE_INDEFINITELY" => Some(Self::RotateIndefinitely),
                "UNAVAILABLE" => Some(Self::Unavailable),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelSubTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelSubTypeEnum`.
pub mod advertising_channel_sub_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelSubType {
        Unspecified = 0,
        Unknown = 1,
        SearchMobileApp = 2,
        DisplayMobileApp = 3,
        SearchExpress = 4,
        DisplayExpress = 5,
        ShoppingSmartAds = 6,
        DisplayGmailAd = 7,
        DisplaySmartCampaign = 8,
        VideoOutstream = 9,
        VideoAction = 10,
        VideoNonSkippable = 11,
        AppCampaign = 12,
        AppCampaignForEngagement = 13,
        LocalCampaign = 14,
        ShoppingComparisonListingAds = 15,
        SmartCampaign = 16,
        VideoSequence = 17,
        AppCampaignForPreRegistration = 18,
        VideoReachTargetFrequency = 19,
        TravelActivities = 20,
        SocialFacebookTrackingOnly = 21,
    }
    impl AdvertisingChannelSubType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisingChannelSubType::Unspecified => "UNSPECIFIED",
                AdvertisingChannelSubType::Unknown => "UNKNOWN",
                AdvertisingChannelSubType::SearchMobileApp => "SEARCH_MOBILE_APP",
                AdvertisingChannelSubType::DisplayMobileApp => "DISPLAY_MOBILE_APP",
                AdvertisingChannelSubType::SearchExpress => "SEARCH_EXPRESS",
                AdvertisingChannelSubType::DisplayExpress => "DISPLAY_EXPRESS",
                AdvertisingChannelSubType::ShoppingSmartAds => "SHOPPING_SMART_ADS",
                AdvertisingChannelSubType::DisplayGmailAd => "DISPLAY_GMAIL_AD",
                AdvertisingChannelSubType::DisplaySmartCampaign => {
                    "DISPLAY_SMART_CAMPAIGN"
                }
                AdvertisingChannelSubType::VideoOutstream => "VIDEO_OUTSTREAM",
                AdvertisingChannelSubType::VideoAction => "VIDEO_ACTION",
                AdvertisingChannelSubType::VideoNonSkippable => "VIDEO_NON_SKIPPABLE",
                AdvertisingChannelSubType::AppCampaign => "APP_CAMPAIGN",
                AdvertisingChannelSubType::AppCampaignForEngagement => {
                    "APP_CAMPAIGN_FOR_ENGAGEMENT"
                }
                AdvertisingChannelSubType::LocalCampaign => "LOCAL_CAMPAIGN",
                AdvertisingChannelSubType::ShoppingComparisonListingAds => {
                    "SHOPPING_COMPARISON_LISTING_ADS"
                }
                AdvertisingChannelSubType::SmartCampaign => "SMART_CAMPAIGN",
                AdvertisingChannelSubType::VideoSequence => "VIDEO_SEQUENCE",
                AdvertisingChannelSubType::AppCampaignForPreRegistration => {
                    "APP_CAMPAIGN_FOR_PRE_REGISTRATION"
                }
                AdvertisingChannelSubType::VideoReachTargetFrequency => {
                    "VIDEO_REACH_TARGET_FREQUENCY"
                }
                AdvertisingChannelSubType::TravelActivities => "TRAVEL_ACTIVITIES",
                AdvertisingChannelSubType::SocialFacebookTrackingOnly => {
                    "SOCIAL_FACEBOOK_TRACKING_ONLY"
                }
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH_MOBILE_APP" => Some(Self::SearchMobileApp),
                "DISPLAY_MOBILE_APP" => Some(Self::DisplayMobileApp),
                "SEARCH_EXPRESS" => Some(Self::SearchExpress),
                "DISPLAY_EXPRESS" => Some(Self::DisplayExpress),
                "SHOPPING_SMART_ADS" => Some(Self::ShoppingSmartAds),
                "DISPLAY_GMAIL_AD" => Some(Self::DisplayGmailAd),
                "DISPLAY_SMART_CAMPAIGN" => Some(Self::DisplaySmartCampaign),
                "VIDEO_OUTSTREAM" => Some(Self::VideoOutstream),
                "VIDEO_ACTION" => Some(Self::VideoAction),
                "VIDEO_NON_SKIPPABLE" => Some(Self::VideoNonSkippable),
                "APP_CAMPAIGN" => Some(Self::AppCampaign),
                "APP_CAMPAIGN_FOR_ENGAGEMENT" => Some(Self::AppCampaignForEngagement),
                "LOCAL_CAMPAIGN" => Some(Self::LocalCampaign),
                "SHOPPING_COMPARISON_LISTING_ADS" => {
                    Some(Self::ShoppingComparisonListingAds)
                }
                "SMART_CAMPAIGN" => Some(Self::SmartCampaign),
                "VIDEO_SEQUENCE" => Some(Self::VideoSequence),
                "APP_CAMPAIGN_FOR_PRE_REGISTRATION" => {
                    Some(Self::AppCampaignForPreRegistration)
                }
                "VIDEO_REACH_TARGET_FREQUENCY" => Some(Self::VideoReachTargetFrequency),
                "TRAVEL_ACTIVITIES" => Some(Self::TravelActivities),
                "SOCIAL_FACEBOOK_TRACKING_ONLY" => Some(Self::SocialFacebookTrackingOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdvertisingChannelTypeEnum {}
/// Nested message and enum types in `AdvertisingChannelTypeEnum`.
pub mod advertising_channel_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdvertisingChannelType {
        Unspecified = 0,
        Unknown = 1,
        Search = 2,
        Display = 3,
        Shopping = 4,
        Hotel = 5,
        Video = 6,
        MultiChannel = 7,
        Local = 8,
        Smart = 9,
        PerformanceMax = 10,
        LocalServices = 11,
        Discovery = 12,
        Travel = 13,
        Social = 15,
    }
    impl AdvertisingChannelType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdvertisingChannelType::Unspecified => "UNSPECIFIED",
                AdvertisingChannelType::Unknown => "UNKNOWN",
                AdvertisingChannelType::Search => "SEARCH",
                AdvertisingChannelType::Display => "DISPLAY",
                AdvertisingChannelType::Shopping => "SHOPPING",
                AdvertisingChannelType::Hotel => "HOTEL",
                AdvertisingChannelType::Video => "VIDEO",
                AdvertisingChannelType::MultiChannel => "MULTI_CHANNEL",
                AdvertisingChannelType::Local => "LOCAL",
                AdvertisingChannelType::Smart => "SMART",
                AdvertisingChannelType::PerformanceMax => "PERFORMANCE_MAX",
                AdvertisingChannelType::LocalServices => "LOCAL_SERVICES",
                AdvertisingChannelType::Discovery => "DISCOVERY",
                AdvertisingChannelType::Travel => "TRAVEL",
                AdvertisingChannelType::Social => "SOCIAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "DISPLAY" => Some(Self::Display),
                "SHOPPING" => Some(Self::Shopping),
                "HOTEL" => Some(Self::Hotel),
                "VIDEO" => Some(Self::Video),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                "LOCAL" => Some(Self::Local),
                "SMART" => Some(Self::Smart),
                "PERFORMANCE_MAX" => Some(Self::PerformanceMax),
                "LOCAL_SERVICES" => Some(Self::LocalServices),
                "DISCOVERY" => Some(Self::Discovery),
                "TRAVEL" => Some(Self::Travel),
                "SOCIAL" => Some(Self::Social),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BiddingStrategySystemStatusEnum {}
/// Nested message and enum types in `BiddingStrategySystemStatusEnum`.
pub mod bidding_strategy_system_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BiddingStrategySystemStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        LearningNew = 3,
        LearningSettingChange = 4,
        LearningBudgetChange = 5,
        LearningCompositionChange = 6,
        LearningConversionTypeChange = 7,
        LearningConversionSettingChange = 8,
        LimitedByCpcBidCeiling = 9,
        LimitedByCpcBidFloor = 10,
        LimitedByData = 11,
        LimitedByBudget = 12,
        LimitedByLowPrioritySpend = 13,
        LimitedByLowQuality = 14,
        LimitedByInventory = 15,
        MisconfiguredZeroEligibility = 16,
        MisconfiguredConversionTypes = 17,
        MisconfiguredConversionSettings = 18,
        MisconfiguredSharedBudget = 19,
        MisconfiguredStrategyType = 20,
        Paused = 21,
        Unavailable = 22,
        MultipleLearning = 23,
        MultipleLimited = 24,
        MultipleMisconfigured = 25,
        Multiple = 26,
    }
    impl BiddingStrategySystemStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BiddingStrategySystemStatus::Unspecified => "UNSPECIFIED",
                BiddingStrategySystemStatus::Unknown => "UNKNOWN",
                BiddingStrategySystemStatus::Enabled => "ENABLED",
                BiddingStrategySystemStatus::LearningNew => "LEARNING_NEW",
                BiddingStrategySystemStatus::LearningSettingChange => {
                    "LEARNING_SETTING_CHANGE"
                }
                BiddingStrategySystemStatus::LearningBudgetChange => {
                    "LEARNING_BUDGET_CHANGE"
                }
                BiddingStrategySystemStatus::LearningCompositionChange => {
                    "LEARNING_COMPOSITION_CHANGE"
                }
                BiddingStrategySystemStatus::LearningConversionTypeChange => {
                    "LEARNING_CONVERSION_TYPE_CHANGE"
                }
                BiddingStrategySystemStatus::LearningConversionSettingChange => {
                    "LEARNING_CONVERSION_SETTING_CHANGE"
                }
                BiddingStrategySystemStatus::LimitedByCpcBidCeiling => {
                    "LIMITED_BY_CPC_BID_CEILING"
                }
                BiddingStrategySystemStatus::LimitedByCpcBidFloor => {
                    "LIMITED_BY_CPC_BID_FLOOR"
                }
                BiddingStrategySystemStatus::LimitedByData => "LIMITED_BY_DATA",
                BiddingStrategySystemStatus::LimitedByBudget => "LIMITED_BY_BUDGET",
                BiddingStrategySystemStatus::LimitedByLowPrioritySpend => {
                    "LIMITED_BY_LOW_PRIORITY_SPEND"
                }
                BiddingStrategySystemStatus::LimitedByLowQuality => {
                    "LIMITED_BY_LOW_QUALITY"
                }
                BiddingStrategySystemStatus::LimitedByInventory => "LIMITED_BY_INVENTORY",
                BiddingStrategySystemStatus::MisconfiguredZeroEligibility => {
                    "MISCONFIGURED_ZERO_ELIGIBILITY"
                }
                BiddingStrategySystemStatus::MisconfiguredConversionTypes => {
                    "MISCONFIGURED_CONVERSION_TYPES"
                }
                BiddingStrategySystemStatus::MisconfiguredConversionSettings => {
                    "MISCONFIGURED_CONVERSION_SETTINGS"
                }
                BiddingStrategySystemStatus::MisconfiguredSharedBudget => {
                    "MISCONFIGURED_SHARED_BUDGET"
                }
                BiddingStrategySystemStatus::MisconfiguredStrategyType => {
                    "MISCONFIGURED_STRATEGY_TYPE"
                }
                BiddingStrategySystemStatus::Paused => "PAUSED",
                BiddingStrategySystemStatus::Unavailable => "UNAVAILABLE",
                BiddingStrategySystemStatus::MultipleLearning => "MULTIPLE_LEARNING",
                BiddingStrategySystemStatus::MultipleLimited => "MULTIPLE_LIMITED",
                BiddingStrategySystemStatus::MultipleMisconfigured => {
                    "MULTIPLE_MISCONFIGURED"
                }
                BiddingStrategySystemStatus::Multiple => "MULTIPLE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "LEARNING_NEW" => Some(Self::LearningNew),
                "LEARNING_SETTING_CHANGE" => Some(Self::LearningSettingChange),
                "LEARNING_BUDGET_CHANGE" => Some(Self::LearningBudgetChange),
                "LEARNING_COMPOSITION_CHANGE" => Some(Self::LearningCompositionChange),
                "LEARNING_CONVERSION_TYPE_CHANGE" => {
                    Some(Self::LearningConversionTypeChange)
                }
                "LEARNING_CONVERSION_SETTING_CHANGE" => {
                    Some(Self::LearningConversionSettingChange)
                }
                "LIMITED_BY_CPC_BID_CEILING" => Some(Self::LimitedByCpcBidCeiling),
                "LIMITED_BY_CPC_BID_FLOOR" => Some(Self::LimitedByCpcBidFloor),
                "LIMITED_BY_DATA" => Some(Self::LimitedByData),
                "LIMITED_BY_BUDGET" => Some(Self::LimitedByBudget),
                "LIMITED_BY_LOW_PRIORITY_SPEND" => Some(Self::LimitedByLowPrioritySpend),
                "LIMITED_BY_LOW_QUALITY" => Some(Self::LimitedByLowQuality),
                "LIMITED_BY_INVENTORY" => Some(Self::LimitedByInventory),
                "MISCONFIGURED_ZERO_ELIGIBILITY" => {
                    Some(Self::MisconfiguredZeroEligibility)
                }
                "MISCONFIGURED_CONVERSION_TYPES" => {
                    Some(Self::MisconfiguredConversionTypes)
                }
                "MISCONFIGURED_CONVERSION_SETTINGS" => {
                    Some(Self::MisconfiguredConversionSettings)
                }
                "MISCONFIGURED_SHARED_BUDGET" => Some(Self::MisconfiguredSharedBudget),
                "MISCONFIGURED_STRATEGY_TYPE" => Some(Self::MisconfiguredStrategyType),
                "PAUSED" => Some(Self::Paused),
                "UNAVAILABLE" => Some(Self::Unavailable),
                "MULTIPLE_LEARNING" => Some(Self::MultipleLearning),
                "MULTIPLE_LIMITED" => Some(Self::MultipleLimited),
                "MULTIPLE_MISCONFIGURED" => Some(Self::MultipleMisconfigured),
                "MULTIPLE" => Some(Self::Multiple),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignServingStatusEnum {}
/// Nested message and enum types in `CampaignServingStatusEnum`.
pub mod campaign_serving_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignServingStatus {
        Unspecified = 0,
        Unknown = 1,
        Serving = 2,
        None = 3,
        Ended = 4,
        Pending = 5,
        Suspended = 6,
    }
    impl CampaignServingStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignServingStatus::Unspecified => "UNSPECIFIED",
                CampaignServingStatus::Unknown => "UNKNOWN",
                CampaignServingStatus::Serving => "SERVING",
                CampaignServingStatus::None => "NONE",
                CampaignServingStatus::Ended => "ENDED",
                CampaignServingStatus::Pending => "PENDING",
                CampaignServingStatus::Suspended => "SUSPENDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SERVING" => Some(Self::Serving),
                "NONE" => Some(Self::None),
                "ENDED" => Some(Self::Ended),
                "PENDING" => Some(Self::Pending),
                "SUSPENDED" => Some(Self::Suspended),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CampaignStatusEnum {}
/// Nested message and enum types in `CampaignStatusEnum`.
pub mod campaign_status_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CampaignStatus {
        Unspecified = 0,
        Unknown = 1,
        Enabled = 2,
        Paused = 3,
        Removed = 4,
    }
    impl CampaignStatus {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                CampaignStatus::Unspecified => "UNSPECIFIED",
                CampaignStatus::Unknown => "UNKNOWN",
                CampaignStatus::Enabled => "ENABLED",
                CampaignStatus::Paused => "PAUSED",
                CampaignStatus::Removed => "REMOVED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "ENABLED" => Some(Self::Enabled),
                "PAUSED" => Some(Self::Paused),
                "REMOVED" => Some(Self::Removed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NegativeGeoTargetTypeEnum {}
/// Nested message and enum types in `NegativeGeoTargetTypeEnum`.
pub mod negative_geo_target_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum NegativeGeoTargetType {
        Unspecified = 0,
        Unknown = 1,
        PresenceOrInterest = 4,
        Presence = 5,
    }
    impl NegativeGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                NegativeGeoTargetType::Unspecified => "UNSPECIFIED",
                NegativeGeoTargetType::Unknown => "UNKNOWN",
                NegativeGeoTargetType::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                NegativeGeoTargetType::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct OptimizationGoalTypeEnum {}
/// Nested message and enum types in `OptimizationGoalTypeEnum`.
pub mod optimization_goal_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptimizationGoalType {
        Unspecified = 0,
        Unknown = 1,
        CallClicks = 2,
        DrivingDirections = 3,
        AppPreRegistration = 4,
    }
    impl OptimizationGoalType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                OptimizationGoalType::Unspecified => "UNSPECIFIED",
                OptimizationGoalType::Unknown => "UNKNOWN",
                OptimizationGoalType::CallClicks => "CALL_CLICKS",
                OptimizationGoalType::DrivingDirections => "DRIVING_DIRECTIONS",
                OptimizationGoalType::AppPreRegistration => "APP_PRE_REGISTRATION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CALL_CLICKS" => Some(Self::CallClicks),
                "DRIVING_DIRECTIONS" => Some(Self::DrivingDirections),
                "APP_PRE_REGISTRATION" => Some(Self::AppPreRegistration),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PositiveGeoTargetTypeEnum {}
/// Nested message and enum types in `PositiveGeoTargetTypeEnum`.
pub mod positive_geo_target_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum PositiveGeoTargetType {
        Unspecified = 0,
        Unknown = 1,
        PresenceOrInterest = 5,
        SearchInterest = 6,
        Presence = 7,
    }
    impl PositiveGeoTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                PositiveGeoTargetType::Unspecified => "UNSPECIFIED",
                PositiveGeoTargetType::Unknown => "UNKNOWN",
                PositiveGeoTargetType::PresenceOrInterest => "PRESENCE_OR_INTEREST",
                PositiveGeoTargetType::SearchInterest => "SEARCH_INTEREST",
                PositiveGeoTargetType::Presence => "PRESENCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "PRESENCE_OR_INTEREST" => Some(Self::PresenceOrInterest),
                "SEARCH_INTEREST" => Some(Self::SearchInterest),
                "PRESENCE" => Some(Self::Presence),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SummaryRowSettingEnum {}
/// Nested message and enum types in `SummaryRowSettingEnum`.
pub mod summary_row_setting_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum SummaryRowSetting {
        Unspecified = 0,
        Unknown = 1,
        NoSummaryRow = 2,
        SummaryRowWithResults = 3,
        SummaryRowOnly = 4,
    }
    impl SummaryRowSetting {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                SummaryRowSetting::Unspecified => "UNSPECIFIED",
                SummaryRowSetting::Unknown => "UNKNOWN",
                SummaryRowSetting::NoSummaryRow => "NO_SUMMARY_ROW",
                SummaryRowSetting::SummaryRowWithResults => "SUMMARY_ROW_WITH_RESULTS",
                SummaryRowSetting::SummaryRowOnly => "SUMMARY_ROW_ONLY",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "NO_SUMMARY_ROW" => Some(Self::NoSummaryRow),
                "SUMMARY_ROW_WITH_RESULTS" => Some(Self::SummaryRowWithResults),
                "SUMMARY_ROW_ONLY" => Some(Self::SummaryRowOnly),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductChannelExclusivityEnum {}
/// Nested message and enum types in `ProductChannelExclusivityEnum`.
pub mod product_channel_exclusivity_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductChannelExclusivity {
        Unspecified = 0,
        Unknown = 1,
        SingleChannel = 2,
        MultiChannel = 3,
    }
    impl ProductChannelExclusivity {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductChannelExclusivity::Unspecified => "UNSPECIFIED",
                ProductChannelExclusivity::Unknown => "UNKNOWN",
                ProductChannelExclusivity::SingleChannel => "SINGLE_CHANNEL",
                ProductChannelExclusivity::MultiChannel => "MULTI_CHANNEL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SINGLE_CHANNEL" => Some(Self::SingleChannel),
                "MULTI_CHANNEL" => Some(Self::MultiChannel),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InteractionEventTypeEnum {}
/// Nested message and enum types in `InteractionEventTypeEnum`.
pub mod interaction_event_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum InteractionEventType {
        Unspecified = 0,
        Unknown = 1,
        Click = 2,
        Engagement = 3,
        VideoView = 4,
        None = 5,
    }
    impl InteractionEventType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                InteractionEventType::Unspecified => "UNSPECIFIED",
                InteractionEventType::Unknown => "UNKNOWN",
                InteractionEventType::Click => "CLICK",
                InteractionEventType::Engagement => "ENGAGEMENT",
                InteractionEventType::VideoView => "VIDEO_VIEW",
                InteractionEventType::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "CLICK" => Some(Self::Click),
                "ENGAGEMENT" => Some(Self::Engagement),
                "VIDEO_VIEW" => Some(Self::VideoView),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QualityScoreBucketEnum {}
/// Nested message and enum types in `QualityScoreBucketEnum`.
pub mod quality_score_bucket_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum QualityScoreBucket {
        Unspecified = 0,
        Unknown = 1,
        BelowAverage = 2,
        Average = 3,
        AboveAverage = 4,
    }
    impl QualityScoreBucket {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                QualityScoreBucket::Unspecified => "UNSPECIFIED",
                QualityScoreBucket::Unknown => "UNKNOWN",
                QualityScoreBucket::BelowAverage => "BELOW_AVERAGE",
                QualityScoreBucket::Average => "AVERAGE",
                QualityScoreBucket::AboveAverage => "ABOVE_AVERAGE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "BELOW_AVERAGE" => Some(Self::BelowAverage),
                "AVERAGE" => Some(Self::Average),
                "ABOVE_AVERAGE" => Some(Self::AboveAverage),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdNetworkTypeEnum {}
/// Nested message and enum types in `AdNetworkTypeEnum`.
pub mod ad_network_type_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum AdNetworkType {
        Unspecified = 0,
        Unknown = 1,
        Search = 2,
        SearchPartners = 3,
        Content = 4,
        YoutubeSearch = 5,
        YoutubeWatch = 6,
        Mixed = 7,
    }
    impl AdNetworkType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                AdNetworkType::Unspecified => "UNSPECIFIED",
                AdNetworkType::Unknown => "UNKNOWN",
                AdNetworkType::Search => "SEARCH",
                AdNetworkType::SearchPartners => "SEARCH_PARTNERS",
                AdNetworkType::Content => "CONTENT",
                AdNetworkType::YoutubeSearch => "YOUTUBE_SEARCH",
                AdNetworkType::YoutubeWatch => "YOUTUBE_WATCH",
                AdNetworkType::Mixed => "MIXED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "SEARCH" => Some(Self::Search),
                "SEARCH_PARTNERS" => Some(Self::SearchPartners),
                "CONTENT" => Some(Self::Content),
                "YOUTUBE_SEARCH" => Some(Self::YoutubeSearch),
                "YOUTUBE_WATCH" => Some(Self::YoutubeWatch),
                "MIXED" => Some(Self::Mixed),
                _ => None,
            }
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ProductConditionEnum {}
/// Nested message and enum types in `ProductConditionEnum`.
pub mod product_condition_enum {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum ProductCondition {
        Unspecified = 0,
        Unknown = 1,
        Old = 2,
        New = 3,
        Refurbished = 4,
        Used = 5,
    }
    impl ProductCondition {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                ProductCondition::Unspecified => "UNSPECIFIED",
                ProductCondition::Unknown => "UNKNOWN",
                ProductCondition::Old => "OLD",
                ProductCondition::New => "NEW",
                ProductCondition::Refurbished => "REFURBISHED",
                ProductCondition::Used => "USED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "UNKNOWN" => Some(Self::Unknown),
                "OLD" => Some(Self::Old),
                "NEW" => Some(Self::New),
                "REFURBISHED" => Some(Self::Refurbished),
                "USED" => Some(Self::Used),
                _ => None,
            }
        }
    }
}
